[
  {
    "url": "https://api.github.com/repos/bosens-China/blog/issues/77",
    "repository_url": "https://api.github.com/repos/bosens-China/blog",
    "labels_url": "https://api.github.com/repos/bosens-China/blog/issues/77/labels{/name}",
    "comments_url": "https://api.github.com/repos/bosens-China/blog/issues/77/comments",
    "events_url": "https://api.github.com/repos/bosens-China/blog/issues/77/events",
    "html_url": "https://github.com/bosens-China/blog/issues/77",
    "id": 1041025871,
    "node_id": "I_kwDOCzPAy84-DMtP",
    "number": 77,
    "title": "当equal函数遇到对象",
    "user": {
      "login": "bosens-China",
      "id": 39508895,
      "node_id": "MDQ6VXNlcjM5NTA4ODk1",
      "avatar_url": "https://avatars.githubusercontent.com/u/39508895?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/bosens-China",
      "html_url": "https://github.com/bosens-China",
      "followers_url": "https://api.github.com/users/bosens-China/followers",
      "following_url": "https://api.github.com/users/bosens-China/following{/other_user}",
      "gists_url": "https://api.github.com/users/bosens-China/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/bosens-China/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/bosens-China/subscriptions",
      "organizations_url": "https://api.github.com/users/bosens-China/orgs",
      "repos_url": "https://api.github.com/users/bosens-China/repos",
      "events_url": "https://api.github.com/users/bosens-China/events{/privacy}",
      "received_events_url": "https://api.github.com/users/bosens-China/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [
      {
        "id": 1371686609,
        "node_id": "MDU6TGFiZWwxMzcxNjg2NjA5",
        "url": "https://api.github.com/repos/bosens-China/blog/labels/js%20%E7%9B%B8%E5%85%B3",
        "name": "js 相关",
        "color": "F7DF1E",
        "default": false,
        "description": ""
      }
    ],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 0,
    "created_at": "2021-11-01T10:38:09Z",
    "updated_at": "2021-11-01T10:38:09Z",
    "closed_at": null,
    "author_association": "OWNER",
    "active_lock_reason": null,
    "body": "JavaScript 自带了`==`和`===`两种判断方式，前者会隐式转换类型导致代码出现问题，而后者则是根据指针地址进行判断。\r\n\r\n在绝大多数情况这两种已经足够使用了，不过延伸下想判断两个对象或数组元素是否相同，则会显得不太友好，而且在 JavaScript 中有一些特殊的规则：`NaN`和`NaN`不相同、`+0`和`-0`相同，这就导致有的场景使用起来不便，下面动手实现一个`equal`函数，它具备以下功能：\r\n\r\n- `+0`和`-0`不相同\r\n- `NaN`和`NaN`相同\r\n- `{}`和`{}`相同\r\n- `[]`和`[]`相同\r\n- `new Set()`和`new Set()`相同\r\n- `new Map()`和`new Map()`相同\r\n- `new Date(111)`和`new Date(111)`相同\r\n- `new String(1)`和`new String(1)`之类的包装对象相同\r\n- `/a/`和`/a/`相同 -`() => {}`和`() => {}`不相同\r\n- 其他情况一律`===`判断\r\n\r\n## 第一版\r\n\r\n在这一版中，我们先实现`+0`和`-0`、`NaN`的判断\r\n\r\n```js\r\nfunction equal(a, b) {\r\n  // 判断NaN\r\n  if (a === b) {\r\n    return 1 / a === 1 / b;\r\n  }\r\n  // 判断对象\r\n  if (a && b && typeof a === 'object' && typeof b === 'object') {\r\n    //... 留空\r\n  }\r\n  // 判断NaN\r\n  return a !== a && b !== b;\r\n}\r\n```\r\n\r\n上面判断`NaN`的思路为`1 / 0`为`Infinity`，而`1/-0`为`-Infinity`\r\n\r\n## 第二版\r\n\r\n第一版中我们已经实现了基础的功能，下面就来实现一下怎么深层次判断对象和数组是否相同\r\n\r\n```js\r\nfunction equal(a, b) {\r\n  // 判断NaN\r\n  if (a === b) {\r\n    return 1 / a === 1 / b;\r\n  }\r\n  // 判断对象\r\n  if (a && b && typeof a === 'object' && typeof b === 'object') {\r\n    if (a.constructor !== b.constructor) {\r\n      return false;\r\n    }\r\n    // 判断array\r\n    if (Array.isArray(a) && Array.isArray(b)) {\r\n      const len = a.length;\r\n      if (len !== b.length) {\r\n        return false;\r\n      }\r\n      for (let i = 0; i < len; i++) {\r\n        if (!equal(a[i], b[i])) {\r\n          return false;\r\n        }\r\n      }\r\n      return true;\r\n    }\r\n    // 默认为对象，进行key和长度对比\r\n    const keys = Object.keys(a);\r\n    const len = keys.length;\r\n    if (Object.keys(b).length !== len) {\r\n      return false;\r\n    }\r\n    for (let i = 0; i < len; i++) {\r\n      const key = keys[i];\r\n      if (!Object.prototype.hasOwnProperty.call(b, key)) {\r\n        return false;\r\n      }\r\n      if (!equal(a[key], b[key])) {\r\n        return false;\r\n      }\r\n    }\r\n    return true;\r\n  }\r\n}\r\n```\r\n\r\n上面代码中首先判断`constructor`是否相同，`constructor`可以从实例指向原型的构造函数，上面代码首先的意思是首先判断构造函数是否相同，如果不相同直接返回。\r\n\r\n后面的话判断数组的成员数量、每个子属性是否相同，而判断对象也是判断`length`之后判断`b`下是否存在`name`，之后统一对比值是否相同。\r\n\r\n至于执行`Object.prototype.hasOwnProperty`的原因则是`hasOwnProperty`有可能被改写，例如：\r\n\r\n```js\r\nvar foo = {\r\n  hasOwnProperty: function () {\r\n    return false;\r\n  },\r\n  bar: 'Here be dragons',\r\n};\r\n\r\nfoo.hasOwnProperty('bar'); // 始终返回 false\r\n```\r\n\r\n## 第三版\r\n\r\n上面的代码基本实现了一个雏形，下面加入`Set`、`Map`的对比，`Set`和`Map`是 es6 是引入的新的数据结构，`Set`是一组不重复的成员，`Map`则是`object`的升级版：重点解决了键名循环不稳定以及只能插入 string 键名的问题。\r\n\r\n它们两者都是有序的，且都遵循`Symbol.iterator`，所以我们不仅要对比`name`、`value`也要对比所在的位置是否相同，这里为了简化后面的工作提前写了一个函数\r\n\r\n```js\r\nconst iteration = (value, j) => {\r\n  let i = 0;\r\n  for (const iterator of value) {\r\n    if (j === i++) {\r\n      return iterator;\r\n    }\r\n  }\r\n  return undefined;\r\n};\r\n```\r\n\r\n它的作用就是根据`j`指定下标来运行迭代器的`next`方法，例如：\r\n\r\n```js\r\niteration(new Set([1, 2, 3]), 1); // 2\r\n```\r\n\r\n```js\r\n// 判断set\r\nif (a instanceof Set && b instanceof Set) {\r\n  const len = a.size;\r\n  if (len !== b.size) {\r\n    return false;\r\n  }\r\n  for (let i = 0; i < len; i++) {\r\n    if (!equal(iteration(a, i), iteration(b, i))) {\r\n      return false;\r\n    }\r\n  }\r\n  return true;\r\n}\r\n// 判断Map\r\nif (a instanceof Map && b instanceof Map) {\r\n  const len = a.size;\r\n  if (len !== b.size) {\r\n    return false;\r\n  }\r\n  for (let i = 0; i < len; i++) {\r\n    const [nameA, valueA] = iteration(a.entries(), i);\r\n    const [nameB, valueB] = iteration(b.entries(), i);\r\n    if (!equal(nameA, nameB) || !equal(valueA, valueB)) {\r\n      return false;\r\n    }\r\n  }\r\n  return true;\r\n}\r\n```\r\n\r\n可以发现`Set`和`Map`判断是否相似，首先对比成员数量，其次对比每一次当前位置的键名和键值。\r\n\r\n## 第四版\r\n\r\n写到这里我们已经实现了 80%的功能，剩下的一些判断还有\r\n\r\n- `new Date(111)`和`new Date(111)`相同\r\n- `new String(1)`和`new String(1)`之类的包装对象相同\r\n- `/a/`和`/a/`相同\r\n\r\n```js\r\n// 判断regexp\r\nif (a.constructor === RegExp) {\r\n  return a.source === b.source && a.flags === b.flags;\r\n}\r\nif (a.toString !== Object.prototype.toString) {\r\n  return a.toString() === b.toString();\r\n}\r\nif (a.valueOf !== Object.prototype.valueOf) {\r\n  return a.valueOf() === b.valueOf();\r\n}\r\n```\r\n\r\n判断包装类型和`Date`可以`valueOf`和`toString`方法实现，每个对象都会从`Object.prototype`继承`vlaueOf`和`toString`方法。\r\n\r\n通常情况下`valueOf`返回包装对象传递的参数，而有的对象会更改`valueOf`方法，例如`Date`返回`number`类型，所以上面判断`valueOf`一则是为了`Date`另外一方则是初始过滤传递的参数。\r\n\r\n至于为什么也判断`toString`则是为了考虑边界情况，例如：\r\n\r\n```js\r\nvar a = new Boolean(true);\r\nvar b = new Boolean(1);\r\na === b ?\r\n```\r\n\r\n如果没有`toString`这个就相同了\r\n\r\n## 最后\r\n\r\n完整的把代码贴一下，如果对你有帮助也可以`star`支持一下，有什么错误也欢迎指出。\r\n\r\n```js\r\nconst iteration = (value, j) => {\r\n  let i = 0;\r\n  for (const iterator of value) {\r\n    if (j === i++) {\r\n      return iterator;\r\n    }\r\n  }\r\n  return undefined;\r\n};\r\nfunction equal(a, b) {\r\n  // 判断NaN\r\n  if (a === b) {\r\n    return 1 / a === 1 / b;\r\n  }\r\n  // 判断对象\r\n  if (a && b && typeof a === 'object' && typeof b === 'object') {\r\n    // 判断对象\r\n    if (a && b && typeof a === 'object' && typeof b === 'object') {\r\n      if (a.constructor !== b.constructor) {\r\n        return false;\r\n      }\r\n      // 判断array\r\n      if (Array.isArray(a) && Array.isArray(b)) {\r\n        const len = a.length;\r\n        if (len !== b.length) {\r\n          return false;\r\n        }\r\n        for (let i = 0; i < len; i++) {\r\n          if (!equal(a[i], b[i])) {\r\n            return false;\r\n          }\r\n        }\r\n        return true;\r\n      }\r\n      // 判断set\r\n      if (a instanceof Set && b instanceof Set) {\r\n        const len = a.size;\r\n        if (len !== b.size) {\r\n          return false;\r\n        }\r\n        for (let i = 0; i < len; i++) {\r\n          if (!equal(iteration(a, i), iteration(b, i))) {\r\n            return false;\r\n          }\r\n        }\r\n        return true;\r\n      }\r\n      // 判断Map\r\n      if (a instanceof Map && b instanceof Map) {\r\n        const len = a.size;\r\n        if (len !== b.size) {\r\n          return false;\r\n        }\r\n        for (let i = 0; i < len; i++) {\r\n          const [nameA, valueA] = iteration(a.entries(), i);\r\n          const [nameB, valueB] = iteration(b.entries(), i);\r\n          if (!equal(nameA, nameB) || !equal(valueA, valueB)) {\r\n            return false;\r\n          }\r\n        }\r\n        return true;\r\n      }\r\n      // 判断regexp\r\n      if (a.constructor === RegExp) {\r\n        return a.source === b.source && a.flags === b.flags;\r\n      }\r\n      if (a.toString !== Object.prototype.toString) {\r\n        return a.toString() === b.toString();\r\n      }\r\n      if (a.valueOf !== Object.prototype.valueOf) {\r\n        return a.valueOf() === b.valueOf();\r\n      }\r\n      // 默认为对象，进行key和长度对比\r\n      const keys = Object.keys(a);\r\n      const len = keys.length;\r\n      if (Object.keys(b).length !== len) {\r\n        return false;\r\n      }\r\n      for (let i = 0; i < len; i++) {\r\n        const key = keys[i];\r\n        if (!Object.prototype.hasOwnProperty.call(b, key)) {\r\n          return false;\r\n        }\r\n        if (!equal(a[key], b[key])) {\r\n          return false;\r\n        }\r\n      }\r\n      return true;\r\n    }\r\n  }\r\n  // 判断NaN\r\n  return a !== a && b !== b;\r\n}\r\n```\r\n\r\n## 参考\r\n\r\n- [fast-deep-equal](https://github.com/epoberezkin/fast-deep-equal)\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/bosens-China/blog/issues/77/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/bosens-China/blog/issues/77/timeline",
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/bosens-China/blog/issues/54",
    "repository_url": "https://api.github.com/repos/bosens-China/blog",
    "labels_url": "https://api.github.com/repos/bosens-China/blog/issues/54/labels{/name}",
    "comments_url": "https://api.github.com/repos/bosens-China/blog/issues/54/comments",
    "events_url": "https://api.github.com/repos/bosens-China/blog/issues/54/events",
    "html_url": "https://github.com/bosens-China/blog/issues/54",
    "id": 588233327,
    "node_id": "MDU6SXNzdWU1ODgyMzMzMjc=",
    "number": 54,
    "title": "使用 canvas 实现贪吃蛇小游戏",
    "user": {
      "login": "bosens-China",
      "id": 39508895,
      "node_id": "MDQ6VXNlcjM5NTA4ODk1",
      "avatar_url": "https://avatars.githubusercontent.com/u/39508895?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/bosens-China",
      "html_url": "https://github.com/bosens-China",
      "followers_url": "https://api.github.com/users/bosens-China/followers",
      "following_url": "https://api.github.com/users/bosens-China/following{/other_user}",
      "gists_url": "https://api.github.com/users/bosens-China/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/bosens-China/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/bosens-China/subscriptions",
      "organizations_url": "https://api.github.com/users/bosens-China/orgs",
      "repos_url": "https://api.github.com/users/bosens-China/repos",
      "events_url": "https://api.github.com/users/bosens-China/events{/privacy}",
      "received_events_url": "https://api.github.com/users/bosens-China/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [
      {
        "id": 1371686609,
        "node_id": "MDU6TGFiZWwxMzcxNjg2NjA5",
        "url": "https://api.github.com/repos/bosens-China/blog/labels/js%20%E7%9B%B8%E5%85%B3",
        "name": "js 相关",
        "color": "F7DF1E",
        "default": false,
        "description": ""
      },
      {
        "id": 1935755992,
        "node_id": "MDU6TGFiZWwxOTM1NzU1OTky",
        "url": "https://api.github.com/repos/bosens-China/blog/labels/%E5%BE%85%E5%AE%8C%E6%88%90%E7%B3%BB%E5%88%97",
        "name": "待完成系列",
        "color": "cc6e43",
        "default": false,
        "description": "等待完成系列..."
      }
    ],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 0,
    "created_at": "2020-03-26T08:13:17Z",
    "updated_at": "2021-10-27T10:07:20Z",
    "closed_at": null,
    "author_association": "OWNER",
    "active_lock_reason": null,
    "body": "<div align=center><img src=\"https://user-images.githubusercontent.com/39508895/139045104-f01d3705-928a-478a-8859-ae6e3cf20c98.png\" alt=\"贪吃蛇\"></div>\r\n\r\n\r\n童年使用的诺基亚基本上都会搭载这款小游戏，最近心血来潮想用 canvas 来实现这个游戏就有了这篇文章，下面讲解一下实现的思路，本文的最终代码已经放到了[codesandbox](https://codesandbox.io/s/peaceful-firefly-c1i43?file=/src/index.js)上。\r\n\r\n当然实现的方式并不止 `canvas` 这一种，还可以使用 `html` + `css` 的形式，这里不讨论优劣取舍，让我们快速开始吧。\r\n\r\n## 游戏规则\r\n\r\n在开发之前先要设计游戏的具体规则是怎么样的，就像是实现`polyfill`也要对照规范一样，贪吃蛇游戏规则还是蛮简单下面概括一下：\r\n\r\n- 初始的时候会被四周墙体包围着，贪吃蛇这时候很虚弱只有一节，墙的周围随机分布着一个鸡蛋（奖励品）\r\n- 按下方向键游戏开始，吃到鸡蛋身体会边长，同时会生成新的鸡蛋\r\n- 撞到墙体和撞到身体会结束游戏\r\n\r\n上面规则概括成代码就是我们需要给一个界面范围、绘制蛇和鸡蛋、让蛇动起来。\r\n\r\n## 基本概念\r\n\r\n`canvas` 是 `html5` 出现的元素，它可以用于数据可视化、动画、游戏、图像操作、视频等方面，它以 `JavaScript` 的方式来进行交互。\r\n\r\n为了方便下面的理解介绍几个基本概念\r\n\r\n- `var ctx = canvas.getContext(contextType);`\r\n\r\n`getContext` 返回 `canvas` 的上下文，`contextType` 指定了何种上下文，它有 `2d`、`webgl`、`webgl2`、`bitmaprenderer`这几种选项，这里只需要 2d 界面，所以填写 2d 即可。\r\n\r\n> 可以根据 `canvas.getContext` 存在判断浏览器支不支持 `canvas` 元素\r\n\r\n- `CanvasRenderingContext2D.clearRect`\r\n\r\n指定矩形区域的像素都变成透明，**注意这个方法不等于完全清除画布，对于一些 `path` 的方法记得手动 `closePath()`**\r\n\r\n- 动画的组成原理\r\n\r\n后续我们需要让贪吃蛇动起来，但是动这个概念是一个伪命题，想一下电视和电影是怎么让我们感觉到动的呢？就是通过一帧帧的画面快速播放得到的视觉效果。\r\n\r\n后面让蛇动起来也是通过定时器来让 `canvas` 不断重绘达到动画的效果。\r\n\r\n## 实现思路\r\n\r\n![坐标](https://user-images.githubusercontent.com/39508895/139045144-fb2d7562-20a8-4c52-a76b-30a1eca7031c.png)\r\n\r\n\r\n如文章首页的示例图片，贪吃蛇可以想象成一个坐标，根据这个坐标很容易得到下面启示：\r\n\r\n- 蛇和鸡蛋都会在坐标中出现，但不会超出\r\n- 撞到坐标的边界即是撞墙\r\n- 每次贪吃蛇移动都需要擦拭移动的路径\r\n- 判断有没有撞到身体和吃不是吃到鸡蛋，判断移动的坐标值是什么即可\r\n\r\n也就是说，贪吃蛇这个游戏最核心的就是坐标这个概念，为了快速得到坐标的信息，我们期待以下面的形式来储存数据。\r\n\r\n```js\r\ninterface CoordinateAll {\r\n  [x: number]: {\r\n    [y: number]: 'block' | 'egg' | 'sanke';\r\n  };\r\n}\r\n// 转化成JavaScript表示\r\n{\r\n  1: {1: 'block', 2: 'egg', 'block'},\r\n  2: {1: 'block', 2: 'block', 'block'},\r\n  // ...\r\n}\r\n```\r\n\r\n为了后续的使用方便，提前定义两个文件\r\n\r\n```js\r\n// utils.js\r\n// 传递一个整数，来循环它\r\nexport const eachNumber = (n, fn) => {\r\n  for (let i = 0; i < n; i++) {\r\n    fn(i);\r\n  }\r\n};\r\n// 返回随机整数\r\nexport const randomNumber = (min, max) => {\r\n  return Math.floor(Math.random() * (max - min + 1)) + min;\r\n};\r\n```\r\n\r\n```js\r\n// const.js\r\n// canvas宽度\r\nexport const WIDTH = 400;\r\n// 高度\r\nexport const HEIGHT = 400;\r\n// 像素x\r\nexport const PIXEL_X = 20;\r\n// 像素y\r\nexport const PIXEL_Y = 20;\r\n// 行\r\nexport const ROW = HEIGHT / PIXEL_Y;\r\n// 列\r\nexport const COLUMN = WIDTH / PIXEL_X;\r\n// 半径\r\nexport const RADIUS = 10;\r\n// 定时器间隔\r\nexport const INTERVAL = 150;\r\n// 鸡蛋颜色\r\nexport const EGG_COLOR = '#767803';\r\n// 蛇颜色\r\nexport const SANKE_COLOR = '#6f5f06';\r\n// 边框颜色\r\nexport const BORDER_COLOR = '#796e09';\r\n```\r\n\r\n后面就开始绘制初始的界面。\r\n\r\n## 初始化界面\r\n\r\n```js\r\nclass Sanke {\r\n  constructor() {\r\n    const canvas = document.createElement('canvas');\r\n    canvas.width = WIDTH;\r\n    canvas.height = HEIGHT;\r\n    this.canvas = canvas;\r\n    document.body.appendChild(canvas);\r\n    const ctx = canvas.getContext('2d');\r\n    this.ctx = ctx;\r\n\r\n    // 蛇身\r\n    this.currentSanke = [];\r\n    // 出现的egg位置\r\n    this.currentEgg = null;\r\n    // 坐标系\r\n    this.coordinateAll = {};\r\n    this.init();\r\n  }\r\n  init() {\r\n    // 创建坐标系\r\n    this.coordinateAll = {};\r\n    eachNumber(ROW, (x) => {\r\n      this.coordinateAll[x] = {};\r\n      eachNumber(COLUMN, (y) => {\r\n        this.coordinateAll[x][y] = 'block';\r\n      });\r\n    });\r\n    const sanke = this.randomCoordinate();\r\n    this.setCoordinate(sanke, 'sanke');\r\n    this.currentSanke = [sanke];\r\n    this.currentEgg = this.randomCoordinate();\r\n    this.setCoordinate(this.currentEgg, 'egg');\r\n    this.repaint();\r\n  }\r\n  repaint() {\r\n    const { ctx, canvas, currentSanke } = this;\r\n    // 绘制egg和绘制sanke\r\n    ctx.clearRect(0, 0, canvas.width, canvas.height);\r\n    ctx.strokeStyle = BORDER_COLOR;\r\n    ctx.strokeRect(0, 0, canvas.width, canvas.height);\r\n    ctx.fillStyle = SANKE_COLOR;\r\n    currentSanke.forEach((item) => {\r\n      ctx.fillRect(item.x * PIXEL_X, item.y * PIXEL_Y, PIXEL_X, PIXEL_Y);\r\n    });\r\n    // 绘制egg\r\n    ctx.beginPath();\r\n    ctx.fillStyle = EGG_COLOR;\r\n    if (!this.currentEgg) {\r\n      this.currentEgg = this.randomCoordinate();\r\n      this.setCoordinate(this.currentEgg, 'egg');\r\n    }\r\n    const { currentEgg } = this;\r\n    ctx.arc(\r\n      0 + RADIUS + currentEgg.x * PIXEL_X,\r\n      0 + RADIUS + currentEgg.y * PIXEL_Y,\r\n      RADIUS,\r\n      0,\r\n      Math.PI * 2,\r\n      true\r\n    );\r\n    ctx.fill();\r\n    ctx.closePath();\r\n  }\r\n\r\n  randomCoordinate() {\r\n    const arr = [];\r\n    eachNumber(ROW, (x) => {\r\n      eachNumber(COLUMN, (y) => {\r\n        const value = this.coordinateAll[x][y];\r\n        if (value === 'block') {\r\n          arr.push({ x, y });\r\n        }\r\n      });\r\n    });\r\n    // 说明无坐标可取\r\n    if (!arr.length) {\r\n      return null;\r\n    }\r\n    return arr[randomNumber(0, arr.length)];\r\n  }\r\n  setCoordinate({ x, y }, value) {\r\n    this.coordinateAll[x][y] = value;\r\n  }\r\n  getCoordinate({ x, y }) {\r\n    if (x < 0 || y < 0 || x > ROW - 1 || y > COLUMN - 1) {\r\n      return null;\r\n    }\r\n    return this.coordinateAll[x][y];\r\n  }\r\n}\r\n```\r\n\r\n代码看起来还是蛮多的，不过之前已经介绍过实现的思路了，接下来一步步分析执行：\r\n\r\n- `constructor`\r\n\r\n这里主要是创建 `canvas` 对象，在 `this` 上绑定一些必要的属性，例如`坐标系`、`egg 位置`和 `sanke 位置`，这里 `currentSanke` ` array` 是因为蛇存在多节，用数组管理比较方便的。\r\n\r\n- `init`\r\n\r\n用 `init` 来完成组装，第一步是创建坐标系，这里给所有的初始元素打上 `block`，它一共三个值：`'block' | 'egg' | 'sanke'`。\r\n后面随机获取蛋的位置和蛇的位置，储存到` coordinateAll` 中，最后调用 `repaint` 完成绘制\r\n\r\n- `repaint`\r\n\r\n这一步就是调用 `canvas` 完成界面绘制，主要用到了两个 `api`\r\n\r\n[ctx.arc](https://developer.mozilla.org/zh-CN/docs/Web/API/CanvasRenderingContext2D/arc) 和 [ctx.fillRect](https://developer.mozilla.org/zh-CN/docs/Web/API/CanvasRenderingContext2D/fillRect)，前者绘制弧形后者填充矩形，先 `clearRect` 后绘制是因为这个方法后续会被重复调用，后面的一些`randomCoordinate`、`setCoordinate`、`getCoordinate`都是跟坐标方法有关，比较简单看一下即可。\r\n\r\n![静态效果](https://user-images.githubusercontent.com/39508895/139045166-b0b27e8d-3517-4e16-a0e7-c8b3cbdb01a3.png)\r\n\r\n\r\n到这里我们就可以得到静态的效果，后面就是让其动起来。\r\n\r\n## 动起来\r\n\r\n想让贪吃蛇动起来，我们需要做两步：\r\n\r\n- 监听方向键，也就是动的方向（也充当启动游戏作用）\r\n- 使用定时器不断的重绘蛇和鸡蛋的位置来造成视觉的移动\r\n\r\n监听方向键很简单，我们直接在 `body` 上监听 `keydown` 即可，这个事件在键盘按下的时候触发\r\n\r\n```js\r\nthis.keydownFn = (e) => {\r\n  const code = e.code;\r\n  const result = ['ArrowDown', 'ArrowUp', 'ArrowLeft', 'ArrowRight'].indexOf(\r\n    code\r\n  );\r\n  if (result <= -1) {\r\n    return;\r\n  }\r\n  this.direction = code;\r\n};\r\nmonitor() {\r\n  document.body.addEventListener('keydown', this.keydownFn);\r\n};\r\n```\r\n\r\n```js\r\nmove() {\r\n  if (this.timeId) {\r\n    clearInterval(this.timeId);\r\n  }\r\n  this.timeId = setInterval(() => {\r\n    const { direction, currentSanke, currentEgg } = this;\r\n    // 如果方向键不存在就返回\r\n    if (!direction) {\r\n      return;\r\n    }\r\n    let nextCoordinate;\r\n    // 蛇头始终是0\r\n    const { x, y } = currentSanke[0];\r\n    switch (direction) {\r\n      case 'ArrowDown':\r\n      case 'ArrowUp':\r\n        nextCoordinate = { x, y: direction === 'ArrowUp' ? y - 1 : y + 1 };\r\n        break;\r\n      case 'ArrowLeft':\r\n      case 'ArrowRight':\r\n        nextCoordinate = { y, x: direction === 'ArrowLeft' ? x - 1 : x + 1 };\r\n        break;\r\n      default:\r\n        break;\r\n    }\r\n    // nextCoordinate的作用是确认下一步是什么类型\r\n    const value = this.getCoordinate(nextCoordinate);\r\n    switch (value) {\r\n      case 'block':\r\n        this.setCoordinate(currentSanke.pop(), 'block');\r\n        currentSanke.unshift(nextCoordinate);\r\n        this.setCoordinate(nextCoordinate, 'sanke');\r\n        break;\r\n      case 'egg':\r\n        this.setCoordinate(currentEgg, 'sanke');\r\n        this.currentEgg = null;\r\n        currentSanke.unshift(nextCoordinate);\r\n        break;\r\n      case 'sanke':\r\n      case null:\r\n        // 游戏结束\r\n        break;\r\n      default:\r\n        break;\r\n    }\r\n    this.repaint();\r\n  }, INTERVAL);\r\n};\r\n```\r\n\r\n之后在 init 中插入这这两个方法\r\n\r\n```js\r\ninit() {\r\n  // ...\r\n  this.monitor();\r\n  this.move();\r\n}\r\n```\r\n\r\n![示例](https://user-images.githubusercontent.com/39508895/139045193-71ae885b-bb3d-4613-82b9-9c7b4d9f6e38.png)\r\n\r\n\r\n到这一步，贪吃蛇也实现了动起来的要求，在 `swtich` 中判断 `value` 的类型来决定坐标值如何变化，之后继续执行 `repaint` 重绘界面\r\n\r\n## 结束游戏\r\n\r\n上面 `move` 对游戏结束只进行了注释，下面就把` case null:`下面语句替换成`this.end`\r\n\r\n```js\r\nend() {\r\n  if (this.timeId) {\r\n    clearInterval(this.timeId);\r\n  }\r\n  this.timeId = null;\r\n  document.body.removeEventListener('keydown', this.keydownFn);\r\n  alert(`游戏结束，当前分数：${(this.currentSanke.length - 1) * 10}`);\r\n};\r\n```\r\n\r\n## 最后\r\n\r\n如果有什么错误请不吝指点，对你有帮助也可以 `start` 一下。\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/bosens-China/blog/issues/54/reactions",
      "total_count": 1,
      "+1": 1,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/bosens-China/blog/issues/54/timeline",
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/bosens-China/blog/issues/76",
    "repository_url": "https://api.github.com/repos/bosens-China/blog",
    "labels_url": "https://api.github.com/repos/bosens-China/blog/issues/76/labels{/name}",
    "comments_url": "https://api.github.com/repos/bosens-China/blog/issues/76/comments",
    "events_url": "https://api.github.com/repos/bosens-China/blog/issues/76/events",
    "html_url": "https://github.com/bosens-China/blog/issues/76",
    "id": 1029841361,
    "node_id": "I_kwDOCzPAy849YiHR",
    "number": 76,
    "title": "当 memoization 遇到 async",
    "user": {
      "login": "bosens-China",
      "id": 39508895,
      "node_id": "MDQ6VXNlcjM5NTA4ODk1",
      "avatar_url": "https://avatars.githubusercontent.com/u/39508895?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/bosens-China",
      "html_url": "https://github.com/bosens-China",
      "followers_url": "https://api.github.com/users/bosens-China/followers",
      "following_url": "https://api.github.com/users/bosens-China/following{/other_user}",
      "gists_url": "https://api.github.com/users/bosens-China/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/bosens-China/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/bosens-China/subscriptions",
      "organizations_url": "https://api.github.com/users/bosens-China/orgs",
      "repos_url": "https://api.github.com/users/bosens-China/repos",
      "events_url": "https://api.github.com/users/bosens-China/events{/privacy}",
      "received_events_url": "https://api.github.com/users/bosens-China/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [
      {
        "id": 1371686609,
        "node_id": "MDU6TGFiZWwxMzcxNjg2NjA5",
        "url": "https://api.github.com/repos/bosens-China/blog/labels/js%20%E7%9B%B8%E5%85%B3",
        "name": "js 相关",
        "color": "F7DF1E",
        "default": false,
        "description": ""
      }
    ],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 0,
    "created_at": "2021-10-19T04:16:45Z",
    "updated_at": "2021-10-19T04:16:45Z",
    "closed_at": null,
    "author_association": "OWNER",
    "active_lock_reason": null,
    "body": "> **记忆化**（英语：memoization）是一种提高[计算机程序](https://zh.wikipedia.org/wiki/计算机程序)执行速度的优化技术。通过储存大计算量[函数](https://zh.wikipedia.org/wiki/子程序)的返回值，当这个结果再次被需要时将其从[缓存](https://zh.wikipedia.org/wiki/缓存)提取，而不用再次计算来节省计算时间。\r\n>\r\n> 记忆化是一种典型的在计算时间与[电脑存储器](https://zh.wikipedia.org/wiki/電腦記憶體)空间之中获取平衡的方案。\r\n>\r\n> 来源：[维基百科](https://zh.wikipedia.org/wiki/%E8%AE%B0%E5%BF%86%E5%8C%96)\r\n\r\n从上面的定义可以看出缓存是一种非常有用的技巧，它可以把一些函数结果储存起来在下次调用的时候返回。\r\n这里不讨论什么样场景使用缓存而是抛砖引玉如何编写一个可复用的 Memoization 函数\r\n\r\n## MemoizationSync\r\n\r\nMemoizationSync 从字面就可以看出它是一个同步版本的 Memoization，下面的以 `add` 函数为例介绍如何编写一个通用的 memoization 来对结果进行缓存\r\n\r\n```js\r\nconst memo = {};\r\n\r\nconst add = (...args) => {\r\n  const key = args.join();\r\n  if (Object.prototype.hasOwnProperty.call(memo, key)) {\r\n    return memo[key];\r\n  }\r\n  const result = args.reduce((a, b) => a + b, 0);\r\n  memo[key] = result;\r\n  return result;\r\n};\r\n\r\nadd(1, 2, 3);\r\nadd(1, 2, 3);\r\n```\r\n\r\n如果要给 `add` 函数显示的添加一个缓存功能可能会按照上面的情况来编写，但是它存在问题。\r\n\r\n这个函数同时做了两件事情\r\n\r\n- 计算 args\r\n- 读取 memo 的缓存\r\n  但是这样显示违背了设计模式的单一原则，而且会给后续的维护带来麻烦，以及如果我们需要新的函数缓存是不是还要重新复制一份过去，显然不符合我们的要求，我们尝试将它进行一次抽离\r\n\r\n```js\r\nconst add = (...args) => {\r\n  return args.reduce((a, b) => a + b, 0);\r\n};\r\n\r\nconst memoizationSync = (fn, key) => {\r\n  const memo = {};\r\n  return function callback(...args) {\r\n    if (memo.hasOwnProperty(key)) {\r\n      return memo[key];\r\n    }\r\n    const result = fn.apply(this, args);\r\n    memo[key] = result;\r\n    return result;\r\n  };\r\n};\r\n\r\nconst argumentsArr = [1, 2, 3];\r\nconst memoizationAdd = memoizationSync(add, argumentsArr);\r\nmemoizationAdd(...argumentsArr);\r\nmemoizationAdd(...argumentsArr);\r\n```\r\n\r\n这样就得到了一个通用的 memoizationSync 函数，它接受一个 `key` ，通过 `key` 来进行区分缓存。\r\n\r\n不过为了它的灵活性和符合更多的场景的要求我们还是需要对它进行一次改造，来改造前我们看下这个函数做了啥\r\n\r\n- 根据 key 来读取缓存\r\n- 无缓存来执行函数设置缓存\r\n  显然这两步是不会改变的，但是我们可以对 `key` 下手提高 `key` 的唯一性，我们希望它可以是一个函数并且存在默认值，这样在复杂场景下可以由用户根据参数来指定缓存什么字段\r\n\r\n```js\r\nconst memoizationSync = (fn, getKey = (...args) => args.join('')) => {\r\n  const memo = {};\r\n  return function callback(...args) {\r\n    const key = typeof getKey === 'function' ? getKey.apply(this, args) : getKey;\r\n    if (memo.hasOwnProperty(key)) {\r\n      return memo[key];\r\n    }\r\n    const result = fn.apply(this, args);\r\n    memo[key] = result;\r\n    return result;\r\n  };\r\n};\r\n```\r\n\r\n## MemoizationAsync\r\n\r\n在 JavaScript 中异步场景粗略可以分为两部分\r\n\r\n- 回调函数\r\n- Promise（async 、Generator 都是基于 Promise）\r\n\r\n下面就来讨论这两部分我们如何实现缓存\r\n\r\n### Callback\r\n\r\n我现在有一个 getImgSize 的函数，它会根据 `img` 的 `src` 来返回图片的真实宽度和高度，如果成功就会调用 `callback` 来传递参数（node 回调风格），但是我希望如果 url 相同的时候就直接返回而不是继续调用一次 getImgSize\r\n\r\n```js\r\nconst getImgSize = (src, callback) => {\r\n  const img = new Image();\r\n  img.src = src;\r\n  img.addEventListener('load', () => {\r\n    callback(null, {\r\n      width: img.naturalWidth,\r\n      height: img.naturalHeight,\r\n    });\r\n  });\r\n\r\n  img.addEventListener('error', (e) => {\r\n    callback(new Error(e), null);\r\n  });\r\n};\r\n\r\nconst url = 'https://www.google.com/images/branding/googlelogo/1x/googlelogo_color_272x92dp.png';\r\n\r\ngetImgSize(url, (error, size) => {\r\n  if (error) {\r\n    return;\r\n  }\r\n  console.log(size);\r\n});\r\n```\r\n\r\n在编写 memoizationAsync 函数之前我们先想一下以什么样的方式来编写这个函数，按照惯例我们希望不要对用户的使用方式有太多影响，所以期待的调用方式如下\r\n\r\n```js\r\nconst getImgSizeMemoization = memoizationAsync(getImgSize);\r\ngetImgSizeMemoization(url, (error, size) => {\r\n  if (error) {\r\n    return;\r\n  }\r\n  console.log(size);\r\n});\r\n// 相同参数使用缓存\r\ngetImgSizeMemoization(url, (error, size) => {\r\n  if (error) {\r\n    return;\r\n  }\r\n  console.log(size);\r\n});\r\n```\r\n\r\n后面就是来编写这个函数\r\n\r\n```js\r\nconst memoizationAsync = (fn, getKey = (...args) => args.join()) => {\r\n  const memo = {};\r\n  const queue = {};\r\n  return function (...rest) {\r\n    const callback = Array.prototype.pop.call(rest);\r\n    const key = getKey.apply(this, rest);\r\n    const cb = (...args) => {\r\n      memo[key] = args;\r\n      queue[key].forEach((item) => {\r\n        item.apply(this, args);\r\n      });\r\n      delete queue[key];\r\n    };\r\n    if (memo.hasOwnProperty(key)) {\r\n      return memo[key];\r\n    }\r\n    if (!queue.hasOwnProperty(key)) {\r\n      queue[key] = [callback];\r\n    } else {\r\n      queue[key].push(callback);\r\n      // 后续加入等待第一个执行结束\r\n      return;\r\n    }\r\n    fn.apply(this, [...rest, cb]);\r\n  };\r\n};\r\n```\r\n\r\n说一下这个函数编写的思路，通过自定义创建 cb 回调函数来完成记录缓存和调用用户传递的回调，其他的读取和设置缓存与上面一致。\r\n\r\n而存在 `queue` 变量的原因是因为异步任务添加进来的时候可能正在请求，但是 `memo` 还没有被写入结果，所以通过队列来管理这个请求，等待第一个请求结束之后批量来执行队列的任务，最后删除。\r\n\r\n### Promise\r\n\r\n回忆一下[Promise 函数的特性](https://es6.ruanyifeng.com/#docs/promise#Promise-%E7%9A%84%E5%90%AB%E4%B9%89)\r\n\r\n- 对象的状态不受外界影响\r\n- 一旦状态改变，就不会再变，任何时候都可以得到这个结果\r\n\r\n重点是第二点，它不同于回调函数，只要结果出来了任何时候都可以调用，我们在 click 监听一个事件如果错过了这个监听想要回溯是不可能的，但是 promise 你重复无数次的`.then` 调用，基于这个特性我们来编写 MemoizationAsync\r\n\r\n```js\r\nconst getImgSize = (src) => {\r\n  return new Promise((resolve, reject) => {\r\n    const img = new Image();\r\n    img.src = src;\r\n    img.addEventListener('load', () => {\r\n      return resolve({\r\n        width: img.naturalWidth,\r\n        height: img.naturalHeight,\r\n      });\r\n    });\r\n\r\n    img.addEventListener('error', (e) => {\r\n      return reject(e);\r\n    });\r\n  });\r\n};\r\n\r\nconst url = 'https://www.google.com/images/branding/googlelogo/1x/googlelogo_color_272x92dp.png';\r\n\r\nconst memoizationAsync = (fn, getKey = (...args) => args.join()) => {\r\n  const memo = {};\r\n  return async function (...args) {\r\n    const key = getKey.apply(this, args);\r\n    if (memo.hasOwnProperty(key)) {\r\n      return memo[key];\r\n    }\r\n    const result = fn.apply(this, args);\r\n    memo[key] = result;\r\n    return result;\r\n  };\r\n};\r\n\r\nconst getImgSizeMemoization = memoizationAsync(getImgSize);\r\n\r\n(async () => {\r\n  const result = await Promise.all([getImgSizeMemoization(url), getImgSizeMemoization(url)]);\r\n  console.log(result);\r\n})();\r\n```\r\n\r\nmemoizationAsync 函数编写的十分精简跟同步版本基本没区别，不同点在于我们只是返回了 **Promise 的状态**，而得益于 Promise 的特性在任何时候这个函数都会返回正确的结果\r\n\r\n## 最后\r\n\r\n如果对你有帮助可以`关注`、 `star` 一下，有什么错误欢迎指出\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/bosens-China/blog/issues/76/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/bosens-China/blog/issues/76/timeline",
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/bosens-China/blog/issues/75",
    "repository_url": "https://api.github.com/repos/bosens-China/blog",
    "labels_url": "https://api.github.com/repos/bosens-China/blog/issues/75/labels{/name}",
    "comments_url": "https://api.github.com/repos/bosens-China/blog/issues/75/comments",
    "events_url": "https://api.github.com/repos/bosens-China/blog/issues/75/events",
    "html_url": "https://github.com/bosens-China/blog/issues/75",
    "id": 975496779,
    "node_id": "MDU6SXNzdWU5NzU0OTY3Nzk=",
    "number": 75,
    "title": "怎么用 Vue Composition 造轮子",
    "user": {
      "login": "bosens-China",
      "id": 39508895,
      "node_id": "MDQ6VXNlcjM5NTA4ODk1",
      "avatar_url": "https://avatars.githubusercontent.com/u/39508895?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/bosens-China",
      "html_url": "https://github.com/bosens-China",
      "followers_url": "https://api.github.com/users/bosens-China/followers",
      "following_url": "https://api.github.com/users/bosens-China/following{/other_user}",
      "gists_url": "https://api.github.com/users/bosens-China/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/bosens-China/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/bosens-China/subscriptions",
      "organizations_url": "https://api.github.com/users/bosens-China/orgs",
      "repos_url": "https://api.github.com/users/bosens-China/repos",
      "events_url": "https://api.github.com/users/bosens-China/events{/privacy}",
      "received_events_url": "https://api.github.com/users/bosens-China/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [
      {
        "id": 1473940161,
        "node_id": "MDU6TGFiZWwxNDczOTQwMTYx",
        "url": "https://api.github.com/repos/bosens-China/blog/labels/Vue%20%E7%9B%B8%E5%85%B3",
        "name": "Vue 相关",
        "color": "42b883",
        "default": false,
        "description": "Vue 相关"
      }
    ],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 0,
    "created_at": "2021-08-20T10:51:18Z",
    "updated_at": "2021-08-20T10:51:18Z",
    "closed_at": null,
    "author_association": "OWNER",
    "active_lock_reason": null,
    "body": "\r\n![wallhaven-zmmwzw](https://user-images.githubusercontent.com/39508895/130222612-f8e2410a-4101-47dd-ba41-f488225cb94d.jpg)\r\n\r\n\r\n最近项目临近尾声，终于有时间来对这段工作总结。其实之前使用的一直是 Vue 但是现在公司的主要业务使用是 React 为此还特意看了许多文章，加上实际上这两个框架有很多类似的地方，所以就有了这篇文章。\r\n\r\n因为主要是分享经验所以下面的示例主要作为抛砖引玉的作用，在正式分享之前先科普两个小知识\r\n\r\n- hooks 默认以 use 为前缀，这个是 React 的官方推荐做法，约束大于配置也方便 eslint 等解析工具识别，这里也遵循这个做法；\r\n- watchEffect 与 useEffect 最大的区别就是，watchEffect 可以自动检测依赖，而 useEffect 需要你显示指定；\r\n\r\n```js\r\nconst count = ref(0);\r\nconst onClick = () => {\r\n  count.value++;\r\n};\r\nwatchEffect(() => {\r\n  console.log(`被点击`);\r\n});\r\n```\r\n\r\n例如上面这段代码，当 `onClick` 被触发的时候 watchEffect 不会重复执行，因为它内部有一个收集相关依赖的过程，只有依赖变化才会重新执行，这一点很重要，请记住。\r\n\r\n## 示例\r\n根据常见场景划分了三个类型，如果你有更好的例子欢迎补充\r\n### DOM\r\n\r\n#### 修改页面 title\r\n\r\n```js\r\nimport { ref, watchEffect } from 'vue';\r\n\r\nconst useTitle = (title) => {\r\n  const str = ref(title);\r\n  watchEffect(() => {\r\n    document.title = str.value;\r\n  });\r\n};\r\n```\r\n\r\n调用`useTitle`即可更新标题\r\n\r\n#### 监听页面大小变化\r\n\r\n```js\r\nimport { watchEffect, reactive, toRefs } from 'vue';\r\n\r\nconst useResize = () => {\r\n  const size = reactive({\r\n    width: window.innerWidth,\r\n    height: window.innerHeight,\r\n  });\r\n  const onChange = () => {\r\n    Object.assign(size, {\r\n      width: window.innerWidth,\r\n      height: window.innerHeight,\r\n    });\r\n  };\r\n  watchEffect((onInvalidate) => {\r\n    window.addEventListener('resize', onChange);\r\n    onInvalidate(() => {\r\n      window.removeEventListener('resize', onChange);\r\n    });\r\n  });\r\n  return toRefs(size);\r\n};\r\n```\r\n\r\n这里调用 `toRefs` 的原因是为了解构的情况也可以使用，例如\r\n\r\n```js\r\nconst { width } = useResize();\r\n```\r\n\r\n#### 监听网络是否断开\r\n\r\n```js\r\nimport { ref, watchEffect } from 'vue';\r\n\r\nconst useLineState = () => {\r\n  const line = ref(window.navigator.onLine);\r\n  const onLine = () => {\r\n    line.value = true;\r\n  };\r\n  const onOffline = () => {\r\n    line.value = false;\r\n  };\r\n\r\n  watchEffect((onInvalidate) => {\r\n    window.addEventListener('online', onLine);\r\n    window.addEventListener('offline', onOffline);\r\n    onInvalidate(() => {\r\n      window.removeEventListener('online', onLine);\r\n      window.removeEventListener('offline', onOffline);\r\n    });\r\n  });\r\n\r\n  return line;\r\n};\r\n```\r\n\r\n跟上面的 `useResize` 类似，监听相关事件来决定 `state` 的相关状态\r\n\r\n#### 监听 dom 元素变化\r\n\r\n```js\r\nimport { watchEffect, reactive, toRefs } from 'vue';\r\n\r\nconst isObject = (obj) => typeof obj === 'object' && obj;\r\nconst isElement = (obj) => isObject(obj) && obj.nodeType === Node.ELEMENT_NODE;\r\nconst useResizeObserver = (dom) => {\r\n  if (!isElement(dom)) {\r\n    throw new Error(`DOM is not an element!`);\r\n  }\r\n  const size = reactive(dom.getBoundingClientRect());\r\n  watchEffect((onInvalidate) => {\r\n    const resizeObserver = new ResizeObserver(() => {\r\n      Object.assign(size, dom.getBoundingClientRect());\r\n    });\r\n    onInvalidate(() => {\r\n      resizeObserver.disconnect();\r\n    });\r\n  });\r\n  return toRefs(size);\r\n};\r\n```\r\n\r\n这里监听元素使用了还在实验阶段的 `ResizeObserver` ，为了兼容性请使用 `polyfill`\r\n\r\n### 封装请求\r\n\r\najax 的请求很常见，不过在 vue2.x 中我们很容易写出下面的代码\r\n\r\n```js\r\nmounted(() => {\r\n  fn().then().catch().finally();\r\n});\r\n```\r\n\r\n这样的代码最大的问题就是不够清晰，因为变量在 `data` 中定义，而如果切换成下面这种形式，看起来就会直观许多。\r\n\r\n更多的例子还可以结合 `form` 和 `table` 进行更加深度的 hooks 封装\r\n\r\n```js\r\nconst { data, loading, error } = useRequest(() => {\r\n  //...\r\n});\r\nif (loading) {\r\n  //...\r\n}\r\nif (error) {\r\n  // ...\r\n}\r\n```\r\n\r\n```js\r\nimport { watchEffect, reactive, toRefs } from 'vue';\r\n\r\nconst useRequest = (fn, { manual } = {}) => {\r\n  const obj = reactive({\r\n    loading: false,\r\n    data: undefined,\r\n    error: undefined,\r\n  });\r\n  const run = () => {\r\n    obj.loading = true;\r\n    Promise.resolve(fn())\r\n      .then((data) => {\r\n        obj.data = data;\r\n      })\r\n      .catch((err) => {\r\n        obj.error = err;\r\n      })\r\n      .finally(() => {\r\n        obj.loading = false;\r\n      });\r\n  };\r\n  watchEffect(() => {\r\n    if (!manual) {\r\n      run();\r\n    }\r\n  });\r\n\r\n  return {\r\n    ...toRefs(obj),\r\n    run,\r\n  };\r\n};\r\n```\r\n\r\n### 模拟生命周期\r\n\r\n这里 Vue 官方的自带生命周期已经很齐全了，不过有的生命周期还是可以通过 `watchEffect` 做到模拟。\r\n\r\n例如：`mounted` 和 `beforeUnmount`，这里实现的原理主要就是利用 `watchEffect` 自动检测依赖，那如果不对响应式变量做收集的相关操作其实就是一个 `mounted`\r\n\r\n```js\r\nimport { watchEffect, nextTick } from 'vue';\r\n\r\nconst useMounted = (fn) => {\r\n  watchEffect(() => {\r\n    if (typeof fn !== 'function') {\r\n      return;\r\n    }\r\n    nextTick().then(() => {\r\n      fn();\r\n    });\r\n  });\r\n};\r\n\r\nconst useBeforeUnmount = (fn) => {\r\n  watchEffect((onInvalidate) => {\r\n    onInvalidate(() => {\r\n      if (typeof fn !== 'function') {\r\n        return;\r\n      }\r\n      fn();\r\n    });\r\n  });\r\n};\r\n```\r\n\r\n### 封装持久化\r\n\r\n在一些登录页面中很容易看到记住相关账号和密码，传统的做法就是 `login` 之后存储相关的账号和密码，然后在页面渲染的时候查看相关 `localStorage` 有没有对应的数据。\r\n\r\n这样写做大的问题还是分离，以及书写的代码量很多，下面就介绍一下如何结合 `localStorage` 做到一个支持对象的 hooks\r\n\r\n```js\r\nimport { ref, watchEffect } from 'vue';\r\nconst isObject = (obj) => typeof obj === 'object' && obj;\r\nconst useLocalStorageState = (key, defaultValue) => {\r\n  const value = ref(undefined);\r\n  try {\r\n    value.value = window.localStorage.getItem(key);\r\n    if (value.value === undefined) {\r\n      value.value = defaultValue;\r\n    }\r\n    value.value = JSON.parse(value.value);\r\n  } catch {}\r\n\r\n  watchEffect(() => {\r\n    const v = value.value;\r\n    window.localStorage.setItem(key, isObject(v) ? JSON.stringify(v) : v);\r\n  });\r\n  return value;\r\n};\r\n```\r\n\r\n```js\r\nconst name = useLocalStorageState('name', 'admin');\r\n```\r\n\r\n## 最后\r\n\r\n以上代码全部上传到了[codesandbox](https://codesandbox.io/s/nostalgic-chaum-9bwuo)，如果对你有帮助可以`star`一下\r\n\r\n## 参考文章\r\n\r\n- [精读《怎么用 React Hooks 造轮子》](https://github.com/ascoders/weekly/blob/v2/080.%E7%B2%BE%E8%AF%BB%E3%80%8A%E6%80%8E%E4%B9%88%E7%94%A8%20React%20Hooks%20%E9%80%A0%E8%BD%AE%E5%AD%90%E3%80%8B.md)\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/bosens-China/blog/issues/75/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/bosens-China/blog/issues/75/timeline",
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/bosens-China/blog/issues/74",
    "repository_url": "https://api.github.com/repos/bosens-China/blog",
    "labels_url": "https://api.github.com/repos/bosens-China/blog/issues/74/labels{/name}",
    "comments_url": "https://api.github.com/repos/bosens-China/blog/issues/74/comments",
    "events_url": "https://api.github.com/repos/bosens-China/blog/issues/74/events",
    "html_url": "https://github.com/bosens-China/blog/issues/74",
    "id": 931481508,
    "node_id": "MDU6SXNzdWU5MzE0ODE1MDg=",
    "number": 74,
    "title": "为 react 添加双向绑定 hook",
    "user": {
      "login": "bosens-China",
      "id": 39508895,
      "node_id": "MDQ6VXNlcjM5NTA4ODk1",
      "avatar_url": "https://avatars.githubusercontent.com/u/39508895?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/bosens-China",
      "html_url": "https://github.com/bosens-China",
      "followers_url": "https://api.github.com/users/bosens-China/followers",
      "following_url": "https://api.github.com/users/bosens-China/following{/other_user}",
      "gists_url": "https://api.github.com/users/bosens-China/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/bosens-China/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/bosens-China/subscriptions",
      "organizations_url": "https://api.github.com/users/bosens-China/orgs",
      "repos_url": "https://api.github.com/users/bosens-China/repos",
      "events_url": "https://api.github.com/users/bosens-China/events{/privacy}",
      "received_events_url": "https://api.github.com/users/bosens-China/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [
      {
        "id": 1371686609,
        "node_id": "MDU6TGFiZWwxMzcxNjg2NjA5",
        "url": "https://api.github.com/repos/bosens-China/blog/labels/js%20%E7%9B%B8%E5%85%B3",
        "name": "js 相关",
        "color": "F7DF1E",
        "default": false,
        "description": ""
      }
    ],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 0,
    "created_at": "2021-06-28T11:43:52Z",
    "updated_at": "2021-06-29T03:01:13Z",
    "closed_at": null,
    "author_association": "OWNER",
    "active_lock_reason": null,
    "body": "最近换了一家新公司，用的技术栈`react`为主，所以上周紧急的看了一下`react`相关的文档，也对照文档写了几个 demo，不过在开发阶段我的体验还是蛮差的。\r\n\r\n- 生态很繁荣，但是不知道那种方案是最佳\r\n- 开发效率很繁琐（这一点待商榷）\r\n\r\n刚刚简单写了一个 todolist 的功能，不过在对 list 进行保存、修改、删除的时候，感觉很酸爽\r\n\r\n```js\r\n// ...\r\nconst list = myContent.list[props.index]!;\r\nlist.title = inp;\r\nlist.show = false;\r\nmyContent.setlist([...myContent.list]);\r\n```\r\n\r\n大量这样的代码，所以就想通过 hook + 数据劫持 来实现下面这样的功能\r\n\r\n```js\r\nimport { useModel } from './utils';\r\nconst app = () => {\r\n  // ... 省略其他代码\r\n  const [arr] = useModel([]);\r\n  arr.push(1);\r\n};\r\n```\r\n\r\n在 push 之类的操作时，自动帮我们完成`setArr([...arr])`这样的操作\r\n\r\n## 实现思路\r\n\r\n之前想借鉴`useEffect, useCallback`之类自带的 hook 来实现，不过很遗憾这个必须要显示调用`setxxx`才会触发，所以现在摆在面前的如何通过变化之后通过回调来触发 set 的操作。\r\n\r\n因为之前使用的是 vue 所以脑海中最先蹦出的就是通过`Object.defineProperty`来劫持数据\r\n\r\n> 这里补充一点，proxy 的效果更好，不过这里会有一些兼容性问题，后面我会将这些功能封装成一个库，优先使用`proxy`之后降级到`Object.defineProperty`\r\n\r\n## Object.defineProperty\r\n\r\n刷过面试题的应该对这个 api 应该不陌生，它是 vue2.x 实现数据劫持的关键，通过拦截对象的 get 和 set 属性，之后分发事件来通知视图进行更新。\r\n\r\n不过这个 api 是有一些缺点的，尤其是对数组而言\r\n\r\n- 不支持拦截`length`属性，这点很关键，会导致我们直接修改`arr.length = 0`无效，原因是内部引擎的规定不允许监听\r\n\r\n- 不支持方法监听，例如使用 push 等\r\n\r\n明确上面两点之后，我们就来动手设计这个`useModel`应该怎么写，思路借鉴 vue2.x 的写法，\r\n\r\n- 约定不能直接修改`length`，例如：`arr[100] = {}`；\r\n- 使用变异方法`push、pop、shift、unshift、splice、sort、reverse`来完成对数组的删除和其他修改；\r\n- 允许修改存在的数组下标，可以直接修改 arr[0]这样的数据；\r\n\r\n> 这里稍微提一下 vue 官方不允许修改已存在数组下标是因为存在性能考虑\r\n\r\n## 实现思路\r\n\r\n实现思路很简单，主要就是递归遍历对象的所有属性，之后将属性改用`get`和`set`的形式进行定义，在对象属性值更改的时候来调用`useState`返回的 set 方法进行数据的更新。\r\n\r\n而数组的变异方法监听，则是通过改写数组的原型链实现，例如\r\n\r\n```js\r\nconst arr = [];\r\nconst myProto = Object.create(Array.prototype);\r\nconst arrFn = arr.push;\r\nmyProto.push = (...rest) => {\r\n  consoole.log(1);\r\n  arrFn.push.apply(arr, rest);\r\n};\r\nObject.setPrototypeOf(arr, myProto);\r\n// 1\r\narr.push(1);\r\n```\r\n\r\n将这个数组的 `__propo__`指向我们自定义的原型对象上，这个原型对象上有 push、pop 等变异方法，通过调用变异方法完成对原数组的的操作和对 set 的更新\r\n\r\n![实现思路](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/db03f6a89974472f9bd617577d3b6365~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n## 具体实现\r\n\r\n代码量并不是很大，所以直接放代码了，一些关键的地方已经进行了注释\r\n\r\n```js\r\nimport { useState } from 'react';\r\nconst isObject = (obj) => {\r\n  return (typeof obj === 'object' && obj) || typeof obj === 'function';\r\n};\r\n// 直接改写成一个通用遍历，这里进行类型判断，后续的useModel则不需要进行判断了\r\nconst each = (obj, change) => {\r\n  if (!isObject(obj)) {\r\n    return;\r\n  }\r\n  const isArr = Array.isArray(obj);\r\n  const keys = isArr ? obj : Object.keys(obj);\r\n  for (let i = 0, len = keys.length; i < len; i++) {\r\n    const key = isArr ? i : keys[i];\r\n    const value = obj[key];\r\n    change(key, value);\r\n  }\r\n};\r\nexport const useModel = (obj) => {\r\n  const [model, setModel] = useState(obj);\r\n  // 更新的时候直接更新顶层对象即可，因为这是hook写法不存在class的局部替换\r\n  const setRootValue = () => {\r\n    if (Array.isArray(model)) {\r\n      setModel([...model]);\r\n      return;\r\n    }\r\n    setModel(Object.assign({...model});\r\n  };\r\n  // 定义对象的key\r\n  const defineProperty = (key, value, o) => {\r\n    Object.defineProperty(o, key, {\r\n      enumerable: true,\r\n      get() {\r\n        return value;\r\n      },\r\n      set(v) {\r\n        if (v === value || (Number.isNaN(v) && Number.isNaN(value))) {\r\n          return;\r\n        }\r\n        value = v;\r\n        setRootValue();\r\n      },\r\n    });\r\n  };\r\n  const definePropertyArray = (all) => {\r\n    const myProto = Object.create(Array.prototype);\r\n    each(['push', 'pop', 'shift', 'unshift', 'splice', 'sort', 'reverse'], (_, value) => {\r\n      const fn = all[value];\r\n      myProto[value] = (...rest) => {\r\n        fn.apply(all, rest);\r\n        setRootValue();\r\n      };\r\n    });\r\n    Object.setPrototypeOf(all, myProto);\r\n  };\r\n  const observer = (all) => {\r\n    each(all, (key, value) => {\r\n      defineProperty(key, value, all);\r\n      observer(value);\r\n    });\r\n    if (Array.isArray(all)) {\r\n      definePropertyArray(all);\r\n    }\r\n  };\r\n  observer(model);\r\n  return [model, setRootValue];\r\n};\r\n```\r\n\r\n> 注意，上面并没有在`Object.defineProperty`set 的时候继续执行深度监听，是因为 hook 在改变的时候就会重新执行这个方法，所以并不需要深度监听\r\n\r\n## 最后\r\n\r\n如果写的有什么不对的地方欢迎指出，如果对你有帮助可以点一下`start`\r\n\r\n为了方便验证效果，放一个[示例代码（可能需要翻墙）](https://codesandbox.io/s/eloquent-kilby-1cdj7?from-embed=&file=/src/App.js)\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/bosens-China/blog/issues/74/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/bosens-China/blog/issues/74/timeline",
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/bosens-China/blog/issues/72",
    "repository_url": "https://api.github.com/repos/bosens-China/blog",
    "labels_url": "https://api.github.com/repos/bosens-China/blog/issues/72/labels{/name}",
    "comments_url": "https://api.github.com/repos/bosens-China/blog/issues/72/comments",
    "events_url": "https://api.github.com/repos/bosens-China/blog/issues/72/events",
    "html_url": "https://github.com/bosens-China/blog/issues/72",
    "id": 914175625,
    "node_id": "MDU6SXNzdWU5MTQxNzU2MjU=",
    "number": 72,
    "title": "团队规范系列之用户体验规范",
    "user": {
      "login": "bosens-China",
      "id": 39508895,
      "node_id": "MDQ6VXNlcjM5NTA4ODk1",
      "avatar_url": "https://avatars.githubusercontent.com/u/39508895?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/bosens-China",
      "html_url": "https://github.com/bosens-China",
      "followers_url": "https://api.github.com/users/bosens-China/followers",
      "following_url": "https://api.github.com/users/bosens-China/following{/other_user}",
      "gists_url": "https://api.github.com/users/bosens-China/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/bosens-China/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/bosens-China/subscriptions",
      "organizations_url": "https://api.github.com/users/bosens-China/orgs",
      "repos_url": "https://api.github.com/users/bosens-China/repos",
      "events_url": "https://api.github.com/users/bosens-China/events{/privacy}",
      "received_events_url": "https://api.github.com/users/bosens-China/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [
      {
        "id": 1371686611,
        "node_id": "MDU6TGFiZWwxMzcxNjg2NjEx",
        "url": "https://api.github.com/repos/bosens-China/blog/labels/%E5%85%B6%E4%BB%96",
        "name": "其他",
        "color": "f6ecbf",
        "default": false,
        "description": "暂定为分享之类的"
      }
    ],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 0,
    "created_at": "2021-06-08T02:22:11Z",
    "updated_at": "2021-06-08T03:09:49Z",
    "closed_at": null,
    "author_association": "OWNER",
    "active_lock_reason": null,
    "body": "![bg](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b9625a50c497462ab14fb45ab08d21d6~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n最近一周的工作重心就是在梳理团队规范，在写的过程也查缺补漏了不少知识，剔除掉关于公司场景的部分就有了这一系列的文章，预计写四部分：\r\n\r\n1. [git 规范](https://github.com/bosens-China/blog/issues/70)\r\n2. [工程规范](https://github.com/bosens-China/blog/issues/71)\r\n3. 用户体验规范\r\n4. [命名规范](https://github.com/bosens-China/blog/issues/73)\r\n\r\n# 用户体验规范\r\n\r\n关于用户体验是一个很庞大的命题并且每个人对于体验的理解也各不相同，同时伴随着时效性，随着新技术的出现可能之前的体验就很快落伍了，所以下面内容只能简短概括下。\r\n\r\n## 通用准则\r\n\r\n### 增加可点击区域大小\r\n\r\n![1.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a2fb47391323406d90d3cc8a350bdf0b~tplv-k3u1fbpfcp-watermark.image)\r\n\r\n以上图为例，如果必须点击到`checkbox`区域才能点击生效，必然会导致体验不佳\r\n\r\n组件的考虑一致性同时也包含了页面结构，对于上图所示 label 和 checkbox 就是一个整体，这里抛砖引玉说一些常见适用该准则的元素：\r\n\r\n- header 区域右上角头像和姓名部分；\r\n- Label、li 等整体一行元素；\r\n- 自定义图标\r\n- ...\r\n\r\n在对上面元素进行交互的时候，尽量避免用户的点击成本，下面说两个常见的做法\r\n\r\n#### 增大整体区域点击，例如有下面一个头像区域\r\n\r\n```html\r\n<p class=\"portrait\">\r\n  <img class=\"portrait-img\" src=\"xxx\" />\r\n  <span class=\"portrait-name\">xxxx</span>\r\n</p>\r\n```\r\n\r\n如果原本是点击事件绑定在`.portrait-img`，那么请考虑增加到`.portrait`\r\n\r\n#### 增大元素本身的点击区域\r\n\r\n```html\r\n<i class=\"i-con\"></i>\r\n```\r\n\r\n对于上面的 i 元素，通常用来设置自定义图标，但是在实际操作中，用户的鼠标或者手势可能存在偏差所以需要增加这个元素的本身范围。\r\n\r\n回归`css box`的概念，我们可以增加`border`来完成增加区域的效果\r\n\r\n```css\r\n.i-con {\r\n  /* 省略其它代码 */\r\n  border: 5px solid transparent;\r\n}\r\n```\r\n\r\n> 注意：pc 上还需要考虑光标的一致性，以及 hover 等一系列整体的效果\r\n\r\n### 图片相关优化\r\n\r\n对于很多项目而言，图片是常见的优化点，毕竟多方面的优化远没有压缩一张图片来的直观，而对于用户体验来说也同样是\r\n\r\n#### 预加载\r\n\r\n不同于懒加载，预加载的目的就是提前输出图片，避免用户等待。\r\n\r\n举一个常见的例子：轮播图就很适合使用预加载，否则用户看到下一张图片的时候还继续等待加载就会感觉很突兀。\r\n\r\n预加载的原理就是提前请求，之后重复请求相同资源时会返回缓存文件，我们可以封装一个方法，利用`Image`对 src 赋值即可\r\n\r\n```js\r\nconst preloading = (src) => {\r\n  return new Promise((resolve, reject) => {\r\n    const img = new Image();\r\n    img.src = src;\r\n    img.onload = resolve;\r\n    img.onerror = reject;\r\n  });\r\n};\r\n```\r\n\r\n#### 错误图片\r\n\r\n各个浏览器对错误图片的处理方式各不相同，虽然存在`alt`提示信息，但是不够统一和美观\r\n\r\n![2.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/eb2385e0dcf34915b0ada7050405f3a5~tplv-k3u1fbpfcp-watermark.image)\r\n\r\n例如上面这种错误信息看起来就不够美观，更好的做法给出默认的错误图片，监听图片的`onerror`事件来重新赋值，如果不想一个个写，可以监听`window.addEventListener error`来完成全局监听\r\n\r\n```js\r\nwindow.addEventListener(\r\n  'error',\r\n  function (event) {\r\n    var dom = event.target;\r\n    if (/img/i.test(dom.nodeName)) {\r\n      dom.src = 'xxxx.png';\r\n    }\r\n  },\r\n  true\r\n);\r\n```\r\n\r\n> 如果想增加对错误图片进行重试，或者对 JSP 动态渲染内容进行拦截，可以参考这篇文章[如何优雅处理图片异常](https://juejin.cn/post/6844904046705246216#heading-2)\r\n\r\n### 空数据默认处理\r\n\r\n对空数据放任不管，可能会导致用户认为系统出现了问题，通常情况下我们要尽量避免空数据的出现，一般而言有两种处理方式\r\n\r\n#### 使用 empty（空状态）进行填充\r\n\r\n![3.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1a378691e6c94997ad9cbf2578f3d310~tplv-k3u1fbpfcp-watermark.image)\r\n\r\n一般 UI 框架现在都内置 empty 组件，可以跟产品和设计沟通无误后，对于常见的 table 或者 list 无数据的进行默认的提示\r\n\r\n```vue\r\n<template>\r\n  <template v-if=\"list.length\"> /* ... */ </template>\r\n  <template v-else>\r\n    <empty />\r\n  </template>\r\n</template>\r\n```\r\n\r\n#### 隐藏整体区域\r\n\r\n![1.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2945ac9ba5ed4a8d83341bf1815157fe~tplv-k3u1fbpfcp-watermark.image)\r\n\r\n对于上面的作者帮当，如果当前子项不存在数据，只展示一个标题和完整榜单的信息可能会很奇怪那不妨考虑删除整体区域\r\n\r\n### 优先使用语义化标签\r\n\r\n尽量避免无语义的`div、span`滥用，因为搜索引擎抓录不友好，维护起来不够直观，而且使用语义化标签可以节省很多代码性工作，下面举一个例子\r\n\r\n![5.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/942b4d168d254463801b2938ee7c8cbe~tplv-k3u1fbpfcp-watermark.image)\r\n\r\n例如上面的按钮，假设它的功能是跳转到一个新的页面，如果在 spa 页面中，我们可以直接使用`vue-router`自带的`router-link`跳转即可完成，而在传统开发中可以在`button`外部嵌套一个`a`标签完成跳转\r\n\r\n```html\r\n<a href=\"xxx\">\r\n  <button>xxx</button>\r\n</a>\r\n<!-- 或者 -->\r\n<router-link to=\"xxx\">\r\n  <button>xxx</button>\r\n</router-link>\r\n```\r\n\r\n而且这样做很容易配合浏览器的一些其它行为，比如右击打开在新标签页\r\n\r\n### 操作反馈\r\n\r\n操作反馈是提升用户体验的一个重要指标，具体可以展开为三部分来说\r\n\r\n#### Require 反馈\r\n\r\n在与后端进行通信的过程中，如果成功或者失败，都请告知用户，而且提示的消息必须友好。\r\n\r\n这里有一个准则\r\n\r\n- 成功消息可以由前端来定义，可以结合各种操作场景做到更细致的提示\r\n- 对于错误消息，则返回后端返回的 message 等信息\r\n- 对于 500 等错误，请在拦截器统一改成`网络连接错误，请稍后重试`，而不是提示一串超时等英文信息\r\n\r\n#### 元素反馈\r\n\r\n在衡量一个 ui 框架的时候就有两点很重要：\r\n\r\n1. 组件本身的交互是否友好，比如动画是否流畅，有没有 hover、active 等效果\r\n2. 对于无障碍阅读是否友好\r\n\r\n可见交互的重要性，要让用户感觉自己在点击一个真实存在的元素，而不是像图片一样的静止\r\n\r\n![6.gif](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f7548ccd492147eb989ca42b2057e0d6~tplv-k3u1fbpfcp-watermark.image)\r\n\r\n例如上图中，最少要存在`hover`、`active`等效果\r\n\r\n#### 等待反馈\r\n\r\n![7.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6af4503f4f9c425583118b98b1f3b57e~tplv-k3u1fbpfcp-watermark.image)\r\n\r\n因为与后端的通信是异步的，而且用户的网络好坏也不是固定不变的，所以给元素添加`loading`就很有必要，这里说两个常见的场景\r\n\r\n#### 表单提交\r\n\r\n![7.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6af4503f4f9c425583118b98b1f3b57e~tplv-k3u1fbpfcp-watermark.image)\r\n\r\n需要操作交互的常见都可以考虑使用`loading`，这样可以防止用户重复点击和避免用户不知道有没有点击成功\r\n\r\n#### 重新获取数据\r\n\r\n![8.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/17d967b2947344f5815e114084df2ad8~tplv-k3u1fbpfcp-watermark.image)\r\n\r\n#### 获取前置信息\r\n\r\n在 pc 上，整体进入页面的时候为了掩盖获取一些前置的信息的场景，可以选择使用 loading 元素减少用户等待的焦虑感\r\n\r\n### 缓存\r\n\r\n缓存本质上就是拿空间换时间，对于客户端而言，更多的瓶颈是在时间上，下面就说两种常见的缓存场景\r\n\r\n#### 组件信息缓存\r\n\r\n![9.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2dbabc0b5fb8449297b174ca267ef2f2~tplv-k3u1fbpfcp-watermark.image)\r\n\r\n例如上面表单，如果用户误操作关闭网页，从头开始填写体验就不是特别好，可以在未提交成功的状态下结合本地做持久化缓存\r\n\r\n下面给一个简单示例（没有给出完成清除本地储存）\r\n\r\n```vue\r\n<script>\r\nimport { reactive, watchEffect } from 'vue';\r\n\r\nexport default {\r\n  setUp() {\r\n    const key = 'form';\r\n    const form = reactive({\r\n      name: '',\r\n      password: '',\r\n    });\r\n    const set = (key, value) => {\r\n      localStorage.setItem(key, JSON.stringify(value));\r\n    };\r\n    const get = () => {\r\n      const value = localStorage.getItem(key);\r\n      try {\r\n        return JSON.parse(value);\r\n      } catch {\r\n        return undefined;\r\n      }\r\n    };\r\n    watchEffect(() => {\r\n      set(key, form);\r\n    });\r\n    Object.assign(form, get('form'));\r\n  },\r\n};\r\n</script>\r\n```\r\n\r\n#### 接口缓存\r\n\r\n如果存在频繁请求且很耗时，接口本身基本不会变更的情况，可以考虑接口缓存，下面给出一段简单的代码示例\r\n\r\n生产环境可以考虑使用一些库 [axios-request-cache](https://github.com/ZhengXiaowei/axios-request-cache)\r\n\r\n```js\r\nimport axios from 'axios';\r\nconst { toString } = Object.prototype;\r\n\r\n// 数据存储\r\nexport const cache = {\r\n  data: {},\r\n  set(key, data) {\r\n    this.data[key] = data;\r\n  },\r\n  get(key) {\r\n    return this.data[key];\r\n  },\r\n  clear(key) {\r\n    delete this.data[key];\r\n  },\r\n};\r\n\r\n// 建立唯一的key值\r\nexport const buildUniqueUrl = (url, method, params = {}, data = {}) => {\r\n  const paramStr = (obj) => {\r\n    if (toString.call(obj) === '[object Object]') {\r\n      return JSON.stringify(\r\n        Object.keys(obj)\r\n          .sort()\r\n          .reduce((result, key) => {\r\n            result[key] = obj[key];\r\n            return result;\r\n          }, {})\r\n      );\r\n    } else {\r\n      return JSON.stringify(obj);\r\n    }\r\n  };\r\n  url += `?${paramStr(params)}&${paramStr(data)}&${method}`;\r\n  return url;\r\n};\r\n\r\n// 防止重复请求\r\nexport default (options = {}) =>\r\n  async (config) => {\r\n    const defaultOptions = {\r\n      // 设置为0，不清除缓存\r\n      time: 0,\r\n      ...options,\r\n    };\r\n    const index = buildUniqueUrl(config.url, config.method, config.params, config.data);\r\n    let responsePromise = cache.get(index);\r\n    if (!responsePromise) {\r\n      responsePromise = (async () => {\r\n        try {\r\n          const response = await axios.defaults.adapter(config);\r\n          return Promise.resolve(response);\r\n        } catch (reason) {\r\n          cache.clear(index);\r\n          return Promise.reject(reason);\r\n        }\r\n      })();\r\n      cache.set(index, responsePromise);\r\n      if (defaultOptions.time !== 0) {\r\n        setTimeout(() => {\r\n          cache.clear(index);\r\n        }, defaultOptions.time);\r\n      }\r\n    }\r\n    // 为防止数据源污染\r\n    return responsePromise.then((data) => JSON.parse(JSON.stringify(data)));\r\n  };\r\n```\r\n\r\n### 风格一致性\r\n\r\n风格一致性包含很多部分，这里不太好全部列举，就说两个常见的\r\n\r\n#### 视觉颜色一致\r\n\r\n每个页面都有一个主色号，对于设计图或者原型图没有给到的部分，自己动手或者引用组件时需要考虑是否跟主色号存在冲突，这里推荐阅读一下`视觉规范`，下面给出一个示例\r\n\r\n![2.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2efab79f3bf4429c852e5f7e4182a8ae~tplv-k3u1fbpfcp-watermark.image)\r\n\r\n![3.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4f0aabbe895d42f0b18b0bdd5b9a7698~tplv-k3u1fbpfcp-watermark.image)\r\n\r\n在默认的 vant 组件中，tab 默认的颜色是`#ee0a24`，如果直接放上去就会导致页面风格不统一，因为页面整体风格是蓝色\r\n\r\n#### 组件交互一致性\r\n\r\n这里在自定义扩展或者二次封装比较常见，还是以表单为例\r\n\r\n![9.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/56f9f210d65e4ae9b23516548a1056e1~tplv-k3u1fbpfcp-watermark.image)\r\n\r\n如果我们想自定义根据业务进行一个文件上传的组件，除了考虑功能本身的实现，还要考虑一致性的问题，例如校验的问题\r\n\r\n这里`Ant Design `在不符合条件的`form-item`下面出现一个红字提示，而如果我们使用`message`或者其他提示就会造成提示信息的不一致性，那更好的做法就是根据官方文档提供的自定义插件做法进行组件开发。\r\n\r\n## pc\r\n\r\n### 考虑最小布局\r\n\r\n请设置`min-width`，防止因为宽度不够导致元素挤在一起\r\n\r\n```css\r\nbody {\r\n  /* 省略其它 */\r\n  min-width: 1200px;\r\n  overflow: auto;\r\n}\r\n```\r\n\r\n### 表格宽度\r\n\r\n对于表格，根据字段的权值不同分配的宽度也应该不同，尽量不要使用`auto`避免二次表格宽度计算造成视觉上的浮动\r\n\r\n![13.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d295a4f0c4544388b1190c62b862bd3c~tplv-k3u1fbpfcp-watermark.image)\r\n\r\n对于不可省略的信息可以让其换行展示，否则请考虑`ellipsis`\r\n\r\n```css\r\n.ellipsis {\r\n  overflow: hidden;\r\n  white-space: nowrap;\r\n  text-overflow: ellipsis;\r\n}\r\n```\r\n\r\n### 指标卡片添加 tip\r\n\r\n在一些中台产品中，很容易遇到一些专业名词，比如`pv`和`uv`等，对于这种专业名词，建议添加一个问号的提示图标，鼠标移动上去给与提示\r\n\r\n![14.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fc35ab89bc294f45b7c0c070d527ec9e~tplv-k3u1fbpfcp-watermark.image)\r\n\r\n上面效果仅供参考\r\n\r\n### 支持键盘快捷键\r\n\r\n![9.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6a0349131f50469e85f9efbeb0934b2f~tplv-k3u1fbpfcp-watermark.image)\r\n\r\n如上图所示，在我们使用`form`或者`input`时，如果按下`enter`时请确保可以进行正常的搜索或者提交操作，不仅局限于表单提交，对于一些常见的搜索场景都需要考虑\r\n\r\n一个好的建议，对于需要 submit 的子元素，都绑定`.enter`修饰符\r\n\r\n```vue\r\n<input @keyup.enter=\"submit\" />\r\n```\r\n\r\n### SPA 路由导航\r\n\r\n对于单页面导航请考虑使用[nprogress](https://github.com/rstacruz/nprogress)这样的进度条，为你的页面添加进度通知\r\n\r\n![15.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7b2a1bf70cab4c279339f2e11ef5e5e0~tplv-k3u1fbpfcp-watermark.image)\r\n\r\n## 移动端\r\n\r\n### 左右滑动监听\r\n\r\n浏览了许多 H5 的页面，对于手势左右滑动基本上都没做支持，而在很多 App 上，例如知乎，从首页进去问题左滑就可以返回\r\n\r\n![微信图片_20210608100923.jpg](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5e1ef02488054521999304fe663d9867~tplv-k3u1fbpfcp-watermark.image)\r\n\r\n这里稍微建议一下，对于下面两种情况可以考虑引入左滑返回\r\n\r\n- 跟上面图片一致的 tab 页比较多，可以考虑做成 tab 下的元素滑动监听\r\n- 对于一些列表和详情页\r\n\r\n推荐一个库源码也很简洁可以基于这个库进行二次封装，提高用户的体验 [swipy](https://github.com/whitecube/swipy)\r\n\r\n### 尽量使用 SVG\r\n\r\nSVG 是一种图像文件格式，它的英文全称为 Scalable Vector Graphics，意思为可缩放的矢量图形。基于 XML 的标记语言\r\n\r\nSVG 是矢量图，它有很多优点\r\n\r\n- SVG 是可伸缩的，在任何的分辨率下被高质量地打印\r\n- SVG 可在图像质量不下降的情况下被放大\r\n- 修改方便，可以在记事本之类的软件中被打开\r\n\r\n而在开发移动端，面对的用户手机的屏幕也各不相同，之前的做法是对不同 ratio 的手机选择不同的图片，但是根据上面 SVG 的优点，我们可以直接选用 SVG 当做图片\r\n\r\n而在 SVG 不适用的场景，我们可以利用媒体查询，选择合适的高倍图\r\n\r\n```js\r\nexport const getMultipleImg = (img1, img2) => {\r\n  const mql = window.matchMedia('@media only screen and (-webkit-min-device-pixel-ratio:3)');\r\n  if (mql.matches) {\r\n    return img2;\r\n  }\r\n  return img1;\r\n};\r\n```\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/bosens-China/blog/issues/72/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/bosens-China/blog/issues/72/timeline",
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/bosens-China/blog/issues/71",
    "repository_url": "https://api.github.com/repos/bosens-China/blog",
    "labels_url": "https://api.github.com/repos/bosens-China/blog/issues/71/labels{/name}",
    "comments_url": "https://api.github.com/repos/bosens-China/blog/issues/71/comments",
    "events_url": "https://api.github.com/repos/bosens-China/blog/issues/71/events",
    "html_url": "https://github.com/bosens-China/blog/issues/71",
    "id": 914142576,
    "node_id": "MDU6SXNzdWU5MTQxNDI1NzY=",
    "number": 71,
    "title": "团队规范系列之工程规范 ",
    "user": {
      "login": "bosens-China",
      "id": 39508895,
      "node_id": "MDQ6VXNlcjM5NTA4ODk1",
      "avatar_url": "https://avatars.githubusercontent.com/u/39508895?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/bosens-China",
      "html_url": "https://github.com/bosens-China",
      "followers_url": "https://api.github.com/users/bosens-China/followers",
      "following_url": "https://api.github.com/users/bosens-China/following{/other_user}",
      "gists_url": "https://api.github.com/users/bosens-China/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/bosens-China/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/bosens-China/subscriptions",
      "organizations_url": "https://api.github.com/users/bosens-China/orgs",
      "repos_url": "https://api.github.com/users/bosens-China/repos",
      "events_url": "https://api.github.com/users/bosens-China/events{/privacy}",
      "received_events_url": "https://api.github.com/users/bosens-China/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [
      {
        "id": 1371686611,
        "node_id": "MDU6TGFiZWwxMzcxNjg2NjEx",
        "url": "https://api.github.com/repos/bosens-China/blog/labels/%E5%85%B6%E4%BB%96",
        "name": "其他",
        "color": "f6ecbf",
        "default": false,
        "description": "暂定为分享之类的"
      }
    ],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 0,
    "created_at": "2021-06-08T01:42:17Z",
    "updated_at": "2021-06-08T03:09:47Z",
    "closed_at": null,
    "author_association": "OWNER",
    "active_lock_reason": null,
    "body": "![bg](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7235b285206d49f5bb8f0cc2e43771c9~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n最近一周的工作重心就是在梳理团队规范，在写的过程也查缺补漏了不少知识，剔除掉关于公司场景的部分就有了这一系列的文章，预计写四部分：\r\n\r\n1. [git 规范](https://github.com/bosens-China/blog/issues/70)\r\n2. 工程规范\r\n3. [用户体验规范](https://github.com/bosens-China/blog/issues/72)\r\n4. [命名规范](https://github.com/bosens-China/blog/issues/73)\r\n\r\n# 工程规范\r\n\r\n## 项目目录\r\n\r\n项目目录定义的名称应当做到清晰易读，对于每个文件夹可以放置一个`README.md`的文件，对重要部分和职责进行描述，下面给一份常用的示例：\r\n\r\n```sh\r\n├── public                          // 静态页面\r\n├── scripts                         // 相关脚本配置\r\n├── src                             // 主目录\r\n    ├── assets                      // 静态资源\r\n    ├── components                  // 全局组件\r\n    ├── lib                         // 全局插件\r\n    ├── router                      // 路由配置\r\n    ├── store                       // vuex 配置\r\n    ├── styles                      // 样式\r\n    ├── utils                       // 工具方法(axios封装，全局方法等)\r\n    ├── views                       // 页面\r\n    ├── App.vue                     // 页面主入口\r\n    ├── main.js                     // 脚本主入口\r\n```\r\n\r\n下面再说几条建议：\r\n\r\n- 如果存在嵌套路由的页面，可以在 src 定义一个 `layout` 当做基础的视图组件使用\r\n- `components` 文件内的组件请保持通用性\r\n- 如果 views 存在业务组件，可以在当前目录下新建 components 使用，或者基于全局 components 进行二次封装\r\n- views 下的页面使用文件夹的形式来定义，例如有一个统计页面，如果只写一个`.vue`文件会导致文件内容过多，而如果直接在 views 下进行抽离多个`.vue`会导致结构不统一\r\n\r\n## utils\r\n\r\n对于 utils 下的文件，请保持按照文件类型进行划分，下面截取[ant-design-pro](https://github.com/ant-design/ant-design-pro/tree/master/src/utils)的 utils 文件为例\r\n\r\n| 名称          |                            提交信息                             |\r\n| ------------- | :-------------------------------------------------------------: |\r\n| Authorized.ts |                     use @umijs/fabric@2.5.0                     |\r\n| authority.ts  |       🌎 localization: docs translated to english (#7938)       |\r\n| request.ts    |       🌎 localization: docs translated to english (#7938)       |\r\n| utils.less    |                clean: remove unuse less (#6214)                 |\r\n| utils.test.ts | feat: @umijs/route-utils replace getAuthorityFromRouter (#7319) |\r\n| utils.ts      |       🌎 localization: docs translated to english (#7938)       |\r\n\r\n> 在开发项目中，请优先使用 [lodash](https://www.lodashjs.com/) 这样的工具库，并在此基础上封装自己的方法，如果真的不存再在考虑手动实现从 0 到 1 实现\r\n\r\n## VueX\r\n\r\n在大型项目中，对 VueX 的拆分通常根据业务，请不要直接使用 VueX 下的`State`、`Getter`、`Mutation`等，而是改用`Module`将相关依赖聚合在一起，最后通过`import`整合在一起，下面以 home 文件夹为例：\r\n\r\n```sh\r\n├── home                            // 主目录\r\n    ├── index.js                    // VueX state getters mutations action 管理\r\n    ├── ...                         // 可能存在的其它文件\r\n└── index.js                        // VueX 主入口\r\n```\r\n\r\nhome/index.js\r\n\r\n```js\r\nexport default {\r\n  namespaced: true,\r\n  state: () => ({ ... }),\r\n  mutations: { ... },\r\n  actions: { ... },\r\n  getters: { ... }\r\n}\r\n```\r\n\r\nindex.js\r\n\r\n```js\r\nimport { createStore } from 'vuex';\r\nimport home from './home';\r\n\r\nconst store = createStore({\r\n  modules: {\r\n    home,\r\n  },\r\n});\r\n\r\nexport default store;\r\n```\r\n\r\n## Router\r\n\r\n### 路由层级\r\n\r\n路由层级十分重要，在 Router4 之前，会根据路由定义的顺序来决定路由的先后顺序，如果层级很不清晰会导致两个问题：\r\n\r\n- 维护或者定义新路由需要查找半天\r\n- 遍历 routes 信息十分困难，做权限之类的的很麻烦\r\n\r\n![1.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8312de118fe34964afb919655f2f7292~tplv-k3u1fbpfcp-watermark.image)\r\n\r\n举个例子，对于上面的一个设计图，包含：`head、content、footer`三个部分，观察他们剩余设计图顶部和底部基本相同，只是 content 区域的内容有所不同。\r\n\r\n而对这样一个设计图进行开发，可以定义一个`layout`组件当做基础公共结构，之后书写`routers`的具体信息\r\n\r\n```sh\r\n├── routes                            // routes的定义目录\r\n    ├── home.js                       // 首页\r\n    ├── type.js                       // 分类\r\n    ├── food.js                       // 东家菜\r\n    ├── brand.js                       // 大牌\r\n└── index.js                          // vue router 主入口\r\n└── routes.js                         // 将routers目录下的文件分发成最终vue router使用结构\r\n```\r\n\r\nroutes.js\r\n\r\n```js\r\nimport layout from '@/layout';\r\nimport home from './routes/home';\r\nimport type from './routes/type';\r\nimport food from './routes/food';\r\nimport brand from './routes/brand';\r\n\r\nconst routes = [\r\n  {\r\n    path: '/',\r\n    component: layout,\r\n    children: home,\r\n  },\r\n  {\r\n    path: '/',\r\n    component: layout,\r\n    children: type,\r\n  },\r\n  {\r\n    path: '/',\r\n    component: layout,\r\n    children: food,\r\n  },\r\n  {\r\n    path: '/',\r\n    component: layout,\r\n    children: brand,\r\n  },\r\n];\r\n\r\nexport default routes;\r\n```\r\n\r\nindex.js\r\n\r\n```js\r\nimport { createRouter, createWebHistory, createWebHashHistory } from 'vue-router';\r\n\r\nimport routes from './routes';\r\n\r\nconst router = createRouter({\r\n  routes,\r\n});\r\n\r\n// 全局导航守卫\r\nrouter.beforeEach(async (to) => {\r\n  // ...\r\n});\r\n\r\nexport default router;\r\n```\r\n\r\n### 捕获未知路由\r\n\r\n无论在做中台还是移动端的产品，都需要正确处理未知的路由，一般而言有二种处理方式，具体参考项目的类型进行选择：\r\n\r\n1. 直接给出 404 之类的提示，提示页面不存在等信息；\r\n2. 帮助其重定向到首页或者其它页面；\r\n\r\n```js\r\n// vue router4\r\n{ path: '/:pathMatch(._)_', name: 'NotFound', redirect: { name: 'home' } };\r\n\r\n// vue router3\r\n{ path: '*', name: 'NotFound', redirect: { name: 'home' } };\r\n```\r\n\r\n### 路由懒加载\r\n\r\n使用懒加载可以节省白屏时间，懒加载的机制利用了 webpack 代码分割 + import()，只在进入当前路由的时候加载所依赖的 js 文件。\r\n\r\n```js\r\n  { path: '/', name: 'home', component: () => import(/* webpackChunkName: \"home\" */ 'views/home/index.vue') }\r\n```\r\n\r\n> 除了需要`children`的父级页面，所有其它页面统一使用懒加载\r\n>\r\n> `/* webpackChunkName: \"home\" */`这样的注释语法，是 webpack 独有的，它负责 build 打包之后的文件名称\r\n\r\n## 组件拆分建议\r\n\r\n![2.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/620871b1cb374af4a5995db475119ba6~tplv-k3u1fbpfcp-watermark.image)\r\n\r\n一个大型项目由无数子组件组合而成，有点像乐高积木一样，直接开发一个大型项目肯定很难，但是如果给无数子组件让你拼接则相对简单。\r\n\r\n组件的拆分，应该遵循两个原则：\r\n\r\n### 颗粒度细分\r\n\r\n在学习设计模式中有很重要的一句话就是**单一职责**，在组件开发也是同理，原则上让一个组件只负责一件事情，可以最大程度的复用组件，方便测试和定位问题。\r\n\r\n但是过度的单一职责组件也会导致一个问题就是颗粒度太细造成组件的碎片化，举一个例子来说，自动完成组件，它是搜索框 + select 组合而成，因此我们可以直接复用，因为前两个组件的颗粒度刚刚好。\r\n\r\n![3.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0e6da1bee9e44e9a9059520b8555a99b~tplv-k3u1fbpfcp-watermark.image)\r\n\r\n还有一个例子就是徽章数组件(Badge)，它的右上角会有红点提示，可能是数字也可能是 icon，它的职责当然也很单一，这个红点提示也理所当然也可以被单独抽象为一个独立组件，但是我们通常不会将它作为独立组件，因为在其它场景中这个组件是无法被复用的，因为没有类似的场景再需要小红点这个小组件了\r\n\r\n![4.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/517274f4b3744cd9acd35e15c091425f~tplv-k3u1fbpfcp-watermark.image)\r\n\r\n### 通用性考虑\r\n\r\n组件分为基础组件和业务组件，当存在业务常见重复使用的时候通常会对通用组件进行二次封装，例如有一个搜索部门的组件，这个组件在很多 view 都有复用而且也对这个组件集成了自动搜索 + 初始 loading + 自动加载下一页，最后使用效果用起来也很方便。\r\n\r\n但是现在突然来一个需求，说对搜索的组件进行底部提示，那难道直接更改源码吗？但是如果直接更改组件，这样也违背了`开放、关闭原则`\r\n\r\n其实说这个例子就是希望思考组件广的适配性，在使用第三方的组件，会看到它们暴露了很多插槽、jsx 的渲染函数，最终的目的也就是应对各种各样的场景\r\n\r\n> 组件的形态(DOM 结构)永远是千变万化的，但是其行为(逻辑)是固定的，因此通用组件的秘诀之一就是将 DOM 结构的控制权交给开发者,组件只负责行为和最基本的 DOM 结构\r\n\r\n## 工程优化\r\n\r\n优化是一个很庞大的命题，根据项目的不同所采取的方式也不尽相同，下面只总结一些常用的方式\r\n\r\n### 项目优化\r\n\r\n- CND\r\n- gzip，让后端支持 gzip 压缩，前端也生成 gzip 文件\r\n- 使用 webp 格式，生产环境下压缩图片\r\n- 路由懒加载\r\n- 第三方组件按需加载\r\n- 抽离第三方库，避免和业务组件耦合一起打包\r\n- ...\r\n\r\n### code 优化\r\n\r\n- 减少对 dom 操作，如果操作将所有 dom 聚合在一起修改\r\n- 不直接修改 style 改用 class 修改；\r\n- 尽量不适用 table，绑定事件采用事件委托形式\r\n- 对动画元素，让其脱离文档流，减少重绘和重排\r\n- ...\r\n\r\n### 构建过程优化\r\n\r\n- 删除 eslint-loader，改用编辑器自带的 eslint\r\n- 使用 catch-loader，对资源进行加速\r\n- 生产环境下删除`.map`文件，缩短`import`查找后缀\r\n- ...\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/bosens-China/blog/issues/71/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/bosens-China/blog/issues/71/timeline",
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/bosens-China/blog/issues/73",
    "repository_url": "https://api.github.com/repos/bosens-China/blog",
    "labels_url": "https://api.github.com/repos/bosens-China/blog/issues/73/labels{/name}",
    "comments_url": "https://api.github.com/repos/bosens-China/blog/issues/73/comments",
    "events_url": "https://api.github.com/repos/bosens-China/blog/issues/73/events",
    "html_url": "https://github.com/bosens-China/blog/issues/73",
    "id": 914211223,
    "node_id": "MDU6SXNzdWU5MTQyMTEyMjM=",
    "number": 73,
    "title": "团队规范系列之命名规范",
    "user": {
      "login": "bosens-China",
      "id": 39508895,
      "node_id": "MDQ6VXNlcjM5NTA4ODk1",
      "avatar_url": "https://avatars.githubusercontent.com/u/39508895?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/bosens-China",
      "html_url": "https://github.com/bosens-China",
      "followers_url": "https://api.github.com/users/bosens-China/followers",
      "following_url": "https://api.github.com/users/bosens-China/following{/other_user}",
      "gists_url": "https://api.github.com/users/bosens-China/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/bosens-China/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/bosens-China/subscriptions",
      "organizations_url": "https://api.github.com/users/bosens-China/orgs",
      "repos_url": "https://api.github.com/users/bosens-China/repos",
      "events_url": "https://api.github.com/users/bosens-China/events{/privacy}",
      "received_events_url": "https://api.github.com/users/bosens-China/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [
      {
        "id": 1371686611,
        "node_id": "MDU6TGFiZWwxMzcxNjg2NjEx",
        "url": "https://api.github.com/repos/bosens-China/blog/labels/%E5%85%B6%E4%BB%96",
        "name": "其他",
        "color": "f6ecbf",
        "default": false,
        "description": "暂定为分享之类的"
      }
    ],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 0,
    "created_at": "2021-06-08T02:53:40Z",
    "updated_at": "2021-06-08T03:09:35Z",
    "closed_at": null,
    "author_association": "OWNER",
    "active_lock_reason": null,
    "body": "![bg](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4b7b48b9a67c44eab564bf46e99f1ee0~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n最近一周的工作重心就是在梳理团队规范，在写的过程也查缺补漏了不少知识，剔除掉关于公司场景的部分就有了这一系列的文章，预计写四部分：\r\n\r\n1. [git 规范](https://github.com/bosens-China/blog/issues/70)\r\n2. [工程规范](https://github.com/bosens-China/blog/issues/71)\r\n3. [用户体验规范](https://github.com/bosens-China/blog/issues/72)\r\n4. 命名规范\r\n\r\n# 命名规范\r\n\r\n命名规范请结合团队情况来进行制定，如果想更进阶一些可以配合 git 钩子写校验工具，配合规范食用\r\n\r\n## 代码命名规范\r\n\r\n### 避免用一个字母命名\r\n\r\n```js\r\n// bad\r\nfunction q() {\r\n  // ...\r\n}\r\n\r\n// good\r\nfunction query() {\r\n  // ...\r\n}\r\n```\r\n\r\n### 用小驼峰命名法来命名你的对象、函数、实例\r\n\r\n```js\r\n// bad\r\nconst OBJEcttsssss = {};\r\nconst this_is_my_object = {};\r\nfunction c() {}\r\n\r\n// good\r\nconst thisIsMyObject = {};\r\nfunction thisIsMyFunction() {}\r\n```\r\n\r\n### 用大驼峰命名法来命名类\r\n\r\n```js\r\n// bad\r\nfunction user(options) {\r\n  this.name = options.name;\r\n}\r\n\r\nconst bad = new user({\r\n  name: 'nope',\r\n});\r\n\r\n// good\r\nclass User {\r\n  constructor(options) {\r\n    this.name = options.name;\r\n  }\r\n}\r\n\r\nconst good = new User({\r\n  name: 'yup',\r\n});\r\n```\r\n\r\n### 不要用前置或后置下划线\r\n\r\nJavaScript 没有私有属性或私有方法的概念。尽管前置下划线通常的概念上意味着私有，事实上，这些属性是完全公有的，因此这部分也是你的 API 的内容。这一概念可能会导致开发者误以为更改这个不会导致崩溃或者不需要测试。如果你想要什么东西变成私有，那就不要让它在这里出现。\r\n\r\n```js\r\n// bad\r\nthis.__firstName__ = 'Panda';\r\nthis.firstName_ = 'Panda';\r\nthis._firstName = 'Panda';\r\n\r\n// good\r\nthis.firstName = 'Panda';\r\n```\r\n\r\n### export\r\n\r\n#### export-default 导出名称与 import 引用名称保持一致\r\n\r\n例如：`export-default 模块 A`，则这个文件名也叫 `A`， import 时候的参数也叫 `A`。 大小写完全一致。\r\n\r\n```js\r\n// file 1 contents\r\nclass CheckBox {\r\n  // ...\r\n}\r\nexport default CheckBox;\r\n\r\n// file 2 contents\r\nexport default function fortyTwo() { return 42; }\r\n\r\n// file 3 contents\r\nexport default function insideDirectory() {}\r\n\r\n// in some other file\r\n// bad\r\nimport CheckBox from './checkBox'; // PascalCase import/export, camelCase filename\r\nimport FortyTwo from './FortyTwo'; // PascalCase import/filename, camelCase export\r\nimport InsideDirectory from './InsideDirectory'; // PascalCase import/filename, camelCase export\r\n\r\n// bad\r\nimport CheckBox from './check_box'; // PascalCase import/export, snake_case filename\r\nimport forty_two from './forty_two'; // snake_case import/filename, camelCase export\r\nimport inside_directory from './inside_directory'; // snake_case import, camelCase export\r\nimport index from './inside_directory/index'; // requiring the index file explicitly\r\nimport insideDirectory from './insideDirectory/index'; // requiring the index file explicitly\r\n\r\n// good\r\nimport CheckBox from './CheckBox'; // PascalCase export/import/filename\r\nimport fortyTwo from './fortyTwo'; // camelCase export/import/filename\r\nimport insideDirectory from './insideDirectory'; // camelCase export/import/directory name/implicit \"index\"\r\n// ^ supports both insideDirectory.js and insideDirectory/index.js\r\n```\r\n\r\n#### export-default 一个函数时，函数名用小驼峰，文件名需要和函数名一致\r\n\r\n```js\r\nfunction makeStyleGuide() {\r\n  // ...\r\n}\r\n\r\nexport default makeStyleGuide;\r\n```\r\n\r\n#### export 一个结构体/类/单例/函数库/对象 时用大驼峰\r\n\r\n```js\r\nconst AirbnbStyleGuide = {\r\n  es6: {},\r\n};\r\n\r\nexport default AirbnbStyleGuide;\r\n```\r\n\r\n### 简称和缩写应该全部大写或全部小写\r\n\r\n```js\r\n// bad\r\nimport SmsContainer from './containers/SmsContainer';\r\n\r\n// bad\r\nconst HttpRequests = [\r\n  // ...\r\n];\r\n\r\n// good\r\nimport SMSContainer from './containers/SMSContainer';\r\n\r\n// good\r\nconst HTTPRequests = [\r\n  // ...\r\n];\r\n\r\n// also good\r\nconst httpRequests = [\r\n  // ...\r\n];\r\n\r\n// best\r\nimport TextMessageContainer from './containers/TextMessageContainer';\r\n\r\n// best\r\nconst requests = [\r\n  // ...\r\n];\r\n```\r\n\r\n### 导出静态变量\r\n\r\n如果导出静态变量，它需要以下条件：\r\n\r\n- 确保被导出\r\n- 尽量全部大写\r\n- const 定义的，保证不能被改变\r\n- 如果导出对象，这个变量是可信的，他的子属性都是不能被改变的\r\n\r\n```js\r\n// bad\r\nconst PRIVATE_VARIABLE = 'should not be unnecessarily uppercased within a file';\r\n// bad\r\nexport const THING_TO_BE_CHANGED = 'should obviously not be uppercased';\r\n// bad\r\nexport let REASSIGNABLE_VARIABLE = 'do not use let with uppercase variables';\r\n// 允许但不够语义化\r\nexport const apiKey = 'SOMEKEY';\r\n// 更好的\r\nexport const API_KEY = 'SOMEKEY';\r\n\r\n// bad 不必要的大写键，没有增加任何语义\r\nexport const MAPPING = {\r\n  KEY: 'value',\r\n};\r\n// good\r\nexport const MAPPING = {\r\n  key: 'value',\r\n};\r\n```\r\n\r\n## CSS 命名规范\r\n\r\ncss 命名规范有很多方案，这里采用`BEM`作为规范，之所以采用 `BEM` 是因为它让你的前端代码更容易阅读和理解，更容易协作，更容易控制，更加健壮和明确，而且更加严密。\r\n\r\n下面介绍一些相关的概念，以及如何书写\r\n\r\n### 什么是 BEM 命名规范\r\n\r\nBem 是块（block）、元素（element）、修饰符（modifier）的简写，由 Yandex 团队提出的一种前端 CSS 命名方法论。\r\n\r\n- 中划线 ：仅作为连字符使用，表示某个块或者某个子元素的多单词之间的连接记号。\r\n\r\n- 双下划线：双下划线用来连接块和块的子元素\r\n\r\n- 单下划线：单下划线用来描述一个块或者块的子元素的一种状态\r\n\r\n### BEM 命名模式\r\n\r\n根据上面条件，下面写一个示例\r\n\r\n```css\r\n.block {\r\n}\r\n\r\n.block__element {\r\n}\r\n\r\n.block--modifier {\r\n}\r\n```\r\n\r\n仔细观察上面结构可以得到三个信息：\r\n\r\n- 每一个块(block)名应该有一个命名空间（前缀）\r\n- `block__element` 代表 `.block` 的后代，用于形成一个完整的 `.block` 的整体\r\n- `block--modifier` 代表 `.block` 的不同状态或不同版本\r\n\r\n使用两个连字符和下划线而不是一个，是为了让你自己的块可以用单个连字符来界定。如：\r\n\r\n```css\r\n.sub-block__element {\r\n}\r\n\r\n.sub-block--modifier {\r\n}\r\n```\r\n\r\n### 什么时候使用 BEM 命名\r\n\r\n- 你要知道什么时候哪些东西是应该写成 BEM 格式的\r\n\r\n或者说你要事先知道效果图或者 dom 结构应当是一个什么样子的\r\n\r\n- 只有模块或者组件有关联的时候才使用 BEM 格式\r\n\r\n- 单独的样式，没有必要使用 BEM 命名\r\n\r\n```css\r\n.hide {\r\n  display: none !important;\r\n}\r\n```\r\n\r\n### 与预处理器结合\r\n\r\nBEM 写起来可能会存在命名很长，但是如果有 less 之类的预处理器就能节省我们很多时间，下面以 less 为例\r\n\r\n```less\r\n.article {\r\n  max-width: 1200px;\r\n  &__body {\r\n    padding: 20px;\r\n  }\r\n  &__button {\r\n    padding: 5px 8px;\r\n    &--primary {\r\n      background: blue;\r\n    }\r\n    &--success {\r\n      background: green;\r\n    }\r\n  }\r\n}\r\n```\r\n\r\n### 在 Vue 中使用\r\n\r\nVue 为了简便开发提供了 `scope` 的 css 语法糖，但是在 BEM 中并不推荐，因为使用`scope`的目的就是避免样式冲突，而 BEM 本身就已经可以做到了。\r\n\r\n```vue\r\n<template>\r\n  <form class=\"form form--theme-xmas form--simple\">\r\n    <input class=\"form__input\" type=\"text\" />\r\n    <input class=\"form__submit form__submit--disabled\" type=\"submit\" />\r\n  </form>\r\n</template>\r\n\r\n<script lang=\"css\">\r\n.form { }\r\n.form--theme-xmas { }\r\n.form--simple { }\r\n.form__input { }\r\n.form__submit { }\r\n.form__submit--disabled { }\r\n</script>\r\n```\r\n\r\n## 组件命名规范\r\n\r\n### 文件名应始终单词大写开头或横线连接\r\n\r\n单词大写开头对于代码编辑器的自动补全最为友好，因为这使得我们在 `JS(X)` 和模板中引用组件的方式尽可能的一致。然而，混用文件命名方式有的时候会导致大小写不敏感的文件系统的问题，这也是横线连接命名同样完全可取的原因。\r\n\r\n```sh\r\n# bad\r\ncomponents/\r\n|- mycomponent.vue\r\n```\r\n\r\n```sh\r\ncomponents/\r\n|- myComponent.vue\r\n```\r\n\r\n```sh\r\n# good\r\ncomponents/\r\n|- TodoList.js\r\n|- TodoItem.js\r\n```\r\n\r\n```sh\r\n# good\r\ncomponents/\r\n|- TodoList.vue\r\n|- TodoItem.vue\r\n```\r\n\r\n### 基础组件以一个特定的前缀开头\r\n\r\n应用特定样式和约定的基础组件 (也就是展示类的、无逻辑的或无状态的组件) 应该全部以一个特定的前缀开头，比如 `Base`、`App` 或 `V`。\r\n\r\n```sh\r\n# bad\r\ncomponents/\r\n|- MyButton.vue\r\n|- VueTable.vue\r\n|- Icon.vue\r\n```\r\n\r\n```sh\r\n# good\r\ncomponents/\r\n|- BaseButton.vue\r\n|- BaseTable.vue\r\n|- BaseIcon.vue\r\n# or\r\ncomponents/\r\n|- AppButton.vue\r\n|- AppTable.vue\r\n|- AppIcon.vue\r\n# or\r\ncomponents/\r\n|- VButton.vue\r\n|- VTable.vue\r\n|- VIcon.vue\r\n```\r\n\r\n### 一次性组件命名\r\n\r\n单个活跃实例的组件应该以 `The` 前缀命名，以示其唯一性。\r\n\r\n这不意味着组件只可用于一个单页面，而是每个页面只使用一次。这些组件永远不接受任何 `prop`，因为它们是为你的应用定制的，而不是它们在你的应用中的上下文。如果你发现有必要添加 `prop`，那就表明这实际上是一个可复用的组件，只是目前在每个页面里只使用一次。\r\n\r\n```sh\r\n# bad\r\ncomponents/\r\n|- Heading.vue\r\n|- MySidebar.vue\r\n```\r\n\r\n```sh\r\n# good\r\ncomponents/\r\n|- TheHeading.vue\r\n|- TheSidebar.vue\r\n```\r\n\r\n### 组件命名请保持关联\r\n\r\n和父组件紧密耦合的子组件应该以父组件名作为前缀命名。\r\n\r\n如果一个组件只在某个父组件的场景下有意义，这层关系应该体现在其名字上。因为编辑器通常会按字母顺序组织文件，所以这样做可以把相关联的文件排在一起。\r\n\r\n```sh\r\n# bad\r\ncomponents/\r\n|- TodoList.vue\r\n|- TodoItem.vue\r\n|- TodoButton.vue\r\n```\r\n\r\n```sh\r\n# good\r\ncomponents/\r\n|- TodoList.vue\r\n|- TodoListItem.vue\r\n|- TodoListItemButton.vue\r\n```\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/bosens-China/blog/issues/73/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/bosens-China/blog/issues/73/timeline",
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/bosens-China/blog/issues/70",
    "repository_url": "https://api.github.com/repos/bosens-China/blog",
    "labels_url": "https://api.github.com/repos/bosens-China/blog/issues/70/labels{/name}",
    "comments_url": "https://api.github.com/repos/bosens-China/blog/issues/70/comments",
    "events_url": "https://api.github.com/repos/bosens-China/blog/issues/70/events",
    "html_url": "https://github.com/bosens-China/blog/issues/70",
    "id": 913346542,
    "node_id": "MDU6SXNzdWU5MTMzNDY1NDI=",
    "number": 70,
    "title": "团队规范系列之git规范",
    "user": {
      "login": "bosens-China",
      "id": 39508895,
      "node_id": "MDQ6VXNlcjM5NTA4ODk1",
      "avatar_url": "https://avatars.githubusercontent.com/u/39508895?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/bosens-China",
      "html_url": "https://github.com/bosens-China",
      "followers_url": "https://api.github.com/users/bosens-China/followers",
      "following_url": "https://api.github.com/users/bosens-China/following{/other_user}",
      "gists_url": "https://api.github.com/users/bosens-China/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/bosens-China/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/bosens-China/subscriptions",
      "organizations_url": "https://api.github.com/users/bosens-China/orgs",
      "repos_url": "https://api.github.com/users/bosens-China/repos",
      "events_url": "https://api.github.com/users/bosens-China/events{/privacy}",
      "received_events_url": "https://api.github.com/users/bosens-China/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [
      {
        "id": 1371686611,
        "node_id": "MDU6TGFiZWwxMzcxNjg2NjEx",
        "url": "https://api.github.com/repos/bosens-China/blog/labels/%E5%85%B6%E4%BB%96",
        "name": "其他",
        "color": "f6ecbf",
        "default": false,
        "description": "暂定为分享之类的"
      }
    ],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 0,
    "created_at": "2021-06-07T09:37:17Z",
    "updated_at": "2021-06-08T02:54:39Z",
    "closed_at": null,
    "author_association": "OWNER",
    "active_lock_reason": null,
    "body": "最近一周的工作重心就是在梳理团队规范，在写的过程也查缺补漏了不少知识，剔除掉关于公司场景的部分就有了这一系列的文章，预计写四部分：\r\n1. git规范\r\n2. [工程规范](https://github.com/bosens-China/blog/issues/71)\r\n3. [用户体验规范](https://github.com/bosens-China/blog/issues/72)\r\n4. [命名规范](https://github.com/bosens-China/blog/issues/73)\r\n\r\n\r\n# Git 规范\r\n\r\nGit 作为现在最流行的分布式管理工具，基本上是每个团队的必备，下面就从分支和提交这两部分展开\r\n\r\n## 什么是分支\r\n\r\n分支就是把你的工作从开发主线上分离开来，以免影响开发主线，假设你准备开发一个新功能，但是需要两周才能完成，第一周你写了 50%的代码，如果立刻提交，由于代码还没写完，不完整的代码库会导致别人不能干活了。如果等代码全部写完再一次提交，又存在丢失每天进度的巨大风险。\r\n\r\n现在有了分支，就不用怕了。你创建了一个属于你自己的分支，别人看不到，还继续在原来的分支上正常工作，而你在自己的分支上干活，想提交就提交，直到开发完毕后，再一次性合并到原来的分支上，这样，既安全，又不影响别人工作。\r\n\r\n![1.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/305ee83c688b49ae859b493fbf7d7218~tplv-k3u1fbpfcp-watermark.image)\r\n\r\n## 分支如何命名\r\n\r\n分支按照类型可以分为以下几种\r\n\r\n| 分支名称         |       命名        |                                                       说明 |\r\n| ---------------- | :---------------: | ---------------------------------------------------------: |\r\n| 主分支           |      master       | 主分支，所有提供给用户使用的正式版本，都在这个主分支上发布 |\r\n| 开发主分支       |      develop      |                         开发分支，永远是功能最新最全的分支 |\r\n| 功能分支         |    feature-\\*     |                         新功能分支，某个功能点正在开发阶段 |\r\n| 发布版本         |    release-\\*     |                                       发布定期要上线的功能 |\r\n| 修复发布版本分支 | bugfix-release-\\* |                                               修复测试 bug |\r\n| 紧急修复分支     | bugfix-master-\\*  |                                     紧急修复线上代码的 bug |\r\n\r\n## 开发流程示例\r\n\r\n下面就以一个产品从最初到发布上线为例子，讲解 git 流程\r\n\r\n### 初始化\r\n\r\n第一步，初始仓库的信息，同时创建`develop`分支\r\n\r\n![2.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cf641e319fd14f93a08b9ee748b0706b~tplv-k3u1fbpfcp-watermark.image)\r\n\r\n### 开发新功能\r\n\r\n开发人员在`develop`分支开发新的功能，包括:新特性与 Bug 修复\r\n\r\n![3.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2656d065a3714906a8a503b318698841~tplv-k3u1fbpfcp-watermark.image)\r\n\r\n如果并行开发多个需求，可以创建 `feature 分支`，命名规则为`feature-分支创建日期-新特性关键字`，例如:`feature-20190919-i18n`\r\n\r\n![4.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/dba19d9f51714f7caa6f8e45ebd1e120~tplv-k3u1fbpfcp-watermark.image)\r\n\r\n开发完成之后将 feature 分支合并到 develop 分支，最后删除 feature 分支\r\n\r\n> 什么时候使用 feature\r\n>\r\n> - 开发一个独立的新特性(完成时，需合并到 develop 分支)\r\n> - 技术研究与尝试(若失败，可随时删除 feature 分支)\r\n> - 提前实现下一个版本需要开发的特性(可不在本次迭代中发布)\r\n\r\n### 准备发布版本\r\n\r\n如果 develop 分支上的功开发完毕\r\n\r\n1. 建 release 分支(发布分支)命名规则:release-分支创建日期-待发布版本号，例如：`release-20190919-v1.0.0`\r\n2. 对 release 分支的版本号进行修改（之后提交一次）\r\n3. 通知测试人员测试\r\n\r\n![5.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f639127d864f404b9cd12d85cc8e5547~tplv-k3u1fbpfcp-watermark.image)\r\n\r\n### 修复问题\r\n\r\n开发人员在 release 修复问题，此时禁止开发新功能，只对 bug 进行修复\r\n\r\n![6.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5566fa0226ee43b78f8daf7d4ed14950~tplv-k3u1fbpfcp-watermark.image)\r\n\r\n### 最终发布\r\n\r\n经过测试没有发现问题，或者问题已经全部修复，这个时候\r\n\r\n1. 将 release 分支同时合并到 master 分支与 develop 分支\r\n\r\n   - 通知测试，进行主分支测试\r\n   - 如果没问题，进行下一步，如果有问题回到 release\r\n\r\n1. 删除 release 分支\r\n1. 构建应用到服务器\r\n\r\n![7.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ad87a01a2eb845a99dfc4ff489e6b4e9~tplv-k3u1fbpfcp-watermark.image)\r\n\r\n## commit 规范\r\n\r\n目前开源社区主要应用是规范是[Angular Git Commit Guidelines](https://github.com/angular/angular.js/blob/master/DEVELOPERS.md#-git-commit-guidelines)\r\n\r\n它由下面几部分组成:\r\n\r\n```sh\r\n<type>: <subject>\r\n<BLANK LINE>\r\n<body>\r\n<BLANK LINE>\r\n<footer>\r\n```\r\n\r\n### type\r\n\r\n本次 commit 的类型，诸如 bugfix、docs、style 等\r\n\r\n完整的类型如下：\r\n\r\n| 名称     |                        描述                        |\r\n| -------- | :------------------------------------------------: |\r\n| feat     |                     添加新特性                     |\r\n| fix      |                      修复 bug                      |\r\n| docs     |                   仅仅修改了文档                   |\r\n| style    | 仅仅修改了空格、格式缩进、都好等等，不改变代码逻辑 |\r\n| refactor |         代码重构，没有加新功能或者修复 bug         |\r\n| perf     |                增加代码进行性能测试                |\r\n| test     |                    增加测试用例                    |\r\n| chore    |        改变构建流程、或者增加依赖库、工具等        |\r\n\r\n### scope\r\n\r\n本次 commit 波及的范围\r\n\r\n### subject\r\n\r\n简明扼要的阐述下本次 commit 的主旨\r\n\r\n有几点需要注意：\r\n\r\n1. 首字母不要大写\r\n2. 结尾无需添加标点\r\n\r\n### body\r\n\r\n主体内容，我们需要把本次 commit 详细的描述一下，比如此次变更的动机等，不能超出 72 个字符\r\n\r\n> 为什么需要\r\n>\r\n> - 它可能是用来修复一个 bug，增加一个 feature，提升性能、可靠性、稳定性等等\r\n> - 它如何解决这个问题? 具体描述解决问题的步骤\r\n> - 是否存在副作用、风险?\r\n\r\n### footer\r\n\r\n描述下与之关联的 issue 或 break change，在公司项目中基本忽略即可\r\n\r\n## 参考文章\r\n\r\n- [Git 分支管理规范](https://juejin.cn/post/6844903945245048846#heading-1)\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/bosens-China/blog/issues/70/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/bosens-China/blog/issues/70/timeline",
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/bosens-China/blog/issues/69",
    "repository_url": "https://api.github.com/repos/bosens-China/blog",
    "labels_url": "https://api.github.com/repos/bosens-China/blog/issues/69/labels{/name}",
    "comments_url": "https://api.github.com/repos/bosens-China/blog/issues/69/comments",
    "events_url": "https://api.github.com/repos/bosens-China/blog/issues/69/events",
    "html_url": "https://github.com/bosens-China/blog/issues/69",
    "id": 911281718,
    "node_id": "MDU6SXNzdWU5MTEyODE3MTg=",
    "number": 69,
    "title": "webpack 插件入门",
    "user": {
      "login": "bosens-China",
      "id": 39508895,
      "node_id": "MDQ6VXNlcjM5NTA4ODk1",
      "avatar_url": "https://avatars.githubusercontent.com/u/39508895?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/bosens-China",
      "html_url": "https://github.com/bosens-China",
      "followers_url": "https://api.github.com/users/bosens-China/followers",
      "following_url": "https://api.github.com/users/bosens-China/following{/other_user}",
      "gists_url": "https://api.github.com/users/bosens-China/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/bosens-China/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/bosens-China/subscriptions",
      "organizations_url": "https://api.github.com/users/bosens-China/orgs",
      "repos_url": "https://api.github.com/users/bosens-China/repos",
      "events_url": "https://api.github.com/users/bosens-China/events{/privacy}",
      "received_events_url": "https://api.github.com/users/bosens-China/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [
      {
        "id": 1740577858,
        "node_id": "MDU6TGFiZWwxNzQwNTc3ODU4",
        "url": "https://api.github.com/repos/bosens-China/blog/labels/%E5%B7%A5%E5%85%B7%E7%9B%B8%E5%85%B3",
        "name": "工具相关",
        "color": "f73d62",
        "default": false,
        "description": ""
      }
    ],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 0,
    "created_at": "2021-06-04T08:53:06Z",
    "updated_at": "2021-06-04T08:53:06Z",
    "closed_at": null,
    "author_association": "OWNER",
    "active_lock_reason": null,
    "body": "# webpack 插件入门\r\n\r\n![bg](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/69547c8c2fe9429faf29c425de792cb3~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n最近写了一个移动端项目，不过每次 build 的时候还需要手动上传服务器感觉很不方便，毕竟每次删除文件夹然后拖拽上传的过程太重复了，本着不重复造轮子的原则去 Github 翻了一下，发现 `Upload`上传插件还是蛮多的，不过距离自己的要求还是有些差异，很多插件只是只是单一职责，只负责上传这件事情。\r\n\r\n而如果只负责上传文件不做删除会导致服务器文件越来越多，占用额外的储存成本，WebPack 在 build 过程中会检测相关依赖是否变更，如果变更相关文件的 `hash` 也是发生变更，这样就会导致新的文件上传到服务器，而旧资源却不会被覆盖替换掉。\r\n\r\n## 基本概念\r\n\r\nWebPack 的插件是基于 `Tapable` 实现的，它是一种发布订阅的实现，作用就是将插件的各个生命周期钩子广播出去，然后在合适的时机执行。同时只让插件关注自身的订阅，保证插件组合起来有序进行。\r\n\r\n`Tapable`暴露了三个方法：\r\n\r\n- tap： 可以注册同步钩子和异步钩子\r\n- tapAsync： 回调形式注册异步钩子\r\n- tapPromise： Promise 形式注册异步钩子\r\n\r\n在编写插件时 WebPack 显示要求我们有 `apply` 方法，这样做的原因是 WebPack 执行期间会执行 apply 方法，并且注入`compiler`，之后在`compiler`上订阅钩子事件，在合适时间触发已订阅的 apply 方法\r\n\r\n再看一下官方给出的示例代码\r\n\r\n```js\r\n// A JavaScript class.\r\nclass MyExampleWebpackPlugin {\r\n  // Define `apply` as its prototype method which is supplied with compiler as its argument\r\n  apply(compiler) {\r\n    // Specify the event hook to attach to\r\n    compiler.hooks.emit.tapAsync('MyExampleWebpackPlugin', (compilation, callback) => {\r\n      console.log('This is an example plugin!');\r\n      console.log(\r\n        'Here’s the `compilation` object which represents a single build of assets:',\r\n        compilation\r\n      );\r\n\r\n      // Manipulate the build using the plugin API provided by webpack\r\n      compilation.addModule(/* ... */);\r\n\r\n      callback();\r\n    });\r\n  }\r\n}\r\n```\r\n\r\n上面插件在`compiler`中订阅了 `emit` 的异步钩子，然后做了一些操作之后，执行 `callback()` 回调\r\n\r\n> 这里稍微说下，对于 `tapAsync` 的钩子，`callback` 必须执行，否则程序会一致在等待，而 callback 左侧的 `compilation` 是用来访问这一次的资源构建信息，例如一些输出的资源，相互依赖的关系等。\r\n\r\n了解了上面的信息，我们找一下 [compiler 钩子 ](https://webpack.docschina.org/api/compiler-hooks/)有没有我们需要的，文档中列举的钩子很多：\r\n\r\n- environment\r\n- afterEnvironment\r\n- entryOption\r\n- ...\r\n\r\n翻到最后会看到一个 `done` 的钩子，它在 `compilation` 完成时执行。\r\n\r\n这里我们需要的前置基本准备齐全了，下面要做的就是在 `done` 触发时\r\n\r\n- 连接 ssh 服务器，执行`rm-rf xx`的操作\r\n- 上传 build 后的资源到 xx 目录下\r\n\r\n## 插件开发准备\r\n\r\n> 之后的内容采用 `TypeScript` 作为开发，如果你没有相关经验直接跳过类型注释即可\r\n\r\n为了方便解耦和复用文件，我们创建了一个 utils.ts 文件\r\n\r\n```ts\r\n// utils.ts\r\nimport { NodeSSH } from 'node-ssh';\r\n\r\nimport { Option } from './typings';\r\n\r\nexport const isObject = (obj: any): obj is Object => typeof obj === 'object' && obj;\r\n\r\n// 删除文件夹\r\nexport const removeDir = async (option: Option) => {\r\n  const ssh = new NodeSSH();\r\n  await ssh.connect(option);\r\n  await ssh.execCommand(`rm -rf ${option.to}`);\r\n  await ssh.dispose();\r\n};\r\n\r\n// 上传文件夹\r\nexport const uploadDir = async (option: Option) => {\r\n  const ssh = new NodeSSH();\r\n  await ssh.connect(option);\r\n  await ssh.putDirectory(option.src!, option.to, {\r\n    recursive: true,\r\n  });\r\n  await ssh.dispose();\r\n};\r\n```\r\n\r\n它暴露三个方法，删除文件夹和上传文件夹还有一个判断 object 的方法，上面的删除和上传文件夹基于 [node-ssh](https://github.com/steelbrain/node-ssh) 封装而来，如果你有兴趣了解可以去阅读一下文档\r\n\r\n## 插件开发\r\n\r\n剩下的插件开发，就是获取用户填写一些必要字段，例如密码、上传的服务器路径、host 等信息，结合上面的 `utils` 和钩子，完成这个上传过程\r\n\r\n```ts\r\n// upload-plugin.ts\r\nimport { Compiler, Stats } from 'webpack';\r\nimport { isObject, uploadDir, removeDir } from './utils';\r\nimport { Option } from './typings';\r\n\r\nclass UploadPlugin {\r\n  public stats: Stats;\r\n\r\n  public option: Option & Record<string, any>;\r\n\r\n  public removeDir: boolean;\r\n\r\n  constructor(option: Option, remove = true) {\r\n    this.stats = null as unknown as Stats;\r\n    this.option = option;\r\n    this.removeDir = remove;\r\n    this.init();\r\n  }\r\n\r\n  init() {\r\n    this.checkOption();\r\n    this.setOption();\r\n  }\r\n\r\n  // 检验参数\r\n  checkOption(option = this.option) {\r\n    if (!isObject(option)) {\r\n      throw new Error('option Must be an object!');\r\n    }\r\n    const result = ['to', 'host'].filter((f) => !option[f]);\r\n    if (result.length) {\r\n      throw new Error(`The ${result.join(',')} parameter is required!`);\r\n    }\r\n    if (!option.password && !option.privateKey) {\r\n      throw new Error('password and privateKey must have one entry!');\r\n    }\r\n  }\r\n\r\n  // 初始化默认值\r\n  setOption() {\r\n    const option = {\r\n      port: 22,\r\n      username: 'root',\r\n    };\r\n    this.option = {\r\n      ...option,\r\n      ...this.option,\r\n    };\r\n  }\r\n\r\n  apply(compiler: Compiler) {\r\n    compiler.hooks.done.tap('upload-plugin', async (stats) => {\r\n      console.time('time');\r\n      // 获取默认的信息，如果src不存在直接使用webpack的配置\r\n      const src = stats.compilation.outputOptions.path;\r\n      this.option.src = this.option.src ?? src;\r\n      if (this.removeDir) {\r\n        await removeDir(this.option);\r\n      }\r\n      await uploadDir(this.option);\r\n      console.timeEnd('time');\r\n    });\r\n  }\r\n}\r\n\r\nexport default UploadPlugin;\r\n```\r\n\r\n整体代码还是很简洁的，去除参数校验部分还有赋值默认值参数，剩下的就是根据参数来是否删除远程文件夹，之后执行上传方法。\r\n\r\n你可能很好奇 `Option` 的定义是啥，这个是结合 `node-ssh` 的连接信息加上自定义扩展的一些字段而来的\r\n\r\n```ts\r\n// typings.d.ts\r\nexport interface Option {\r\n  src?: string;\r\n  to: string;\r\n  port?: number;\r\n  host: string;\r\n  username?: string;\r\n  password?: string;\r\n  privateKey?: string;\r\n}\r\n```\r\n\r\n## 最后\r\n\r\n完整代码已经上传了[Github 仓库](https://github.com/bosens-China/upload-plugin)，如果你有兴趣可以具体看下更具体的一些信息，如果对你有帮助也欢迎 `star`。\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/bosens-China/blog/issues/69/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/bosens-China/blog/issues/69/timeline",
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/bosens-China/blog/issues/68",
    "repository_url": "https://api.github.com/repos/bosens-China/blog",
    "labels_url": "https://api.github.com/repos/bosens-China/blog/issues/68/labels{/name}",
    "comments_url": "https://api.github.com/repos/bosens-China/blog/issues/68/comments",
    "events_url": "https://api.github.com/repos/bosens-China/blog/issues/68/events",
    "html_url": "https://github.com/bosens-China/blog/issues/68",
    "id": 906504178,
    "node_id": "MDU6SXNzdWU5MDY1MDQxNzg=",
    "number": 68,
    "title": "如何选择合适的公司？",
    "user": {
      "login": "bosens-China",
      "id": 39508895,
      "node_id": "MDQ6VXNlcjM5NTA4ODk1",
      "avatar_url": "https://avatars.githubusercontent.com/u/39508895?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/bosens-China",
      "html_url": "https://github.com/bosens-China",
      "followers_url": "https://api.github.com/users/bosens-China/followers",
      "following_url": "https://api.github.com/users/bosens-China/following{/other_user}",
      "gists_url": "https://api.github.com/users/bosens-China/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/bosens-China/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/bosens-China/subscriptions",
      "organizations_url": "https://api.github.com/users/bosens-China/orgs",
      "repos_url": "https://api.github.com/users/bosens-China/repos",
      "events_url": "https://api.github.com/users/bosens-China/events{/privacy}",
      "received_events_url": "https://api.github.com/users/bosens-China/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [
      {
        "id": 3041947800,
        "node_id": "MDU6TGFiZWwzMDQxOTQ3ODAw",
        "url": "https://api.github.com/repos/bosens-China/blog/labels/%E4%BB%A3%E7%A0%81%E4%BA%BA%E7%94%9F",
        "name": "代码人生",
        "color": "7B17E3",
        "default": false,
        "description": "聊聊和技术无关的事情"
      }
    ],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 0,
    "created_at": "2021-05-29T16:03:33Z",
    "updated_at": "2021-05-29T16:03:33Z",
    "closed_at": null,
    "author_association": "OWNER",
    "active_lock_reason": null,
    "body": "![背景图片](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7fc336f293cb45d3a308a9ccc0a1aa17~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n虽然金三银四早也过去，不过坦率的说好多公司招聘的需求量依然很大，再加上自己这段时间也在关注，这块所以就简单聊聊从选择公司到入职的一系列问题\r\n\r\n> 这里不涉及如何写简历以及如何回答面试的问题，后面如果有时间会考虑新开一个篇幅来说\r\n\r\n## 求职渠道\r\n\r\n首先如果自己早已有心仪的目标那可以跳过这一步，直接从脉脉或者知乎等各种社交 app 上找到内推信息，然后投递简历等待面试。\r\n\r\n但是如果没有找到满意的目标，那不妨从 `boss 直聘`着手，之前也用了很多其他的招聘 app 比如拉钩，不过坦率的说沟通模式或者说回复消息这块始终没有 boss 直聘来的简洁和清爽。\r\n\r\n## 筛选公司\r\n\r\n之前在知乎看到一个问题就是说`“年轻人到底选择大公司还有小公司”`，当然各种答案各不相同，但是站在自己踩过坑的情况来说还是建议大家选择一个大公司，因为可以节省你很多额外的采坑成本\r\n\r\n- 有着完整加薪结构，不再是口头上的一年两调或者一调；\r\n- 各种福利比较齐全，公积金和社保缴纳等；\r\n- 开发规范和团队协作流程比较成熟，可以接触到完整的开发流程；\r\n\r\n其次要想好自己做什么样的产品，目前按照产品划分可以分为两种\r\n\r\n- to B：提供给企业的产品\r\n- to C：提供给个人的产品\r\n\r\n所以根据上面两条，在加上自己的一些心理底线：\r\n\r\n1. 确定好自己想去什么规模的公司\r\n2. 做的产品业务是什么样子的\r\n3. 期待的薪资结构 + 上下班时间 + 基础性的福利等\r\n\r\n根据上面条件初步筛选出一些公司，下面的话就是看公司的介绍跟自己的符合度怎么样，这里建议大家不要广撒网而是专门精选这样会更有效的针对公司进行准备，其实不仅仅是公司在选择个人，个人也要选择公司，不然其实你会待的很压抑或者说跟你不匹配就是浪费双方的时间。\r\n\r\n这里额外补充一点，在面试之前可以事先沟通好你自己的一些底线信息。避免更多的时间成本浪费，比如我就是要过滤掉公积金社保不足额缴纳的公司，那你就可以直接说，你好方便问一下你们公积金缴纳比例和基数吗？\r\n\r\n最后，如果对方已读不回那就默认凉了，作为不要怀疑自己，找工作从来不是一个简单的事情。\r\n\r\n## 面试准备\r\n\r\n确定好目标跟 hr 沟通的时候我个人觉得稍微突出主题可以提高不少面试几率，我一般喜欢说：“你好看到贵公司的招聘情况觉得蛮符合的，可以发一份简历给你看看吗？”\r\n\r\n不过这个也不是绝对的，毕竟求职还是看符不符合岗位要求，如果你的简历足够丰富，估计每天沟通你的 hr 自己都要排队处理。\r\n\r\n说完打招呼还有一个需要确认就是面试时间和方式，一般而言如果是在职的话优先远程或者电话面试，不然遇到坑的面试官让你感觉时间被浪费，而如果你在外地求职的地点跟你不在同一个地方那如果对方不支持远程我建议你就不要去了，因为很多公司的 hr 对指标有要求，可能你只是一个他们的 kpi。\r\n\r\n当然如果能实地面试更好，可以通过观察公司附近的环境，公司的环境以及人员初步判断一下。\r\n\r\n## 面试结束\r\n\r\n如果你已经把一面、二面之类的全部都过了，只剩下 hr 这一关了那你就可以聊一下关乎切身的福利之类了。\r\n\r\n### 工资\r\n\r\n劳动合同会签订多少，绩效会占比多少，以及绩效是按照每个月发放还是一个季度发放，试用期工资都需要详细了解清楚，而且关于合同上的工资，也是后面如果需要维权情况的的一个重要依据。\r\n\r\n### 五险一金缴纳的基数和比例\r\n\r\n五险一金不缴纳是违法的，但是有的企业为了降低成本选择只缴纳最低的基数。\r\n\r\n公积金会跟你买房的公积金贷款还有还款挂钩，是一个真正的福利；\r\n\r\n而五险虽然目前可能用不到，但是少交肯定是个人的一个损失\r\n\r\n### 加班\r\n\r\n是否有加班工资或者调休，其实我个人是不怎么喜欢加班多的公司，尤其是因为业务很赶的原因或者团队公司氛围造成的，因为这个会影响到你的后续学习，而且每天使你很疲倦，从长远来看逃离加班多的公司对你的职业生涯更友好。\r\n\r\n### 作息时间是怎么样的\r\n\r\n确定好作息时间，看看自己每天需要通勤多久，如果条件允许就搬到公司附近来吧，每天通勤十几分钟真的很有幸福感。\r\n\r\n还有确定好是否可以弹性打卡，如果你像我一样每天喜欢卡着点上班还有扣钱啥的，就需要仔细想下了，不过对于这种公司建议跑路之。\r\n\r\n### 每年会有调薪的机会吗，一个流程是怎么样的\r\n\r\n这里可以简单了解下，对于互联网来说跳槽永远是涨薪的最好机会，不过如果团队氛围不错，再加上涨薪幅度也 ok 我觉得留下来也没有什么不好的\r\n\r\n### 其他各种福利\r\n\r\n比如餐补、房补、交通补、节假日福利、另外的保险等，不过注意不要跟你谈的薪资混合在了一起，比如你税前 20K，结果是各种福利加在一起的，那我觉得就没有什么必要了，还不如不写。\r\n\r\n### 年终奖\r\n\r\n年终奖也可以问下，一般来说最少一个月，多的话三四个月的也是有。\r\n\r\n对于期权之类的，我个人建议先暂时无视之，因为这个东西需要有时间前置条件，到时候你能不能待满这么久都不好说，如果真的待这么久再了解也不迟。\r\n\r\n## 最后\r\n\r\n如果确定好准备去，记得让对方公司发一份`offer`过来，辞职的话正式员工需要一个月，试用期三天，所以你需要跟新公司的 hr 确定好具体的入职时间，以及确定好社保的缴纳时间，避免断交社保造成的影响。\r\n\r\n最后，如果对你有帮助可以点一下`statr`\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/bosens-China/blog/issues/68/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/bosens-China/blog/issues/68/timeline",
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/bosens-China/blog/issues/64",
    "repository_url": "https://api.github.com/repos/bosens-China/blog",
    "labels_url": "https://api.github.com/repos/bosens-China/blog/issues/64/labels{/name}",
    "comments_url": "https://api.github.com/repos/bosens-China/blog/issues/64/comments",
    "events_url": "https://api.github.com/repos/bosens-China/blog/issues/64/events",
    "html_url": "https://github.com/bosens-China/blog/issues/64",
    "id": 767600367,
    "node_id": "MDU6SXNzdWU3Njc2MDAzNjc=",
    "number": 64,
    "title": "h5适配ios屏幕",
    "user": {
      "login": "bosens-China",
      "id": 39508895,
      "node_id": "MDQ6VXNlcjM5NTA4ODk1",
      "avatar_url": "https://avatars.githubusercontent.com/u/39508895?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/bosens-China",
      "html_url": "https://github.com/bosens-China",
      "followers_url": "https://api.github.com/users/bosens-China/followers",
      "following_url": "https://api.github.com/users/bosens-China/following{/other_user}",
      "gists_url": "https://api.github.com/users/bosens-China/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/bosens-China/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/bosens-China/subscriptions",
      "organizations_url": "https://api.github.com/users/bosens-China/orgs",
      "repos_url": "https://api.github.com/users/bosens-China/repos",
      "events_url": "https://api.github.com/users/bosens-China/events{/privacy}",
      "received_events_url": "https://api.github.com/users/bosens-China/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [
      {
        "id": 1371686610,
        "node_id": "MDU6TGFiZWwxMzcxNjg2NjEw",
        "url": "https://api.github.com/repos/bosens-China/blog/labels/css%20%E7%9B%B8%E5%85%B3",
        "name": "css 相关",
        "color": "42b883",
        "default": false,
        "description": "css 技巧和基础为主"
      }
    ],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 0,
    "created_at": "2020-12-15T13:34:49Z",
    "updated_at": "2021-02-04T03:43:03Z",
    "closed_at": null,
    "author_association": "OWNER",
    "active_lock_reason": null,
    "body": "这篇文章算是迟来的总结，最近做了一个 h5 项目内嵌到 app 页面内联，默认情况下 app 那边不会做任何处理，也就是顶部和底部需要额外处理一下\r\n![bg](https://user-images.githubusercontent.com/39508895/102221576-4211db00-3f1d-11eb-981c-885c51309964.png)\r\n\r\n\r\n## 做法\r\n\r\n默认情况下 ios 的顶部状态栏是`20px`，如果存在刘海则是`44px`，当然实际开发中也不需要使用 js 来进行判断，因为 ios11 之后新增了一个安全区域，用来定义可视窗口的范围，它一共有四个属性\r\n\r\n- safe-area-inset-left：安全区域距离左边边界距离\r\n- safe-area-inset-right：安全区域距离右边边界距离\r\n- safe-area-inset-top：安全区域距离顶部边界距离\r\n- safe-area-inset-bottom：安全区域距离底部边界距离\r\n\r\n使用方法也很简单：\r\n\r\n```css\r\npadding-bottom: env(safe-area-inset-bottom);\r\n```\r\n\r\n在`html`文件的`meta`中添加\r\n\r\n```html\r\n   <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0,user-scalable=no, viewport-fit=cover\">\r\n```\r\n\r\n> 只有设置了viewport-fit=cover，才能使用`env`，注意上面说的都是竖屏情况\r\n\r\n\r\n\r\n#### env 第二个参数\r\n\r\n上面写法的`env`和`constant`其实都支持第二个参数，作为不支持环境的后退，可以作为了解\r\n例如：\r\n``` css\r\n/* 不支持就回退到第二个参数 */\r\npadding-bottom: env(safe-area-inset-bottom, 20px);\r\n```\r\n\r\n#### @supports 额外判断\r\n\r\n为了防止部分安卓也使用`safe-area-inset-top`之类的属性，可以添加`-webkit-overflow-scrolling: touch`来进行双重判断\r\n\r\n> [-webkit-overflow-scrolling](https://caniuse.com/?search=-webkit-overflow-scrolling) 只有 iOS Safari 支持\r\n\r\n```css\r\n@supports (\r\n    (height: constant(safe-area-inset-top)) or\r\n      (height: env(safe-area-inset-top))\r\n  )\r\n  and (-webkit-overflow-scrolling: touch) {\r\n  /* 代码 */\r\n}\r\n```\r\n\r\n## fixed 写法\r\n\r\n- calc，直接把原来写的值加上安全区域范围\r\n\r\n```css\r\nbottom: calc(50px (假设值) + env(safe-area-inset-bottom));\r\n```\r\n\r\n- padding: 添加 padding 的内边距进行填充\r\n\r\n```css\r\npadding-bottom: env(safe-area-inset-bottom);\r\n```\r\n\r\n## 额外注意点\r\n\r\n是不是因为上面就说完了，其实还有还有一点兼容的地方需要额外关注\r\n\r\n> The env() function shipped in iOS 11 with the name constant(). Beginning with Safari Technology Preview 41 and the iOS 11.2 beta, constant() has been removed and replaced with env(). You can use the CSS fallback mechanism to support both versions, if necessary, but should prefer env() going forward.\r\n\r\n翻译过来就是`ios`11.2 之后不再支持`constant`而是使用`env`，所以生产过程中可以使用下面写法做兼容\r\n\r\n```css\r\npadding-bottom: constant(safe-area-inset-bottom);\r\n/* 兼容 iOS < 11.2 */\r\npadding-bottom: env(safe-area-inset-bottom);\r\n/* 兼容 iOS >= 11.2 */\r\n```\r\n\r\n## 最后\r\n\r\n如果对你有帮助可以点一下`star`\r\n\r\n参考文章\r\n\r\n- [网页适配 iPhoneX，就是这么简单](https://aotu.io/notes/2017/11/27/iphonex/index.html)\r\n\r\n- [IOS刘海屏H5 CSS适配](https://juejin.cn/post/6844903974491930637#heading-4)\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/bosens-China/blog/issues/64/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/bosens-China/blog/issues/64/timeline",
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/bosens-China/blog/issues/66",
    "repository_url": "https://api.github.com/repos/bosens-China/blog",
    "labels_url": "https://api.github.com/repos/bosens-China/blog/issues/66/labels{/name}",
    "comments_url": "https://api.github.com/repos/bosens-China/blog/issues/66/comments",
    "events_url": "https://api.github.com/repos/bosens-China/blog/issues/66/events",
    "html_url": "https://github.com/bosens-China/blog/issues/66",
    "id": 776803883,
    "node_id": "MDU6SXNzdWU3NzY4MDM4ODM=",
    "number": 66,
    "title": "从babel和typescript看class私有属性实现",
    "user": {
      "login": "bosens-China",
      "id": 39508895,
      "node_id": "MDQ6VXNlcjM5NTA4ODk1",
      "avatar_url": "https://avatars.githubusercontent.com/u/39508895?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/bosens-China",
      "html_url": "https://github.com/bosens-China",
      "followers_url": "https://api.github.com/users/bosens-China/followers",
      "following_url": "https://api.github.com/users/bosens-China/following{/other_user}",
      "gists_url": "https://api.github.com/users/bosens-China/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/bosens-China/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/bosens-China/subscriptions",
      "organizations_url": "https://api.github.com/users/bosens-China/orgs",
      "repos_url": "https://api.github.com/users/bosens-China/repos",
      "events_url": "https://api.github.com/users/bosens-China/events{/privacy}",
      "received_events_url": "https://api.github.com/users/bosens-China/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [
      {
        "id": 1371686609,
        "node_id": "MDU6TGFiZWwxMzcxNjg2NjA5",
        "url": "https://api.github.com/repos/bosens-China/blog/labels/js%20%E7%9B%B8%E5%85%B3",
        "name": "js 相关",
        "color": "F7DF1E",
        "default": false,
        "description": ""
      }
    ],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 0,
    "created_at": "2020-12-31T05:52:53Z",
    "updated_at": "2020-12-31T05:52:53Z",
    "closed_at": null,
    "author_association": "OWNER",
    "active_lock_reason": null,
    "body": "私有属性目前提案已经进行到了[Stage 3 ](https://github.com/tc39/proposal-private-methods)阶段，即将落地所以还是很有必要了解下，本文不讲解私有属性如何使用以及需要注意的事项，而是侧重于`babel`和`typescript`是怎么实现私有属性的，具体使用方法可以看一下阮一峰的[ ES6 入门](https://es6.ruanyifeng.com/#docs/class#%E7%A7%81%E6%9C%89%E6%96%B9%E6%B3%95%E5%92%8C%E7%A7%81%E6%9C%89%E5%B1%9E%E6%80%A7)\r\n\r\n> 在看这篇文章之前可以阅读我之前写的\r\n> [从 babel 看 class(上)](https://github.com/bosens-China/blog/issues/27)、\r\n> [从 babel 看 class(下)](https://github.com/bosens-China/blog/issues/33)\r\n\r\n## 示例文件\r\n\r\n下面的代码都是通过这个例子的演化而来\r\n\r\n```js\r\nclass Foo {\r\n  #name = 'zhangsan';\r\n  age = 17;\r\n\r\n  getName() {\r\n    return this.#name;\r\n  }\r\n  get #x() {\r\n    return this.#name;\r\n  }\r\n\r\n  set #x(value) {\r\n    this.#name = value;\r\n  }\r\n}\r\n```\r\n\r\n## babel\r\n\r\n```js\r\nfunction _classPrivateFieldSet(receiver, privateMap, value) {\r\n  var descriptor = privateMap.get(receiver);\r\n  if (!descriptor) {\r\n    throw new TypeError('attempted to set private field on non-instance');\r\n  }\r\n  if (descriptor.set) {\r\n    descriptor.set.call(receiver, value);\r\n  } else {\r\n    if (!descriptor.writable) {\r\n      throw new TypeError('attempted to set read only private field');\r\n    }\r\n    descriptor.value = value;\r\n  }\r\n  return value;\r\n}\r\n\r\nfunction _classPrivateFieldGet(receiver, privateMap) {\r\n  var descriptor = privateMap.get(receiver);\r\n  if (!descriptor) {\r\n    throw new TypeError('attempted to get private field on non-instance');\r\n  }\r\n  if (descriptor.get) {\r\n    return descriptor.get.call(receiver);\r\n  }\r\n  return descriptor.value;\r\n}\r\n\r\nvar _name = new WeakMap();\r\n\r\nvar _x = new WeakMap();\r\n\r\nvar Foo = /*#__PURE__*/ (function () {\r\n  function Foo() {\r\n    _classCallCheck(this, Foo);\r\n\r\n    _x.set(this, {\r\n      get: _get_x,\r\n      set: _set_x,\r\n    });\r\n\r\n    _name.set(this, {\r\n      writable: true,\r\n      value: 'zhangsan',\r\n    });\r\n\r\n    _defineProperty(this, 'age', 17);\r\n  }\r\n\r\n  _createClass(Foo, [\r\n    {\r\n      key: 'getName',\r\n      value: function getName() {\r\n        return _classPrivateFieldGet(this, _name);\r\n      },\r\n    },\r\n  ]);\r\n\r\n  return Foo;\r\n})();\r\n\r\nvar _get_x = function _get_x() {\r\n  return _classPrivateFieldGet(this, _name);\r\n};\r\n\r\nvar _set_x = function _set_x(value) {\r\n  _classPrivateFieldSet(this, _name, value);\r\n};\r\n```\r\n\r\n为了保持简洁，我直接去掉了不必要的代码，这里 babel 的执行顺序如下\r\n\r\n1. 首先通过`_classCallCheck`方法检查是否为`new`调用，不是直接抛出错误\r\n2. 通过`new WeakMap`来存储私有属性\r\n3. 通过`_defineProperty`来设置实例属性\r\n4. 通过`_createClass`来设置方法和静态方法\r\n\r\n所以这里已经可以得出结论了，**babel 的私有属性方法实现就是通过`WeakMap`来实现的**\r\n\r\n```js\r\nfunction _classPrivateFieldGet(receiver, privateMap) {\r\n  var descriptor = privateMap.get(receiver);\r\n  if (!descriptor) {\r\n    throw new TypeError('attempted to get private field on non-instance');\r\n  }\r\n  if (descriptor.get) {\r\n    return descriptor.get.call(receiver);\r\n  }\r\n  return descriptor.value;\r\n}\r\n```\r\n\r\n上面的方法中额外进行了一些判断，一个个看\r\n\r\n1. 执行`privateMap.get`\r\n\r\n进行判断的原因是因为 `this` 可能会丢失，例如通过解构\r\n\r\n```js\r\nconst f = new Foo();\r\nconst { getName } = f;\r\ngetName();\r\n```\r\n\r\n2. `descriptor.get`判断\r\n\t\r\n    是因为私有属性可以是`get`、`set`这种形式出现\r\n\r\n`_classPrivateFieldSet`方法跟get获取流程类似就不讲解了。\r\n\r\n## typescript\r\n\r\n```js\r\nvar __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, privateMap) {\r\n    if (!privateMap.has(receiver)) {\r\n        throw new TypeError(\"attempted to get private field on non-instance\");\r\n    }\r\n    return privateMap.get(receiver);\r\n};\r\nvar __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, privateMap, value) {\r\n    if (!privateMap.has(receiver)) {\r\n        throw new TypeError(\"attempted to set private field on non-instance\");\r\n    }\r\n    privateMap.set(receiver, value);\r\n    return value;\r\n};\r\nvar _name;\r\nclass Foo {\r\n    constructor() {\r\n        _name.set(this, 'zhangsan');\r\n        this.age = 17;\r\n    }\r\n    getName() {\r\n        return this.;\r\n    }\r\n    get () { return __classPrivateFieldGet(this, _name); }\r\n    set (value) {\r\n        __classPrivateFieldSet(this, _name, value);\r\n    }\r\n}\r\n_name = new WeakMap();\r\n```\r\n\r\n这里直接把代码编译到`es2015`我们主要看私有属性在 ts 中怎么实现，而 class 转化降级的方法就是降级成函数所以略过。\r\n\r\n`_name.set`和`__classPrivateFieldGet`、`__classPrivateFieldSet`从这三处代码我们可以得出结论，ts 也是通过`WeakMap`来实现的。\r\n\r\n实现的过程跟`babel`大同小异，就是根据`this`和变量名进行读取和设置\r\n\r\n## 最后\r\n\r\n上面的分析到这里就结束了，如果有什么错误欢迎指出，如果对你有帮助欢迎`star`。\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/bosens-China/blog/issues/66/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/bosens-China/blog/issues/66/timeline",
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/bosens-China/blog/issues/65",
    "repository_url": "https://api.github.com/repos/bosens-China/blog",
    "labels_url": "https://api.github.com/repos/bosens-China/blog/issues/65/labels{/name}",
    "comments_url": "https://api.github.com/repos/bosens-China/blog/issues/65/comments",
    "events_url": "https://api.github.com/repos/bosens-China/blog/issues/65/events",
    "html_url": "https://github.com/bosens-China/blog/issues/65",
    "id": 770754319,
    "node_id": "MDU6SXNzdWU3NzA3NTQzMTk=",
    "number": 65,
    "title": "node接口开发",
    "user": {
      "login": "bosens-China",
      "id": 39508895,
      "node_id": "MDQ6VXNlcjM5NTA4ODk1",
      "avatar_url": "https://avatars.githubusercontent.com/u/39508895?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/bosens-China",
      "html_url": "https://github.com/bosens-China",
      "followers_url": "https://api.github.com/users/bosens-China/followers",
      "following_url": "https://api.github.com/users/bosens-China/following{/other_user}",
      "gists_url": "https://api.github.com/users/bosens-China/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/bosens-China/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/bosens-China/subscriptions",
      "organizations_url": "https://api.github.com/users/bosens-China/orgs",
      "repos_url": "https://api.github.com/users/bosens-China/repos",
      "events_url": "https://api.github.com/users/bosens-China/events{/privacy}",
      "received_events_url": "https://api.github.com/users/bosens-China/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [
      {
        "id": 1371686609,
        "node_id": "MDU6TGFiZWwxMzcxNjg2NjA5",
        "url": "https://api.github.com/repos/bosens-China/blog/labels/js%20%E7%9B%B8%E5%85%B3",
        "name": "js 相关",
        "color": "F7DF1E",
        "default": false,
        "description": ""
      }
    ],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 0,
    "created_at": "2020-12-18T10:03:26Z",
    "updated_at": "2020-12-21T02:03:32Z",
    "closed_at": null,
    "author_association": "OWNER",
    "active_lock_reason": null,
    "body": "\r\n\r\n接口请求与其它资源请求没有什么不同，都是借助 `http 协议`返回对应的资源，这篇文章简单介绍一下 `node` 如何开发接口以及如何管理多个接口情况和接口风格\r\n\r\n标题关联了 node，主要因为 node 开启一个服务器是很简单，而且语法基本相同没有太多负担，这篇文章主要讲解思路，换算到其它语言也是可以的。\r\n\r\n先看一个官网的例子，稍微改造一下让它返回一个固定的`json`数据\r\n\r\n```js\r\nconst http = require('http');\r\n\r\nconst hostname = '127.0.0.1';\r\nconst port = 3000;\r\n\r\nconst server = http.createServer((req, res) => {\r\n  res.statusCode = 200;\r\n  res.writeHead(200, { 'Content-Type': 'application/json' });\r\n  res.write(JSON.stringify({ name: 'hello wrold' }));\r\n  res.end();\r\n});\r\n\r\nserver.listen(port, hostname, () => {\r\n  console.log(`服务器运行在 http://${hostname}:${port}/`);\r\n});\r\n```\r\n\r\n将上面代码复制到文件中，之后借助 `node xxx.js` 的形式就可以预览到效果了。\r\n\r\n## koa\r\n\r\n上面是借助 node 的 `http` 原生模块实现的，当然这种实现没有什么问题，不过追求可扩展和简化开发的目的，这里选择了 koa 作为下面使用的的框架。\r\n\r\nkoa 号称是下一代的 web 开发框架，同样以上面的例子安装一下 koa ，看它怎么实现上面的功能\r\n\r\n```sh\r\nyarn add koa\r\n```\r\n\r\n```js\r\nconst Koa = require('koa');\r\n\r\nconst hostname = '127.0.0.1';\r\nconst port = 3000;\r\n\r\nconst app = new Koa();\r\n\r\napp.use(async (ctx) => {\r\n  ctx.type = 'application/json';\r\n  ctx.body = { name: 'hello wrold' };\r\n});\r\napp.listen(port, hostname, () => {\r\n  console.log(`服务器运行在 http://${hostname}:${port}/`);\r\n});\r\n```\r\n\r\n代码方面还是十分简洁的，这里主要介绍实现思路不过多介绍 koa 的语法，而且实际上 koa 只是对 http 模块进行了封装，文档也没多少推荐看一下官网的介绍即可。\r\n\r\n说到`koa`这里还是聊一下 `koa` 的中间件，下面的代码会经常使用到，`koa` 借助中间件来实现各种拓展，就是类似于插件的功能，它本身非常像洋葱结构\r\n![洋葱](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fada01c271eb43c19fa026d988e30642~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n例如上面的`app.use`就是中间件，中间件的执行顺序以`next`为分割，先执行`next`的前半部分，之后按照倒叙的结构执行后半部分的`next`代码，看一下例子\r\n\r\n```js\r\napp.use(async (ctx, next) => {\r\n  console.log(1);\r\n  await next();\r\n  console.log(2);\r\n});\r\n\r\napp.use(async (ctx, next) => {\r\n  console.log(3);\r\n  await next();\r\n  console.log(4);\r\n});\r\n\r\napp.use(async (ctx, next) => {\r\n  console.log(5);\r\n  await next();\r\n  console.log(6);\r\n});\r\n```\r\n\r\n上面代码的打印结果是`1,3,5,6,4,2`，这块有点绕可以多想一下。\r\n\r\n接口开发中一般都是通过`json`来传递消息，`koa`本身的语法已经很简洁了，但是每次都需要返回想重复的部分，时间长了肯定也会有失误或者漏写拼错的情况，还有抛出错误也需要有一个公共的方法，下面是一个返回信息和抛出错误的设想。\r\n\r\n```js\r\napp.use(async (ctx) => {\r\n  ctx.sendData({ name: 'hello wrold' });\r\n  // 如果发生错误\r\n  ctx.throwError('不满足xxx');\r\n});\r\n```\r\n\r\n如果代码都通过这种形式返回就简单多了，而且实际写在中间件部分的也是可能出现问题的，这里可以通过 `koa` 自带的监听错误来处理，或者通过一个`try`来包裹，可以预料的是一个个手动管理`try`一定会让人抓狂。\r\n\r\n借助中间件的机制很容易编写出一个带有`sendData`和`throwError`的功能，只需要在 ctx 中返回，之后调用 next 让后面的实例执行\r\n\r\n```js\r\napp.use(async (ctx, next) => {\r\n  ctx.sendData = () => {};\r\n  ctx.throwError = () => {};\r\n  await next();\r\n});\r\n```\r\n\r\n上面的例子是简化过的，这里稍微错开一下具体实现之后再详细讲解\r\n\r\n> 中间件的顺序非常重要\r\n\r\n## 接口结构\r\n\r\n上面说了要有一个`sendData`和`throwError`的方法来统一返回信息和抛出错误，这里就说下这两个方法的具体参数以及实现。\r\n\r\n首先接口的返回信息，期待它是固定成下面这种结构\r\n\r\n```json\r\n{\r\n  \"data\": {},\r\n  \"message\": \"ok\",\r\n  \"code\": 200\r\n}\r\n```\r\n\r\n这里 `data` 部分是需要手动返回的，`message` 是可选的，默认的时候可以给一个 ok 以及 200 的 code，这里`code`值是固定死的，方法不允许修改，这样做是因为成功返回一般不需要额外的 code 值\r\n\r\n而错误信息，期待它是这种结构\r\n\r\n```json\r\n{\r\n  \"message\": \"\",\r\n  \"code\": \"400\"\r\n}\r\n```\r\n\r\n这里 message 是必填，而 code 则是可选的。\r\n\r\n这里稍微说一下错误到底使用 `code` 来做区分？还是通过`message`来做区分？\r\n如果通过`code`来做不同状态的区分，那么必然要维护一个 code 列表，其实这是很繁琐的而且单纯的数字记忆也不符合人的记忆，而通过`message`来做提示则基本上可以做到大概可以猜到错误情况，例如可以这样返回\r\n\r\n```json\r\n{\r\n  \"message\": \"error_用户名不能为空\"\r\n}\r\n```\r\n\r\n前面类型后面提示，是不是简洁很多，这两种错误提示自己选择一种即可。\r\n\r\n说了需要实现的功能，方法的实现就很简单了，下面代码是`code`值风格的实现\r\n\r\n```js\r\n// 忽略顶层语法问题，这里是把实现提取出来了\r\nasync (ctx, next) => {\r\n  const content = {\r\n    ...ctx,\r\n    sendData: (data, message = 'ok') => {\r\n      ctx.body = {\r\n        data,\r\n        message,\r\n        code: 200,\r\n      };\r\n      ctx.type = 'application/json';\r\n    },\r\n    throwError: (message = '错误', code = 400) => {\r\n      ctx.body = {\r\n        code,\r\n        message,\r\n      };\r\n      ctx.type = 'application/json';\r\n    },\r\n  };\r\n  try {\r\n    await callback(content);\r\n  } catch (e) {\r\n    ctx.body = {\r\n      code: 400,\r\n      message: (e instanceof Error ? e.message : e) || '系统出现错误',\r\n    };\r\n    ctx.status = 400;\r\n  }\r\n  await next();\r\n};\r\n```\r\n\r\n## rest\r\n\r\nrest 简单来说就是接口的一种规则，它主要有下面几种规则\r\n\r\n- 使用`get`来获取资源\r\n- 使用`post`来发送请求\r\n- 使用`put`来更新资源\r\n- 使用`delete`来删除资源\r\n\r\n说了这么多使用`rest`的好处有哪些呢？\r\n\r\n首先 rest 只是一种规范，定义这种规范更方便理解和阅读，和代码规范是一个性质\r\n\r\n## 自动导入\r\n\r\n在项目开发中必然存在不同的接口，如何管理这些接口就很有必要的，一个个手动导入管理固然可以，不过当项目足够大的时候，业务变更的时候一个个调整一定让人抓狂。\r\n\r\n下面借助`koa-router`和中间件就编写一个自动导入接口的功能，先看一下`koar-router`的简单使用\r\n\r\n```sh\r\nyarn add @koa/router\r\n```\r\n\r\n```js\r\nconst Koa = require('koa');\r\nconst Router = require('@koa/router');\r\n\r\nconst hostname = '127.0.0.1';\r\nconst port = 3000;\r\nconst app = new Koa();\r\nconst router = new Router();\r\n\r\nrouter.get('/', (ctx, next) => {\r\n  ctx.type = 'application/json';\r\n  ctx.body = { name: 'hello wrold' };\r\n});\r\n\r\napp.use(router.routes()).use(router.allowedMethods());\r\n\r\napp.listen(port, hostname, () => {\r\n  console.log(`服务器运行在 http://${hostname}:${port}/`);\r\n});\r\n```\r\n\r\n要实现这个功能先定义一下规则\r\n\r\n- 只导入`src`目录下`index.js`结尾的接口文件\r\n\r\n  搜索所有符合要求的`index.js`文件，可以借助`glob`模块来实现，借助通配符`'src/**/index.js'`即可。\r\n\r\n- 导入文件，把对应模板返回的字段添加到`router`上\r\n\r\n  这里可以通过 node 原生`require`来读取文件，在具体实现的时候需要稍微注意，必须满足格式的模块才能被导入，而且要添加`try`来捕捉不是`modules`的文件\r\n\r\n在动手实现这个函数之前，还要约定一下`index.js`文件的内的模块格式是什么样的\r\n\r\n```js\r\nconst api = {\r\n  url: '',\r\n  methods: 'get' || ['post'],\r\n  async callback(ctx) {},\r\n};\r\n```\r\n\r\n上面是约定的格式，只有满足这样的结构才会被导入进来，因为开发用的是`ts`这里就不做转换`js`的操作了，如果不想使用 ts 直接忽略掉类型标注看大概实现即可。\r\n\r\nutils.ts\r\n\r\n```js\r\nimport glob from 'glob';\r\nimport path from 'path';\r\nimport _ from 'lodash';\r\nimport { Iobj, Istructure } from '../../typings/structure';\r\n\r\nexport const globFile = (pattern: string): Promise<Array<string>> => {\r\n  return new Promise((resolve, reject) => {\r\n    glob(pattern, (err, files) => {\r\n      if (err) {\r\n        return reject(err);\r\n      }\r\n      return resolve(files);\r\n    });\r\n  });\r\n};\r\n\r\nexport const importModule = async () => {\r\n  const pattern = 'src/**/index.ts';\r\n  const list = await globFile(pattern);\r\n  const listMap = list.map((item) => {\r\n    const f = path.resolve(process.cwd(), item);\r\n    return import(f)\r\n      .then((res) => {\r\n        // 过滤掉default的属性，其它的返回\r\n        return _.omit(res, ['default']);\r\n      })\r\n      .catch(() => null);\r\n  });\r\n  return (await Promise.all(listMap)).filter((f) => f) as Array<Iobj<Istructure>>;\r\n};\r\n\r\n```\r\n\r\n> 这里注意一下，因为用的 ts 所以用了 `import()`如果只是用 node 语法直接 `require` 即可\r\n\r\nindex.ts\r\n\r\n```js\r\nimport Router from '@koa/router';\r\nimport _ from 'lodash';\r\nimport { Ictx, Iobj } from '../../typings/structure';\r\n\r\nimport { importModule } from './utils';\r\nimport Koa from 'koa';\r\n\r\nconst route = async (koa: Koa) => {\r\n  const router = new Router();\r\n  const list = await importModule();\r\n\r\n  for (const fileAll of list) {\r\n    // 将数据解构，这里返回的是{xxx: {url,methods,callback}}这样解构\r\n\r\n    // 过滤不符合条件的模块\r\n    for (const file of Object.values(fileAll)) {\r\n      if (!_.isObjectLike(file) || !['url', 'methods', 'callback'].every((f) => Object.keys(file).includes(f))) {\r\n        continue;\r\n      }\r\n      const { url, methods, callback } = file;\r\n      const methodsArr = _.isArray(methods) ? methods : [methods];\r\n      for (const met of methodsArr) {\r\n        router[met](url, async (ctx, next) => {\r\n          const content: Ictx = {\r\n            ...ctx,\r\n            sendData: (data: Iobj, message = 'ok') => {\r\n              ctx.body = {\r\n                data,\r\n                message,\r\n                code: 200,\r\n              };\r\n              ctx.type = 'application/json';\r\n            },\r\n            throwError: (message = '错误', code = 400) => {\r\n              ctx.body = {\r\n                code,\r\n                message,\r\n              };\r\n              ctx.type = 'application/json';\r\n            },\r\n          };\r\n          try {\r\n            await callback(content);\r\n          } catch (e) {\r\n            ctx.body = {\r\n              code: 400,\r\n              message: (e instanceof Error ? e.message : e) || '系统出现错误',\r\n            };\r\n            ctx.status = 400;\r\n          }\r\n          await next();\r\n        });\r\n      }\r\n    }\r\n  }\r\n  koa.use(router.routes()).use(router.allowedMethods());\r\n};\r\n\r\nexport default route;\r\n```\r\n\r\n\r\n\r\n## 日志\r\n\r\n借助 koa 的中间件也很容易实现日志的功能，这里以[winston](https://github.com/winstonjs/winston)为例\r\n\r\n日志主要记录系统运行时的错误，还记的上面通过`try`来捕捉错误的例子么，现在让他继续抛出错误，直接通过中间件 try 捕捉错误写入到文件。\r\n\r\n```js\r\nimport winston from 'winston';\r\nimport Koa from 'koa';\r\n\r\nimport 'winston-daily-rotate-file';\r\nconst transport = new winston.transports.DailyRotateFile({\r\n  filename: 'log/%DATE%.log',\r\n  datePattern: 'YYYY-MM-DD-HH',\r\n  zippedArchive: true,\r\n  maxSize: '20m',\r\n  maxFiles: '14d',\r\n});\r\n\r\nconst logger = winston.createLogger({\r\n  transports: [transport],\r\n});\r\n\r\nconst asyncwinston = async (_ctx: Koa.ParameterizedContext<Koa.DefaultState, Koa.DefaultContext>, next: Koa.Next) => {\r\n  try {\r\n    await next();\r\n  } catch (err) {\r\n    const data = {\r\n      data: err,\r\n      time: new Date().valueOf(),\r\n    };\r\n    if (err instanceof Error) {\r\n      data.data = {\r\n        content: err.message,\r\n        name: err.name,\r\n        stack: err.stack,\r\n      };\r\n    }\r\n    logger.error(JSON.stringify(data));\r\n  }\r\n};\r\n\r\nexport default asyncwinston;\r\n```\r\n\r\n## 启动\r\n\r\n启动就很简单了，把上面暴露的 index.js 通过`koa`的 use 引入\r\n\r\nApp.js\r\n\r\n```js\r\nconst Koa = require('koa');\r\nconst bodyParser = require('koa-bodyparser');\r\nconst route = require('./middleware/route');\r\nconst winston = require('./middleware/winston');\r\n\r\nconst App = async () => {\r\n  const app = new Koa();\r\n  app.use(winston);\r\n  app.use(bodyParser());\r\n  await route(app);\r\n  return app;\r\n};\r\n\r\nmodule.exports = App;\r\n```\r\n\r\nstart.js\r\n\r\n```js\r\nconst Koa = require('koa');\r\nconst ip = require('ip');\r\nconst App = require('./App');\r\n\r\nconst start = async () => {\r\n  const app = await App();\r\n  notice(app);\r\n};\r\n\r\nconst notice = (koa: Koa) => {\r\n  const port = 3000;\r\n  const ipStr = ip.address();\r\n  const str = `http://${ipStr}:${port}`;\r\n  koa.listen(port, () => {\r\n    console.log(`服务器运行在\\n${str}`);\r\n  });\r\n};\r\n\r\nstart();\r\n```\r\n\r\n**这里稍微说明一下为什么分成两个文件，这是因为方便接口测试特意分层的，`start`只做启动的用途**\r\n\r\n最后添加一个`node-dev`的模块，就大功告成了\r\n\r\n10/21 补充\r\n\r\n> 上面的 node-dev，是开发环境下使用的，方便代码的快速重启，在生产环境下可以使用 [pm2](https://github.com/Unitech/pm2)\r\n\r\n```js\r\n// 安装\r\nyarn add node-dev\r\n// 启动\r\nnode-dev start.js\r\n```\r\n\r\n通过`node-dev`启动主要是可以方便修改接口可以直接重载以及通知的方式更明显\r\n\r\n## 接口测试\r\n\r\n12/21 补上\r\n\r\n首先在 src 目录下 新建一个 `index.ts` 文件，用于测试的接口\r\n\r\n```js\r\nimport { Istructure } from '../typings/structure';\r\n\r\nconst testGet: Istructure = {\r\n  url: '/api/:id',\r\n  methods: 'get',\r\n  async callback(ctx) {\r\n    const { id } = ctx?.params;\r\n    ctx?.sendData({ name: 'hello', id });\r\n  },\r\n};\r\nconst testPost: Istructure = {\r\n  url: '/api',\r\n  methods: 'post',\r\n  async callback(ctx) {\r\n    const body = ctx?.request.body;\r\n    ctx?.sendData(body || {});\r\n  },\r\n};\r\n\r\nexport { testGet, testPost };\r\n```\r\n\r\n上面是一个很简单的 post 和 get 请求，之后我们新建一个`__test__`目录，在里面新建一个`index.test.js`文件\r\n\r\n```sh\r\nyarn add @babel/core @babel/preset-env @babel/preset-typescript babel-jest jest supertest\r\n```\r\n\r\n在根目录新建`babel.config.js`文件\r\n\r\n```js\r\n// babel.config.js\r\nmodule.exports = {\r\n  presets: [['@babel/preset-env', { targets: { node: 'current' } }], '@babel/preset-typescript'],\r\n};\r\n```\r\n\r\n简单说下，这个 babel 的作用是让我们可以在 js 里面使用 `es6 module` 的语法，同时将 ts 文件转成 js，否则我们这个测试用例是 ts 的根本跑不起来，测试框架方面选用了`jest`测试 http 库使用了`supertest`，其实这块都是可以调整的，单元测试的目的就是对比数据是否符合预期\r\n\r\n`__test__ index.test.js`\r\n\r\n```js\r\nimport App from '../App';\r\n\r\nimport supertest from 'supertest';\r\n\r\ntest('get请求测试', async () => {\r\n  const app = await App();\r\n  const request = supertest(app.listen());\r\n  const id = 6;\r\n  const data = { name: 'hello', id: `${id}` };\r\n  const res = await request.get(`/api/${id}`).expect(200);\r\n  const body = res.body.data;\r\n  expect(body).toEqual(data);\r\n});\r\n\r\ntest('post请求测试', async () => {\r\n  const app = await App();\r\n  const request = supertest(app.listen());\r\n  const data = { name: 'hello', id: 8 };\r\n  const res = await request.post(`/api/`).send(data).expect(200);\r\n  const body = res.body.data;\r\n  expect(body).toEqual(data);\r\n});\r\n```\r\n\r\n运行 `npx jest `，命令行如果没有抛出异常说明我们的代码符合预期，关于更多的 jest 内容可以查看文档\r\n\r\n## 最后\r\n\r\n源码放置到了[仓库](https://github.com/bosens-China/koa-rest)\r\n\r\n如果对你有帮助欢迎 `stat`，如果有什么错误之处欢迎指出，关于代码本来全部想用 ts 举例的，但是 ts 并不是一定要上的，所以某些场景我就手动转了一下，看起来有点风格不统一还望谅解\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/bosens-China/blog/issues/65/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/bosens-China/blog/issues/65/timeline",
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/bosens-China/blog/issues/53",
    "repository_url": "https://api.github.com/repos/bosens-China/blog",
    "labels_url": "https://api.github.com/repos/bosens-China/blog/issues/53/labels{/name}",
    "comments_url": "https://api.github.com/repos/bosens-China/blog/issues/53/comments",
    "events_url": "https://api.github.com/repos/bosens-China/blog/issues/53/events",
    "html_url": "https://github.com/bosens-China/blog/issues/53",
    "id": 586670728,
    "node_id": "MDU6SXNzdWU1ODY2NzA3Mjg=",
    "number": 53,
    "title": "vue ssr快速采坑",
    "user": {
      "login": "bosens-China",
      "id": 39508895,
      "node_id": "MDQ6VXNlcjM5NTA4ODk1",
      "avatar_url": "https://avatars.githubusercontent.com/u/39508895?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/bosens-China",
      "html_url": "https://github.com/bosens-China",
      "followers_url": "https://api.github.com/users/bosens-China/followers",
      "following_url": "https://api.github.com/users/bosens-China/following{/other_user}",
      "gists_url": "https://api.github.com/users/bosens-China/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/bosens-China/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/bosens-China/subscriptions",
      "organizations_url": "https://api.github.com/users/bosens-China/orgs",
      "repos_url": "https://api.github.com/users/bosens-China/repos",
      "events_url": "https://api.github.com/users/bosens-China/events{/privacy}",
      "received_events_url": "https://api.github.com/users/bosens-China/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [
      {
        "id": 1473940161,
        "node_id": "MDU6TGFiZWwxNDczOTQwMTYx",
        "url": "https://api.github.com/repos/bosens-China/blog/labels/Vue%20%E7%9B%B8%E5%85%B3",
        "name": "Vue 相关",
        "color": "42b883",
        "default": false,
        "description": "Vue 相关"
      }
    ],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 0,
    "created_at": "2020-03-24T03:46:56Z",
    "updated_at": "2020-11-14T04:28:25Z",
    "closed_at": null,
    "author_association": "OWNER",
    "active_lock_reason": null,
    "body": "最近写了一个小工具放在自己网站上，网速较慢时呈现空白事件比较长，虽然放置了初始loading但是体验还是不太好，打开控制台查看渲染时间，主要浪费在了初始js文件上，想到可以用ssr同构来优化一下更快呈现网页\r\n\r\n按照官方文档描述，ssr大概可以解决\r\n1. seo 的问题；\r\n2. 优化首屏打开时间，因为无需通过加载 js 来渲染填充dom结构\r\n\r\n下面为了方便分享这个过程，所有的内容都是简化过的，不包含路由部分（这部分对照看文档就 OK 了），分享的部分主要包含两部分\r\n- 静态渲染\r\n- 包含ajax的渲染\r\n\r\n为了节省时间，部分代码没有放到文章中，可以点击查看[vue-ssr-demo](https://github.com/bosens-China/Vue-ssr-demo)\r\n\r\n## 目录结构\r\n\r\n```sh\r\n.\r\n├─ build\r\n│    ├─ webpack.client.js\r\n│    ├─ webpack.config.js\r\n│    └─ webpack.server.js\r\n├─ package.json\r\n├─ server.js\r\n├─ src\r\n│    ├─ App.vue\r\n│    ├─ api\r\n│    │    └─ index.js\r\n│    ├─ app.js\r\n│    ├─ entry-client.js\r\n│    ├─ entry-server.js\r\n│    ├─ index.template.html\r\n│    ├─ store.js\r\n│    └─ utils\r\n│           └─ service\r\n│                  ├─ config.js\r\n│                  └─ index.js\r\n└─ static\r\n       └─ favicon.ico\r\n```\r\n\r\n这里先把最终的项目结构放出来，为了方便理解，下面讲解一些比较重要的文件和目录。\r\n\r\nbuild 是 webpack 的配置文件，这里没有配置开发环境的代码，如果有需要可以参考官方给出的例子[ HackerNews Demo](https://github.com/vuejs/vue-hackernews-2.0/)，同时为了简洁，webpack 的配置文件就不放了，直接在我上面贴出地址找到`build`文件夹参考看就可以了。\r\n\r\n`utils > service`是`axios`的封装代码，需要注意一点，因为代码同时运行在服务器和客户端，所以选用第三方库的时候最好是两端都支持，`axios`具有 node 和浏览器的统一的api，这里就用它作为请求库。\r\n\r\n## 起步\r\n\r\n在使用 vue-CLI 开发项目的时候，会有一个`src/main.js`入口文件，它的功能很简单执行一个`new Vue`然后挂载到`#app`元素上，不过在这里显然是不行的，因为服务器上的代码会持久运行，直接运行一个单例对象可能会导致污染，所以我们先从入口文件进行改造。\r\n\r\n这里定义一个`app.js`它的作用返回一个通用的函数，这样每次运行的时候都是一个新的对象。\r\n\r\n```js\r\nimport Vue from 'vue'\r\nimport App from './App.vue'\r\n\r\nVue.config.productionTip = false\r\n\r\nexport function creatApp() {\r\n  const app = new Vue({\r\n    render: h => h(App),\r\n  })\r\n  return { app }\r\n}\r\n```\r\n\r\n**注意**，我们并没有在这个 app 对象上执行`$mount`的操作，因为这里返回的是通用部分，执行`$mount`操作的时候是在客户端的时候。\r\n\r\n之后定义两个文件`entry-client.js`和`entry-server.js`文件，分别定义客户端代码和服务器端代码\r\n\r\n- entry-client.js\r\n\r\n```js\r\nimport { creatApp } from './app'\r\n\r\nconst { app } = creatApp()\r\napp.$mount('#app')\r\n```\r\n\r\n这里只让它执行挂载步骤就 OK 了\r\n\r\n- entry-server.js\r\n\r\n```js\r\nimport { creatApp } from './app'\r\n\r\nexport default context => {\r\n  const { app } = creatApp()\r\n  return app\r\n}\r\n```\r\n\r\n这里简单返回一个 app 对象给服务器。\r\n\r\n然后再来看一下`index.template.html`\r\n\r\n```html\r\n<html lang=\"zh\">\r\n  <head>\r\n    {{{meta}}}\r\n    <title>{{title}}</title>\r\n  </head>\r\n  <body>\r\n    <!--vue-ssr-outlet-->\r\n  </body>\r\n</html>\r\n```\r\n\r\n它的作用就是一个模板文件，具体内容请参考官方文档，它会在`server.js`文件中被我们使用，注意这里不需要定义`<div id=\"app\"></div>`，取而代之的是必须有一个`<!--vue-ssr-outlet-->`\r\n它的作用就是作为注入的节点。\r\n\r\n> {{ }}和{{{ }}}含义基本相同，区别在于{{{ }}}不会转义特殊字符。\r\n\r\n## App.vue\r\n\r\n```js\r\n;<template>\r\n  <div id=\"app\">\r\n    <p>这是一段计数器，初始值为1，后面每秒会累加一次，打开源代码看看渲染是否正确把：{{ count }}</p>\r\n  </div>\r\n</template>\r\nexport default {\r\n  name: 'app',\r\n  data() {\r\n    return {\r\n      count: 1,\r\n    }\r\n  },\r\n  mounted() {\r\n    setInterval(() => {\r\n      this.count += 1\r\n    }, 1000)\r\n  },\r\n}\r\n```\r\n\r\n上面结构很简单，就是一个定时器不断累加，不过有两个地方需要注意\r\n\r\n1.  `id=\"app\"`\r\n\r\n    这个 id 是必须的，因为我们在`entry-client.js`文件中执行`app.$mount('#app')`实际上就是挂载到了这里\r\n\r\n2.  `mounted`\r\n\r\n    我把定时器的操作写到了`mounted`生命周期内，因为在服务器我们要避免一些副作用的代码，举例来说如果我们写在了`created`中，服务器渲染没有销毁的钩子，这个定时器会一直执行下去，这样肯定就是错误的。\r\n    \r\n    这里贴一下官方给出的[编写通用代码指南](https://ssr.vuejs.org/zh/guide/universal.html#%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8A%E7%9A%84%E6%95%B0%E6%8D%AE%E5%93%8D%E5%BA%94)，只要记住服务器只有`beforeCreate`和`created`两个钩子即可，还有一些特定平台比如`window`等谨慎使用\r\n\r\n## server.js\r\n\r\n`server.js`文件的作用就是读取dist文件夹内文件，之后返回一串 html 字符串给浏览器\r\n\r\n```js\r\nconst Renderer = require('vue-server-renderer')\r\nconst fs = require('fs')\r\nconst path = require('path')\r\nconst Koa = require('koa')\r\nconst statics = require('koa-static')\r\n// 这里读取的`utf-8`不要省略\r\nconst template = fs.readFileSync(path.resolve(__dirname, './src/index.template.html'), 'utf-8')\r\nconst serverBundle = require('./dist/vue-ssr-server-bundle.json')\r\nconst clientManifest = require('./dist/vue-ssr-client-manifest.json')\r\n\r\nconst server = new Koa()\r\nconst renderer = Renderer.createBundleRenderer(serverBundle, {\r\n  template,\r\n  clientManifest,\r\n  // 这里设置为false，因为我们已经用函数包装了，所以不需要\r\n  runInNewContext: false,\r\n})\r\n\r\nserver.use(statics('dist', { index: 'xxx.html' }))\r\n\r\nserver.use(async ctx => {\r\n  const context = {\r\n    title: 'hello Vue Ssr',\r\n    meta: `\r\n    <meta charset=\"UTF-8\">\r\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\r\n    <link rel=\"shortcut icon\" href=\"favicon.ico\" type=\"image/x-icon\">\r\n    `,\r\n  }\r\n  ctx.response.type = 'html'\r\n  const html = await renderer.renderToString(context)\r\n  ctx.body = html\r\n})\r\n\r\nserver.listen(3000, () => {\r\n  console.log('运行成功: http://localhost:3000/')\r\n})\r\n```\r\n\r\n这里使用了`koa`作为服务器启动的框架，因为不包含路由所以请求任何的 url 地址都直接返回这个固定的`html`字符串给浏览器（对应的是`server.use(async (ctx) => {}`这一段代码）\r\n\r\napi 的格式比较固参考文档看即可，讲一两个比较容易入坑的地方\r\n\r\n- `entry-server.js`\r\n\r\n  我们打开`entry-server.js`文件，返回一个函数\r\n\r\n```js\r\n// ...\r\nexport default context => {\r\n  // ...\r\n}\r\n```\r\n\r\n里面有一个`context`的函数参数，实际上这个`context`对应的正是上面`server.js`的`context`对象，这个对象会传递给`index.template.html`文件内部使用\r\n\r\n- `server.use(statics('dist', { index: 'xxx.html' }));`\r\n\r\n这里打包的目录是 dist，直接在浏览器访问`/dist`资源会提示不存在，所以我们需要让这个目录可以访问，这里用了 koa 的中间件，后面的`{ index: 'xxx.html' }`必不可少，因为打包了一个`index.html`的文件，而`statics`默认的 index 会跟打包的文件冲突，在后面任意修改一个不存在的名字就可以了。\r\n\r\n执行到一步，运行 webpack 打包文件，之后启动`server.js`，打开浏览器就应该可以看到被服务器渲染过的页面了\r\n✿✿ヽ(°▽°)ノ✿\r\n\r\n## ajax\r\n\r\n下面说一下的重头戏`ajax`怎么来写，在这之前我们先准备一下要实现 demo 所需要的用到的`vuex`\r\n\r\n```sh\r\nyarn add vuex\r\n```\r\n\r\n这里采用了 vuex 做状态管理，事实上这不是必须的（只要用类似的即可），之后在`src`定义一个`store.js`文件，它的作用就是执行`ajax`请求，把结果保存在`state`内，然后在`App.vue`内通过`vuex`来读取到请求的数据。\r\n\r\n先写一个简单的接口\r\n\r\n```js\r\n// server.js\r\nconst Koa = require('koa')\r\nconst Router = require('koa-router')\r\nconst cors = require('koa-cors')\r\n\r\nconst api = new Koa()\r\nconst router = new Router()\r\nrouter.get('/ancientPoetry', ctx => {\r\n  const ancientPoetry = '古木阴中系短篷，\\n杖藜扶我过桥东。\\n沾衣欲湿杏花雨，\\n吹面不寒杨柳风。'\r\n  ctx.body = {\r\n    status: 200,\r\n    message: '操作成功',\r\n    data: ancientPoetry,\r\n  }\r\n})\r\napi\r\n  .use(cors())\r\n  .use(router.routes())\r\n  .use(router.allowedMethods())\r\n\r\n// 接口运行地址\r\napi.listen(7000)\r\n```\r\n\r\n上面用到了两个中间件\r\n\r\n```sh\r\nyarn add koa-cors koa-router\r\n```\r\n\r\nOK，这样接口部分也完成了，之后就是请求这个地址，然后让数据传递给`App.vue`内\r\n\r\n下面定义`store.js`文件\r\n\r\n```js\r\n// store.js\r\nimport Vue from 'vue'\r\nimport Vuex from 'vuex'\r\n// ancientPoetry是api访问的地址\r\nimport service, { ancientPoetry } from './utils/service'\r\n\r\nVue.use(Vuex)\r\n\r\nexport function createStore() {\r\n  return new Vuex.Store({\r\n    state: {\r\n      poetry: '',\r\n    },\r\n    actions: {\r\n      fetchItem({ commit }) {\r\n        return service({\r\n          method: 'get',\r\n          url: ancientPoetry,\r\n        }).then(item => {\r\n          commit('setItem', item)\r\n        })\r\n      },\r\n    },\r\n    mutations: {\r\n      setItem(state, item) {\r\n        Vue.set(state, 'poetry', item)\r\n      },\r\n    },\r\n  })\r\n}\r\n```\r\n\r\n上面返回的依然是一个函数，之后把这个函数注入到一些文件内部\r\n\r\n##### app.js\r\n\r\n```js\r\nimport Vue from 'vue'\r\nimport App from './App.vue'\r\nimport { createStore } from './store'\r\n\r\nVue.config.productionTip = false\r\n\r\nexport function creatApp() {\r\n  const store = createStore()\r\n  const app = new Vue({\r\n    asyncData({ store: s }) {\r\n      return s.dispatch('fetchItem')\r\n    },\r\n    store,\r\n    render: h => h(App),\r\n  })\r\n  return { app, store }\r\n}\r\n```\r\n\r\n**注意到`asyncData`这个函数**，我们后面会需要用到\r\n\r\n##### entry-server.js\r\n\r\n```js\r\nimport { creatApp } from './app'\r\n\r\nexport default async c => {\r\n  const context = c\r\n  const { app, store } = creatApp()\r\n  if (app.$options.asyncData) {\r\n    await app.$options.asyncData({ store })\r\n    // 状态将自动序列化为 `window.__INITIAL_STATE__`，并注入 HTML。\r\n    context.state = store.state\r\n  }\r\n  return app\r\n}\r\n```\r\n\r\n因为这里就定义了一个`App.vue`的文件，没有路由，所以！\r\n\r\n直接在 app 下通过`app.$options`来检查`asyncData`存不存在，关于`app.$options`的定义官方说是`new Vue`的一些其它选项，这里你可以通过任意方式获取（比如官方是通过匹配路径的文件来循环内部的`asyncData`方法），但是一定要找到定义的函数，因为它的作用就是来让`vuex`来请求数据，注入到组件内部的。\r\n\r\n之后我们更改`context`的`state`，这里还记得`context`么，它是一个上下文对象会同时运行在客户端和浏览器，最初由`server.js`文件提供\r\n\r\n##### entry-client.js\r\n\r\n```js\r\nimport { creatApp } from './app'\r\n\r\nconst { app, store } = creatApp()\r\n\r\n// 将信息注入到客户端\r\nif (window.__INITIAL_STATE__) {\r\n  store.replaceState(window.__INITIAL_STATE__)\r\n}\r\n\r\napp.$mount('#app')\r\n```\r\n\r\n这一步就比较简单了，直接把我们获取到的数据替换到vuex中，`store.replaceState`就是执行替换操作\r\n\r\n##### App.vue\r\n\r\n下面把异步的数据加上\r\n\r\n```js\r\n<template>\r\n  <div id=\"app\">\r\n    <p>这是一段计数器，初始值为1，后面每秒会累加一次，打开源代码看看渲染是否正确把：{{ count }}</p>\r\n    <p>\r\n      下面是一段ajax请求的异步结果\r\n    </p>\r\n    <p class=\"cs-item\">\r\n      <strong>\r\n        {{ item }}\r\n      </strong>\r\n    </p>\r\n  </div>\r\n</template>\r\n\r\n<script>\r\nexport default {\r\n  name: 'app',\r\n  data() {\r\n    return {\r\n      count: 1,\r\n    };\r\n  },\r\n  computed: {\r\n    // 从 store 的 state 对象中的获取 item。\r\n    item() {\r\n      return this.$store.state.poetry;\r\n    },\r\n  },\r\n  mounted() {\r\n    setInterval(() => {\r\n      this.count += 1;\r\n    }, 1000);\r\n  },\r\n};\r\n</script>\r\n\r\n<style>\r\n#app {\r\n  font-family: 'Avenir', Helvetica, Arial, sans-serif;\r\n  -webkit-font-smoothing: antialiased;\r\n  -moz-osx-font-smoothing: grayscale;\r\n  text-align: center;\r\n  color: #2c3e50;\r\n  margin-top: 60px;\r\n}\r\n.cs-item {\r\n  white-space: pre-line;\r\n}\r\n</style>\r\n```\r\n\r\nOK，到这一个简单的 ajax 请求页面就出来了\r\n\r\n\r\n## 缓存\r\n才发现忘记说最后一块缓存的问题了，这个需要根据项目的实际来，因为我写的结构比较固定，所以我让它一个小时才变动一次\r\n``` sh\r\nyarn add lru-cache\r\n```\r\n##### server.js\r\n``` js\r\n// 省略之前代码\r\nconst LRU = require('lru-cache');\r\nconst cache = new LRU({\r\n  max: 10000,\r\n  // 毫秒\r\n  maxAge: 1000 * 60 * 60,\r\n});\r\nconst server = new Koa();\r\nconst renderer = Renderer.createBundleRenderer(serverBundle, {\r\n  template,\r\n  clientManifest,\r\n  runInNewContext: false,\r\n  cache,\r\n});\r\n// ...\r\n```\r\n一个完整的`server.js`看起来应该是这样\r\n``` js\r\nconst Renderer = require('vue-server-renderer');\r\nconst fs = require('fs');\r\nconst path = require('path');\r\nconst Koa = require('koa');\r\n// 缓存\r\nconst LRU = require('lru-cache');\r\nconst statics = require('koa-static');\r\n\r\nconst template = fs.readFileSync(path.resolve(__dirname, './src/index.template.html'), 'utf-8');\r\nconst Router = require('koa-router');\r\nconst cors = require('koa-cors');\r\nconst serverBundle = require('./dist/vue-ssr-server-bundle.json');\r\nconst clientManifest = require('./dist/vue-ssr-client-manifest.json');\r\n\r\nconst cache = new LRU({\r\n  max: 10000,\r\n  // 毫秒\r\n  maxAge: 1000 * 60 * 60,\r\n});\r\n\r\nconst server = new Koa();\r\nconst renderer = Renderer.createBundleRenderer(serverBundle, {\r\n  template,\r\n  clientManifest,\r\n  runInNewContext: false,\r\n  cache,\r\n});\r\n\r\nserver.use(statics('dist', { index: 'xxx.html' }));\r\n\r\nserver.use(async (ctx) => {\r\n  const context = {\r\n    title: 'hello Vue Ssr',\r\n    url: ctx.url,\r\n    meta: `\r\n    <meta charset=\"UTF-8\">\r\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\r\n    <link rel=\"shortcut icon\" href=\"favicon.ico\" type=\"image/x-icon\">\r\n    `,\r\n  };\r\n  ctx.response.type = 'html';\r\n  const html = await renderer.renderToString(context);\r\n  ctx.body = html;\r\n});\r\n\r\nserver.listen(3000, () => {\r\n  console.log('运行成功: http://localhost:3000/');\r\n});\r\n\r\n// 新开一个api接口主要做测试内容用\r\n\r\nconst api = new Koa();\r\nconst router = new Router();\r\nrouter.get('/ancientPoetry', (ctx) => {\r\n  const ancientPoetry = '古木阴中系短篷，\\n杖藜扶我过桥东。\\n沾衣欲湿杏花雨，\\n吹面不寒杨柳风。';\r\n  ctx.body = {\r\n    status: 200,\r\n    message: '操作成功',\r\n    data: ancientPoetry,\r\n  };\r\n});\r\napi\r\n  .use(cors())\r\n  .use(router.routes())\r\n  .use(router.allowedMethods());\r\n\r\n// 接口运行地址\r\napi.listen(7000);\r\n```\r\n最后说一下先打包文件在运行`server.js`文件，撒花，这样一个带有缓存和异步请求的页面就被渲染出来了。",
    "reactions": {
      "url": "https://api.github.com/repos/bosens-China/blog/issues/53/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/bosens-China/blog/issues/53/timeline",
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/bosens-China/blog/issues/62",
    "repository_url": "https://api.github.com/repos/bosens-China/blog",
    "labels_url": "https://api.github.com/repos/bosens-China/blog/issues/62/labels{/name}",
    "comments_url": "https://api.github.com/repos/bosens-China/blog/issues/62/comments",
    "events_url": "https://api.github.com/repos/bosens-China/blog/issues/62/events",
    "html_url": "https://github.com/bosens-China/blog/issues/62",
    "id": 731179982,
    "node_id": "MDU6SXNzdWU3MzExNzk5ODI=",
    "number": 62,
    "title": "从Vue3.0来看组件新写法",
    "user": {
      "login": "bosens-China",
      "id": 39508895,
      "node_id": "MDQ6VXNlcjM5NTA4ODk1",
      "avatar_url": "https://avatars.githubusercontent.com/u/39508895?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/bosens-China",
      "html_url": "https://github.com/bosens-China",
      "followers_url": "https://api.github.com/users/bosens-China/followers",
      "following_url": "https://api.github.com/users/bosens-China/following{/other_user}",
      "gists_url": "https://api.github.com/users/bosens-China/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/bosens-China/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/bosens-China/subscriptions",
      "organizations_url": "https://api.github.com/users/bosens-China/orgs",
      "repos_url": "https://api.github.com/users/bosens-China/repos",
      "events_url": "https://api.github.com/users/bosens-China/events{/privacy}",
      "received_events_url": "https://api.github.com/users/bosens-China/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [
      {
        "id": 1473940161,
        "node_id": "MDU6TGFiZWwxNDczOTQwMTYx",
        "url": "https://api.github.com/repos/bosens-China/blog/labels/Vue%20%E7%9B%B8%E5%85%B3",
        "name": "Vue 相关",
        "color": "42b883",
        "default": false,
        "description": "Vue 相关"
      }
    ],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 0,
    "created_at": "2020-10-28T07:23:50Z",
    "updated_at": "2020-10-28T07:50:01Z",
    "closed_at": null,
    "author_association": "OWNER",
    "active_lock_reason": null,
    "body": "之前写过一篇文章[漫谈 vue 组件设计 ](https://github.com/bosens-China/blog/issues/57)，这里写这篇文章原因是不满一个相同的组件需要在各个页面重复写，而且这样搞维护成本实在太高，但是受限于 vue2.x 的响应机制没有想到更好的方法，所以在某些组件中使用的时候（例如在表单中使用需要添加校验规则、按需使用组件）需求很难实现。\r\n\r\n而从 Vue3.0 的响应式的重写以及组合 api 的出现，让我觉得眼前一亮，下面以省、市、区级联选择和表单校验为例子，因为主要\r\n讲解思路所以 UI 方面选择了`ant-design-vue`帮助快速构建视图\r\n\r\n> [在线演示](https://bosens-china.github.io/combination-demo/dist/)\r\n## 准备实现功能\r\n![1](https://user-images.githubusercontent.com/39508895/97404647-66940280-1931-11eb-9872-e88c6a8bef75.png)\r\n\r\n先上一张最终实现的效果图，下面内容会对照着讲解，代码放置到了[https://github.com/bosens-China/combination-demo](https://github.com/bosens-China/combination-demo)\r\n\r\n- 省、市、区组件可以自由组合使用（但是这个例子选取的不太好关系相互之间依赖，所以实际上只能`省+市+区`、`省+市`）\r\n- 不需要手动管理状态，只需要提供一个`v-model`作为绑定值即可\r\n\r\n\r\n## 实现\r\n\r\n根据上面需求，我们一个个实现\r\n\r\n- 组件组合使用\r\n\r\n要实现组件组合使用，这就要求组件本身耦合度不能太高，只展示数据并不进行任何的省、市、区具体功能的处理\r\n\r\n```js\r\n<a-select value={props.modelValue} onChange={onChange}>\r\n  {...modelValueList.value.map((item) => {\r\n    return <a-select-option value={item.name}>{item.value}</a-select-option>;\r\n  })}\r\n</a-select>\r\n```\r\n\r\n组件的结构如上所示，其实省、市、区的组件结构是一样的不同的只是结构不同，所以实现的时候只需要使用工厂模式即可，这样可以做到少维护可扩展。\r\n\r\n- 管理更新状态\r\n\r\n这一点使用了组合 api 来完成，在新发布的版本中，vue 把响应式功能抽离出来，响应式数据可以通过`ref`来定义，通过`watch`来做到监听，例如这一个例子\r\n\r\n```js\r\nimport { watch, ref } from \"vue\";\r\nconst test = ref(null);\r\nwatch(test, () => {\r\n  console.log(\"变更\");\r\n});\r\ntest.value = 5;\r\n```\r\n\r\n而且这个 ref 可以共享给其他程序使用，例如通过`import`导入给其他组件使用，这样刷新的时候自然而然组件也会发生变化。\r\n\r\n下面通过一个`rely.js`文件来进行组件状态管理，它可以帮助我们实现以下流程\r\n\r\n![123](https://user-images.githubusercontent.com/39508895/97404104-824ad900-1930-11eb-8e59-8b383ef4f612.png)\r\n\r\n在实际过程中我们切换省、市、区的时候需要我们还可以判断下绑定值存不存在 list 数据中，不存在就要清空。\r\n\r\n下面通过注释的方式来讲解\r\n\r\n```js\r\nimport { ref, watch } from \"vue\";\r\nimport { getProvince, getCity, getArea } from \"../../api/region\";\r\n\r\nconst created = () => {\r\n  // 下面字段分比为省、市、区的绑定字段以及list数据\r\n  const province = ref(undefined);\r\n  const provinceList = ref([]);\r\n  const city = ref(undefined);\r\n  const cityList = ref([]);\r\n  const area = ref(undefined);\r\n  const areaList = ref([]);\r\n\r\n  // 初始化省级列表\r\n  getProvince()\r\n    .then((res) => {\r\n      provinceList.value = res;\r\n    })\r\n    .catch(() => {\r\n      provinceList.value = [];\r\n    });\r\n\r\n  // 监听省级变化，更新市级的变化\r\n  watch(province, (value) => {\r\n    if (!value) {\r\n      city.value = undefined;\r\n      cityList.value = [];\r\n      return;\r\n    }\r\n    getCity(value)\r\n      .then((res) => {\r\n        cityList.value = res;\r\n        // 如果绑定值不存在对应的list数据中清除掉\r\n        city.value = res.find((f) => f.name === city.value)?.name;\r\n      })\r\n      .catch(() => {\r\n        cityList.value = [];\r\n        city.value = undefined;\r\n      });\r\n  });\r\n  // 监听市级变化，更新区的数据\r\n  watch(city, (value) => {\r\n    if (!value) {\r\n      areaList.value = [];\r\n      area.value = undefined;\r\n      return;\r\n    }\r\n    getArea(value)\r\n      .then((res) => {\r\n        areaList.value = res;\r\n        // 如果绑定值不存在对应的list数据中清除掉\r\n        area.value = res.find((f) => f.name === area.value)?.name;\r\n      })\r\n      .catch(() => {\r\n        areaList.value = [];\r\n        area.value = undefined;\r\n      });\r\n  });\r\n  // 返回数据，提供给其他组件使用\r\n  return {\r\n    province,\r\n    provinceList,\r\n    city,\r\n    cityList,\r\n    area,\r\n    areaList,\r\n  };\r\n};\r\nexport default created;\r\n```\r\n\r\n这里需要返回一个函数，因为组件状态不能被污染\r\n\r\n- 组合\r\n\r\nassembly.js\r\n\r\n```js\r\nimport { watch } from \"vue\";\r\nimport created from \"./rely\";\r\n\r\nconst basicsComponents = () => {\r\n  // 数据\r\n  const { province, provinceList, area, areaList, city, cityList } = created();\r\n  // 工厂模式返回视图\r\n  const assemble = (modelValue, modelValueList) => {\r\n    return {\r\n      // 3.0中默认绑定的字段\r\n      props: {\r\n        modelValue: null,\r\n      },\r\n      setup(props, { emit }) {\r\n        // 监听绑定值变化\r\n        watch(modelValue, (value) => {\r\n          emit(\"update:modelValue\", value);\r\n        });\r\n        // 监听modelValue值，更新到v-model中\r\n        watch(\r\n          () => props.modelValue,\r\n          (value) => {\r\n            modelValue.value = value;\r\n          },\r\n          { immediate: true }\r\n        );\r\n        const onChange = (value) => {\r\n          emit(\"update:modelValue\", value);\r\n        };\r\n        return () => (\r\n          <a-select value={props.modelValue} onChange={onChange}>\r\n            {...modelValueList.value.map((item) => {\r\n              return (\r\n                <a-select-option value={item.name}>\r\n                  {item.value}\r\n                </a-select-option>\r\n              );\r\n            })}\r\n          </a-select>\r\n        );\r\n      },\r\n    };\r\n  };\r\n\r\n  const componentsProvince = assemble(province, provinceList);\r\n  const componentsCity = assemble(city, cityList);\r\n  const componentsArea = assemble(area, areaList);\r\n  return {\r\n    componentsProvince,\r\n    componentsCity,\r\n    componentsArea,\r\n  };\r\n};\r\nexport default basicsComponents;\r\n```\r\n\r\n\r\n## 最后\r\n\r\n在使用过程中发现 Vue3.0 的热更新速度提升幅度不小使用起来很丝滑，但是还是有不少问题，比如我对 css 添加了`scoped`在开发环境下没有任何问题，在生产环境下`data-***`属性没有出现导致样式没作用起来，所以生产环境使用需要谨慎。\r\n\r\n文章如果对你有帮助，可以点一下`star`支持一下作者。\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/bosens-China/blog/issues/62/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/bosens-China/blog/issues/62/timeline",
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/bosens-China/blog/issues/61",
    "repository_url": "https://api.github.com/repos/bosens-China/blog",
    "labels_url": "https://api.github.com/repos/bosens-China/blog/issues/61/labels{/name}",
    "comments_url": "https://api.github.com/repos/bosens-China/blog/issues/61/comments",
    "events_url": "https://api.github.com/repos/bosens-China/blog/issues/61/events",
    "html_url": "https://github.com/bosens-China/blog/issues/61",
    "id": 680636174,
    "node_id": "MDU6SXNzdWU2ODA2MzYxNzQ=",
    "number": 61,
    "title": "小程序文字高亮",
    "user": {
      "login": "bosens-China",
      "id": 39508895,
      "node_id": "MDQ6VXNlcjM5NTA4ODk1",
      "avatar_url": "https://avatars.githubusercontent.com/u/39508895?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/bosens-China",
      "html_url": "https://github.com/bosens-China",
      "followers_url": "https://api.github.com/users/bosens-China/followers",
      "following_url": "https://api.github.com/users/bosens-China/following{/other_user}",
      "gists_url": "https://api.github.com/users/bosens-China/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/bosens-China/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/bosens-China/subscriptions",
      "organizations_url": "https://api.github.com/users/bosens-China/orgs",
      "repos_url": "https://api.github.com/users/bosens-China/repos",
      "events_url": "https://api.github.com/users/bosens-China/events{/privacy}",
      "received_events_url": "https://api.github.com/users/bosens-China/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [
      {
        "id": 1371686611,
        "node_id": "MDU6TGFiZWwxMzcxNjg2NjEx",
        "url": "https://api.github.com/repos/bosens-China/blog/labels/%E5%85%B6%E4%BB%96",
        "name": "其他",
        "color": "f6ecbf",
        "default": false,
        "description": "暂定为分享之类的"
      }
    ],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 0,
    "created_at": "2020-08-18T02:15:53Z",
    "updated_at": "2020-08-18T03:38:04Z",
    "closed_at": null,
    "author_association": "OWNER",
    "active_lock_reason": null,
    "body": "## 小程序文字高亮\r\n\r\n\r\n![bg](https://user-images.githubusercontent.com/39508895/90462493-935eb900-e13b-11ea-902c-dce1e576fbb4.png)\r\n\r\n\r\n最近实现一个城市级联选择的时候用到了高亮 ，这里就总结回顾下。\r\n\r\n### web 上做法\r\n\r\n可以通过正则表达式`/(高亮的文字)/`来实现\r\n\r\n```js\r\nfunction highlight(str, sep, color) {\r\n  const reg = new RegExp(`\\(${sep}\\)`, \"g\");\r\n  return str.replace(reg, `<i style=\"color:${color};\">$1</i>`);\r\n}\r\nhighlight(\"安徽省合肥市\", \"安徽\", \"reg\");\r\n// <i style=\"color:reg;\">安徽</i>省合肥市\r\n```\r\n\r\n这里实现比较简单，稍微注意一下`replace`api 即可，它还可以接收一个函数作为参数，具体内容这里不做讲解了只简单实现一下。\r\n\r\n### 小程序做法\r\n\r\n不同于 web，因为小程序无法手动管理 `dom` 样式，所以思路是将`高亮文字`和普通文字区分开来，例如：\r\n\r\n```js\r\nvar str = \"安徽省合肥市蜀山区\";\r\n// 如果高亮合肥市，那么我们把他转化为下面这种形式的数组\r\n[\"安徽省\", \"合肥市\", \"蜀山区\"];\r\n```\r\n\r\n将普通文字和高亮文字通过数组的形式区分开来，之后再通过`<text>`标签将转换后的数组`for`循环，每次循环的结果与高亮文字对比，如果符合就添加高亮样式。\r\n\r\n```html\r\n<view>\r\n  <text\r\n    style=\"{{item === keyWord ? 'color:' + color + ';' : ''}}\"\r\n    wx:for=\"{{arr}}\"\r\n    wx:key=\"item\"\r\n  >\r\n    {{item}}\r\n  </text>\r\n</view>\r\n```\r\n\r\n整体的思路就是这样，下面说一下实现的细节。\r\n\r\n- 怎么将一段文字转化为上面数组的形式\r\n  其实这块要分为两步，将文字转化为数组我们可以用`split`的方法，之后通过一个变异的`join`将他们拼成数组。\r\n\r\n```js\r\nfunction join(array, str) {\r\n  const arr = [];\r\n  const len = array.length;\r\n  for (let i = 0; i < len - 1; i++) {\r\n    const value = array[i];\r\n    if (!value) {\r\n      arr.push(str);\r\n    } else {\r\n      arr.push(value, str);\r\n    }\r\n  }\r\n  if (array[len - 1]) {\r\n    arr.push(array[len - 1]);\r\n  }\r\n  return arr;\r\n}\r\n```\r\n\r\n把上面的`wxml`代码片段和`join`相关组合一起就可以实现一个文字高亮的效果了。\r\n\r\n## 最后\r\n\r\n相关代码整合到了[Github](https://github.com/bosens-China/highlight)\r\n\r\n如果对你有帮助可以`star`支持作者一下。\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/bosens-China/blog/issues/61/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/bosens-China/blog/issues/61/timeline",
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/bosens-China/blog/issues/33",
    "repository_url": "https://api.github.com/repos/bosens-China/blog",
    "labels_url": "https://api.github.com/repos/bosens-China/blog/issues/33/labels{/name}",
    "comments_url": "https://api.github.com/repos/bosens-China/blog/issues/33/comments",
    "events_url": "https://api.github.com/repos/bosens-China/blog/issues/33/events",
    "html_url": "https://github.com/bosens-China/blog/issues/33",
    "id": 503916859,
    "node_id": "MDU6SXNzdWU1MDM5MTY4NTk=",
    "number": 33,
    "title": "从babel看class(下)",
    "user": {
      "login": "bosens-China",
      "id": 39508895,
      "node_id": "MDQ6VXNlcjM5NTA4ODk1",
      "avatar_url": "https://avatars.githubusercontent.com/u/39508895?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/bosens-China",
      "html_url": "https://github.com/bosens-China",
      "followers_url": "https://api.github.com/users/bosens-China/followers",
      "following_url": "https://api.github.com/users/bosens-China/following{/other_user}",
      "gists_url": "https://api.github.com/users/bosens-China/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/bosens-China/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/bosens-China/subscriptions",
      "organizations_url": "https://api.github.com/users/bosens-China/orgs",
      "repos_url": "https://api.github.com/users/bosens-China/repos",
      "events_url": "https://api.github.com/users/bosens-China/events{/privacy}",
      "received_events_url": "https://api.github.com/users/bosens-China/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [
      {
        "id": 1908144759,
        "node_id": "MDU6TGFiZWwxOTA4MTQ0NzU5",
        "url": "https://api.github.com/repos/bosens-China/blog/labels/ES6%E7%B3%BB%E5%88%97",
        "name": "ES6系列",
        "color": "0366d6",
        "default": false,
        "description": ""
      }
    ],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 0,
    "created_at": "2019-10-08T08:58:30Z",
    "updated_at": "2020-06-30T08:05:16Z",
    "closed_at": null,
    "author_association": "OWNER",
    "active_lock_reason": null,
    "body": "书接上文[从 babel 看 class(上)](https://github.com/bosens-China/blog/issues/27)，第一篇说了 class 法经过 babel 会转化成什么样子，而这篇则主要介绍继承。\r\n\r\n## es5\r\n\r\n在 es5 下我们常用的就是寄生组合式继承了，下面就是一个例子，看下 es5 的实现步骤\r\n\r\n```js\r\nfunction Foo() {\r\n  this.name = \"foo\";\r\n}\r\nFoo.prototype.getName = function() {\r\n  return this.name;\r\n};\r\nfunction Extends(name) {\r\n  Foo.call(this);\r\n  this.name = name;\r\n}\r\nExtends.prototype = Object.create(Foo.prototype);\r\nExtends.prototype.construcotr = Extends;\r\n\r\nvar child = new Extends(\"Extends\");\r\nchild.getName(); // \"Extends\"\r\n```\r\n\r\n上面对应的原型图为\r\n![back](https://user-images.githubusercontent.com/39508895/66381914-ccdb7980-e9ec-11e9-8e82-1ce53fb1c846.jpg)\r\n\r\n\r\n## es6\r\n\r\n我们用 class 的形式来重写上面的例子\r\n\r\n```js\r\nclass Foo {\r\n  name = \"foo\";\r\n  getName() {\r\n    return this.name;\r\n  }\r\n}\r\nclass Extends extends Foo {\r\n  constructor(name) {\r\n    super();\r\n    this.name = name;\r\n  }\r\n}\r\nvar child = new Extends(\"Extends\");\r\nchild.getName(); // \"Extends\"\r\n```\r\n\r\nclass 通过 `extends` 实现继承，上面调用了`super`这是必须的，相当于`Foo.call(this)`，如果没有调用就使用 this 会报错，因为子类的 this 必须通过父类的 this `来构建，extends` 还可以继承父类的静态属性和方法\r\n\r\n```js\r\nclass Foo {\r\n  name = \"foo\";\r\n  getName() {\r\n    return this.name;\r\n  }\r\n  static getName() {\r\n    return \"Foo\";\r\n  }\r\n}\r\nclass Extends extends Foo {\r\n  constructor(name) {\r\n    super();\r\n    this.name = name;\r\n  }\r\n  static get() {\r\n    return super.getName();\r\n  }\r\n}\r\nvar child = new Extends(\"Extends\");\r\nconsole.log(Extends.get()); //Foo\r\n\r\nchild.getName(); // \"Extends\"\r\n```\r\n\r\n出现这种结果的原因是 class 存在两条继承链\r\n\r\n1. 子类的**proto**属性，表示构造函数的继承，总是指向父类；\r\n\r\n2. 子类 prototype 属性的**proto**属性，表示方法的继承，总是指向父类的 prototype 属性；\r\n\r\n![1](https://user-images.githubusercontent.com/39508895/66381929-d2d15a80-e9ec-11e9-81dd-352e9ebb4d1d.jpg)\r\n\r\n\r\n## babel\r\n\r\nbabel 翻译之后代码有点多，我先精简一下只看核心部分\r\n\r\n```js\r\nvar Foo =\r\n  /*#__PURE__*/\r\n  (function() {\r\n    function Foo() {\r\n      _classCallCheck(this, Foo);\r\n\r\n      _defineProperty(this, \"name\", \"foo\");\r\n    }\r\n\r\n    _createClass(\r\n      Foo,\r\n      [\r\n        {\r\n          key: \"getName\",\r\n          value: function getName() {\r\n            return this.name;\r\n          }\r\n        }\r\n      ],\r\n      [\r\n        {\r\n          key: \"getName\",\r\n          value: function getName() {\r\n            return \"Foo\";\r\n          }\r\n        }\r\n      ]\r\n    );\r\n\r\n    return Foo;\r\n  })();\r\n\r\nvar Extends =\r\n  /*#__PURE__*/\r\n  (function(_Foo) {\r\n    _inherits(Extends, _Foo);\r\n\r\n    function Extends(name) {\r\n      var _this;\r\n\r\n      _classCallCheck(this, Extends);\r\n\r\n      _this = _possibleConstructorReturn(\r\n        this,\r\n        _getPrototypeOf(Extends).call(this)\r\n      );\r\n      _this.name = name;\r\n      return _this;\r\n    }\r\n\r\n    _createClass(Extends, null, [\r\n      {\r\n        key: \"get\",\r\n        value: function get() {\r\n          return _get(_getPrototypeOf(Extends), \"getName\", this).call(this);\r\n        }\r\n      }\r\n    ]);\r\n\r\n    return Extends;\r\n  })(Foo);\r\n\r\nvar child = new Extends(\"Extends\");\r\nconsole.log(Extends.get()); //Foo\r\n\r\nchild.getName(); // \"Extends\"\r\n```\r\n\r\n`Foo`这部分`_classCallCheck`、`_defineProperty`、`_createClass`在上一篇有介绍，主要就是给属性赋值，这里跳过，主要来看`Extends`部分\r\n\r\n首先执行了`_inherits`函数，这个函数展开\r\n\r\n```js\r\nfunction _inherits(subClass, superClass) {\r\n  if (typeof superClass !== \"function\" && superClass !== null) {\r\n    throw new TypeError(\"Super expression must either be null or a function\");\r\n  }\r\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\r\n    constructor: {\r\n      value: subClass,\r\n      writable: true,\r\n      configurable: true\r\n    }\r\n  });\r\n  if (superClass) _setPrototypeOf(subClass, superClass);\r\n}\r\n\r\nfunction _setPrototypeOf(o, p) {\r\n  _setPrototypeOf =\r\n    Object.setPrototypeOf ||\r\n    function _setPrototypeOf(o, p) {\r\n      o.__proto__ = p;\r\n      return o;\r\n    };\r\n  return _setPrototypeOf(o, p);\r\n}\r\n```\r\n\r\n实际上就是验证和重写继承链，`extends`按照规范可以是一个函数或者 null，这里判断没什么好说的；\r\n\r\n`Object.setPrototypeOf`如果存在就用这个，不存在直接用`__proto__`属性，重写了`prototype`和子类的原型。\r\n再来看下这段代码\r\n\r\n```js\r\nvar _this;\r\n\r\n_classCallCheck(this, Extends);\r\n\r\n_this = _possibleConstructorReturn(this, _getPrototypeOf(Extends).call(this));\r\n```\r\n\r\n首先定义了一个`_this`的变量，还记得我们之前说 class 的继承是先通过父类的构造函数完成塑造，得到与父类同样的实例属性和方法，然后再对其进行加工，加上子类自己的实例属性和方法，如果不使用`super`调用 this 进行赋值之类就会报错。\r\n`_possibleConstructorReturn`函数就是通过判断`_this`是否为`undefined`来决定是否显示报错\r\n\r\n```js\r\nfunction _possibleConstructorReturn(self, call) {\r\n  if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {\r\n    return call;\r\n  }\r\n  return _assertThisInitialized(self);\r\n}\r\n\r\nfunction _assertThisInitialized(self) {\r\n  if (self === void 0) {\r\n    throw new ReferenceError(\r\n      \"this hasn't been initialised - super() hasn't been called\"\r\n    );\r\n  }\r\n  return self;\r\n}\r\n```\r\n\r\n而`this, _getPrototypeOf(Extends).call(this);`这段代码就相当于`super`从这一步 this 得到了父类同样的实例属性和方法，下面就是对子类进行加工。\r\n\r\n## 总结\r\n\r\n从整个执行过程来看，babel 的转化过程如下：\r\n\r\n1. 验证，如果不是 new 调用就报错，如果是继承还需要验证继承的是否为函数或者 null；\r\n2. 重写继承链，同时调用父类构造函数得到父类同样的实例属性和方法；\r\n3. 赋值，为构造函数本身和 this 赋值；\r\n\r\n源代码太长就不放了，如果有兴趣可以自己打开[babel 官网](https://babeljs.io/repl)把上面代码复制进来，就可以看到完整代码\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/bosens-China/blog/issues/33/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/bosens-China/blog/issues/33/timeline",
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/bosens-China/blog/issues/40",
    "repository_url": "https://api.github.com/repos/bosens-China/blog",
    "labels_url": "https://api.github.com/repos/bosens-China/blog/issues/40/labels{/name}",
    "comments_url": "https://api.github.com/repos/bosens-China/blog/issues/40/comments",
    "events_url": "https://api.github.com/repos/bosens-China/blog/issues/40/events",
    "html_url": "https://github.com/bosens-China/blog/issues/40",
    "id": 533751723,
    "node_id": "MDU6SXNzdWU1MzM3NTE3MjM=",
    "number": 40,
    "title": "null运算符和链判断运算符",
    "user": {
      "login": "bosens-China",
      "id": 39508895,
      "node_id": "MDQ6VXNlcjM5NTA4ODk1",
      "avatar_url": "https://avatars.githubusercontent.com/u/39508895?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/bosens-China",
      "html_url": "https://github.com/bosens-China",
      "followers_url": "https://api.github.com/users/bosens-China/followers",
      "following_url": "https://api.github.com/users/bosens-China/following{/other_user}",
      "gists_url": "https://api.github.com/users/bosens-China/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/bosens-China/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/bosens-China/subscriptions",
      "organizations_url": "https://api.github.com/users/bosens-China/orgs",
      "repos_url": "https://api.github.com/users/bosens-China/repos",
      "events_url": "https://api.github.com/users/bosens-China/events{/privacy}",
      "received_events_url": "https://api.github.com/users/bosens-China/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [
      {
        "id": 1908144759,
        "node_id": "MDU6TGFiZWwxOTA4MTQ0NzU5",
        "url": "https://api.github.com/repos/bosens-China/blog/labels/ES6%E7%B3%BB%E5%88%97",
        "name": "ES6系列",
        "color": "0366d6",
        "default": false,
        "description": ""
      }
    ],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 0,
    "created_at": "2019-12-06T05:17:34Z",
    "updated_at": "2020-06-30T08:05:03Z",
    "closed_at": null,
    "author_association": "OWNER",
    "active_lock_reason": null,
    "body": "> 2019/12/18 日更新\r\n\r\n主要是介绍`链判断运算符`和`null运算符`，使用场景\r\n\r\n## null 运算符\r\n\r\n```js\r\nconst headerText = response.settings.headerText ?? \"Hello, world!\";\r\nconst animationDuration = response.settings.animationDuration ?? 300;\r\nconst showSplashScreen = response.settings.showSplashScreen ?? true;\r\n```\r\n\r\n上面代码只会在等于`null`和`undefined`的时候被赋值为右侧的表达式，如果没有`null运算符`，我们需要这样写\r\n\r\n```js\r\nconst headerText =\r\n  response.settings.headerText == null\r\n    ? \"Hello, world!\"\r\n    : response.settings.headerText;\r\nconst animationDuration =\r\n  response.settings.animationDuration == null\r\n    ? 300\r\n    : response.settings.animationDuration;\r\nconst showSplashScreen =\r\n  response.settings.showSplashScreen == null\r\n    ? true\r\n    : response.settings.showSplashScreen;\r\n```\r\n\r\n这样写十分的麻烦，而且语法重复的也很多，引进这个语法在我看来主要有两个作用:\r\n\r\n1. 去除了`||`的短路机制写法\r\n\r\n2. 为函数参数提供默认值\r\n\r\nes6 引入了赋值解构默认值，但是这个值只能在等于`undefined`的时候才触发，很多情况下并不是我们想要的\r\n\r\n```js\r\nfunction foo({ obj = \"\" } = {}) {}\r\nfoo(null);\r\n```\r\n\r\n这里就会报错，因为显示给参数传递了值，但是因为传递的是 null 所以导致默认值失效，在看一下用`null运算符的写法`\r\n\r\n```js\r\nfunction foo(rest) {\r\n  const { obj = \"\" } = rest ?? {};\r\n}\r\nfoo(null);\r\n```\r\n\r\n## 链判断运算符\r\n\r\n为了保证代码的正确性一定会做很多判断，例如：\r\n\r\n```js\r\nconst dom = document.querySelector(\".app\");\r\nif (dom && dom.className === \"list\") {\r\n  // 执行一些操作\r\n}\r\n```\r\n\r\n上面的代码已经是简化的了，看起来还好，在来一个复杂一些\r\n\r\n```js\r\nconst firstName =\r\n  (message &&\r\n    message.body &&\r\n    message.body.user &&\r\n    message.body.user.firstName) ||\r\n  \"default\";\r\n```\r\n\r\n是不是感觉判断写的很多了有一点小小的不爽，如果通过链判断运算符来重写上面的例子\r\n\r\n```js\r\nconst dom = document.querySelector(\".app\");\r\nif (dom?.className === \"list\") {\r\n  // 执行一些操作\r\n}\r\n// 例二\r\nconst firstName = message?.body?.user?.firstName || \"default\";\r\n```\r\n\r\n语法简洁了很多，维护起来也很舒服（主要还是懒），下面就赶紧介绍一下怎么在项目中使用，这里再来提一下除了上面的对象形式调用，还有下面的几种常见的形式\r\n\r\n```js\r\nvar a = {\r\n  o: function() {}\r\n};\r\na?.o();\r\ndelete a?.o;\r\n```\r\n\r\n### 项目中使用\r\n\r\n省略`null运算符`的配置，跟`链判断运算符`相同\r\n现在浏览器对这个语法还没有支持，所以要通过 babel 的插件完成这个转换过程\r\n\r\n```sh\r\nyarn add @babel/plugin-proposal-optional-chaining -D\r\n```\r\n\r\n- babel.config.js\r\n\r\n```js\r\n// 只放部分\r\nplugins: [\"@babel/plugin-proposal-optional-chaining\"];\r\n```\r\n\r\n完成这一步就 OK 了，现在可以在项目中使用了，等等...\r\n\r\n`eslint`还没有配置，不过很可惜的是对于实验性的语法`eslint`并不支持，需要使用`babel-eslint`的解析器，目前版本(`babel-eslint\": \"^10.0.3`)已经是支持的了，用 ts 的小伙伴也不用担心`@typescript-eslint/parser`目前版本也是支持的，撒花 ✿✿ ヽ(°▽°)ノ ✿\r\n\r\n## 最后\r\n\r\n因为篇幅的原因，这里就着重介绍了一下基本的使用，这里把阮一峰老师的[es6 入门](http://es6.ruanyifeng.com/#docs/object#Null-%E5%88%A4%E6%96%AD%E8%BF%90%E7%AE%97%E7%AC%A6)奉上，可以具体展开看看\r\n\r\n上面极少的语法配合 babel 已经可以食用了，\r\n\r\n参考：\r\n\r\n- [optional chaining operator 提案](https://github.com/tc39/proposal-optional-chaining)\r\n- [链判断运算符](http://es6.ruanyifeng.com/#docs/proposals#%E9%93%BE%E5%88%A4%E6%96%AD%E8%BF%90%E7%AE%97%E7%AC%A6)\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/bosens-China/blog/issues/40/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/bosens-China/blog/issues/40/timeline",
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/bosens-China/blog/issues/27",
    "repository_url": "https://api.github.com/repos/bosens-China/blog",
    "labels_url": "https://api.github.com/repos/bosens-China/blog/issues/27/labels{/name}",
    "comments_url": "https://api.github.com/repos/bosens-China/blog/issues/27/comments",
    "events_url": "https://api.github.com/repos/bosens-China/blog/issues/27/events",
    "html_url": "https://github.com/bosens-China/blog/issues/27",
    "id": 499194656,
    "node_id": "MDU6SXNzdWU0OTkxOTQ2NTY=",
    "number": 27,
    "title": "从babel看class(上)",
    "user": {
      "login": "bosens-China",
      "id": 39508895,
      "node_id": "MDQ6VXNlcjM5NTA4ODk1",
      "avatar_url": "https://avatars.githubusercontent.com/u/39508895?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/bosens-China",
      "html_url": "https://github.com/bosens-China",
      "followers_url": "https://api.github.com/users/bosens-China/followers",
      "following_url": "https://api.github.com/users/bosens-China/following{/other_user}",
      "gists_url": "https://api.github.com/users/bosens-China/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/bosens-China/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/bosens-China/subscriptions",
      "organizations_url": "https://api.github.com/users/bosens-China/orgs",
      "repos_url": "https://api.github.com/users/bosens-China/repos",
      "events_url": "https://api.github.com/users/bosens-China/events{/privacy}",
      "received_events_url": "https://api.github.com/users/bosens-China/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [
      {
        "id": 1908144759,
        "node_id": "MDU6TGFiZWwxOTA4MTQ0NzU5",
        "url": "https://api.github.com/repos/bosens-China/blog/labels/ES6%E7%B3%BB%E5%88%97",
        "name": "ES6系列",
        "color": "0366d6",
        "default": false,
        "description": ""
      }
    ],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 0,
    "created_at": "2019-09-27T02:02:30Z",
    "updated_at": "2020-06-30T08:04:32Z",
    "closed_at": null,
    "author_association": "OWNER",
    "active_lock_reason": null,
    "body": "> class 语法已经出来很长时间了，借助 babel 我们可以在生产中使用，下面就通过一个例子来看看 babel 是怎么处理 class 的\r\n\r\n## es6\r\n\r\n下面是一段代码，我们分别为实例、静态、实例的原型添加方法和属性\r\n\r\n```js\r\nclass Foo {\r\n  static foo = \"Foo\";\r\n  foo = \"foo\";\r\n  static getName() {\r\n    return this.foo;\r\n  }\r\n  getName() {\r\n    return this.foo;\r\n  }\r\n  static get value() {\r\n    return this.foo + \"static\";\r\n  }\r\n  get value() {\r\n    return this.foo + \"example\";\r\n  }\r\n}\r\n```\r\n\r\n上面用到了`static`，`static`表明属性或者方法添加到 Class 本身而不是实例上，下面再来对比一下 es5 的写法\r\n\r\n## es5\r\n\r\n```js\r\nfunction Foo() {\r\n  this.name = \"foo\";\r\n}\r\nFoo.foo = \"Foo\";\r\nFoo.getName = function() {\r\n  return this.foo;\r\n};\r\nFoo.prototype.getName = function() {\r\n  return this.foo;\r\n};\r\nObject.defineProperty(Foo, \"value\", {\r\n  configurable: true,\r\n  enumerable: true,\r\n  get() {\r\n    return this.foo + \"static\";\r\n  }\r\n});\r\nObject.defineProperty(Foo.prototype, \"value\", {\r\n  configurable: true,\r\n  enumerable: true,\r\n  get() {\r\n    return this.foo + \"example\";\r\n  }\r\n});\r\n```\r\n\r\n上面我们使用了`Object.defineProperty`来为对象定义属性，其中 getter/setter 是可选，不过在严格模式下中 getter/setter 必须同时出现，使用 getter/setter 后 value 和 writable 不可出现，否则报错。\r\n\r\n## babel 转码\r\n\r\n```js\r\n\"use strict\";\r\n\r\nfunction _instanceof(left, right) {\r\n  if (\r\n    right != null &&\r\n    typeof Symbol !== \"undefined\" &&\r\n    right[Symbol.hasInstance]\r\n  ) {\r\n    return !!right[Symbol.hasInstance](left);\r\n  } else {\r\n    return left instanceof right;\r\n  }\r\n}\r\n\r\nfunction _classCallCheck(instance, Constructor) {\r\n  if (!_instanceof(instance, Constructor)) {\r\n    throw new TypeError(\"Cannot call a class as a function\");\r\n  }\r\n}\r\n\r\nfunction _defineProperties(target, props) {\r\n  for (var i = 0; i < props.length; i++) {\r\n    var descriptor = props[i];\r\n    descriptor.enumerable = descriptor.enumerable || false;\r\n    descriptor.configurable = true;\r\n    if (\"value\" in descriptor) descriptor.writable = true;\r\n    Object.defineProperty(target, descriptor.key, descriptor);\r\n  }\r\n}\r\n\r\nfunction _createClass(Constructor, protoProps, staticProps) {\r\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\r\n  if (staticProps) _defineProperties(Constructor, staticProps);\r\n  return Constructor;\r\n}\r\n\r\nfunction _defineProperty(obj, key, value) {\r\n  if (key in obj) {\r\n    Object.defineProperty(obj, key, {\r\n      value: value,\r\n      enumerable: true,\r\n      configurable: true,\r\n      writable: true\r\n    });\r\n  } else {\r\n    obj[key] = value;\r\n  }\r\n  return obj;\r\n}\r\n\r\nvar Foo =\r\n  /*#__PURE__*/\r\n  (function() {\r\n    function Foo() {\r\n      _classCallCheck(this, Foo);\r\n\r\n      _defineProperty(this, \"foo\", \"foo\");\r\n    }\r\n\r\n    _createClass(\r\n      Foo,\r\n      [\r\n        {\r\n          key: \"getName\",\r\n          value: function getName() {\r\n            return this.foo;\r\n          }\r\n        },\r\n        {\r\n          key: \"value\",\r\n          get: function get() {\r\n            return this.foo + \"example\";\r\n          }\r\n        }\r\n      ],\r\n      [\r\n        {\r\n          key: \"getName\",\r\n          value: function getName() {\r\n            return this.foo;\r\n          }\r\n        },\r\n        {\r\n          key: \"value\",\r\n          get: function get() {\r\n            return this.foo + \"static\";\r\n          }\r\n        }\r\n      ]\r\n    );\r\n\r\n    return Foo;\r\n  })();\r\n\r\n_defineProperty(Foo, \"foo\", \"Foo\");\r\n```\r\n\r\n转码过的代码看起来有点多，不过我们顺着执行顺序来看，首先`var Foo =`内部执行了一个`_classCallCheck`函数，那么它有什么用呢？\r\n\r\n其实这个函数是为了保证 class 必须通过 new 来调用，ES6 规定 class 必须通过 new 调用，不然会显式报错。\r\n\r\n### 必须为 new 调用\r\n\r\n判断一个函数是否为`new`调用可以通过 `instanceof` 来进行判断，例如：\r\n\r\n```js\r\nfunction F() {\r\n  if (!(this instanceof F)) {\r\n    throw new Error(\"必须通过new调用\");\r\n  }\r\n}\r\n```\r\n\r\n在全局作用域下如果不通过 new 调用 this 为 `undefined`，`instanceof`与非对象对比总是返回`false`;\r\n\r\n在 ES6 还可以通过`new.target`来判断\r\n\r\n```js\r\nfunction F() {\r\n  if (!new.target) {\r\n    throw new Error(\"必须通过new调用\");\r\n  }\r\n}\r\n```\r\n\r\n`new.target` 指向被 new 调用的构造函数，如果不存在返回 `undefined`。\r\n\r\n上面介绍了两种判断方法再来看下 babel 是怎么处理这一过程的\r\n\r\n1. 将 this 和构造函数传递给`_classCallCheck`；\r\n2. `_classCallCheck`将参数传递给`_instanceof`函数；\r\n\r\n`_instanceof`函数负责了什么事情呢？\r\n\r\n其实也是判断函数是否通过 new 调用，不过它同时对`Symbol.hasInstance`也进行了判断。\r\n\r\n### Symbol.hasInstance\r\n\r\n当其他对象使用 `instanceof` 运算符，判断是否为该对象的实例时，会调用这个方法，\r\n\r\n> 方法定义在类本身\r\n\r\n```js\r\nclass MyClass {\r\n  [Symbol.hasInstance](foo) {\r\n    return foo instanceof Array;\r\n  }\r\n}\r\n\r\n[1, 2, 3] instanceof new MyClass(); // true\r\n```\r\n\r\n上面演示了一个例子，我们书接上文看下`_instanceof`函数内部怎么判断这一过程\r\n\r\n```js\r\nfunction _instanceof(left, right) {\r\n  if (\r\n    right != null &&\r\n    typeof Symbol !== \"undefined\" &&\r\n    right[Symbol.hasInstance]\r\n  ) {\r\n    return !!right[Symbol.hasInstance](left);\r\n  } else {\r\n    return left instanceof right;\r\n  }\r\n}\r\n```\r\n\r\n判断构造函数存在且同时存在 `Symbol.hasInstance`方法，如果有就执行`Symbol.hasInstance()`，没有的话就直接执行`instanceof`判断。\r\n\r\n撒花，这里初始判断讲完，下面就是为对象赋值\r\n\r\n### 赋值\r\n\r\n我们继续顺着代码看，发现调用了`_defineProperty`，它是为对象辅助赋值，转到函数内部我们看到\r\n\r\n```js\r\nif (key in obj) {\r\n  Object.defineProperty(obj, key, {\r\n    value: value,\r\n    enumerable: true,\r\n    configurable: true,\r\n    writable: true\r\n  });\r\n} else {\r\n  obj[key] = value;\r\n}\r\n```\r\n\r\n不过为什么要通过`key in obj`来判断呢，其实下面的`_defineProperties`函数也用到了这一判断，简单来说就是不是`getter/setter`就直接把 value 添加到`Object.defineProperty`的 value 上，否则就直接复制。\r\n\r\n再来看代码最后一句也调用了这个函数为 Foo 静态属性赋值，对应的我们已经走完了对应 class 的静态和实例属性的赋值\r\n\r\n```js\r\nclass Foo {\r\n  static foo = \"Foo\";\r\n  foo = \"foo\";\r\n}\r\n```\r\n\r\n在顺着代码往下看发现调用了`_createClass`函数，同时还把构造函数以及我们的静态方法和实例方法通过数组传递，我们转到`_createClass`函数\r\n\r\n```js\r\nfunction _createClass(Constructor, protoProps, staticProps) {\r\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\r\n  if (staticProps) _defineProperties(Constructor, staticProps);\r\n  return Constructor;\r\n}\r\n```\r\n\r\n这一步就是为构造函数和构造函数的`prototype`属性赋值，再来看`_defineProperties`函数\r\n\r\n```js\r\nfunction _defineProperties(target, props) {\r\n  for (var i = 0; i < props.length; i++) {\r\n    var descriptor = props[i];\r\n    descriptor.enumerable = descriptor.enumerable || false;\r\n    descriptor.configurable = true;\r\n    if (\"value\" in descriptor) descriptor.writable = true;\r\n    Object.defineProperty(target, descriptor.key, descriptor);\r\n  }\r\n}\r\n```\r\n\r\n`_defineProperties`执行的步骤很简单\r\n\r\n1. 遍历数组，取到每次循环的数组下标对象；\r\n2. 为对象添加`enumerable`、`configurable`属性描述符，注意`enumerable`赋值为 false，这样做的原因是类的内部所有定义的方法，都是不可枚举的;\r\n3. 判断 value 存在，如果存在添加`writable`描述属性\r\n4. 通过`Object.defineProperty`为对象赋值\r\n\r\n## 最后\r\n\r\n上面把 class 转化为构造函数讲完了，不过你是否好奇 babel 怎么处理继承的呢？\r\n\r\n下一篇文章[从babel看class(下) ](https://github.com/bosens-China/blog/issues/33)就讲解这一过程，如果喜欢请点赞一下,^\\_^\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/bosens-China/blog/issues/27/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/bosens-China/blog/issues/27/timeline",
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/bosens-China/blog/issues/60",
    "repository_url": "https://api.github.com/repos/bosens-China/blog",
    "labels_url": "https://api.github.com/repos/bosens-China/blog/issues/60/labels{/name}",
    "comments_url": "https://api.github.com/repos/bosens-China/blog/issues/60/comments",
    "events_url": "https://api.github.com/repos/bosens-China/blog/issues/60/events",
    "html_url": "https://github.com/bosens-China/blog/issues/60",
    "id": 647959365,
    "node_id": "MDU6SXNzdWU2NDc5NTkzNjU=",
    "number": 60,
    "title": "模拟实现私有属性",
    "user": {
      "login": "bosens-China",
      "id": 39508895,
      "node_id": "MDQ6VXNlcjM5NTA4ODk1",
      "avatar_url": "https://avatars.githubusercontent.com/u/39508895?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/bosens-China",
      "html_url": "https://github.com/bosens-China",
      "followers_url": "https://api.github.com/users/bosens-China/followers",
      "following_url": "https://api.github.com/users/bosens-China/following{/other_user}",
      "gists_url": "https://api.github.com/users/bosens-China/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/bosens-China/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/bosens-China/subscriptions",
      "organizations_url": "https://api.github.com/users/bosens-China/orgs",
      "repos_url": "https://api.github.com/users/bosens-China/repos",
      "events_url": "https://api.github.com/users/bosens-China/events{/privacy}",
      "received_events_url": "https://api.github.com/users/bosens-China/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [
      {
        "id": 1908144759,
        "node_id": "MDU6TGFiZWwxOTA4MTQ0NzU5",
        "url": "https://api.github.com/repos/bosens-China/blog/labels/ES6%E7%B3%BB%E5%88%97",
        "name": "ES6系列",
        "color": "0366d6",
        "default": false,
        "description": ""
      }
    ],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 0,
    "created_at": "2020-06-30T08:03:39Z",
    "updated_at": "2020-06-30T08:03:39Z",
    "closed_at": null,
    "author_association": "OWNER",
    "active_lock_reason": null,
    "body": "## 前言\r\n\r\n私有属性已经出来很长时间了，目前在`Stage 3`阶段(2020/6/30)日，目前 chrome 浏览器已经支持了，在讲解之前先看看怎么使用\r\n\r\n```js\r\nclass IncreasingCounter {\r\n  #count = 0;\r\n  get value() {\r\n    console.log(\"Getting the current value!\");\r\n    return this.#count;\r\n  }\r\n  increment() {\r\n    this.#count++;\r\n  }\r\n}\r\nconst counter = new IncreasingCounter();\r\ncounter.#count; // 报错\r\ncounter.#count = 42; // 报错\r\n```\r\n\r\n上面代码`#count`是私有属性，只能在类内部使用，在外部使用就会报错，下面就讲讲怎么来模拟实现它。\r\n\r\n## 闭包\r\n\r\n最先想到的就是使用闭包的形式，如果我们在内部调用外部的变量那么根据作用域的查找规则，我们可以在类内部引用它，而在外部永远也不能访问。\r\n\r\n```js\r\nconst IncreasingCounter = (function () {\r\n  let count = 42;\r\n  return class {\r\n    get value() {\r\n      console.log(\"Getting the current value!\");\r\n      return count;\r\n    }\r\n    increment() {\r\n      count++;\r\n    }\r\n  };\r\n})();\r\nconst counter = new IncreasingCounter();\r\ncounter.#count; // 报错\r\ncounter.#count = 42; // 报错\r\n```\r\n\r\n优点：\r\n\r\n- 实现了私有属性，外部无法访问\r\n- 无命名冲突\r\n\r\n缺点：\r\n\r\n- 有额外的构建开销\r\n\r\n## Symbol\r\n\r\nes6 新增了`Symbol`类型，它表示独一无二的值，我们可以利用这个特性模拟私有属性。\r\n\r\n```js\r\nconst IncreasingCounter = (function () {\r\n  const _count = Symbol(\"count\");\r\n  return class {\r\n    get value() {\r\n      console.log(\"Getting the current value!\");\r\n      return this[_count];\r\n    }\r\n    constructor() {\r\n      this[_count] = 42;\r\n    }\r\n    increment() {\r\n      this[_count]++;\r\n    }\r\n  };\r\n})();\r\nconst counter = new IncreasingCounter();\r\ncounter.#count; // 报错\r\ncounter.#count = 42; // 报错\r\n```\r\n\r\n优点：\r\n\r\n- 无命名冲突\r\n- 外部无法访问和修改\r\n- 无性能损失\r\n\r\n缺点：\r\n\r\n- 有兼容性问题\r\n\r\n## WeakMap\r\n\r\n```js\r\nconst IncreasingCounter = (function () {\r\n  const _private = new WeakMap();\r\n  return class {\r\n    get value() {\r\n      console.log(\"Getting the current value!\");\r\n      const value = _private.get(\"count\");\r\n      return value;\r\n    }\r\n    constructor() {\r\n      _private.set(\"count\", 42);\r\n    }\r\n    increment() {\r\n      const value = _private.get(\"count\");\r\n      _private.set(\"count\", ++value);\r\n    }\r\n  };\r\n})();\r\nconst counter = new IncreasingCounter();\r\ncounter.#count; // 报错\r\ncounter.#count = 42; // 报错\r\n```\r\n\r\n优点：\r\n\r\n- 无命名冲突\r\n- 外部无法访问和修改\r\n\r\n缺点：\r\n\r\n- 有兼容性问题\r\n- 有性能上的损失\r\n\r\n## babel 做法\r\n\r\n先直接看 babel 转换后的代码是怎么样的\r\n\r\n```js\r\n\"use strict\";\r\n\r\nfunction _instanceof(left, right) {\r\n  if (\r\n    right != null &&\r\n    typeof Symbol !== \"undefined\" &&\r\n    right[Symbol.hasInstance]\r\n  ) {\r\n    return !!right[Symbol.hasInstance](left);\r\n  } else {\r\n    return left instanceof right;\r\n  }\r\n}\r\n\r\nfunction _classCallCheck(instance, Constructor) {\r\n  if (!_instanceof(instance, Constructor)) {\r\n    throw new TypeError(\"Cannot call a class as a function\");\r\n  }\r\n}\r\n\r\nfunction _defineProperties(target, props) {\r\n  for (var i = 0; i < props.length; i++) {\r\n    var descriptor = props[i];\r\n    descriptor.enumerable = descriptor.enumerable || false;\r\n    descriptor.configurable = true;\r\n    if (\"value\" in descriptor) descriptor.writable = true;\r\n    Object.defineProperty(target, descriptor.key, descriptor);\r\n  }\r\n}\r\n\r\nfunction _createClass(Constructor, protoProps, staticProps) {\r\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\r\n  if (staticProps) _defineProperties(Constructor, staticProps);\r\n  return Constructor;\r\n}\r\n\r\nfunction _classPrivateFieldSet(receiver, privateMap, value) {\r\n  var descriptor = privateMap.get(receiver);\r\n  if (!descriptor) {\r\n    throw new TypeError(\"attempted to set private field on non-instance\");\r\n  }\r\n  if (descriptor.set) {\r\n    descriptor.set.call(receiver, value);\r\n  } else {\r\n    if (!descriptor.writable) {\r\n      throw new TypeError(\"attempted to set read only private field\");\r\n    }\r\n    descriptor.value = value;\r\n  }\r\n  return value;\r\n}\r\n\r\nfunction _classPrivateFieldGet(receiver, privateMap) {\r\n  var descriptor = privateMap.get(receiver);\r\n  if (!descriptor) {\r\n    throw new TypeError(\"attempted to get private field on non-instance\");\r\n  }\r\n  if (descriptor.get) {\r\n    return descriptor.get.call(receiver);\r\n  }\r\n  return descriptor.value;\r\n}\r\n\r\nvar _count = new WeakMap();\r\n\r\nvar IncreasingCounter = /*#__PURE__*/ (function () {\r\n  function IncreasingCounter() {\r\n    _classCallCheck(this, IncreasingCounter);\r\n\r\n    _count.set(this, {\r\n      writable: true,\r\n      value: 0,\r\n    });\r\n  }\r\n\r\n  _createClass(IncreasingCounter, [\r\n    {\r\n      key: \"increment\",\r\n      value: function increment() {\r\n        var _this$count;\r\n\r\n        _classPrivateFieldSet(\r\n          this,\r\n          _count,\r\n          (_this$count = +_classPrivateFieldGet(this, _count)) + 1\r\n        ),\r\n          _this$count;\r\n      },\r\n    },\r\n    {\r\n      key: \"value\",\r\n      get: function get() {\r\n        console.log(\"Getting the current value!\");\r\n        return _classPrivateFieldGet(this, _count);\r\n      },\r\n    },\r\n  ]);\r\n\r\n  return IncreasingCounter;\r\n})();\r\n\r\nvar counter = new IncreasingCounter();\r\ncounter.#count; // 报错\r\ncounter.#count = 42; // 报错\r\n```\r\n\r\n上面的代码，我之前在[从 babel 看 class(上)](https://github.com/bosens-China/blog/issues/27)有讲解过，我们只看私有变量相关的\r\n\r\n```js\r\n\"use strict\";\r\n\r\nfunction _classPrivateFieldSet(receiver, privateMap, value) {\r\n  var descriptor = privateMap.get(receiver);\r\n  if (!descriptor) {\r\n    throw new TypeError(\"attempted to set private field on non-instance\");\r\n  }\r\n  if (descriptor.set) {\r\n    descriptor.set.call(receiver, value);\r\n  } else {\r\n    if (!descriptor.writable) {\r\n      throw new TypeError(\"attempted to set read only private field\");\r\n    }\r\n    descriptor.value = value;\r\n  }\r\n  return value;\r\n}\r\n\r\nfunction _classPrivateFieldGet(receiver, privateMap) {\r\n  var descriptor = privateMap.get(receiver);\r\n  if (!descriptor) {\r\n    throw new TypeError(\"attempted to get private field on non-instance\");\r\n  }\r\n  if (descriptor.get) {\r\n    return descriptor.get.call(receiver);\r\n  }\r\n  return descriptor.value;\r\n}\r\n\r\nvar _count = new WeakMap();\r\n\r\nvar IncreasingCounter = /*#__PURE__*/ (function () {\r\n  function IncreasingCounter() {}\r\n\r\n  _createClass(IncreasingCounter, [\r\n    {\r\n      key: \"increment\",\r\n      value: function increment() {\r\n        var _this$count;\r\n\r\n        _classPrivateFieldSet(\r\n          this,\r\n          _count,\r\n          (_this$count = +_classPrivateFieldGet(this, _count)) + 1\r\n        ),\r\n          _this$count;\r\n      },\r\n    },\r\n    {\r\n      key: \"value\",\r\n      get: function get() {\r\n        console.log(\"Getting the current value!\");\r\n        return _classPrivateFieldGet(this, _count);\r\n      },\r\n    },\r\n  ]);\r\n\r\n  return IncreasingCounter;\r\n})();\r\n\r\nvar counter = new IncreasingCounter();\r\ncounter.#count; // 报错\r\ncounter.#count = 42; // 报错\r\n```\r\n\r\n去除了不必要的代码，`babel`的做法跟我们上述`WeakMap`的做法差不多，不过它多了几步\r\n\r\n1. 每个私有属性都用一个`WeakMap`值存储\r\n2. 赋值和读取值的时候进行检查，`get`和`set`属性存不存在，如果存在就直接调用函数，否则直接赋值或者读取\r\n\r\n上面`babel`的代码多了很多的边界检查，下面模拟写一版伪代码。\r\n\r\n```js\r\nconst IncreasingCounter = (function () {\r\n  const _count = new WeakMap();\r\n  return class {\r\n    // 初始化赋值\r\n    constructor() {\r\n      _count.set(this, {\r\n        writable: true,\r\n        value: 0,\r\n      });\r\n    }\r\n\r\n    get value() {\r\n      const descriptor = _count.get(this);\r\n      if (!descriptor) {\r\n        throw new TypeError(\"attempted to get private field on non-instance\");\r\n      }\r\n      console.log(\"Getting the current value!\");\r\n      return this.descriptor;\r\n    }\r\n    increment() {\r\n      if (!descriptor.writable) {\r\n        throw new TypeError(\"attempted to set read only private field\");\r\n      }\r\n\r\n      if (!descriptor.writable) {\r\n        throw new TypeError(\"attempted to set read only private field\");\r\n      }\r\n      descriptor.value = descriptor.value++;\r\n    }\r\n  };\r\n})();\r\nvar counter = new IncreasingCounter();\r\ncounter.#count; // 报错\r\ncounter.#count = 42; // 报错\r\n```\r\n\r\n到这一步基本上就把私有变量说的差不多了，剩下的说几个比较容易混淆的点\r\n\r\n## 其他\r\n\r\n### 静态私有方法怎么实现的\r\n\r\n静态私有属性实现与私有属性实现没有太多区别，先看一段`babel`的代码\r\n\r\n```js\r\nvar Test = /*#__PURE__*/ (function () {\r\n  function Test() {\r\n    _classCallCheck(this, Test);\r\n  }\r\n\r\n  _createClass(Test, null, [\r\n    {\r\n      key: \"obtain\",\r\n      value: function obtain() {\r\n        _classStaticPrivateMethodGet(Test, Test, _computeRandomNumber).call(\r\n          Test\r\n        );\r\n      },\r\n    },\r\n  ]);\r\n\r\n  return Test;\r\n})();\r\n\r\nvar _computeRandomNumber = function _computeRandomNumber() {\r\n  return _classStaticPrivateFieldSpecGet(Test, Test, _totallyRandomNumber);\r\n};\r\n\r\nvar _totallyRandomNumber = {\r\n  writable: true,\r\n  value: 4,\r\n};\r\nTest.obtain();\r\n```\r\n\r\n`_totallyRandomNumber`是定义静态属性变量信息，`_classStaticPrivateMethodGet`是静态方法相关的调用函数，它的源码也很简单\r\n\r\n```js\r\nfunction _classStaticPrivateMethodGet(receiver, classConstructor, method) {\r\n  if (receiver !== classConstructor) {\r\n    throw new TypeError(\"Private static access of wrong provenance\");\r\n  }\r\n  return method;\r\n}\r\n```\r\n\r\n检查构造函数是否相同，相同返回`method`。\r\n\r\n而`_classStaticPrivateFieldSpecGet`函数做的就是返回`_totallyRandomNumber`变量的信息，源码如下\r\n\r\n```js\r\nfunction _classStaticPrivateFieldSpecGet(\r\n  receiver,\r\n  classConstructor,\r\n  descriptor\r\n) {\r\n  if (receiver !== classConstructor) {\r\n    throw new TypeError(\"Private static access of wrong provenance\");\r\n  }\r\n  if (descriptor.get) {\r\n    return descriptor.get.call(receiver);\r\n  }\r\n  return descriptor.value;\r\n}\r\n```\r\n\r\n结论：\r\n对比私有属性没有太多变化，只是检查从`WeakMap`变成了对比构造函数\r\n\r\n### 继承能使用么？\r\n\r\n嗯。。。答案是不能，因为我试过\r\n\r\n```js\r\nclass Root {\r\n  #foo = 456;\r\n}\r\n\r\nclass Child extends Root {\r\n  getName() {\r\n    return this.#foo;\r\n  }\r\n}\r\nconst value = new Child();\r\nconsole.log(value.getName());\r\n```\r\n\r\n可以在 chrome 尝试下，如果真的想用可以使用`typescript`，而且从`babel`转义的过程来看，子类实际上并没有与父类建立联系出现这种结果也在意料之中了。\r\n\r\n## 最后\r\n\r\n如果有错误或者不严谨的地方，请务必给予指正，十分感谢。如果喜欢或者有所启发，欢迎`star`，对作者也是一种鼓励。\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/bosens-China/blog/issues/60/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/bosens-China/blog/issues/60/timeline",
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/bosens-China/blog/issues/59",
    "repository_url": "https://api.github.com/repos/bosens-China/blog",
    "labels_url": "https://api.github.com/repos/bosens-China/blog/issues/59/labels{/name}",
    "comments_url": "https://api.github.com/repos/bosens-China/blog/issues/59/comments",
    "events_url": "https://api.github.com/repos/bosens-China/blog/issues/59/events",
    "html_url": "https://github.com/bosens-China/blog/issues/59",
    "id": 647201487,
    "node_id": "MDU6SXNzdWU2NDcyMDE0ODc=",
    "number": 59,
    "title": "javascript专题系列之深浅拷贝和extend",
    "user": {
      "login": "bosens-China",
      "id": 39508895,
      "node_id": "MDQ6VXNlcjM5NTA4ODk1",
      "avatar_url": "https://avatars.githubusercontent.com/u/39508895?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/bosens-China",
      "html_url": "https://github.com/bosens-China",
      "followers_url": "https://api.github.com/users/bosens-China/followers",
      "following_url": "https://api.github.com/users/bosens-China/following{/other_user}",
      "gists_url": "https://api.github.com/users/bosens-China/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/bosens-China/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/bosens-China/subscriptions",
      "organizations_url": "https://api.github.com/users/bosens-China/orgs",
      "repos_url": "https://api.github.com/users/bosens-China/repos",
      "events_url": "https://api.github.com/users/bosens-China/events{/privacy}",
      "received_events_url": "https://api.github.com/users/bosens-China/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [
      {
        "id": 1602397157,
        "node_id": "MDU6TGFiZWwxNjAyMzk3MTU3",
        "url": "https://api.github.com/repos/bosens-China/blog/labels/%E4%B8%93%E9%A2%98%E7%9B%B8%E5%85%B3",
        "name": "专题相关",
        "color": "719192",
        "default": false,
        "description": "主要介绍实现的思路"
      }
    ],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 0,
    "created_at": "2020-06-29T07:59:36Z",
    "updated_at": "2020-06-29T08:00:07Z",
    "closed_at": null,
    "author_association": "OWNER",
    "active_lock_reason": null,
    "body": "## 前言\r\n\r\n深浅拷贝和 extend 是项目中常用的工具类函数，今天就动手实现一下\r\n\r\n下面会重复这几个基础函数，为了简洁下面不会出现相关定义\r\n\r\n```js\r\nfunction isObject(obj) {\r\n  return obj && typeof obj === \"object\";\r\n}\r\nfunction type(obj) {\r\n  return Object.prototype.toString\r\n    .call(obj)\r\n    .replace(/\\[object.(.+?)\\]/, \"$1\")\r\n    .toLowerCase();\r\n}\r\nfunction array(par) {\r\n  return type(par) === \"array\";\r\n}\r\n```\r\n\r\n## 浅拷贝用法\r\n\r\n```js\r\nvar obj = { name: \"test\", args: [{ name: 1 }] };\r\nvar test = { ...obj };\r\n// 修改下原来属性\r\nobj.name = \"foo\";\r\n// test.name test\r\nobj.args.push(\"456\");\r\n// args: (2) [{…}, \"456\"]\r\n```\r\n\r\n从上面例子可以看到，当两个对象出现相同字段的时候，后者会覆盖前者，而不会进行深层次的覆盖。\r\n\r\n由此可以得到一个结论：浅拷贝可以简单理解为只拷贝对象的一层属性，如果拷贝的属性还是对象，那么修改它则会影响到拥有相同属性的对象。\r\n\r\n## 浅拷贝实现\r\n\r\n结合上面的结论，我们动手实现一个函数\r\n\r\n```js\r\nexport function copy(obj) {\r\n  if (!isObject(obj)) {\r\n    return;\r\n  }\r\n  const src = array(obj) ? [] : {};\r\n  for (const key in obj) {\r\n    const value = obj[key];\r\n    if (Object.prototype.hasOwnProperty.call(obj, key)) {\r\n      src[key] = value;\r\n    }\r\n  }\r\n  return src;\r\n}\r\n```\r\n\r\n测试用例\r\n\r\n```js\r\ntest(\"浅拷贝\", () => {\r\n  const value = { a: 123, b: 456, c: [1] };\r\n  const test = copy(value);\r\n  expect(test).toEqual({ a: 123, b: 456, c: [1] });\r\n  expect(value === test).toBeFalsy();\r\n  expect(value.c === test.c).toBeTruthy();\r\n  expect(value.a === test.a).toBeTruthy();\r\n});\r\n```\r\n\r\n## 深拷贝\r\n\r\n上面我们已经实现了浅拷贝，浅拷贝只是简单的拷贝了一层属性，如果是深拷贝呢？\r\n\r\n其实就是对属性为对象进行重复的调用，在实现这个之前先看一个比较简单的做法。\r\n\r\n#### json\r\n\r\n```js\r\nfunction deepAssign(par) {\r\n  return JSON.parse(JSON.stringify(par));\r\n}\r\n// 测试用例\r\nconst value = {a: {name: 456}};\r\nconst test = deepAssign({value);\r\ntest.a === value.a;\r\n//false\r\ndeepAssign({ a() {}, b: /abc/, c: Math.floor, d: null, e: new Set() });\r\n// {b: {}, d: null, e: {}}\r\n```\r\n\r\n需要特别注意用这个方法处理函数、正则之类的对象不会出现预期结果，不过在处理接口返回的数据不失为一种方法。\r\n\r\n#### 递归\r\n\r\n相比`JSON`的方式实现，可以让我们自由定制一些类型，例如上面的`正则`就可以通过`hack`方法创建，为了简化源码，这里只处理对象和数组，对于其他类型的处理可以参考一下第三方库\r\n\r\n```js\r\nfunction deepCopy(obj, has = new WeakMap()) {\r\n  if (!isObject(obj)) {\r\n    return;\r\n  }\r\n  // 避免循环引用\r\n  if (has.has(obj)) {\r\n    return has.get(obj);\r\n  }\r\n  const src = array(obj) ? [] : {};\r\n  has.set(obj, src);\r\n  for (const key in obj) {\r\n    const value = obj[key];\r\n    if (Object.prototype.hasOwnProperty.call(obj, key)) {\r\n      // 注意这一行\r\n      src[key] = isObject(value) ? copy(value, has) : value;\r\n    }\r\n  }\r\n  return src;\r\n}\r\n```\r\n\r\n测试用例\r\n\r\n```js\r\ntest(\"深拷贝\", () => {\r\n  const value = { a: 123, b: 456, c: [1] };\r\n  const test = deepCopy(value);\r\n  expect(test).toEqual({ a: 123, b: 456, c: [1] });\r\n  expect(value === test).toBeFalsy();\r\n  expect(value.c === test.c).toBeFalsy();\r\n  expect(value.a === test.a).toBeTruthy();\r\n});\r\n```\r\n\r\n注意上面用了一个`WeakMap`，这个是为了避免循环引入，你可以把上面的`WeakMap`相关代码去掉，然后在控制台输入下面这个例子，看看会出现什么结果。\r\n\r\n```js\r\nvar a = {};\r\na.a = a;\r\nvar test = deepCopy(a);\r\n```\r\n\r\n## extend\r\n\r\nextend 分为两部分:\r\n\r\n1. 浅合并，`Object.assign`就是浅拷贝；\r\n2. 深合并，没有相关的的 api，需要手动实现\r\n\r\n#### 浅合并使用方法\r\n\r\n在实现这个方法之前，我们约定一下格式\r\n\r\n```js\r\nassign( target [, object1 ] [, objectN ] )\r\n```\r\n\r\n第一个参数为目标对象必须是对象，之后的参数是目标对象，可以不为对象\r\n\r\n```js\r\nvar obj1 = {\r\n  a: 1,\r\n  b: { b1: 1, b2: 2 },\r\n};\r\n\r\nvar obj2 = {\r\n  b: { b1: 3, b3: 4 },\r\n  c: 3,\r\n};\r\n\r\nvar obj3 = {\r\n  d: 4,\r\n};\r\n\r\nconsole.log(assign(obj1, obj2, obj3));\r\n\r\n// {\r\n//    a: 1,\r\n//    b: { b1: 3, b3: 4 },\r\n//    c: 3,\r\n//    d: 4\r\n// }\r\n```\r\n\r\n#### 浅合并实现\r\n\r\n根据上面的约束，动手实现一下\r\n\r\n```js\r\nfunction assign() {\r\n  let target = arguments[0];\r\n  let i = 1,\r\n    leg = arguments.length;\r\n  if (!isObject(target)) {\r\n    target = {};\r\n  }\r\n  for (; i < leg; i++) {\r\n    const value = arguments[i];\r\n    if (value == null) {\r\n      continue;\r\n    }\r\n    for (const name in value) {\r\n      if (Object.prototype.hasOwnProperty.call(value, name)) {\r\n        const copy = value[name];\r\n        target[name] = copy;\r\n      }\r\n    }\r\n  }\r\n  return target;\r\n}\r\n```\r\n\r\n测试用例\r\n\r\n```js\r\ntest(\"浅拷贝\", () => {\r\n  const value1 = { name: \"test\", age: 17 };\r\n  const value2 = { name: \"app\", age: [1, 2, 3] };\r\n  const test = assign(value1, value2, null, undefined, \"abc\");\r\n  expect(assign(test)).toEqual({\r\n    name: \"app\",\r\n    age: [1, 2, 3],\r\n    0: \"a\",\r\n    1: \"b\",\r\n    2: \"c\",\r\n  });\r\n  expect(test.age === value2.age).toBeTruthy();\r\n  var obj1 = {\r\n    a: 1,\r\n    b: { b1: 1, b2: 2 },\r\n  };\r\n\r\n  var obj2 = {\r\n    b: { b1: 3, b3: 4 },\r\n    c: 3,\r\n  };\r\n\r\n  var obj3 = {\r\n    d: 4,\r\n  };\r\n  expect(assign(obj1, obj2, obj3)).toEqual({\r\n    a: 1,\r\n    b: { b1: 3, b3: 4 },\r\n    c: 3,\r\n    d: 4,\r\n  });\r\n});\r\n```\r\n\r\n#### 深合并\r\n\r\n```js\r\nfunction deepAssign(...args) {\r\n  let obj = {};\r\n  for (const value of args) {\r\n    if (array(value)) {\r\n      if (!array(obj)) {\r\n        obj = [];\r\n      }\r\n      // 对数组内容进行深拷贝\r\n      const arr = value.reduce((x, y) => {\r\n        x = x.concat(isObject(y) ? deepAssign([], y) : y);\r\n        return x;\r\n      }, []);\r\n      obj = [...obj, ...arr];\r\n    } else if (isObject(value)) {\r\n      for (let [name, val] of Object.entries(value)) {\r\n        if (isObject(val) && name in obj) {\r\n          val = deepAssign(obj[name], val);\r\n        }\r\n        obj = {\r\n          ...obj,\r\n          [name]: val,\r\n        };\r\n      }\r\n    }\r\n  }\r\n  return obj;\r\n}\r\n```\r\n\r\n`if (isObject(val) && name in obj)`注意这行的判断，只有当 target 属性上有值的时候才会进行递归调用。\r\n\r\n测试用例\r\n\r\n```js\r\ntest(\"深合并\", () => {\r\n  const value1 = [1, 2, { name: { age: [1, 2, 3, 4, 5] } }];\r\n  const value2 = [1, 2, { age: 18 }];\r\n  const test = deepAssign(value1, value2);\r\n  expect(test[2] === value1[2]).toBe(false);\r\n  expect(test).toEqual([\r\n    1,\r\n    2,\r\n    { name: { age: [1, 2, 3, 4, 5] } },\r\n    1,\r\n    2,\r\n    { age: 18 },\r\n  ]);\r\n  const obj1 = { name: [1, 2, 3] };\r\n  const obj2 = { age: 17, name: [4, 5, 6] };\r\n  const obj = deepAssign(obj1, obj2);\r\n  expect(obj).toEqual({ name: [1, 2, 3, 4, 5, 6], age: 17 });\r\n  const a = {};\r\n  a.a = a;\r\n  expect(deepAssign(a)).toEqual({ a: { a } });\r\n});\r\n```\r\n\r\n## 最后\r\n\r\n如果有错误或者不严谨的地方，请务必给予指正，十分感谢。如果喜欢或者有所启发，欢迎 `star`，对作者也是一种鼓励。\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/bosens-China/blog/issues/59/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/bosens-China/blog/issues/59/timeline",
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/bosens-China/blog/issues/57",
    "repository_url": "https://api.github.com/repos/bosens-China/blog",
    "labels_url": "https://api.github.com/repos/bosens-China/blog/issues/57/labels{/name}",
    "comments_url": "https://api.github.com/repos/bosens-China/blog/issues/57/comments",
    "events_url": "https://api.github.com/repos/bosens-China/blog/issues/57/events",
    "html_url": "https://github.com/bosens-China/blog/issues/57",
    "id": 643617629,
    "node_id": "MDU6SXNzdWU2NDM2MTc2Mjk=",
    "number": 57,
    "title": "漫谈vue组件设计",
    "user": {
      "login": "bosens-China",
      "id": 39508895,
      "node_id": "MDQ6VXNlcjM5NTA4ODk1",
      "avatar_url": "https://avatars.githubusercontent.com/u/39508895?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/bosens-China",
      "html_url": "https://github.com/bosens-China",
      "followers_url": "https://api.github.com/users/bosens-China/followers",
      "following_url": "https://api.github.com/users/bosens-China/following{/other_user}",
      "gists_url": "https://api.github.com/users/bosens-China/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/bosens-China/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/bosens-China/subscriptions",
      "organizations_url": "https://api.github.com/users/bosens-China/orgs",
      "repos_url": "https://api.github.com/users/bosens-China/repos",
      "events_url": "https://api.github.com/users/bosens-China/events{/privacy}",
      "received_events_url": "https://api.github.com/users/bosens-China/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [
      {
        "id": 1473940161,
        "node_id": "MDU6TGFiZWwxNDczOTQwMTYx",
        "url": "https://api.github.com/repos/bosens-China/blog/labels/Vue%20%E7%9B%B8%E5%85%B3",
        "name": "Vue 相关",
        "color": "42b883",
        "default": false,
        "description": "Vue 相关"
      }
    ],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 0,
    "created_at": "2020-06-23T07:56:00Z",
    "updated_at": "2020-06-23T07:56:00Z",
    "closed_at": null,
    "author_association": "OWNER",
    "active_lock_reason": null,
    "body": "本来标题准备起 vue 组件设计，不过觉得不太好太过于广泛了，下面就以一个实际的例子来谈谈项目中用到的设计思想。\r\n\r\n![bg1](https://user-images.githubusercontent.com/39508895/85376198-fe3fa980-b569-11ea-995c-5a78d6de1282.jpg)\r\n\r\n\r\n这个是一个很传统的级联选择器，在项目中使用大概有三个方面使用\r\n\r\n- 第一个起到搜索作用，比如一个列表的筛选需要选定一定的条件\r\n- 在创建或者编辑的时候使用，例如新建一个列表项\r\n- 单独在某一个场景使用，比如只使用省这一级别\r\n\r\n基于以上两点，直接硬怼肯定不行了，要保证这个组件的足够低耦合同时也要方便自己使用，比如使用的时候肯定期待，只需要放置组件，一些组件的变动交给内部处理。\r\n\r\n> 为了方便讲解所有数据会固定，但是实际中可能数据是通过接口获取的\r\n\r\n## 初步设计想法\r\n![bg2](https://user-images.githubusercontent.com/39508895/85376222-04ce2100-b56a-11ea-83ac-eebfff39bb96.jpg)\r\n\r\n\r\n向上抽离一个组件起到监听的作用，当根组件或者前置组件发生变化的时候，通知到`watch`提醒`watch`通知相关依赖组件，这里就是`市`。\r\n\r\n> 为了代码的精简，这里只展示两级\r\n\r\n回想一下组件的通信，对于这种父子组件可以使用`emit`的方式\r\n不过在这里不行，因为上面举例子说了可能用作新建中。\r\n\r\n也就是说可能是被这样包裹的\r\n\r\n```html\r\n<a-form>\r\n  <watch>\r\n    <a-form-item>\r\n      <省><省 />\r\n    </a-form-item>\r\n    <a-form-item>\r\n      <市><市 />\r\n    </a-form-item>\r\n  </watch>\r\n</a-form>\r\n```\r\n\r\n所以使用父子组件通信不太可行。\r\n不过还是有两种方式的\r\n\r\n- 使用`$parent`、`$children`\r\n\r\n指定已创建的实例之父实例，在两者之间建立父子关系。子实例可以用 `this.$parent` 访问父实例，子实例被推入父实例的 `$children` 数组中。\r\n\r\n- provide / inject\r\n\r\n这对选项需要一起使用，以允许一个祖先组件向其所有子孙后代注入一个依赖，不论组件层次有多深，并在起上下游关系成立的时间里始终生效。\r\n\r\n> 提示：provide 和 inject 绑定并不是可响应的。这是刻意为之的。然而，如果你传入了一个可监听的对象，那么其对象的 property 还是可响应的。\r\n\r\n## 组件实现\r\n\r\n第一种方式的实现就是通过递归来实现，这个实现过程可以通过匹配组件相对应的`name`实现，今天重点用`provide / inject`的方式来实现。\r\n\r\n代码本身不是特别多，直接就贴了\r\n\r\n#### child.vue\r\n\r\n```html\r\n<template>\r\n  <span class=\"cs-child\">\r\n    <select v-bind=\"$attrs\" :value=\"value\" @change=\"change\">\r\n      <option v-for=\"(item, k) of province\" :key=\"k\" :value=\"item\"\r\n        >{{ item }}</option\r\n      >\r\n    </select>\r\n  </span>\r\n</template>\r\n\r\n<script>\r\n  export default {\r\n    props: [\"value\"],\r\n    model: {\r\n      prop: \"value\",\r\n      event: \"change\",\r\n    },\r\n    name: \"cs-child\",\r\n    inject: {\r\n      theme: {\r\n        default: () => undefined,\r\n      },\r\n    },\r\n    data() {\r\n      const province = [\r\n        \"河北省\",\r\n        \"山西省\",\r\n        \"辽宁省\",\r\n        \"吉林省\",\r\n        \"黑龙江省\",\r\n        \"江苏省\",\r\n        \"浙江省\",\r\n        \"安徽省\",\r\n        \"福建省\",\r\n        \"江西省\",\r\n        \"山东省\",\r\n        \"河南省\",\r\n        \"湖北省\",\r\n        \"湖南省\",\r\n        \"广东省\",\r\n        \"海南省\",\r\n        \"四川省\",\r\n        \"贵州省\",\r\n        \"云南省\",\r\n        \"陕西省\",\r\n        \"甘肃省\",\r\n        \"青海省\",\r\n        \"台湾省\",\r\n      ];\r\n      return {\r\n        province,\r\n      };\r\n    },\r\n    methods: {\r\n      change(e) {\r\n        const value = e.target.value;\r\n        this.$emit(\"change\", value);\r\n        this.trigger(value);\r\n      },\r\n      trigger(value = this.value) {\r\n        if (!this.theme) {\r\n          return;\r\n        }\r\n        this.theme.obj = {\r\n          ...this.theme.obj,\r\n          child: value,\r\n        };\r\n        this.theme.$emit(\"change-item\", value);\r\n      },\r\n    },\r\n    // 注意生命周期时机，在依赖组件我们是在created绑定的时间，需要隔离这个事件来触发事件\r\n    mounted() {\r\n      this.trigger();\r\n    },\r\n  };\r\n</script>\r\n```\r\n\r\n#### relyonChild.vue\r\n\r\n```html\r\n<template>\r\n  <span class=\"cs-relyonChild\">\r\n    <select v-bind=\"$attrs\" v-model=\"value\">\r\n      <option v-for=\"(item, k) of list\" :key=\"k\" :value=\"item.value\"\r\n        >{{ item.name }}</option\r\n      >\r\n    </select>\r\n  </span>\r\n</template>\r\n\r\n<script>\r\n  export default {\r\n    name: \"cs-relyonChild\",\r\n    inject: [\"theme\"],\r\n    data() {\r\n      return {\r\n        list: [{ name: 1, value: 1 }],\r\n        value: undefined,\r\n      };\r\n    },\r\n    created() {\r\n      this.theme.$on(\"change-item\", this.change);\r\n    },\r\n    watch: {\r\n      value: {\r\n        handler(value) {\r\n          this.theme.obj = {\r\n            ...this.theme.obj,\r\n            relyonChild: value,\r\n          };\r\n        },\r\n        immediate: true,\r\n      },\r\n    },\r\n    methods: {\r\n      change(value) {\r\n        this.list = new Array(100).fill().map((_item, key) => {\r\n          return {\r\n            name: `${value || \"\"}-${key}`,\r\n            value: key,\r\n          };\r\n        });\r\n        this.value = 0;\r\n      },\r\n    },\r\n  };\r\n</script>\r\n```\r\n\r\n#### watch.vue\r\n\r\n```html\r\n<template>\r\n  <span class=\"cs-watch\">\r\n    <slot></slot>\r\n  </span>\r\n</template>\r\n\r\n<script>\r\n  export default {\r\n    name: \"cs-watch\",\r\n    props: [\"value\"],\r\n    model: {\r\n      prop: \"value\",\r\n      event: \"change\",\r\n    },\r\n    data() {\r\n      return {\r\n        obj: {\r\n          child: undefined,\r\n          relyonChild: undefined,\r\n        },\r\n      };\r\n    },\r\n    watch: {\r\n      obj: {\r\n        handler(value) {\r\n          this.$emit(\"change\", value);\r\n        },\r\n        immediate: true,\r\n      },\r\n    },\r\n    provide() {\r\n      return {\r\n        theme: this,\r\n      };\r\n    },\r\n  };\r\n</script>\r\n```\r\n\r\nOK，整体的代码就放到上面了，需要特别注意两点\r\n\r\n1. inject\r\n\r\n```js\r\n  inject: {\r\n    theme: {\r\n      default: () => undefined\r\n    }\r\n  },\r\n```\r\n\r\n这里之所以使用`default`是为了让`child.vue`可以单独使用，不然控制台会报一个错误。\r\n\r\n2. `$on`、`$emit`绑定时机\r\n\r\n`relyonChild.vue`组件依赖`child.vue`组件，在一个完整的生命周期，我们能拿到 this 的情况最早也是在`created`中，所以`relyonChild.vue`在`created`中绑定了需要监听的事件，而`child.vue`初始化的时候也需要传递一次事件，而这个事件只能晚于`created`，否则会导致`relyonChild.vue`监听不到。\r\n\r\n## 使用方法\r\n\r\n- index.js\r\n\r\n```js\r\nexport { default as child } from \"./child.vue\";\r\nexport { default as watch } from \"./watch.vue\";\r\nexport { default as relyonChild } from \"./relyonChild.vue\";\r\n```\r\n\r\n- App.vue\r\n\r\n```html\r\n<template>\r\n  <div id=\"app\">\r\n    <watch v-model=\"obj\">\r\n      <label>\r\n        <span>省级区域：</span>\r\n        <child v-model=\"item\"></child>\r\n      </label>\r\n      <label>\r\n        <span>子项区域：</span>\r\n        <relyonChild></relyonChild>\r\n      </label>\r\n      <button @click=\"click\">查询</button>\r\n    </watch>\r\n  </div>\r\n</template>\r\n\r\n<script>\r\n  import { watch, child, relyonChild } from \"./components/demo\";\r\n\r\n  export default {\r\n    name: \"App\",\r\n    components: {\r\n      watch,\r\n      child,\r\n      relyonChild,\r\n    },\r\n    data() {\r\n      return {\r\n        item: \"河南省\",\r\n        obj: undefined,\r\n      };\r\n    },\r\n  };\r\n</script>\r\n```\r\n\r\n## 最后\r\n\r\n贴一个预览地址，有什么疑问可以多看几遍，子组件通过绑定`$on`和`$emit`来实现监听与触发\r\n\r\nhttps://codesandbox.io/s/modest-wright-zw7u2?fontsize=14&hidenavigation=1&theme=dark\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/bosens-China/blog/issues/57/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/bosens-China/blog/issues/57/timeline",
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/bosens-China/blog/issues/37",
    "repository_url": "https://api.github.com/repos/bosens-China/blog",
    "labels_url": "https://api.github.com/repos/bosens-China/blog/issues/37/labels{/name}",
    "comments_url": "https://api.github.com/repos/bosens-China/blog/issues/37/comments",
    "events_url": "https://api.github.com/repos/bosens-China/blog/issues/37/events",
    "html_url": "https://github.com/bosens-China/blog/issues/37",
    "id": 522628294,
    "node_id": "MDU6SXNzdWU1MjI2MjgyOTQ=",
    "number": 37,
    "title": "聊一聊处理一张A4纸需要做什么",
    "user": {
      "login": "bosens-China",
      "id": 39508895,
      "node_id": "MDQ6VXNlcjM5NTA4ODk1",
      "avatar_url": "https://avatars.githubusercontent.com/u/39508895?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/bosens-China",
      "html_url": "https://github.com/bosens-China",
      "followers_url": "https://api.github.com/users/bosens-China/followers",
      "following_url": "https://api.github.com/users/bosens-China/following{/other_user}",
      "gists_url": "https://api.github.com/users/bosens-China/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/bosens-China/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/bosens-China/subscriptions",
      "organizations_url": "https://api.github.com/users/bosens-China/orgs",
      "repos_url": "https://api.github.com/users/bosens-China/repos",
      "events_url": "https://api.github.com/users/bosens-China/events{/privacy}",
      "received_events_url": "https://api.github.com/users/bosens-China/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [
      {
        "id": 1371686611,
        "node_id": "MDU6TGFiZWwxMzcxNjg2NjEx",
        "url": "https://api.github.com/repos/bosens-China/blog/labels/%E5%85%B6%E4%BB%96",
        "name": "其他",
        "color": "f6ecbf",
        "default": false,
        "description": "暂定为分享之类的"
      }
    ],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 2,
    "created_at": "2019-11-14T05:09:28Z",
    "updated_at": "2020-06-22T01:20:46Z",
    "closed_at": null,
    "author_association": "OWNER",
    "active_lock_reason": null,
    "body": "说这个是因为最近心血来潮准备写一个A4纸大小的body，方便打印正好顺便补充一下像素的基本概念，就有了这篇文章。\r\n A4 纸张大小（21\\*29.7cm（210mm×297mm））\r\n\r\n## 像素、dpi、英寸\r\n\r\n一张图片的打印出来的实际尺寸是由图片的像素和分辨率共同决定的，像素(Pixel)是指构成图片的小色点，分辨率(单位 DPI)是指每英寸(Inch)上的像素数量，可以看做是这些小色点的分布密度；像素相同时，分辨率越高则像素密度越大，实际打印尺寸越小，图像也越清晰。\r\n\r\n**像素 = 实际尺寸(英寸) \\* 分辨率**\r\n1 英寸=2.54 厘米; 如一张图片际打印宽度为 2 分辨率为 300，那么实际像素：300 \\* 2 = 600 像素。\r\n\r\n## 实现\r\n\r\n目前 js 还没有获取 DPI 相关的方法，所以我们通过 css 和 html 结合获取\r\n\r\n```js\r\nfunction getDip() {\r\n  var tmpNode = document.createElement(\"div\");\r\n  tmpNode.style.cssText =\r\n    \"width:1in;height:1in;position:absolute;left:0px;top:0px;z-index:99;visibility:hidden\";\r\n  document.body.appendChild(tmpNode);\r\n  var x = parseInt(tmpNode.offsetWidth);\r\n  var y = parseInt(tmpNode.offsetHeight);\r\n  tmpNode.parentNode.removeChild(tmpNode);\r\n  return { x: x, y: y };\r\n}\r\n```\r\n\r\n你可能注意到了`1in`这个单位，它代表一英寸，我们获取这个 1 英寸内的所有像素点就知道了 DPI，下面就是换算，这里我写成了一个函数\r\n\r\n```js\r\nfunction getPixel({ x, y } = {}) {\r\n  // 转化为英寸\r\n  const inW = x / 2.54;\r\n  const inH = y / 2.54;\r\n  const dip = getDip();\r\n  return {\r\n    w: inW * dip.x,\r\n    h: inH * dip.y\r\n  };\r\n}\r\n```\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/bosens-China/blog/issues/37/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/bosens-China/blog/issues/37/timeline",
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/bosens-China/blog/issues/56",
    "repository_url": "https://api.github.com/repos/bosens-China/blog",
    "labels_url": "https://api.github.com/repos/bosens-China/blog/issues/56/labels{/name}",
    "comments_url": "https://api.github.com/repos/bosens-China/blog/issues/56/comments",
    "events_url": "https://api.github.com/repos/bosens-China/blog/issues/56/events",
    "html_url": "https://github.com/bosens-China/blog/issues/56",
    "id": 592405354,
    "node_id": "MDU6SXNzdWU1OTI0MDUzNTQ=",
    "number": 56,
    "title": "后台项目总结",
    "user": {
      "login": "bosens-China",
      "id": 39508895,
      "node_id": "MDQ6VXNlcjM5NTA4ODk1",
      "avatar_url": "https://avatars.githubusercontent.com/u/39508895?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/bosens-China",
      "html_url": "https://github.com/bosens-China",
      "followers_url": "https://api.github.com/users/bosens-China/followers",
      "following_url": "https://api.github.com/users/bosens-China/following{/other_user}",
      "gists_url": "https://api.github.com/users/bosens-China/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/bosens-China/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/bosens-China/subscriptions",
      "organizations_url": "https://api.github.com/users/bosens-China/orgs",
      "repos_url": "https://api.github.com/users/bosens-China/repos",
      "events_url": "https://api.github.com/users/bosens-China/events{/privacy}",
      "received_events_url": "https://api.github.com/users/bosens-China/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [
      {
        "id": 1473940161,
        "node_id": "MDU6TGFiZWwxNDczOTQwMTYx",
        "url": "https://api.github.com/repos/bosens-China/blog/labels/Vue%20%E7%9B%B8%E5%85%B3",
        "name": "Vue 相关",
        "color": "42b883",
        "default": false,
        "description": "Vue 相关"
      }
    ],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 0,
    "created_at": "2020-04-02T07:03:45Z",
    "updated_at": "2020-04-02T07:11:46Z",
    "closed_at": null,
    "author_association": "OWNER",
    "active_lock_reason": null,
    "body": "之前在公司主要负责后台项目，就趁着即将离职回顾和总结自己踩过的坑\r\n\r\n## 目录结构\r\n\r\n初始化目录使用的是 `Vue CLI` 生成的，但是默认的目录结构不能满足对项目需求，下面是拓展后的结构\r\n\r\n```sh\r\n├── public                          // 静态页面\r\n├── scripts                         // 相关脚本配置\r\n├── src                             // 主目录\r\n    ├── assets                      // 静态资源\r\n    ├── api                         // 接口信息\r\n    ├── filters                     // 过滤\r\n    ├── lib                         // 全局插件\r\n    ├── router                      // 路由配置\r\n    ├── store                       // vuex 配置\r\n    ├── styles                      // 样式\r\n    ├── utils                       // 工具方法(axios封装，全局方法等)\r\n    ├── views                       // 页面\r\n    ├── App.vue                     // 页面主入口\r\n    ├── main.js                     // 脚本主入口\r\n├── tests                           // 测试用例\r\n├── .editorconfig                   // 编辑相关配置\r\n├── .postcssrc.js                   // postcss 配置\r\n├── babel.config.js                 // preset 记录\r\n├── package.json                    // 依赖\r\n├── .eslintrc.js                    // eslint相关配置\r\n├── README.md                       // 项目 readme\r\n└── vue.config.js                   // webpack 配置\r\n```\r\n\r\n## 权限管理\r\n\r\n一个中大型的后台必然少不了权限的控制，其中`RBAC`模型是需要了解的，更复杂的模型就是在此基础上演化而来的，因为之前写过相关文章，这里就不具体介绍了，可以点击查看[漫谈一下权限设计相关](https://juejin.im/post/5dccadc3e51d45105d5630fb)\r\n\r\n## axios 和 mock\r\n\r\n#### axios\r\n\r\n这里`axios`是重点说的部分，axios 是一个 HTTP 库，可以用在浏览器和 node.js 中，在使用 srr 同构的时候也会经常使用它，下面说一下基本的封装方式，具体情况根据业务调整。\r\n\r\n```js\r\n// utils/config.js\r\nimport http from \"http\";\r\nimport https from \"https\";\r\nimport qs from \"qs\";\r\n\r\nconst axiosConfig = {\r\n  // 注意生产环境下要区分，这里只做演示\r\n  baseURL: \"/mock/\",\r\n  // 请求后的数据处理\r\n  transformResponse: [\r\n    function(data) {\r\n      return data;\r\n    }\r\n  ],\r\n  // 查询对象序列化函数\r\n  paramsSerializer: function(params) {\r\n    return qs.stringify(params);\r\n  },\r\n  // 超时设置\r\n  timeout: 30000,\r\n  // 跨域是否带Token\r\n  withCredentials: true,\r\n  responseType: \"json\",\r\n  // xsrf 设置\r\n  xsrfCookieName: \"XSRF-TOKEN\",\r\n  xsrfHeaderName: \"X-XSRF-TOKEN\",\r\n  // 最多转发数，用于node.js\r\n  maxRedirects: 5,\r\n  // 最大响应数据大小\r\n  maxContentLength: 2000,\r\n  // 自定义错误状态码范围\r\n  validateStatus: function(status) {\r\n    return status >= 200 && status < 300;\r\n  },\r\n  // 用于node.js\r\n  httpAgent: new http.Agent({ keepAlive: true }),\r\n  httpsAgent: new https.Agent({ keepAlive: true })\r\n};\r\n\r\nexport default axiosConfig;\r\n```\r\n\r\n上面定义的是配置文件，之所以不全局调用`axios`或者修改配置的原因是会造成污染，下面还需要对拦截器这块做下处理，取消重复请求（如果有业务代码也可以在里面配置，比如需要统一发送`token`等参数）。\r\n\r\n```js\r\n// utils/api.js\r\nimport axios from \"axios\";\r\nimport config from \"./config\";\r\n\r\n// 取消重复请求\r\nlet pending = [];\r\nconst cancelToken = axios.CancelToken;\r\nconst removePending = config => {\r\n  for (let p in pending) {\r\n    let item = p;\r\n    let list = pending[p];\r\n    // 当前请求在数组中存在时执行函数体\r\n    if (list.url === config.url + \"&request_type=\" + config.method) {\r\n      // 执行取消操作\r\n      list.cancel();\r\n      // 从数组中移除记录\r\n      pending.splice(item, 1);\r\n    }\r\n  }\r\n};\r\n\r\nconst service = axios.create(config);\r\n\r\n// 添加请求拦截器\r\nservice.interceptors.request.use(\r\n  config => {\r\n    removePending(config);\r\n    config.cancelToken = new cancelToken(c => {\r\n      pending.push({\r\n        url: config.url + \"&request_type=\" + config.method,\r\n        cancel: c\r\n      });\r\n    });\r\n    return config;\r\n  },\r\n  error => {\r\n    return Promise.reject(error);\r\n  }\r\n);\r\n\r\n// 返回状态判断(添加响应拦截器)\r\nservice.interceptors.response.use(\r\n  res => {\r\n    removePending(res.config);\r\n    return res;\r\n  },\r\n  error => {\r\n    return Promise.reject(error);\r\n  }\r\n);\r\n\r\nexport default service;\r\n```\r\n\r\nOK，基本封装到这一步就说完了，在具体开发中可以在通过引入`vuex`中`Action`来调用`axios`。\r\n\r\n#### mock\r\n\r\nmock 在前后端开发中很常见，为了解耦与后端之前不必要的等待时间，通过约定文档接口的形式，让前端可以快速开发。\r\n\r\n这里简单说一下如何配置，具体的接口等信息根据业务来调整，首先在`src`创建一个`mock`文件夹，作为 mock 存放的信息，如果业务分为多层记得做好划分，之后通过暴露`index.js`文件，在`src/main.js`中全局引入，下面是一个简单的 demo 例子\r\n\r\n```js\r\n// src/mock/index.js\r\nimport Mock from \"mockjs\";\r\n// 获取 mock.Random 对象\r\nconst Random = Mock.Random;\r\n// 设置异步等待时间\r\nMock.setup({\r\n  timeout: \"200-2000\"\r\n});\r\nconst produceNewsData = function() {\r\n  let newNewsObject = {\r\n    title: Random.ctitle(), //  Random.ctitle( min, max ) 随机产生一个中文标题，长度默认在3-7之间\r\n    content: Random.cparagraph(), // Random.cparagraph(min, max) 随机生成一个中文段落，段落里的句子个数默认3-7个\r\n    createdTime: Random.date() // Random.date()指示生成的日期字符串的格式,默认为yyyy-MM-dd；\r\n  };\r\n\r\n  return newNewsObject;\r\n};\r\n// 随便演示的请求图片\r\nconst demoOther = function() {\r\n  let newsList = [];\r\n  for (let i = 0; i < 20; i++) {\r\n    let newNewsObject = {\r\n      img: Random.dataImage(\"300x250\")\r\n    };\r\n    newsList.push(newNewsObject);\r\n  }\r\n\r\n  return newsList;\r\n};\r\n// 请求这个url就会被mock\r\nMock.mock(\"/mock/user\", produceNewsData);\r\nMock.mock(\"/mock/other\", demoOther);\r\n```\r\n\r\n```js\r\n// src/main.js\r\n// 省略一下其他代码\r\nimport \"./mock\";\r\n```\r\n\r\n上面封装`axios`配置文件`config.js`下填写了`baseURL`，所以可以直接省略`mock`的前缀，注意记得区分开发和生产环境\r\n\r\n## 全局 loading\r\n\r\n先说一下常见的 loading 集中管理方式\r\n\r\n- 手动管理，每个页面引入一个 `loading`，在即将发送的请求的时候展开，请求结束关闭，除了啰嗦和修改麻烦之外没有问题\r\n- 通过一些中间件来完成拦截，例如`dav-loading`\r\n- 通过拦截器拦截，例如`axios`\r\n\r\n这里介绍第三种的具体实现，原因在于是后台项目 loading 实质上只有一种，所以没有必要引入第二种影响划分组件的灵活性。\r\n\r\n实现思路很简单，**借助`api`目录的划分将需要 loading 的接口单独放置在一个文件中，通过`axios`请求、响应拦截器匹配`url`完成显示隐藏 loading**，下面是具体的实现\r\n\r\n```js\r\n// src/utils/app.js\r\nimport axios from \"axios\";\r\nimport config from \"./config\";\r\nimport vue from \"vue\";\r\nimport * as loadingAPI from \"@/api/loading\";\r\n\r\n// 通过这个变化，来提醒loading显示与否\r\nconst state = vue.observable({ content: 0 });\r\n\r\nfunction changeState(config, add = true) {\r\n  const { url } = config;\r\n  const value = Object.values(loadingAPI);\r\n\r\n  if (!value.includes(url)) {\r\n    return;\r\n  }\r\n  if (add) {\r\n    state.content += 1;\r\n    return;\r\n  }\r\n  state.content -= 1;\r\n  return;\r\n}\r\n\r\nconst service = axios.create(config);\r\n\r\n// 添加请求拦截器\r\nservice.interceptors.request.use(\r\n  config => {\r\n    changeState(config);\r\n    return config;\r\n  },\r\n  error => {\r\n    return Promise.reject(error);\r\n  }\r\n);\r\n\r\n// 返回状态判断(添加响应拦截器)\r\nservice.interceptors.response.use(\r\n  res => {\r\n    changeState(res.config, false);\r\n    try {\r\n      const { data } = res;\r\n      Reflect.set(res, \"data\", JSON.parse(data));\r\n    } catch (e) {\r\n      //\r\n    }\r\n    return res;\r\n  },\r\n  error => {\r\n    return Promise.reject(error);\r\n  }\r\n);\r\n// 省略一些代码\r\nexport default service;\r\nexport { state };\r\n```\r\n\r\n借助`vue.observable`生成一个可供组件用于渲染函数和计算属性内的对象，通过改变这个对象内部`content`值来完成 loading 的显示和隐藏， 上面引入的 api 接口就是全部需要管理 loading 的接口地址，这也是上面为什么强调**需要单独划分`api`目录**的原因，之后再页面中引入 `loading`组件 和`state`对象\r\n\r\n```html\r\n<template>\r\n  <div>\r\n    <loading v-model=\"show\" />\r\n    <router-view class=\"router\"></router-view>\r\n  </div>\r\n</template>\r\n\r\n<script>\r\n  import loading from \"./loading\";\r\n  import { state } from \"@/utils/server\";\r\n  export default {\r\n    components: {\r\n      loading\r\n    },\r\n    data: () => ({ state }),\r\n    computed: {\r\n      show() {\r\n        return this.state.content > 0;\r\n      }\r\n    }\r\n  };\r\n</script>\r\n```\r\n\r\n具体 `loading` 组件实现细节这里就跳过了，最后说一下页面的请求直接像正常页面一致即可，例如\r\n\r\n```js\r\nserve.get(user).then(user => {\r\n  this.content = user.data.content;\r\n  this.title = user.data.title;\r\n});\r\n// 一些其他操作不会影响到loading的\r\nPromise.all([serve.get(other)]).then(all => {\r\n  console.log(all);\r\n});\r\n```\r\n\r\n## 虚拟列表\r\n\r\n听名字可能有点不知所然，抛砖引玉之前写项目遇到的一个场景，在后台项目（根据业务）图片管理功能可能经常遇到，后端返回给你一定数量的图片的地址然后你滚动加载这些信息，这段逻辑很简单，不过需要思考这样会不会有性能上的问题？显然会的，当滚动的数量足够多的时候，之前的`dom 节点`一直存在就会造成浏览器的卡顿（吐槽一下知乎的无限滚动）。\r\n\r\n虚拟列表解决的就是类似的场景，用户感知的区域永远是有限的，只需要在需要变化的时候更换展示的数据就可以了，这里贴一下之前写的文章[浅谈一下列表优化](https://juejin.im/post/5d70d2d36fb9a06afe12b799)\r\n\r\n## 路由组件自定义缓存\r\n\r\n一个很常见的场景就是在电商页面中，当你在列表中点击进入详情在返回的时候，列表信息一定是存在没有被清空的，也就是\r\n\r\n主页->列表->详情\r\n\r\n在列表前往详情的时候返回我们显然希望这个页面的信息不回被清空，从列表返回到主页再进入列表，这一过程列表的信息不希望保留，下面就聊聊如何实现\r\n\r\n#### keep-alive\r\n\r\nvue 内置了组件`keep-alive`，它的作用就是缓存组件的信息，在官方指南中它和动态组件结合节省了不必要的渲染，同时它也是可以与`<router-view></router-view>`结合做到缓存路由页面的。\r\n\r\n```html\r\n<keep-alive>\r\n  <router-view></router-view>\r\n</keep-alive>\r\n```\r\n\r\n不过单纯使用和这个只能做到缓存，但是却做不到我们要求的指定某个页面缓存,还有其他方法么？\r\n\r\n其实也是有的可以定义两个`<router-view/>`根据标志来区分是否需要缓存，然后利用`keep-alive`内置组件的`include`属性动态调整就可以实现我们的需求了。\r\n\r\n说的有点抽象了，先看一个例子吧\r\n![1](https://user-gold-cdn.xitu.io/2020/4/2/17139b73cee79220?w=720&h=481&f=gif&s=267987)\r\n\r\n```js\r\n// route\r\n// 省略部分代码\r\n {\r\n      path: \"/keepAlive/\",\r\n      component: keepAlive,\r\n      children: [\r\n        {\r\n          path: \"\",\r\n          component: () =>\r\n            import(/* webpackChunkName: \"keep-alive-home\" */ \"@/view/keep-alive/home\"),\r\n          name: \"keepAlive\",\r\n          meta: {\r\n            depth: 1\r\n          }\r\n        },\r\n        {\r\n          path: \"list\",\r\n          component: () =>\r\n            import(/* webpackChunkName: \"keep-alive-list\" */ \"@/view/keep-alive/list\"),\r\n          name: \"list\",\r\n          meta: {\r\n            name: \"list\",\r\n            keepAlive: true,\r\n            depth: 2\r\n          }\r\n        },\r\n        {\r\n          path: \"details\",\r\n          component: () =>\r\n            import(/* webpackChunkName: \"keep-alive-details\" */ \"@/view/keep-alive/details\"),\r\n          name: \"details\",\r\n          meta: {\r\n            depth: 3\r\n          }\r\n        }\r\n      ]\r\n    },\r\n```\r\n\r\n上面的路由信息`keepAlive`代表是否需要缓存，`depth`代表深度，是我们对比的时候使用，在定义`<router-view/>`的 vue 文件内，通过监听`$route`来实现具体逻辑\r\n\r\n```html\r\n// index.vue\r\n<template>\r\n  <!-- 定义两个出口，一个可以被缓存，一个普通路由 -->\r\n  <div>\r\n    <keep-alive :include=\"include\">\r\n      <router-view v-if=\"$route.meta.keepAlive\"></router-view>\r\n    </keep-alive>\r\n    <router-view v-if=\"!$route.meta.keepAlive\"></router-view>\r\n  </div>\r\n</template>\r\n\r\n<script>\r\n  export default {\r\n    data: () => ({ include: [] }),\r\n    watch: {\r\n      $route(to, from) {\r\n        // 判断进入的情况\r\n        const { keepAlive, name, depth } = to.meta;\r\n        if (keepAlive && !this.include.includes(name)) {\r\n          this.include.push(name);\r\n        }\r\n        // 判断回退的情况\r\n        if (from.meta.keepAlive && from.meta.depth > depth) {\r\n          // 删除\r\n          const index = this.include.indexOf(from.meta.name);\r\n          if (index !== -1) {\r\n            this.include.splice(index, 1);\r\n          }\r\n        }\r\n      }\r\n    }\r\n  };\r\n</script>\r\n```\r\n\r\n这里需要注意一点！\r\n就是做缓存的页面一定要有`name`属性值\r\n\r\n\r\n**include：**\r\n匹配首先检查组件自身的 name 选项，如果 name\r\n选项不可用，则匹配它的局部注册名称 (父组件 components选项的键值)。匿名组件不能被匹配。\r\n\r\n\r\n上述为了方便管理，将组件的 name 属性和路由的`meta`属性做到了一致\r\n\r\n## 最后\r\n\r\n上面演示的例子，放到了我的[仓库](https://github.com/bosens-China/Background-problem-demo)，有兴趣可以 clone 下来自己调试。\r\n\r\n我本人正在求职，如果小伙伴有合适的岗位拜托帮忙内推下，具体简历可以私聊评论我，或者联系我的邮箱`yangboses@gmail.com`\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/bosens-China/blog/issues/56/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/bosens-China/blog/issues/56/timeline",
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/bosens-China/blog/issues/55",
    "repository_url": "https://api.github.com/repos/bosens-China/blog",
    "labels_url": "https://api.github.com/repos/bosens-China/blog/issues/55/labels{/name}",
    "comments_url": "https://api.github.com/repos/bosens-China/blog/issues/55/comments",
    "events_url": "https://api.github.com/repos/bosens-China/blog/issues/55/events",
    "html_url": "https://github.com/bosens-China/blog/issues/55",
    "id": 588235496,
    "node_id": "MDU6SXNzdWU1ODgyMzU0OTY=",
    "number": 55,
    "title": " vueRouter 组件自定义缓存",
    "user": {
      "login": "bosens-China",
      "id": 39508895,
      "node_id": "MDQ6VXNlcjM5NTA4ODk1",
      "avatar_url": "https://avatars.githubusercontent.com/u/39508895?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/bosens-China",
      "html_url": "https://github.com/bosens-China",
      "followers_url": "https://api.github.com/users/bosens-China/followers",
      "following_url": "https://api.github.com/users/bosens-China/following{/other_user}",
      "gists_url": "https://api.github.com/users/bosens-China/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/bosens-China/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/bosens-China/subscriptions",
      "organizations_url": "https://api.github.com/users/bosens-China/orgs",
      "repos_url": "https://api.github.com/users/bosens-China/repos",
      "events_url": "https://api.github.com/users/bosens-China/events{/privacy}",
      "received_events_url": "https://api.github.com/users/bosens-China/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [
      {
        "id": 1935755992,
        "node_id": "MDU6TGFiZWwxOTM1NzU1OTky",
        "url": "https://api.github.com/repos/bosens-China/blog/labels/%E5%BE%85%E5%AE%8C%E6%88%90%E7%B3%BB%E5%88%97",
        "name": "待完成系列",
        "color": "cc6e43",
        "default": false,
        "description": "等待完成系列..."
      }
    ],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 0,
    "created_at": "2020-03-26T08:17:33Z",
    "updated_at": "2020-03-26T08:17:33Z",
    "closed_at": null,
    "author_association": "OWNER",
    "active_lock_reason": null,
    "body": "",
    "reactions": {
      "url": "https://api.github.com/repos/bosens-China/blog/issues/55/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/bosens-China/blog/issues/55/timeline",
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/bosens-China/blog/issues/51",
    "repository_url": "https://api.github.com/repos/bosens-China/blog",
    "labels_url": "https://api.github.com/repos/bosens-China/blog/issues/51/labels{/name}",
    "comments_url": "https://api.github.com/repos/bosens-China/blog/issues/51/comments",
    "events_url": "https://api.github.com/repos/bosens-China/blog/issues/51/events",
    "html_url": "https://github.com/bosens-China/blog/issues/51",
    "id": 566103021,
    "node_id": "MDU6SXNzdWU1NjYxMDMwMjE=",
    "number": 51,
    "title": "基于History实现前端路由",
    "user": {
      "login": "bosens-China",
      "id": 39508895,
      "node_id": "MDQ6VXNlcjM5NTA4ODk1",
      "avatar_url": "https://avatars.githubusercontent.com/u/39508895?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/bosens-China",
      "html_url": "https://github.com/bosens-China",
      "followers_url": "https://api.github.com/users/bosens-China/followers",
      "following_url": "https://api.github.com/users/bosens-China/following{/other_user}",
      "gists_url": "https://api.github.com/users/bosens-China/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/bosens-China/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/bosens-China/subscriptions",
      "organizations_url": "https://api.github.com/users/bosens-China/orgs",
      "repos_url": "https://api.github.com/users/bosens-China/repos",
      "events_url": "https://api.github.com/users/bosens-China/events{/privacy}",
      "received_events_url": "https://api.github.com/users/bosens-China/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [
      {
        "id": 1371686609,
        "node_id": "MDU6TGFiZWwxMzcxNjg2NjA5",
        "url": "https://api.github.com/repos/bosens-China/blog/labels/js%20%E7%9B%B8%E5%85%B3",
        "name": "js 相关",
        "color": "F7DF1E",
        "default": false,
        "description": ""
      }
    ],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 0,
    "created_at": "2020-02-17T07:21:46Z",
    "updated_at": "2020-02-17T07:21:46Z",
    "closed_at": null,
    "author_association": "OWNER",
    "active_lock_reason": null,
    "body": "`History`是 HTML5 新增的标准，对比`hash`它的展示更加优雅，但低版本 ie 还有兼容问题。\r\n\r\n首先`History`表示窗口浏览历史，可以通过`pushState`方法添加历史记录，以及通过`go`方法来实现跳转，还有`popstate`事件可以监听到记录变更。\r\n\r\n下面就来分析实现一个`History路由`的基础是什么\r\n\r\n1. 它需要在变更地址的时候，不会导致文档直接跳转，例如`hash路由`的出现是因为 url 的`hash`变更不会导致文档变化；\r\n2. 需要有事件可以辅助我们监听到这个变化;\r\n\r\n这两个要求`History`都能很好满足，当使用`pushState`方法添加一条记录的时候，只会导致浏览器的地址栏发生变化，但是不会跳转到这个地址，并且浏览器也不会检查这个地址，利用这个特性我们可以实现比较优雅的路由地址，例如`https://xxx.com/a`，`a`就是这个路由地址。\r\n\r\n为了方便理解下面实现的代码，简短介绍一下`pushState`\r\n\r\n#### pushState\r\n\r\n`pushState`方法，它有三个参数\r\n\r\n- 第一个是`state`，表示发生`popstate`事件的时候传递的对象；\r\n- title，当前浏览器已经忽略了，传递`''`就好了；\r\n- 网址，要更改的地址，注意要符合同源政策；\r\n\r\n举个例子，当前网站的根路径是`https://xxx.com`，我们使用`pushState`添加一条记录\r\n\r\n```js\r\nhistory.pushState({ path: \"/abc\" }, \"\", \"/abc\");\r\n```\r\n\r\n当前的网址就是`https://xxx.com/abc`。\r\n\r\n#### popstate\r\n\r\n`pushState`事件触发的条件是用户点击`前进`、`后退`按钮或者调用 `History.back()`、`History.forward()`、`History.go()`方法时才会触发。\r\n\r\n触发事件后有一个`event`对象，它有一个`state`属性，就是对应`pushState`方法的第一个参数。\r\n\r\n更多关于`history`的信息可以查阅[MDN](https://developer.mozilla.org/zh-CN/docs/Web/API/History)\r\n\r\n### history 路由实现\r\n\r\n```js\r\nclass Router {\r\n  constructor() {\r\n    this.routes = new Map();\r\n    this.init();\r\n  }\r\n  change(e) {\r\n    // 防止为null\r\n    const { path } = e.state || {};\r\n    this.implement(path);\r\n  }\r\n  init() {\r\n    window.addEventListener(\"popstate\", this.change.bind(this));\r\n    window.addEventListener(\"load\", () => {\r\n      const { pathname } = location;\r\n      history.replaceState({ path: pathname }, \"\", pathname);\r\n      this.implement(pathname);\r\n    });\r\n  }\r\n  implement(path) {\r\n    if (!this.routes.has(path)) {\r\n      return;\r\n    }\r\n    const fn = this.routes.get(path);\r\n    typeof fn == \"function\" && fn.call(this, path);\r\n  }\r\n  go(num) {\r\n    history.go(num);\r\n  }\r\n  route(state, fn) {\r\n    this.routes.set(state, fn);\r\n  }\r\n  push(state) {\r\n    history.pushState({ path: state }, \"\", state);\r\n    this.implement(state);\r\n  }\r\n  replace(state) {\r\n    history.replaceState({ path: state }, \"\", state);\r\n    this.implement(state);\r\n  }\r\n}\r\n```\r\n\r\n这一块比较简单就不做更多赘述了，唯一一点需要注意的就是页面加载完毕也需要监听一次，这里用了`load事件`。\r\n\r\n### 使用方法\r\n\r\n```html\r\n<ul>\r\n  <li><a href=\"/\">hash1</a></li>\r\n  <li><a href=\"/hash2\">hash2</a></li>\r\n  <li><a href=\"/hash3\">hash3</a></li>\r\n</ul>\r\n<div><button class=\"f\">前进</button> <button class=\"b\">后退</button></div>\r\n```\r\n\r\n```js\r\nconst color = {\r\n  \"/\": \"yellow\",\r\n  \"/hash2\": \"#333\",\r\n  \"/hash3\": \"#DDD\"\r\n};\r\nconst route = new Router();\r\nroute.route(\"/\", function(e) {\r\n  document.body.style.background = color[e];\r\n});\r\nroute.route(\"/hash2\", function(e) {\r\n  document.body.style.background = color[e];\r\n});\r\nroute.route(\"/hash3\", function(e) {\r\n  document.body.style.background = color[e];\r\n});\r\nArray.from(document.links).forEach(fn => {\r\n  fn.addEventListener(\"click\", e => {\r\n    e.preventDefault();\r\n    const href = fn.href;\r\n    const { pathname } = new URL(href);\r\n    route.push(pathname);\r\n  });\r\n});\r\nconst backOff = document.querySelector(\".b\");\r\nconst forward = document.querySelector(\".f\");\r\nbackOff.addEventListener(\"click\", () => route.go(-1));\r\nforward.addEventListener(\"click\", () => route.go(1));\r\n```\r\n\r\n这里注意，我直接屏蔽了`a`链接的默认跳转，这个是防止它直接到其他文档。\r\n\r\n### 最后\r\n\r\n关于前端路由的两种实现，这里就抛砖引玉的讲解完成了，剩下的就是在这个原理上更加完善，例如对 404 页面的处理。\r\n\r\n如果有帮助可以 **star** 一下。\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/bosens-China/blog/issues/51/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/bosens-China/blog/issues/51/timeline",
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/bosens-China/blog/issues/50",
    "repository_url": "https://api.github.com/repos/bosens-China/blog",
    "labels_url": "https://api.github.com/repos/bosens-China/blog/issues/50/labels{/name}",
    "comments_url": "https://api.github.com/repos/bosens-China/blog/issues/50/comments",
    "events_url": "https://api.github.com/repos/bosens-China/blog/issues/50/events",
    "html_url": "https://github.com/bosens-China/blog/issues/50",
    "id": 566035569,
    "node_id": "MDU6SXNzdWU1NjYwMzU1Njk=",
    "number": 50,
    "title": "基于hash实现前端路由",
    "user": {
      "login": "bosens-China",
      "id": 39508895,
      "node_id": "MDQ6VXNlcjM5NTA4ODk1",
      "avatar_url": "https://avatars.githubusercontent.com/u/39508895?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/bosens-China",
      "html_url": "https://github.com/bosens-China",
      "followers_url": "https://api.github.com/users/bosens-China/followers",
      "following_url": "https://api.github.com/users/bosens-China/following{/other_user}",
      "gists_url": "https://api.github.com/users/bosens-China/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/bosens-China/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/bosens-China/subscriptions",
      "organizations_url": "https://api.github.com/users/bosens-China/orgs",
      "repos_url": "https://api.github.com/users/bosens-China/repos",
      "events_url": "https://api.github.com/users/bosens-China/events{/privacy}",
      "received_events_url": "https://api.github.com/users/bosens-China/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [
      {
        "id": 1371686609,
        "node_id": "MDU6TGFiZWwxMzcxNjg2NjA5",
        "url": "https://api.github.com/repos/bosens-China/blog/labels/js%20%E7%9B%B8%E5%85%B3",
        "name": "js 相关",
        "color": "F7DF1E",
        "default": false,
        "description": ""
      }
    ],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 0,
    "created_at": "2020-02-17T03:34:23Z",
    "updated_at": "2020-02-17T03:34:23Z",
    "closed_at": null,
    "author_association": "OWNER",
    "active_lock_reason": null,
    "body": "> 前端路由分为两部分，hash 路由和 History 路由，例如我们常用的 vue-roter 就包含这两部分，这里并不探讨框架是如何进行封装的，而是使用原生的 api 来实现这样一个功能。\r\n\r\n> 预计分为两部分，这里先介绍 hash 路由，实现基本的接受响应和前进后退（为了方便，下面代码不做任何兼容处理）\r\n\r\nhash 指的就是 url 标识符后面`#`号部分的内容（包含#），例如：`https://xxx#abc`这个 url 的 hash 就是`#abc`。\r\n\r\n而 hash 路由就是指接收 hash 的变化更新对应的路由视图，它的优点就是兼容性很好，在 ie 下也能正常工作，不足之处就是`#`这个符号很丑陋。\r\n\r\n### 监听 hash 变化\r\n\r\nwindow 对象上有`hashchange`事件可以监听到 hash 的变化，我们先拿来用用，看看好不好用。\r\n\r\n```js\r\nclass Router {\r\n  constructor() {\r\n    this.hash = new Map();\r\n    this.change = () => {\r\n      const href = this.getHash();\r\n      this.move(href);\r\n    };\r\n    window.addEventListener(\"hashchange\", this.change);\r\n  }\r\n  route(href, fn) {\r\n    this.hash.set(href, fn);\r\n  }\r\n  move(href) {\r\n    if (!this.hash.has(href)) {\r\n      return false;\r\n    }\r\n    const fn = this.hash.get(href);\r\n    if (typeof fn == \"function\") {\r\n      fn.call(this, href);\r\n    }\r\n    return true;\r\n  }\r\n  getHash() {\r\n    return location.hash ? location.hash.slice(1) : \"/\";\r\n  }\r\n}\r\n```\r\n\r\n#### 使用方法\r\n\r\n```js\r\nconst color = {\r\n  hash1: \"#333\",\r\n  hash2: \"#666\",\r\n  hash3: \"#DDD\"\r\n};\r\nconst route = new Router();\r\nroute.route(\"hash1\", function(e) {\r\n  document.body.style.background = color[e];\r\n});\r\nroute.route(\"hash2\", function(e) {\r\n  document.body.style.background = color[e];\r\n});\r\nroute.route(\"hash3\", function(e) {\r\n  document.body.style.background = color[e];\r\n});\r\n```\r\n\r\n这里已经实现了 hash 响应了，不过还是有一个问题就是如果点击 hash 之后刷新浏览器，对应的回调函数并不会执行，所以我们还需要浏览器加载完成后响应对应的回调函数，修订这个问题很简单监听 load 事件即可。\r\n\r\n```js\r\n// 省略其他代码\r\nconstructor() {\r\n    window.addEventListener('load', this.change);\r\n    window.addEventListener(\"hashchange\", this.change);\r\n  }\r\n```\r\n\r\n### 后退功能\r\n\r\n上面完成了基础功能，下面对这个代码进行改造，首先新增一个后退处理。\r\n\r\n实现的思路是新增一个`history`数组来储存变化的 hash，并且创建一个指针，在后退的时候移动指针变化，同时触发对应的函数。\r\n\r\n```js\r\nclass Router {\r\n  constructor() {\r\n    this.hash = new Map();\r\n    // 储存hash变化的数组\r\n    this.history = [];\r\n    // 指针\r\n    this.pointer = this.history.length - 1;\r\n    this.change = () => {\r\n      const href = this.getHash();\r\n      if (!this.move(href)) {\r\n        return console.error(`hash路由${href}无对应处理函数`);\r\n      }\r\n      // 在路由发生变化的时候，同时对history添加，和移动指针\r\n      this.history.push(href);\r\n      this.pointer++;\r\n    };\r\n    // 后退\r\n    this.backOff = () => {\r\n      // 数组下表不能负\r\n      if (this.pointer <= 0) {\r\n        this.pointer = 0;\r\n      } else {\r\n        // 移动下标\r\n        this.pointer -= 1;\r\n      }\r\n      // 读取对应的值，移动hash\r\n      const href = this.history[this.pointer];\r\n      console.log(href, this.pointer, this.history);\r\n      this.setHash(href);\r\n      this.move(href);\r\n    };\r\n    window.addEventListener(\"load\", this.change);\r\n    window.addEventListener(\"hashchange\", this.change);\r\n  }\r\n  route(href, fn) {\r\n    this.hash.set(href, fn);\r\n  }\r\n  move(href) {\r\n    if (!this.hash.has(href)) {\r\n      return false;\r\n    }\r\n    const fn = this.hash.get(href);\r\n    if (typeof fn == \"function\") {\r\n      fn.call(this, href);\r\n    }\r\n    return true;\r\n  }\r\n  getHash() {\r\n    // 过滤掉'#'\r\n    return location.hash ? location.hash.slice(1) : \"/\";\r\n  }\r\n  setHash(href) {\r\n    if (!href) {\r\n      return;\r\n    }\r\n    if (!/^/.test(href)) {\r\n      href = `#${href}`;\r\n    }\r\n    location.hash = href;\r\n  }\r\n}\r\n```\r\n\r\n上面看似实现了后退功能，不过仔细观察上面的代码，我们会发现这样实现是有问题的\r\n\r\n1. 回调函数被执行两次；\r\n2. `history`数组记录的 hash 不对，因为后退是不需要记录的；\r\n\r\n下面来修正这两个问题。\r\n\r\n```js\r\nclass Router {\r\n  constructor() {\r\n    this.hash = new Map();\r\n    // 储存hash变化的数组\r\n    this.history = [];\r\n    // 指针\r\n    this.pointer = this.history.length - 1;\r\n    // 是否后退，默认给false\r\n    this.isBackOff = false;\r\n    this.change = () => {\r\n      const href = this.getHash();\r\n      if (!this.hash.has(href)) {\r\n        return console.error(`hash路由${href}无对应处理函数`);\r\n      }\r\n      if (!this.isBackOff) {\r\n        // 看一下指针长度对不对，如果多余就截取掉\r\n        if (this.pointer < this.history.length - 1) {\r\n          this.history = this.history.slice(0, this.pointer + 1);\r\n        }\r\n        // 在路由发生变化的时候，同时对history添加，和移动指针\r\n        this.history.push(href);\r\n        this.pointer++;\r\n      }\r\n      this.move(href);\r\n      this.isBackOff = false;\r\n    };\r\n    // 后退\r\n    this.backOff = () => {\r\n      this.isBackOff = true;\r\n      // 数组下表不能负\r\n      if (this.pointer <= 0) {\r\n        this.pointer = 0;\r\n      } else {\r\n        // 移动下标\r\n        this.pointer -= 1;\r\n      }\r\n      // 读取对应的值，移动hash\r\n      const href = this.history[this.pointer];\r\n      console.log(href, this.pointer, this.history);\r\n      this.setHash(href);\r\n    };\r\n    window.addEventListener(\"load\", this.change);\r\n    window.addEventListener(\"hashchange\", this.change);\r\n  }\r\n  route(href, fn) {\r\n    this.hash.set(href, fn);\r\n  }\r\n  move(href) {\r\n    const fn = this.hash.get(href);\r\n    if (typeof fn == \"function\") {\r\n      fn.call(this, href);\r\n    }\r\n  }\r\n  getHash() {\r\n    // 过滤掉'#'\r\n    return location.hash ? location.hash.slice(1) : \"/\";\r\n  }\r\n  setHash(href) {\r\n    if (!href) {\r\n      return;\r\n    }\r\n    if (!/^/.test(href)) {\r\n      href = `#${href}`;\r\n    }\r\n    location.hash = href;\r\n  }\r\n}\r\n```\r\n\r\n借助变量`isBackOff`来控制，如果是后退只执行回调函数，当正常操作的时候新增`history`数据，同时清楚多余数组，前进跟后退类似，下面就来实现它。\r\n\r\n### 前进\r\n\r\n思路跟后退的一致，借助变量来进行控制，定义一个前进方法。\r\n\r\n```js\r\nclass Router {\r\n  constructor() {\r\n    this.hash = new Map();\r\n    // 储存hash变化的数组\r\n    this.history = [];\r\n    // 指针\r\n    this.pointer = this.history.length - 1;\r\n    // 是否后退，默认给false\r\n    this.isBackOff = false;\r\n    // 前进标识\r\n    this.isForward = false;\r\n    this.change = () => {\r\n      const href = this.getHash();\r\n      if (!this.hash.has(href)) {\r\n        return console.error(`hash路由${href}无对应处理函数`);\r\n      }\r\n      if (!this.isBackOff && !this.isForward) {\r\n        // 看一下指针长度对不对，如果多余就截取掉\r\n        if (this.pointer < this.history.length - 1) {\r\n          this.history = this.history.slice(0, this.pointer + 1);\r\n        }\r\n        // 在路由发生变化的时候，同时对history添加，和移动指针\r\n        this.history.push(href);\r\n        this.pointer++;\r\n      }\r\n      this.move(href);\r\n      this.isBackOff = false;\r\n      this.isForward = false;\r\n    };\r\n    // 后退\r\n    this.backOff = () => {\r\n      this.isBackOff = true;\r\n      // 数组下表不能负\r\n      if (this.pointer <= 0) {\r\n        this.pointer = 0;\r\n      } else {\r\n        // 移动下标\r\n        this.pointer -= 1;\r\n      }\r\n      // 读取对应的值，移动hash\r\n      const href = this.history[this.pointer];\r\n      console.log(href, this.pointer, this.history);\r\n      this.setHash(href);\r\n    };\r\n    // 前进\r\n    this.forward = () => {\r\n      this.isForward = true;\r\n      // 数组下表不能负\r\n      if (this.pointer >= this.history.length - 1) {\r\n        this.pointer = this.history.length - 1;\r\n      } else {\r\n        // 移动下标\r\n        this.pointer += 1;\r\n      }\r\n      // 读取对应的值，移动hash\r\n      const href = this.history[this.pointer];\r\n      console.log(`前进${href}`, this.pointer, this.history);\r\n      this.setHash(href);\r\n    };\r\n    window.addEventListener(\"load\", this.change);\r\n    window.addEventListener(\"hashchange\", this.change);\r\n  }\r\n  route(href, fn) {\r\n    this.hash.set(href, fn);\r\n  }\r\n  move(href) {\r\n    const fn = this.hash.get(href);\r\n    if (typeof fn == \"function\") {\r\n      fn.call(this, href);\r\n    }\r\n  }\r\n  getHash() {\r\n    // 过滤掉'#'\r\n    return location.hash ? location.hash.slice(1) : \"/\";\r\n  }\r\n  setHash(href) {\r\n    if (!href) {\r\n      return;\r\n    }\r\n    if (!/^/.test(href)) {\r\n      href = `#${href}`;\r\n    }\r\n    location.hash = href;\r\n  }\r\n}\r\n```\r\n\r\n跟后退对比，实质上也只是把后退指针改成前进了，如果想要实现`go`跳转的功能也跟前进、后退思路一样。\r\n\r\n### 使用方法\r\n\r\n```html\r\n<ul>\r\n  <li><a href=\"#hash1\">hash1</a></li>\r\n  <li><a href=\"#hash2\">hash2</a></li>\r\n  <li><a href=\"#hash3\">hash3</a></li>\r\n</ul>\r\n<div><button class=\"f\">前进</button> <button class=\"b\">后退</button></div>\r\n1\r\n```\r\n\r\n```js\r\nconst color = {\r\n  hash1: \"#333\",\r\n  hash2: \"#666\",\r\n  hash3: \"#DDD\"\r\n};\r\nconst route = new Router();\r\nroute.route(\"hash1\", function(e) {\r\n  document.body.style.background = color[e];\r\n});\r\nroute.route(\"hash2\", function(e) {\r\n  document.body.style.background = color[e];\r\n});\r\nroute.route(\"hash3\", function(e) {\r\n  document.body.style.background = color[e];\r\n});\r\nconst backOff = document.querySelector(\".b\");\r\nconst forward = document.querySelector(\".f\");\r\nbackOff.addEventListener(\"click\", route.backOff);\r\nforward.addEventListener(\"click\", route.forward);\r\n```\r\n\r\n### 最后\r\n\r\n这里实现了 hash 路由的`响应变化`和`前进`、`后退`、`404` 的功能，但是还有很多地方需要完善，比如`go`跳转。\r\n\r\n下一节将介绍 `History 路由的实现`，如果喜欢请点击一下 **star**\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/bosens-China/blog/issues/50/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/bosens-China/blog/issues/50/timeline",
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/bosens-China/blog/issues/49",
    "repository_url": "https://api.github.com/repos/bosens-China/blog",
    "labels_url": "https://api.github.com/repos/bosens-China/blog/issues/49/labels{/name}",
    "comments_url": "https://api.github.com/repos/bosens-China/blog/issues/49/comments",
    "events_url": "https://api.github.com/repos/bosens-China/blog/issues/49/events",
    "html_url": "https://github.com/bosens-China/blog/issues/49",
    "id": 548743305,
    "node_id": "MDU6SXNzdWU1NDg3NDMzMDU=",
    "number": 49,
    "title": "使用GitHub Actions完成定时构建应用",
    "user": {
      "login": "bosens-China",
      "id": 39508895,
      "node_id": "MDQ6VXNlcjM5NTA4ODk1",
      "avatar_url": "https://avatars.githubusercontent.com/u/39508895?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/bosens-China",
      "html_url": "https://github.com/bosens-China",
      "followers_url": "https://api.github.com/users/bosens-China/followers",
      "following_url": "https://api.github.com/users/bosens-China/following{/other_user}",
      "gists_url": "https://api.github.com/users/bosens-China/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/bosens-China/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/bosens-China/subscriptions",
      "organizations_url": "https://api.github.com/users/bosens-China/orgs",
      "repos_url": "https://api.github.com/users/bosens-China/repos",
      "events_url": "https://api.github.com/users/bosens-China/events{/privacy}",
      "received_events_url": "https://api.github.com/users/bosens-China/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [
      {
        "id": 1371686611,
        "node_id": "MDU6TGFiZWwxMzcxNjg2NjEx",
        "url": "https://api.github.com/repos/bosens-China/blog/labels/%E5%85%B6%E4%BB%96",
        "name": "其他",
        "color": "f6ecbf",
        "default": false,
        "description": "暂定为分享之类的"
      }
    ],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 0,
    "created_at": "2020-01-13T07:07:52Z",
    "updated_at": "2020-01-13T08:05:56Z",
    "closed_at": null,
    "author_association": "OWNER",
    "active_lock_reason": null,
    "body": "写这篇文章是无意之间看到阮一峰老师发布的[GitHub Actions 入门教程](http://www.ruanyifeng.com/blog/2019/09/getting-started-with-github-actions.html)里面介绍了 GitHub Actions 的一些概念，碰巧我之前用爬虫 + vuePress 构件了一个[typescript 的中文手册](https://bosens-china.github.io/Typescript-manual/)，下面就以每天定时构建这个应用为背景介绍如何使用 GitHub Actions 完成下面工作。\r\n\r\n下面内容主要以实践为主。\r\n\r\n## 思路\r\n\r\n1. 编写 bash 上传脚本\r\n2. 执行爬虫命令构建应用；\r\n3. 定时执行脚本，完成上传\r\n4. 出现错误发送邮件通知我；\r\n\r\n### deploy.sh\r\n\r\n```sh\r\n#!/usr/bin/env sh\r\n\r\n# 确保脚本抛出遇到的错误\r\nset -e\r\n# 下面是脚本命令，根据你的需求来选取。\r\nnpm run xxxx\r\n# 进入生成的文件夹\r\ncd docs/.vuepress/dist\r\ngit init\r\ngit add -A\r\ngit commit -m 'deploy'\r\n# 强制推送到指定分支\r\ngit push -f git@github.com:bosens-China/Typescript-manual.git master:gh-pages\r\ncd -\r\n```\r\n\r\n脚本执行的功能很简单，执行构建命令，之后进入构建的文件夹创建 git 仓库之后推送，这里需要注意一点的就是我们会将任务放置在`GitHub Actions`上，**而 git 推送是需要权限的**，下面就来解决和这个问题。\r\n\r\n###  ssh-keygen\r\n\r\n运行\r\n\r\n```sh\r\nssh-keygen\r\n```\r\n\r\n创建`id_rsa`和`id_rsa.pub`两个文件，分别对应私钥文件和公钥文件。\r\n\r\n之后将`id_rsa.pub`中的公钥添加到 Github 对应仓库的 Deploye keys 中\r\n![xx](https://user-gold-cdn.xitu.io/2020/1/13/16f9deb5aa175f0f?w=800&h=439&f=png&s=121430)\r\n再将`id_rsa`的私钥文件添加到 Github 对应仓库的 Secrets 中，这里将名称定义为`ACTION_DEPLOY_KEY`，你可以自行定义，目的就是为了让虚拟机拥有 git 仓库的权限\r\n![xx](https://user-gold-cdn.xitu.io/2020/1/13/16f9deb52f7e5467?w=800&h=389&f=png&s=121131)\r\n\r\nOK，到这一步我们得准备工作就基本上完成了，下面就是对 yml 配置文件的编写了。\r\n\r\n### deploy.yml\r\n\r\n我们在根目录新建一个`.github`的文件夹在文件夹内新建一个文件`deploy.yml`\r\n\r\n```sh\r\n# 触发的事件\r\non:\r\n  push:\r\n    branches:\r\n      - master\r\n# 定时任务在utc的9点执行，换算北京时间需要 + 8也就是凌晨五点\r\n  schedule:\r\n    - cron: \"0 21 * * *\"\r\n\r\njobs:\r\n  build:\r\n    runs-on: ubuntu-18.04\r\n\r\n    strategy:\r\n      matrix:\r\n        node-version: [12.x]\r\n\r\n    steps:\r\n      - uses: actions/checkout@v1\r\n      - name: Use Node.js ${{ matrix.node-version }}\r\n        uses: actions/setup-node@v1\r\n        with:\r\n          node-version: ${{ matrix.node-version }}\r\n      - name: git Actions\r\n        uses: srt32/git-actions@v0.0.3\r\n      - name: Setup\r\n        env:\r\n          ACTION_DEPLOY_KEY: ${{ secrets.ACTION_DEPLOY_KEY }}\r\n        run: |\r\n          mkdir -p ~/.ssh/\r\n          echo \"$ACTION_DEPLOY_KEY\" > ~/.ssh/id_rsa\r\n          chmod 600 ~/.ssh/id_rsa\r\n          ssh-keyscan github.com >> ~/.ssh/known_hosts\r\n          git config --global user.email \"你的邮箱\"\r\n          git config --global user.name \"你的名字\"\r\n          npm install\r\n          npm run updata\r\n```\r\n\r\n简单说下上面脚本干了什么事情。\r\n\r\n1. 拉取源码（actions/checkout@v1）\r\n2. 安装 node 和 git（actions/setup-node@v1 和 srt32/git-actions@v0.0.3）\r\n3. 将我们的私匙放置在.ssh 目录下（Setup）\r\n4. 执行`deploy.sh`脚本，上述的最后指定的 npm run updata 值就是`bash deploy.sh`\r\n\r\n在上面我指定了 on 它是触发的事件，我在这里指定了每天定时和`master`分支提交的时候执行这段脚本；\r\n\r\n`jobs`则是动作，动作可以有很多 build 就是一个动作，需要特别注意一点**runs-on: ubuntu-18.04**的值是指定虚拟机这个字段是必填的，不建议使用`windows`虚拟机。\r\n\r\n至于上面的`uses`字段，这个是官方提供的模块，你可以这样理解，它可以方便我们的操作，你也可以自己编写脚本之后上传到 github 的市场上，更多的内容我推荐到[官方文档上查阅](https://github.com/features/actions)\r\n\r\n### 执行错误邮件通知\r\n\r\n因为上面说这个是爬虫的应用，为了知道错误我需要邮件及时通知我，这里就使用第三方`nodemailer`的模块为例。\r\n\r\n```js\r\nfunction sendMail(e) {\r\n  const mailTransport = nodemailer.createTransport({\r\n    host: \"smtp.qq.com\",\r\n    secureConnection: true,\r\n    auth: {\r\n      user: \"xxx@qq.com\",\r\n      pass: \"vbwjzecplhehibed\"\r\n    }\r\n  });\r\n  const options = {\r\n    from: \"xxxx@qq.com\",\r\n    to: \"xxx@qq.com\",\r\n    subject: \"typescript-book出现错误\",\r\n    text: e instanceof Error ? e.message : e\r\n  };\r\n  mailTransport.sendMail(options);\r\n}\r\n```\r\n\r\n稍微注意一下`auth`字段，有一个 pass 这个本来是密码不过如果直接把密码暴露出来可能会造成不安全，所以也支持授权码，如果你想了解更多可以[什么是授权码，它又是如何设置？](https://link.jianshu.com/?t=http%3A%2F%2Fservice.mail.qq.com%2Fcgi-bin%2Fhelp%3Fsubtype%3D1%26%26no%3D1001256%26%26id%3D28)点击了解。\r\n\r\n最后你需要为邮箱开通`SMTP服务`，qq 邮箱直接点开设置查找就行了，其他邮箱也类似。\r\n之后再调用这个函数就 OK 了。\r\n\r\n### 查看效果\r\n\r\n上面写完后我们的定时发布脚本就完成了，剩下的就是提交代码触发钩子来执行我们的任务，这里我 push`master`分支代码，打开 actions\r\n![xx](https://user-gold-cdn.xitu.io/2020/1/13/16f9ded560ff8454?w=1920&h=937&f=png&s=62950)\r\n\r\n右侧就是我们脚本的执行次数和状态了，√ 表示成功，你可以详细点开查看更多的细节，例如下面的错误，你可以展开查看报错的原因是什么，方便对错误定位和调试，这里不做展开了。\r\n\r\n## 最后\r\n\r\n这篇文章写完发现更多是分享我怎么完成的，希望对你有所帮助，如果喜欢请给一下 Star\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/bosens-China/blog/issues/49/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/bosens-China/blog/issues/49/timeline",
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/bosens-China/blog/issues/48",
    "repository_url": "https://api.github.com/repos/bosens-China/blog",
    "labels_url": "https://api.github.com/repos/bosens-China/blog/issues/48/labels{/name}",
    "comments_url": "https://api.github.com/repos/bosens-China/blog/issues/48/comments",
    "events_url": "https://api.github.com/repos/bosens-China/blog/issues/48/events",
    "html_url": "https://github.com/bosens-China/blog/issues/48",
    "id": 548738832,
    "node_id": "MDU6SXNzdWU1NDg3Mzg4MzI=",
    "number": 48,
    "title": "如何优雅处理图片异常",
    "user": {
      "login": "bosens-China",
      "id": 39508895,
      "node_id": "MDQ6VXNlcjM5NTA4ODk1",
      "avatar_url": "https://avatars.githubusercontent.com/u/39508895?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/bosens-China",
      "html_url": "https://github.com/bosens-China",
      "followers_url": "https://api.github.com/users/bosens-China/followers",
      "following_url": "https://api.github.com/users/bosens-China/following{/other_user}",
      "gists_url": "https://api.github.com/users/bosens-China/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/bosens-China/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/bosens-China/subscriptions",
      "organizations_url": "https://api.github.com/users/bosens-China/orgs",
      "repos_url": "https://api.github.com/users/bosens-China/repos",
      "events_url": "https://api.github.com/users/bosens-China/events{/privacy}",
      "received_events_url": "https://api.github.com/users/bosens-China/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [
      {
        "id": 1371686609,
        "node_id": "MDU6TGFiZWwxMzcxNjg2NjA5",
        "url": "https://api.github.com/repos/bosens-China/blog/labels/js%20%E7%9B%B8%E5%85%B3",
        "name": "js 相关",
        "color": "F7DF1E",
        "default": false,
        "description": ""
      }
    ],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 0,
    "created_at": "2020-01-13T06:54:18Z",
    "updated_at": "2020-01-13T06:54:18Z",
    "closed_at": null,
    "author_association": "OWNER",
    "active_lock_reason": null,
    "body": "## 前言\r\n\r\n不同浏览器对加载失败图片的图标展示不统一，所以给定一个默认的失败图片就尤为重要。\r\n\r\n正好前几天处理了一下公司首页图片 error 默认图片的问题，就趁着记忆没有消失分享一下这篇文章。\r\n\r\n## error\r\n\r\nimg 标签有一个 error 事件，通过它我们可以捕捉到异常，使用起来也很简单\r\n\r\n```html\r\n<img src=\"abc.xxx\" alt=\"xxx\" class=\"cs-img\" />\r\n```\r\n\r\n```js\r\n<img src=\"abc.xxx\" alt=\"xxx\" class=\"cs-img\" onerror=\"this.src = 'xxxx.png'\" />;\r\n// 或者\r\nvar img = document.querySelector(\".cs-img\");\r\nimg.addEventListener(\"error\", function(e) {\r\n  e.target.src = \"xxxx.png\";\r\n});\r\n```\r\n\r\n## 全局\r\n\r\n上面的方法没有问题，不过需要我们手动管理图片这样写的话维护成本可能很高，有可能你只是想为图片失败统一处理。\r\n\r\n我们希望可以统一监听到`error`的事件来完成，不过图片的`error`处于事件模型的第二阶段也就是目标阶段，是不会向上冒泡的，但是也是可以通过`window.addEventListener.error`来完成监听。\r\n\r\n> 顺便说下`window.addEventListener.error`不仅可以监听到图片的失败也可以监听到 `css,js` 之类加载错误，注意区分`window.onerror`和`window.addEventListener.error`之间的区别，前者是 js 运行错误，后者是资源错误，对于事件模型网上的例子很多，这里不做展开来说了。\r\n\r\n来看下如何用\r\n\r\n```js\r\nwindow.addEventListener(\r\n  \"error\",\r\n  function(event) {\r\n    var dom = event.target;\r\n    if (/img/i.test(dom.nodeName)) {\r\n      dom.src = \"xxxx.png\";\r\n    }\r\n  },\r\n  true\r\n);\r\n```\r\n\r\n注意 `addEventListener` 第二个参数必须是 `true`，默认为 `false`，表示只在冒泡阶段出发，但是上面我们说过图片的 error 事件并不会向上冒泡所以是不会捕捉到的。\r\n\r\n## 重试次数\r\n\r\n上面的代码没有考虑到备选`src`也会失效的问题，如果备选`src`失效就会导致图片无限重试，下面就抛砖引玉写一种方法。\r\n\r\n```js\r\nwindow.addEventListener(\r\n  \"error\",\r\n  function(event) {\r\n    var dom = event.target;\r\n    if (!/img/i.test(dom.nodeName)) {\r\n      return;\r\n    }\r\n    // 不存在返回null\r\n    var retry = +dom.getAttribute(\"data-retry\");\r\n    if (retry >= 3) {\r\n      // 绝对安全的图片\r\n      dom.src =\r\n        \"data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7\";\r\n    } else {\r\n      dom.src = \"xxxx.png\";\r\n      dom.setAttribute(\"data-retry\", (retry += 1));\r\n    }\r\n  },\r\n  true\r\n);\r\n```\r\n\r\n## 动态填充\r\n\r\n最后分享一个动态模板渲染出来的网页(例如，网页的内容是从后台的编辑器 html 直接插入的)如何监听`error`，如果不考虑兼容问题可以在`head`使用`window.addEventListener.error`方法，但是如果需要兼容性很高不妨试试下面这种。\r\n\r\n```js\r\nconst img = Array.prototype.slice.call(document.images);\r\nfor (let i = 0; i < img.length; i++) {\r\n  var dom = img[i];\r\n  const image = document.createElement(\"img\");\r\n  image.src = dom.src;\r\n  image.style.display = \"none\";\r\n  document.body.appendChild(image);\r\n  image.onerror = function(event) {\r\n    dom.src = \"xxxx.png\";\r\n    document.body.removeChild(image);\r\n  };\r\n  image.onload = function() {\r\n    document.body.removeChild(image);\r\n  };\r\n}\r\n```\r\n\r\n上面我们说了假设内容是直接通过 html 代码插入的，我们可能监听不到图片的默认错误事件，那么我们可以在网页加载完成之后重试一遍所有的 img，在为 img 指定一次错误事件就 OK 了。\r\n\r\n## 最后\r\n\r\n为了方便演示，上面的代码我都没有做兼容性的补充，但是在实际生产中上面代码需要`polyfill`尤其是 dom 的一些语法，推荐简单一些的做法可以把上面的例子转化为 jquery 的语法。\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/bosens-China/blog/issues/48/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/bosens-China/blog/issues/48/timeline",
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/bosens-China/blog/issues/44",
    "repository_url": "https://api.github.com/repos/bosens-China/blog",
    "labels_url": "https://api.github.com/repos/bosens-China/blog/issues/44/labels{/name}",
    "comments_url": "https://api.github.com/repos/bosens-China/blog/issues/44/comments",
    "events_url": "https://api.github.com/repos/bosens-China/blog/issues/44/events",
    "html_url": "https://github.com/bosens-China/blog/issues/44",
    "id": 547208786,
    "node_id": "MDU6SXNzdWU1NDcyMDg3ODY=",
    "number": 44,
    "title": "详解global对象的获取",
    "user": {
      "login": "bosens-China",
      "id": 39508895,
      "node_id": "MDQ6VXNlcjM5NTA4ODk1",
      "avatar_url": "https://avatars.githubusercontent.com/u/39508895?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/bosens-China",
      "html_url": "https://github.com/bosens-China",
      "followers_url": "https://api.github.com/users/bosens-China/followers",
      "following_url": "https://api.github.com/users/bosens-China/following{/other_user}",
      "gists_url": "https://api.github.com/users/bosens-China/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/bosens-China/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/bosens-China/subscriptions",
      "organizations_url": "https://api.github.com/users/bosens-China/orgs",
      "repos_url": "https://api.github.com/users/bosens-China/repos",
      "events_url": "https://api.github.com/users/bosens-China/events{/privacy}",
      "received_events_url": "https://api.github.com/users/bosens-China/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [
      {
        "id": 1371686609,
        "node_id": "MDU6TGFiZWwxMzcxNjg2NjA5",
        "url": "https://api.github.com/repos/bosens-China/blog/labels/js%20%E7%9B%B8%E5%85%B3",
        "name": "js 相关",
        "color": "F7DF1E",
        "default": false,
        "description": ""
      }
    ],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 0,
    "created_at": "2020-01-09T02:19:18Z",
    "updated_at": "2020-01-09T02:19:18Z",
    "closed_at": null,
    "author_association": "OWNER",
    "active_lock_reason": null,
    "body": "global 在开发中经常使用遇到，例如下面一段代码调用的就是 global 内置的对象\r\n\r\n```js\r\nconst min = Math.min(...[1, 11, 22, 55, -2, -1]);\r\n```\r\n\r\n这里的 Math 对象就是 global 内置的，在浏览器环境下我们可以通过`window.Math.min`显示调用，而在 node 环境下我们则要通过`global.Math.min`来调用，在实际中我们不会通过`window.Math.min`这种方式来调用，不过却也能看到不同环境下获取 global 对象各不相同。\r\n\r\n下面就以编写一个现代的工具库为假设，这个库要支持全局引用也是很科学的，但是如何让其挂载在全局属性上呢？\r\n\r\n## 第一版\r\n\r\n```js\r\n(function() {\r\n  var _global = this;\r\n  var _ = {};\r\n  _.debounce = function() {};\r\n  // ...一些其他的方法\r\n  return (_global._ = _);\r\n})();\r\n```\r\n\r\n这里的想法是通过全局环境下运行 this 来返回一个全局对象，在全局对象上挂载我们的工具函数，不通过 `window` 显示挂载是因为我们不仅要让这个工具库运行在浏览器环境下,同时也让他运行在 `node` 环境中。\r\n\r\n## 严格模式\r\n\r\n上面的写法是假设在非严格模式下运行，而在严格模式下运行，this 会返回一个`undefined`\r\n\r\n```js\r\n(function() {\r\n  \"use strict\";\r\n  console.log(this === undefined); // true\r\n})();\r\n```\r\n\r\n下面我们来尝试修订一下严格模式下的错误\r\n\r\n```js\r\n(function() {\r\n  // 防止null出现\r\n  function isObjectLike(par) {\r\n    return par && typeof par == \"object\";\r\n  }\r\n  var _global;\r\n  if (isObjectLike(global) && global.global === global) {\r\n    _global = global;\r\n  } else {\r\n    _global = window;\r\n  }\r\n  var _ = {};\r\n  _.debounce = function() {};\r\n  // ...一些其他的方法\r\n  return (_global._ = _);\r\n})();\r\n```\r\n\r\n这里我们通过判断 global 是否存在，如果存在就是 `node` 环境如果不存在就是浏览器环境。\r\n\r\n> `global.global`和`window.window`都是指向自身，可以理解为无限嵌套的属性\r\n\r\n## Web Worker\r\n\r\nWeb Worker 是为 JavaScript 创造多线程环境出现的，不过使用它是有一些限制无法使用 `document、window、parent`等这些对象，所以在上面的例子中如果我们在 Web Worker 环境中一定会报错，因为不存在 `global` 和 `window` 对象\r\n\r\n不过 Worker 可以通过`self`来拿到子线程的全局对象，而且 self 在浏览器环境下也指向 window\r\n\r\n```js\r\n(function() {\r\n  // 防止null出现\r\n  function isObjectLike(par) {\r\n    return par && typeof par == \"object\";\r\n  }\r\n  var _global;\r\n  if (isObjectLike(global) && global.global === global) {\r\n    _global = global;\r\n  } else if (isObjectLike(self) && self === self) {\r\n    _global = self;\r\n  }\r\n  var _ = {};\r\n  _.debounce = function() {};\r\n  // ...一些其他的方法\r\n  return (_global._ = _);\r\n})();\r\n```\r\n\r\n## node 虚拟机\r\n\r\nnode vm（沙盒） 环境下不存在 global 和 window 对象，所以上面代码还是会出现问题，不过我们可以通过\r\n`new Function('return this')()`或者`this`的形式来解决\r\n\r\n```js\r\n(function() {\r\n  // 防止null出现\r\n  function isObjectLike(par) {\r\n    return par && typeof par == \"object\";\r\n  }\r\n  var _global;\r\n  if (isObjectLike(global) && global.global === global) {\r\n    _global = global;\r\n  } else if (isObjectLike(self) && self === self) {\r\n    _global = self;\r\n  } else {\r\n    _global = new Function(\"return this\")();\r\n    // 或者\r\n    // _global = this;\r\n  }\r\n  var _ = {};\r\n  _.debounce = function() {};\r\n  // ...一些其他的方法\r\n  return (_global._ = _);\r\n})();\r\n```\r\n\r\n## Content Security Policy\r\n\r\n上面你可能注意到了，我在上一版提到了两个方法来最后获取 `global` 的值\r\n\r\n- \\_global = new Function(\"return this\")();\r\n- \\_global = this;\r\n\r\n不过在网页安全政策（Content Security Policy）下只会加载信任的白名单，`eval、new Function`这些方法都可能无法使用，只能使用`\\_global = this`来获取 global\r\n\r\n```js\r\n(function() {\r\n  // 防止null出现\r\n  function isObjectLike(par) {\r\n    return par && typeof par == \"object\";\r\n  }\r\n  var _global;\r\n  if (isObjectLike(global) && global.global === global) {\r\n    _global = global;\r\n  } else if (isObjectLike(self) && self === self) {\r\n    _global = self;\r\n  } else {\r\n    // 或者\r\n    _global = this;\r\n  }\r\n  var _ = {};\r\n  _.debounce = function() {};\r\n  // ...一些其他的方法\r\n  return (_global._ = _);\r\n})();\r\n```\r\n\r\n## 微信小程序\r\n\r\n在微信小程序中`global`和`window`都不存在再加上使用的是严格模式，this 会返回`undefined`所以我们还需要在加一个判断\r\n\r\n```js\r\n(function() {\r\n  // 防止null出现\r\n  function isObjectLike(par) {\r\n    return par && typeof par == \"object\";\r\n  }\r\n  var _global;\r\n  if (isObjectLike(global) && global.global === global) {\r\n    _global = global;\r\n  } else if (isObjectLike(self) && self === self) {\r\n    _global = self;\r\n  } else {\r\n    // 或者\r\n    _global = this || {};\r\n  }\r\n  var _ = {};\r\n  _.debounce = function() {};\r\n  // ...一些其他的方法\r\n  return (_global._ = _);\r\n})();\r\n```\r\n\r\n## globalThis\r\n\r\n上面的判断方式是现在社区主流做法，不过在 tc39 的提案中`globalThis`可以获取全局对象，使用方法也很简单\r\n\r\n```js\r\n// 浏览器环境\r\nglobalThis === window; // true\r\n// node\r\nglobalThis === global; // true\r\n```\r\n\r\n目前是`Stage 3`使用的话还是需要做一些兼容性的处理，下面就来写最后一版\r\n\r\n```js\r\n(function() {\r\n  // 防止null出现\r\n  function isObjectLike(par) {\r\n    return par && typeof par == \"object\";\r\n  }\r\n  function getGlobal() {\r\n    if (isObjectLike(globalThis) && globalThis.Object === Object) {\r\n      return globalThis;\r\n    }\r\n    if (isObjectLike(global) && global.global === global) {\r\n      return global;\r\n    }\r\n\r\n    if (isObjectLike(self) && self === self) {\r\n      return self;\r\n    }\r\n    return this || {};\r\n  }\r\n\r\n  var _global = getGlobal();\r\n  var _ = {};\r\n  _.debounce = function() {};\r\n  // ...一些其他的方法\r\n  return (_global._ = _);\r\n})();\r\n```\r\n\r\n## 最后\r\n\r\n本来可以一次写完，不过还是希望循循而进了解写了这么多判断究竟是为什么，最后如果有不正确的地方希望有小伙伴指出来，欢迎 star，对作者也是一种鼓励。\r\n\r\n## 参考链接\r\n\r\n- https://developer.mozilla.org/zh-CN/docs/Web/HTTP/CSP\r\n- https://github.com/mqyqingfeng/Blog/issues/56\r\n- https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/globalThis\r\n- https://github.com/lodash/lodash/blob/master/.internal/root.js\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/bosens-China/blog/issues/44/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/bosens-China/blog/issues/44/timeline",
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/bosens-China/blog/issues/43",
    "repository_url": "https://api.github.com/repos/bosens-China/blog",
    "labels_url": "https://api.github.com/repos/bosens-China/blog/issues/43/labels{/name}",
    "comments_url": "https://api.github.com/repos/bosens-China/blog/issues/43/comments",
    "events_url": "https://api.github.com/repos/bosens-China/blog/issues/43/events",
    "html_url": "https://github.com/bosens-China/blog/issues/43",
    "id": 544505720,
    "node_id": "MDU6SXNzdWU1NDQ1MDU3MjA=",
    "number": 43,
    "title": "javascript 设计模式之从form表单来看策略模式",
    "user": {
      "login": "bosens-China",
      "id": 39508895,
      "node_id": "MDQ6VXNlcjM5NTA4ODk1",
      "avatar_url": "https://avatars.githubusercontent.com/u/39508895?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/bosens-China",
      "html_url": "https://github.com/bosens-China",
      "followers_url": "https://api.github.com/users/bosens-China/followers",
      "following_url": "https://api.github.com/users/bosens-China/following{/other_user}",
      "gists_url": "https://api.github.com/users/bosens-China/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/bosens-China/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/bosens-China/subscriptions",
      "organizations_url": "https://api.github.com/users/bosens-China/orgs",
      "repos_url": "https://api.github.com/users/bosens-China/repos",
      "events_url": "https://api.github.com/users/bosens-China/events{/privacy}",
      "received_events_url": "https://api.github.com/users/bosens-China/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [
      {
        "id": 1740561541,
        "node_id": "MDU6TGFiZWwxNzQwNTYxNTQx",
        "url": "https://api.github.com/repos/bosens-China/blog/labels/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F",
        "name": "设计模式",
        "color": "d1a540",
        "default": false,
        "description": "javascript设计模式的实现"
      }
    ],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 0,
    "created_at": "2020-01-02T09:36:08Z",
    "updated_at": "2020-01-02T09:47:14Z",
    "closed_at": null,
    "author_association": "OWNER",
    "active_lock_reason": null,
    "body": "### 前言\r\n\r\n之前写程序的时候为了快速开发写了许多`if`、`else if`的语句，当时开发倒是挺爽的，事后维护的时候想骂人，为了不坑自己和其他小伙伴，下面从零开始用一个基础表单 + 策略模式清除`if`分支语句\r\n\r\n```html\r\n<form class=\"cs-form\">\r\n  <label>\r\n    <span>账号：</span>\r\n    <input name=\"account\" type=\"text\" />\r\n  </label>\r\n  <label>\r\n    <span>密码：</span>\r\n    <input name=\"password\" type=\"password\" />\r\n  </label>\r\n  <label>\r\n    <span>手机号：</span>\r\n    <input name=\"mobile\" type=\"number\" />\r\n  </label>\r\n  <button class=\"submit\" type=\"submit\">登录</button>\r\n</form>\r\n```\r\n\r\n上面是一个很常见的表单元素，里面有账号和密码以及手机号，我们需要在提交之前对他进行一些校验，这里默认的规则是账号和密码不能为空，手机号的长度必须是 11 的纯数字。\r\n\r\n### 第一版\r\n\r\n```ts\r\ninterface Iform {\r\n  [k: string]: any;\r\n  account: HTMLInputElement;\r\n  password: HTMLInputElement;\r\n  mobile: HTMLInputElement;\r\n}\r\nconst form = document.querySelector(\".cs-form\") as HTMLFormElement;\r\n\r\nform.addEventListener(\"submit\", function(e) {\r\n  e.preventDefault();\r\n  const { account, password, mobile } = (form as unknown) as Iform;\r\n  if (!account.value) {\r\n    // 提示\r\n    alert(\"请输入账号\");\r\n    return false;\r\n  }\r\n  if (!password.value) {\r\n    // 提示\r\n    alert(\"请输入密码\");\r\n    return false;\r\n  }\r\n  if (!/\\d{11}/.test(mobile.value)) {\r\n    // 提示\r\n    alert(\"请输入正确的手机号\");\r\n    return false;\r\n  }\r\n  return false;\r\n});\r\n```\r\n\r\n根据上面的要求，我们实现了第一版代码，从代码的实现看毫无疑问是正确的，为了对比下面再用策略模式实现以下上述的功能\r\n\r\n### 第二版\r\n\r\n```ts\r\ninterface Iform {\r\n  [k: string]: any;\r\n  account: HTMLInputElement;\r\n  password: HTMLInputElement;\r\n  mobile: HTMLInputElement;\r\n}\r\n\r\ninterface Ilist {\r\n  value: string;\r\n  type: name;\r\n  msg: string;\r\n}\r\n\r\ntype name = keyof typeof rule;\r\nconst rule = {\r\n  account(value: string, msg: string) {\r\n    if (!value) {\r\n      return msg;\r\n    }\r\n  },\r\n  password(value: string, msg: string) {\r\n    if (!value) {\r\n      return msg;\r\n    }\r\n  },\r\n  mobile(value: string, msg: string) {\r\n    if (!/\\d{11}/.test(value)) {\r\n      return msg;\r\n    }\r\n  }\r\n};\r\nclass Verification {\r\n  private list: Ilist[] = [];\r\n  public message: string;\r\n  add<T extends { value: string }>(dom: T, type: name, msg: string) {\r\n    this.list.push({\r\n      value: dom.value,\r\n      type: type,\r\n      msg: msg\r\n    });\r\n  }\r\n  start(): boolean {\r\n    for (let i = 0; i < this.list.length; i++) {\r\n      const { value, type, msg } = this.list[i];\r\n      const fn = rule[type](value, msg);\r\n      if (fn) {\r\n        this.message = msg;\r\n        return false;\r\n      }\r\n    }\r\n    this.message = \"\";\r\n    return true;\r\n  }\r\n}\r\n\r\nconst form = document.querySelector(\".cs-form\") as HTMLFormElement;\r\n\r\nform.addEventListener(\"submit\", function(e) {\r\n  e.preventDefault();\r\n  const { account, password, mobile } = (form as unknown) as Iform;\r\n\r\n  const ruleSet = new Verification();\r\n  ruleSet.add(account, \"account\", \"请输入账号\");\r\n  ruleSet.add(password, \"password\", \"请输入密码\");\r\n  ruleSet.add(mobile, \"mobile\", \"请输入正确的手机号\");\r\n\r\n  if (!ruleSet.start()) {\r\n    // 提示\r\n    alert(ruleSet.message);\r\n    return false;\r\n  }\r\n  return false;\r\n});\r\n```\r\n\r\n从代码量看比第一版多出了很多语句，这里做法是把代码的规则放置在 rule 对象中，因为 javascript 本身就是这么灵活不需要在使用传统语言的 class 来实现了，剩下的就是新建一个校验类，新增校验规则最后校验，当然现在验证规则还是比较少，看不出策略模式的优点。\r\n\r\n下面再来新增一个要求，密码长度不能小于 6 位，在第一版中我们要紧接在密码不能为空的校验之后写，再来看下策略模式新增这个验证会新增哪些代码。\r\n\r\n```ts\r\ninterface Iform {\r\n  [k: string]: any;\r\n  account: HTMLInputElement;\r\n  password: HTMLInputElement;\r\n  mobile: HTMLInputElement;\r\n}\r\n\r\ninterface Ilist {\r\n  value: string;\r\n  type: name;\r\n  msg: string;\r\n}\r\n\r\ntype name = keyof typeof rule;\r\nconst rule = {\r\n  account(value: string, msg: string) {\r\n    if (!value) {\r\n      return msg;\r\n    }\r\n  },\r\n  password(value: string, msg: string) {\r\n    if (!value) {\r\n      return msg;\r\n    }\r\n  },\r\n  // 密码长度小于6的时候提示\r\n  passwordMinLength(value: string, msg: string) {\r\n    if (value.length < 6) {\r\n      return msg;\r\n    }\r\n  },\r\n  mobile(value: string, msg: string) {\r\n    if (!/\\d{11}/.test(value)) {\r\n      return msg;\r\n    }\r\n  }\r\n};\r\nclass Verification {\r\n  private list: Ilist[] = [];\r\n  public message: string;\r\n  add<T extends { value: string }>(dom: T, type: name, msg: string) {\r\n    this.list.push({\r\n      value: dom.value,\r\n      type: type,\r\n      msg: msg\r\n    });\r\n  }\r\n  start(): boolean {\r\n    for (let i = 0; i < this.list.length; i++) {\r\n      const { value, type, msg } = this.list[i];\r\n      const fn = rule[type](value, msg);\r\n      if (fn) {\r\n        this.message = msg;\r\n        return false;\r\n      }\r\n    }\r\n    this.message = \"\";\r\n    return true;\r\n  }\r\n}\r\n\r\nconst form = document.querySelector(\".cs-form\") as HTMLFormElement;\r\n\r\nform.addEventListener(\"submit\", function(e) {\r\n  e.preventDefault();\r\n  const { account, password, mobile } = (form as unknown) as Iform;\r\n\r\n  const ruleSet = new Verification();\r\n  ruleSet.add(account, \"account\", \"请输入账号\");\r\n  ruleSet.add(password, \"password\", \"请输入密码\");\r\n  ruleSet.add(password, \"passwordMinLength\", \"密码长度不符合要求\");\r\n  ruleSet.add(mobile, \"mobile\", \"请输入正确的手机号\");\r\n\r\n  if (!ruleSet.start()) {\r\n    // 提示\r\n    alert(ruleSet.message);\r\n    return false;\r\n  }\r\n  return false;\r\n});\r\n```\r\n\r\n把密码不能小于六位的规则添加到`rule`中，之后 add 的时候添加它，这里基本的校验其实就完成了，不过从上面看，我们的校验肯定不是一个 input 就对应一条，实际上会存在多种校验，比如最小长度最大长度，不能包含敏感词等，添加多条规则也是很合理的要求，下面就是最终版的实现。\r\n\r\n### 最终版\r\n\r\n```ts\r\ninterface Iform {\r\n  [k: string]: any;\r\n  account: HTMLInputElement;\r\n  password: HTMLInputElement;\r\n  mobile: HTMLInputElement;\r\n}\r\n\r\ninterface Ilist {\r\n  value: string;\r\n  type: name;\r\n  msg: string;\r\n}\r\ninterface Iadd {\r\n  type: name;\r\n  msg: string;\r\n}\r\n\r\ntype name = keyof typeof rule;\r\nconst rule = {\r\n  require(value: string, msg: string) {\r\n    if (!value) {\r\n      return msg;\r\n    }\r\n  },\r\n  minLength(value: string, msg: string) {\r\n    if (value.length < 6) {\r\n      return msg;\r\n    }\r\n  },\r\n  mobile(value: string, msg: string) {\r\n    if (!/\\d{11}/.test(value)) {\r\n      return msg;\r\n    }\r\n  }\r\n};\r\nclass Verification {\r\n  private list: Ilist[] = [];\r\n  public message: string;\r\n  // 用函数重载的形式实现\r\n  add<T extends { value: string }>(dom: T, type: name, msg: string): void;\r\n  add<T extends { value: string }>(dom: T, ruleArr: Array<Iadd>): void;\r\n  add<T extends { value: string }>(\r\n    dom: T,\r\n    ruleArr: Array<Iadd> | name,\r\n    msg?: string\r\n  ): void {\r\n    if (Array.isArray(ruleArr)) {\r\n      this.list.push(\r\n        ...ruleArr.map(f => {\r\n          return {\r\n            value: dom.value,\r\n            type: f.type,\r\n            msg: f.msg\r\n          };\r\n        })\r\n      );\r\n    } else {\r\n      this.list.push({\r\n        value: dom.value,\r\n        type: ruleArr,\r\n        msg: msg\r\n      });\r\n    }\r\n  }\r\n  start(): boolean {\r\n    for (let i = 0; i < this.list.length; i++) {\r\n      const { value, type, msg } = this.list[i];\r\n      const fn = rule[type](value, msg);\r\n      if (fn) {\r\n        this.message = msg;\r\n        return false;\r\n      }\r\n    }\r\n    this.message = \"\";\r\n    return true;\r\n  }\r\n}\r\n\r\nconst form = document.querySelector(\".cs-form\") as HTMLFormElement;\r\n\r\nform.addEventListener(\"submit\", function(e) {\r\n  e.preventDefault();\r\n  const { account, password, mobile } = (form as unknown) as Iform;\r\n\r\n  const ruleSet = new Verification();\r\n  ruleSet.add(account, \"require\", \"请输入账号\");\r\n  ruleSet.add(password, [\r\n    {\r\n      type: \"require\",\r\n      msg: \"请输入密码\"\r\n    },\r\n    {\r\n      type: \"minLength\",\r\n      msg: \"密码长度不符合要求\"\r\n    }\r\n  ]);\r\n  ruleSet.add(mobile, [\r\n    {\r\n      type: \"require\",\r\n      msg: \"请输入手机号\"\r\n    },\r\n    {\r\n      type: \"mobile\",\r\n      msg: \"请输入正确的手机号\"\r\n    }\r\n  ]);\r\n\r\n  if (!ruleSet.start()) {\r\n    // 提示\r\n    alert(ruleSet.message);\r\n    return false;\r\n  }\r\n  return false;\r\n});\r\n```\r\n\r\n撒花，这里就已经写完了，整体来看代码量还是蛮多的，主要是用 ts 写需要定义各种接口和类型，最终版本的时候我将上述的手机和账号的验证抽离成 require 函数，后续如果有用到只需要在 `rule` 规则中新增即可。\r\n\r\n当然因为只是讲解策略模式的使用所以这里并没有对这个校验更完整的定义，如果有进一步需要可以将 min 和 max 属性以及 regexp 属性新增上，进一步提高校验的规则\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/bosens-China/blog/issues/43/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/bosens-China/blog/issues/43/timeline",
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/bosens-China/blog/issues/42",
    "repository_url": "https://api.github.com/repos/bosens-China/blog",
    "labels_url": "https://api.github.com/repos/bosens-China/blog/issues/42/labels{/name}",
    "comments_url": "https://api.github.com/repos/bosens-China/blog/issues/42/comments",
    "events_url": "https://api.github.com/repos/bosens-China/blog/issues/42/events",
    "html_url": "https://github.com/bosens-China/blog/issues/42",
    "id": 542405907,
    "node_id": "MDU6SXNzdWU1NDI0MDU5MDc=",
    "number": 42,
    "title": "使用IntersectionObserver实现图片懒加载",
    "user": {
      "login": "bosens-China",
      "id": 39508895,
      "node_id": "MDQ6VXNlcjM5NTA4ODk1",
      "avatar_url": "https://avatars.githubusercontent.com/u/39508895?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/bosens-China",
      "html_url": "https://github.com/bosens-China",
      "followers_url": "https://api.github.com/users/bosens-China/followers",
      "following_url": "https://api.github.com/users/bosens-China/following{/other_user}",
      "gists_url": "https://api.github.com/users/bosens-China/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/bosens-China/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/bosens-China/subscriptions",
      "organizations_url": "https://api.github.com/users/bosens-China/orgs",
      "repos_url": "https://api.github.com/users/bosens-China/repos",
      "events_url": "https://api.github.com/users/bosens-China/events{/privacy}",
      "received_events_url": "https://api.github.com/users/bosens-China/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [
      {
        "id": 1580833992,
        "node_id": "MDU6TGFiZWwxNTgwODMzOTky",
        "url": "https://api.github.com/repos/bosens-China/blog/labels/%E5%AE%9E%E9%AA%8C%E6%80%A7%20API",
        "name": "实验性 API",
        "color": "7aa9d6",
        "default": false,
        "description": ""
      }
    ],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 0,
    "created_at": "2019-12-26T01:53:33Z",
    "updated_at": "2019-12-26T01:54:56Z",
    "closed_at": null,
    "author_association": "OWNER",
    "active_lock_reason": null,
    "body": "> 传统的图片懒加载实现思路是判断图片的 top 区域是否小于父级区域，且自身高度加上 top 大于 0，\r\n> 例如\r\n\r\n```js\r\n// 元素是否可视\r\nconst viewVisible = el => {\r\n  const { top, width, height, left } = el.getBoundingClientRect();\r\n  const w = window.innerWidth || document.documentElement.clientWidth;\r\n  const h = window.innerHeight || document.documentElement.clientHeight;\r\n  return top < h && top + height >= 0 && left < w && left + width >= 0;\r\n};\r\n```\r\n\r\n> 不过这样写的话有一个问题就是我们监听的事件会重复多次触发，所以我们还需要写一个节流或者防抖函数，不过使用`IntersectionObserver`我们可以轻松实现，首先看下兼容性\r\n\r\n> ![IntersectionObserver兼容性](https://user-gold-cdn.xitu.io/2019/7/3/16bb72b8143aca06?w=720&h=334&f=png&s=74534)可以看到差强人意，不过好在可以[polyfill](https://github.com/w3c/IntersectionObserver/tree/master/polyfill)，下面就介绍使用\r\n\r\n## 使用方法\r\n\r\n`IntersectionObserver`使用方法很简单\r\n\r\n```js\r\nvar observer = new IntersectionObserver(callback[, options]);\r\n```\r\n\r\n`callback`接收两个参数，一个 IntersectionObserverEntry 对象列表(list)，以及触发 IntersectionObserverEntry 的实例\r\n\r\n| 方法         | 说明                                           |\r\n| ------------ | ---------------------------------------------- |\r\n| disconnect() | 使 IntersectionObserver 对象停止监听工作。     |\r\n| observe()    | 使 IntersectionObserver 开始监听一个目标元素。 |\r\n| unobserve()  | 使 IntersectionObserver 停止监听特定目标元素。 |\r\n\r\n**注意**\r\n`callback`的回调函数会触发两次，第一次是元素开始可见，第二次是元素不可见的时候。\r\n\r\n## 选项(options)\r\n\r\n注意可选属性\r\n\r\n| 属性       | 说明                                                                                                                                                                                           |\r\n| ---------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\r\n| root       | 监听元素的祖先元素 Element 对象                                                                                                                                                                |\r\n| rootMargin | 一个在计算交叉值时添加至根的边界盒(bounding_box)中的一组偏移量，类型为字符串，可以有效的缩小或扩大根的判定范围从而满足计算需要。语法大致和 CSS 中的 margin 属性等同，默认值是\"0px 0px 0px 0px\" |\r\n| threshold  | 规定了一个监听目标与边界盒交叉区域的比例值，可以是一个具体的数值或是一组 0.0 到 1.0 之间的数组。若指定值为 0.0，则意味着监听元素即使与根有 1 像素交叉，此元素也会被视为可见.                   |\r\n\r\n## 实例\r\n\r\n```js\r\nconst dom = new IntersectionObserver(a => {\r\n  console.log(a);\r\n});\r\nArray.from(document.querySelectorAll(\"img\")).forEach(f => {\r\n  dom.observe(f);\r\n});\r\n```\r\n\r\n返回的 a 是一个数组，里面存放着一些元素信息，下面所有属性都是只读\r\n\r\n| 属性               | 说明                                                                                                                                                                                                                                |\r\n| ------------------ | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\r\n| boundingClientRect | 返回包含目标元素的边界信息的 DOMRectReadOnly. 边界的计算方式与 Element.getBoundingClientRect() 相同.                                                                                                                                |\r\n| intersectionRatio  | 返回 intersectionRect 与 boundingClientRect 的比例值,**如果大于 0 则表示可见，完全可见为 1**.                                                                                                                                       |\r\n| intersectionRect   | 返回一个 DOMRectReadOnly 用来描述根和目标元素的相交区域.                                                                                                                                                                            |\r\n| isIntersecting     | 返回一个布尔值, 如果目标元素与交叉区域观察者对象(intersection observer) 的根相交，则返回 true .如果返回 true, 则 IntersectionObserverEntry 描述了变换到交叉时的状态; 如果返回 false, 那么可以由此判断,变换是从交叉状态到非交叉状态. |\r\n| rootBounds         | 返回一个 DOMRectReadOnly 用来描述交叉区域观察者(intersection observer)中的根.                                                                                                                                                       |\r\n| target             | 与根出现相交区域改变的元素 (Element).                                                                                                                                                                                               |\r\n| time               | 返回一个记录从 IntersectionObserver 的时间原点(time origin)到交叉被触发的时间的时间戳(DOMHighResTimeStamp).                                                                                                                         |\r\n\r\n## 实现\r\n\r\n上面已经实现判断元素是否可见，下面我们只需要根据上面思路完善一下即可开发一个图片懒加载的类，首先先说明一下图片懒加载一般情况下为了防止图片`src`为空样式不统一和加载图片突然拉伸空间，会给默认的图片设置一个占位图片，或者给定一个样式\r\n\r\n```css\r\nimg {\r\n  width: 400px;\r\n  height: 400px;\r\n  display: inline-block;\r\n}\r\n```\r\n\r\n```html\r\n<img />\r\n```\r\n\r\n上面给了一个简单的演示，注意 `src` 属性不要写，因为即使为空也还会加载。 顺便说下火狐浏览器如果 img 标签没有其他属性的话会理解成内联元素，就是 span 标签一样的内联元素，所以如果不放置占位图片的话推荐重置 img 为 `inline-block` 然后设置固定宽高。\r\n\r\n之后就是给图片动态添加 src 属性，比较推荐的是`data-`的自定义属性，许多库用的也是这个方法，替换完成之后将图片元素从`IntersectionObserver`移除。\r\n\r\n## 最后\r\n\r\n`IntersectionObserver`使用的是异步的方式，可以不用担心性能问题\r\n\r\n- 参考\r\n  [IntersectionObserver MDN](https://developer.mozilla.org/zh-CN/docs/Web/API/IntersectionObserver/IntersectionObserver)\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/bosens-China/blog/issues/42/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/bosens-China/blog/issues/42/timeline",
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/bosens-China/blog/issues/41",
    "repository_url": "https://api.github.com/repos/bosens-China/blog",
    "labels_url": "https://api.github.com/repos/bosens-China/blog/issues/41/labels{/name}",
    "comments_url": "https://api.github.com/repos/bosens-China/blog/issues/41/comments",
    "events_url": "https://api.github.com/repos/bosens-China/blog/issues/41/events",
    "html_url": "https://github.com/bosens-China/blog/issues/41",
    "id": 539716296,
    "node_id": "MDU6SXNzdWU1Mzk3MTYyOTY=",
    "number": 41,
    "title": "vuepress插件开发不完全指南",
    "user": {
      "login": "bosens-China",
      "id": 39508895,
      "node_id": "MDQ6VXNlcjM5NTA4ODk1",
      "avatar_url": "https://avatars.githubusercontent.com/u/39508895?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/bosens-China",
      "html_url": "https://github.com/bosens-China",
      "followers_url": "https://api.github.com/users/bosens-China/followers",
      "following_url": "https://api.github.com/users/bosens-China/following{/other_user}",
      "gists_url": "https://api.github.com/users/bosens-China/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/bosens-China/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/bosens-China/subscriptions",
      "organizations_url": "https://api.github.com/users/bosens-China/orgs",
      "repos_url": "https://api.github.com/users/bosens-China/repos",
      "events_url": "https://api.github.com/users/bosens-China/events{/privacy}",
      "received_events_url": "https://api.github.com/users/bosens-China/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [
      {
        "id": 1473940161,
        "node_id": "MDU6TGFiZWwxNDczOTQwMTYx",
        "url": "https://api.github.com/repos/bosens-China/blog/labels/Vue%20%E7%9B%B8%E5%85%B3",
        "name": "Vue 相关",
        "color": "42b883",
        "default": false,
        "description": "Vue 相关"
      }
    ],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 0,
    "created_at": "2019-12-18T14:30:58Z",
    "updated_at": "2019-12-19T00:42:17Z",
    "closed_at": null,
    "author_association": "OWNER",
    "active_lock_reason": null,
    "body": "最近用 `vuepress` 把社区的 typeScript 翻译文章打包成了一个[在线文档](https://bosens-china.github.io/Typescript-manual/dist/)，不过有一些插件社区没有或者实现的不符合自己定制需求，所以决定自定义实现一个，这篇文化以掘金`复制代码`功能为例子。\r\n先看一下开发完成的界面\r\n\r\n![1](https://user-images.githubusercontent.com/39508895/71094442-f3384500-21e5-11ea-91b5-a0de07c72903.png)\r\n\r\n\r\n先看一下官方给出的架构图\r\n![](https://user-gold-cdn.xitu.io/2019/12/18/16f195bad0aeb2f4?w=1774&h=2334&f=png&s=65238)\r\n是不是感觉有点头疼，这里记不住没有关系，我们只需要知道**插件是在 node 环境下运行**，所以我们插件的返回形式必须是`CommonJS`形式。\r\n\r\n与 vue 类似，`vuepress`也有生命周期\r\n\r\n- ready\r\n\r\n可以简单理解为初始化完成调用\r\n\r\n- updated\r\n\r\n页面更新调用\r\n\r\n- generated\r\n\r\n生产环境构建完成调用\r\n\r\n### 实现思路\r\n\r\n因为`vuepress`会将 md 文件打包成多份 html 文件，所以在每次文件地址变更的时候我们都需要知道这个变更之后更新我们的组件，根据上面的生命周期可以在`updated`实现我们的需求\r\n\r\n至于如何将复制粘贴的组件插入到指定的`code`中，我们可以在页面加载完成后，搜索所有的指定节点，之后通过`appendChild`将组件插入\r\n\r\n### 项目结构\r\n\r\n```sh\r\ncopy\r\n├─ clientRootMixin.js\r\n├─ clipboard.js\r\n├─ copy.vue\r\n└─ index.js\r\n```\r\n\r\n- index.js\r\n\r\n暴露的出口文件\r\n\r\n- copy.vue\r\n\r\n具体实现复制代码组件\r\n\r\n- clipboard.js\r\n\r\n负责实现置剪切板文本\r\n\r\n- clientRootMixin.js\r\n\r\n负责实现将组件插入到不同的页面之中\r\n\r\n### index.js\r\n\r\n上面说了我们要开发一个复制代码的插件，我们就先按照简单的做法定义三个参数\r\n\r\n- 第一个是选择器的范围\r\n- 第二个是复制代码显示的文本\r\n- 第三个则是回调函数，负责接收变更消息，实现自定义的动画效果\r\n\r\n在官方给出的例子，有两种方式使用插件\r\n\r\n```js\r\n// 例1\r\nmodule.exports = {\r\n  plugins: [\r\n    [\r\n      \"vuepress-plugin-xxx\",\r\n      {\r\n        /* options */\r\n      }\r\n    ]\r\n  ]\r\n};\r\n// 例2\r\nmodule.exports = {\r\n  plugins: {\r\n    xxx: {\r\n      /* options */\r\n    }\r\n  }\r\n};\r\n```\r\n\r\n可以看到，如果有参数的话可以这样传递，那么我们定义的插件第一步就是要处理这个参数，当然也可以不接受，如果不接受直接返回一个对象就可以了\r\n\r\n```js\r\nmodule.exports = {\r\n  // ...\r\n};\r\n```\r\n\r\n下面来定义一个简单接受`options`的函数\r\n\r\n```js\r\n// 对象式\r\n\r\nmodule.exports = {\r\n  define: {\r\n    selector: options.selector || 'div[class*=\"language-\"] pre',\r\n    copyText: options.copyText || \"复制代码\",\r\n    change: options.change\r\n  }\r\n};\r\n// 函数式:\r\nmodule.exports = (options, context) => ({\r\n  define() {\r\n    return {\r\n      selector: options.selector || 'div[class*=\"language-\"] pre',\r\n      copyText: options.copyText || \"复制代码\",\r\n      change: options.change\r\n    };\r\n  }\r\n});\r\n```\r\n\r\n注意必须返回是`CommonJS`形式，上面我们通过`define`属性来定义供我们插件内部使用的全局变量，他支持函数和对象两种形式，可以理解为 vue 的 data 属性\r\n\r\n这一步比较简单，就不做其他过多说明了，上面我们提到了需要将组件注入到所有页面中，这一步是`clientRootMixin.js`所需要负责的事情，下面就是实现它，我们需要在`index.js`引入它，一个完整的`index.js`看起来应该是这样\r\n\r\n```js\r\nconst path = require(\"path\");\r\n\r\nmodule.exports = (options = {}, ctx) => ({\r\n  define: {\r\n    // ...\r\n  },\r\n  clientRootMixin: path.resolve(__dirname, \"clientRootMixin.js\")\r\n});\r\n```\r\n\r\n### clientRootMixin.js\r\n\r\n`clientRootMixin` 可以让我们控制根文组件的生命周期，这里我们只需要监听`updated`事件，之后把`copy.vue`插入到当前页面内即可\r\n\r\n```js\r\nimport CodeCopy from \"./copy.vue\";\r\nimport Vue from \"vue\";\r\n\r\nexport default {\r\n  updated() {\r\n    // 等待dom加载完成之后执行\r\n    this.$nextTick(() => {\r\n      this.update();\r\n    });\r\n  },\r\n  methods: {\r\n    update() {\r\n      // 获取所有的dom，之后在所有的代码块上插入vue的组件\r\n      const dom = Array.from(document.querySelectorAll(selector));\r\n      dom.forEach(el => {\r\n        // 判断一下，当前节点是不是已经插入了\r\n        if (/v-copy/.test(el.className)) {\r\n          return;\r\n        }\r\n        // 创建copy组件\r\n        const C = Vue.extend(CodeCopy);\r\n        const copy = new C();\r\n        // 下面这些是组件的props以及一些私有属性\r\n        copy.copyText = copyText;\r\n        copy.code = el.textContent;\r\n        copy._parent = el;\r\n        copy.$mount();\r\n        el.className += ` v- copy`;\r\n        el.appendChild(copy.$el);\r\n      });\r\n    }\r\n  }\r\n};\r\n```\r\n\r\nOK，到这一步也完成了，下面就是怎么把代码置入剪切板了\r\n\r\n### clipboard.js\r\n\r\n- navigator.clipboard\r\n  支持异步剪贴板\r\n- document.execCommand()\r\n  兼容性比较好一些，但是只能同步剪贴板\r\n\r\n上面是两种原生的方式，不过这里因为是作为库使用，需要考虑兼容性问题，所以我选择了已经封装好的`clipboard.js`作为实现复制粘贴，下面是具体的封装方法，这一步可以跳过\r\n\r\n```js\r\nimport ClipboardJS from \"clipboard\";\r\n// 封装的剪切板事件\r\nconst btn = document.createElement(\"div\");\r\nbtn.style.display = \"none\";\r\ndocument.body.appendChild(btn);\r\n\r\nfunction setUpText(text = \"\") {\r\n  return new Promise((resolve, reject) => {\r\n    const cli = new ClipboardJS(btn, {\r\n      text() {\r\n        return text;\r\n      }\r\n    });\r\n    // 触发点击事件\\\r\n    const click = new Event(\"click\");\r\n    cli.on(\"success\", function() {\r\n      resolve(text);\r\n      // 无论成功与否都删除\r\n      cli.destroy();\r\n    });\r\n\r\n    cli.on(\"error\", function(e) {\r\n      reject(e.action);\r\n      // 无论成功与否都删除\r\n      cli.destroy();\r\n    });\r\n    btn.dispatchEvent(click);\r\n  });\r\n}\r\n\r\nexport default setUpText;\r\n```\r\n\r\nOK，到这一步基本上就完成了准备工作，下面就回归我们熟悉的 vue 组件开发了\r\n\r\n### copy.vue\r\n\r\n这一步比较简单，就是定义一些 css 属性点击按钮的时候执行`clipboard.js`就行了\r\n\r\n```vue\r\n<template>\r\n  <span>\r\n    <span ref=\"btn\" class=\"v-copy-code-btn\" @click=\"copyClick\">{{\r\n      copyText\r\n    }}</span>\r\n  </span>\r\n</template>\r\n\r\n<script>\r\nimport clipboard from \"./clipboard\";\r\nexport default {\r\n  props: {\r\n    copyText: {\r\n      type: String,\r\n      default: \"复制代码\"\r\n    },\r\n    code: String\r\n  },\r\n  methods: {\r\n    copyClick() {\r\n      clipboard(this.code);\r\n      // 执行复制具体实现省略\r\n    }\r\n  }\r\n};\r\n</script>\r\n\r\n<style>\r\n<!-- 省略 -->\r\n</style>\r\n```\r\n\r\n### 最后\r\n\r\n撒花，完成这一步之后就是将代码发布到 npm 上供大家使用，这个过程就不再描述了。\r\n\r\n最后本人目前准备找工作，有小伙伴内推一下么，不胜感激\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/bosens-China/blog/issues/41/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/bosens-China/blog/issues/41/timeline",
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/bosens-China/blog/issues/32",
    "repository_url": "https://api.github.com/repos/bosens-China/blog",
    "labels_url": "https://api.github.com/repos/bosens-China/blog/issues/32/labels{/name}",
    "comments_url": "https://api.github.com/repos/bosens-China/blog/issues/32/comments",
    "events_url": "https://api.github.com/repos/bosens-China/blog/issues/32/events",
    "html_url": "https://github.com/bosens-China/blog/issues/32",
    "id": 503866389,
    "node_id": "MDU6SXNzdWU1MDM4NjYzODk=",
    "number": 32,
    "title": "javascript专题系列之模拟实现new",
    "user": {
      "login": "bosens-China",
      "id": 39508895,
      "node_id": "MDQ6VXNlcjM5NTA4ODk1",
      "avatar_url": "https://avatars.githubusercontent.com/u/39508895?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/bosens-China",
      "html_url": "https://github.com/bosens-China",
      "followers_url": "https://api.github.com/users/bosens-China/followers",
      "following_url": "https://api.github.com/users/bosens-China/following{/other_user}",
      "gists_url": "https://api.github.com/users/bosens-China/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/bosens-China/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/bosens-China/subscriptions",
      "organizations_url": "https://api.github.com/users/bosens-China/orgs",
      "repos_url": "https://api.github.com/users/bosens-China/repos",
      "events_url": "https://api.github.com/users/bosens-China/events{/privacy}",
      "received_events_url": "https://api.github.com/users/bosens-China/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [
      {
        "id": 1602397157,
        "node_id": "MDU6TGFiZWwxNjAyMzk3MTU3",
        "url": "https://api.github.com/repos/bosens-China/blog/labels/%E4%B8%93%E9%A2%98%E7%9B%B8%E5%85%B3",
        "name": "专题相关",
        "color": "719192",
        "default": false,
        "description": "主要介绍实现的思路"
      }
    ],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 0,
    "created_at": "2019-10-08T07:03:22Z",
    "updated_at": "2019-12-18T03:12:47Z",
    "closed_at": null,
    "author_association": "OWNER",
    "active_lock_reason": null,
    "body": "> new 运算符创建一个用户定义的对象类型的实例或具有构造函数的内置对象的实例。\r\n\r\n上面的定义有点抽象，我们来通过一个例子看 new 运算符扮演的角色\r\n\r\n```js\r\nfunction Foo(name, age) {\r\n  this.name = name;\r\n  this.age = age;\r\n}\r\nFoo.prototype.getName = function() {\r\n  return this.name;\r\n};\r\nFoo.prototype.foo = \"foo\";\r\nvar f = new Foo(\"zhangsan\", 18);\r\nf.getName(); // zhangsan\r\nf.foo; // foo\r\n```\r\n\r\n上面通过 new 创建了一个新的对象，并且这个对象通过原型链访问到了原型上的方法和属性，所以 new 运算符就是执行构造函数返回一个实例对象。\r\n\r\nnew 运算符在执行时执行了下面四步：\r\n\r\n1. 创建一个空的简单 JavaScript 对象（即{}）；\r\n2. 链接该对象（即设置该对象的构造函数）到另一个对象 ；\r\n3. 将步骤 1 新创建的对象作为 this 的上下文 ；\r\n4. 如果该函数没有返回对象，则返回 this。\r\n\r\n## 实现\r\n\r\n根据上面的执行步骤我们来尝试实现下，当然 new 操作符肯定是模拟不了了，下面通过函数的形式展示\r\n\r\n```js\r\nfunction newCall(fn) {\r\n  var args = Array.prototype.slice.call(arguments, 1);\r\n  var obj = {};\r\n  obj.__proto__ = fn.prototype;\r\n  var result = fn.apply(obj, args);\r\n  return result && typeof result === \"object\" ? result : obj;\r\n}\r\n```\r\n\r\nOk，到这里就实现了一个模拟 new 的操作，我们测试一下\r\n\r\n```js\r\nfunction Otaku(name, age) {\r\n  this.name = name;\r\n  this.age = age;\r\n\r\n  this.habit = \"Games\";\r\n}\r\n\r\nOtaku.prototype.strength = 60;\r\n\r\nOtaku.prototype.sayYourName = function() {\r\n  console.log(\"I am \" + this.name);\r\n};\r\n\r\nfunction newCall(fn) {\r\n  var args = Array.prototype.slice.call(arguments, 1);\r\n  var obj = {};\r\n  obj.__proto__ = fn.prototype;\r\n  var result = fn.apply(obj, args);\r\n  return result && typeof result === \"object\" ? result : obj;\r\n}\r\n\r\nvar person = newCall(Otaku, \"Kevin\", \"18\");\r\n\r\nconsole.log(person.name); // Kevin\r\nconsole.log(person.habit); // Games\r\nconsole.log(person.strength); // 60\r\n```\r\n\r\n撒花 ✿✿ ヽ(°▽°)ノ ✿，不过额外提醒一下`__proto__`是浏览器实现的非标准属性，一般情况下不推荐使用，不过既然是模拟 es5 推荐的`Object.setPrototypeOf`肯定没办法用了，只能将就着用了\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/bosens-China/blog/issues/32/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/bosens-China/blog/issues/32/timeline",
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/bosens-China/blog/issues/22",
    "repository_url": "https://api.github.com/repos/bosens-China/blog",
    "labels_url": "https://api.github.com/repos/bosens-China/blog/issues/22/labels{/name}",
    "comments_url": "https://api.github.com/repos/bosens-China/blog/issues/22/comments",
    "events_url": "https://api.github.com/repos/bosens-China/blog/issues/22/events",
    "html_url": "https://github.com/bosens-China/blog/issues/22",
    "id": 485122259,
    "node_id": "MDU6SXNzdWU0ODUxMjIyNTk=",
    "number": 22,
    "title": "javascript专题系列之实现迭代器",
    "user": {
      "login": "bosens-China",
      "id": 39508895,
      "node_id": "MDQ6VXNlcjM5NTA4ODk1",
      "avatar_url": "https://avatars.githubusercontent.com/u/39508895?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/bosens-China",
      "html_url": "https://github.com/bosens-China",
      "followers_url": "https://api.github.com/users/bosens-China/followers",
      "following_url": "https://api.github.com/users/bosens-China/following{/other_user}",
      "gists_url": "https://api.github.com/users/bosens-China/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/bosens-China/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/bosens-China/subscriptions",
      "organizations_url": "https://api.github.com/users/bosens-China/orgs",
      "repos_url": "https://api.github.com/users/bosens-China/repos",
      "events_url": "https://api.github.com/users/bosens-China/events{/privacy}",
      "received_events_url": "https://api.github.com/users/bosens-China/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [
      {
        "id": 1602397157,
        "node_id": "MDU6TGFiZWwxNjAyMzk3MTU3",
        "url": "https://api.github.com/repos/bosens-China/blog/labels/%E4%B8%93%E9%A2%98%E7%9B%B8%E5%85%B3",
        "name": "专题相关",
        "color": "719192",
        "default": false,
        "description": "主要介绍实现的思路"
      }
    ],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 0,
    "created_at": "2019-08-26T08:47:04Z",
    "updated_at": "2019-12-18T03:12:42Z",
    "closed_at": null,
    "author_association": "OWNER",
    "active_lock_reason": null,
    "body": "> 迭代器在很多语言都很常见，js 的 forEach 就是一个迭代器，下面就来介绍实现一个支持数组、对象、类数组的的 each 函数。\r\n\r\n## 前言\r\n\r\n写之前先整理一下思路\r\n\r\n1. 我们首先需要判断是不是类数组，如果是数组和类数组就使用 for 循环，如果是对象我们就用 for...in 循环。\r\n2. 回调函数的 this 处理，返回 false 终止循环\r\n\r\n## 判断类型\r\n\r\n判断基本类型我们可以使用 `typeof`，不过对于引用类型，比如数组和函数都会返回`object`，那么还有更好的判断方法么？\r\n那就是`Object.prototype.toString`\r\n\r\n```js\r\nObject.prototype.toString.call({}); // \"[object Object]\"\r\nObject.prototype.toString.call([]); // \"[object Array]\"\r\n```\r\n\r\n这里使用`Object.prototype.toString`的原因是一些引用类型的`toString`有自己的实现方式，比如数组的 `toString` 返回的就是以`\",\"`分隔的文本。\r\n数组的判断可以基于上面方法，下面就是封装成一个函数\r\n\r\n```js\r\nfunction isArray(arr) {\r\n  return Object.prototype.toString.call(arr) === \"[object Array]\";\r\n}\r\n```\r\n\r\n下面就来实现判断类数组的的思路，类数组就是指类似于\r\n\r\n```js\r\n{1: 123, 2：45, 6: 789, length: 7}\r\n// or\r\n// nodelist[]\r\n// arguments\r\n// ...\r\n```\r\n\r\n上面列举的几种对象，都存在`length`，而且都是一个对象，所以我们以这个为判断准则，下面就是实现\r\n\r\n```js\r\nfunction isClassArray(arr) {\r\n  var length = !!arr && length in arr && arr.length;\r\n  return (\r\n    isArray(arr) ||\r\n    length === 0 ||\r\n    (typeof arr === \"number\" && length - 1 in arr)\r\n  );\r\n}\r\n```\r\n\r\n判断还是比较简洁的，判断了三种情况\r\n\r\n1. 必须有 `length` 属性\r\n2. `length` 为 0 的情况\r\n3. `length- 1`必须存在\r\n\r\n第一种就不说了，第二种为什么要判断 length 为 `0` 的情况呢？\r\n假设有一个对象`{a: 1, b: 2, length: 0}`，认为它是类数组是不是不太合适，还有`arguments`是不是类数组对象根据函数的传递参数来变化，但是如果没有参数`length`为 0 就返回 false，是不是也不太合适，其实这里主要就是为了判断一些边界的对象\r\n\r\n```js\r\nfunction foo() {\r\n  arguments.length; // 0\r\n}\r\nfoo();\r\n```\r\n\r\n第三点，为什么要求 `length - 1` 存在？\r\n数组的 length 永远是成员数+1，要求`length - 1` 存在实际上这是为了数组和类数组的形式想对应，例如：\r\n\r\n```js\r\nvar a = [, , 2]; // length: 3\r\n// 对应类数组\r\nvar obj = {\r\n  2: 2,\r\n  length: 3\r\n};\r\n```\r\n\r\n上面数组存在`,`我们认为前面两位就是空，但是如果取消了`length - 1`必须存在，那么下面这种写法会出现下面情况\r\n\r\n```js\r\n// length: 2\r\nvar a = [1, ,];\r\nvar obj = {\r\n  0: 1，\r\n  length: 1\r\n};\r\n```\r\n\r\n## each\r\n\r\n上面把所需要用的讲解完毕了，下面就来实现一个最终版的 each\r\n\r\n```js\r\nfunction isArray(arr) {\r\n  return Object.prototype.toString.call(arr) === \"[object Array]\";\r\n}\r\nfunction isClassArray(arr) {\r\n  var length = !!arr && length in arr && arr.length;\r\n  return (\r\n    isArray(arr) ||\r\n    length === 0 ||\r\n    (typeof arr === \"number\" && length - 1 in arr)\r\n  );\r\n}\r\nfunction each(obj, callback) {\r\n  if (typeof obj !== \"object\") {\r\n    return obj;\r\n  }\r\n  // 数组和类数组\r\n  if (isClassArray(obj)) {\r\n    for (let i = 0; i < obj.length; i++) {\r\n      let v = callback.call(obj, i, obj[i]);\r\n      if (v === false) {\r\n        break;\r\n      }\r\n    }\r\n  } else {\r\n    for (let item in obj) {\r\n      let v = callback.call(obj, item, obj[item]);\r\n      if (v === false) {\r\n        break;\r\n      }\r\n    }\r\n  }\r\n}\r\n```\r\n\r\n## 参考\r\n\r\n[JavaScript 专题之类型判断(下) #30](https://github.com/mqyqingfeng/Blog/issues/30)\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/bosens-China/blog/issues/22/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/bosens-China/blog/issues/22/timeline",
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/bosens-China/blog/issues/14",
    "repository_url": "https://api.github.com/repos/bosens-China/blog",
    "labels_url": "https://api.github.com/repos/bosens-China/blog/issues/14/labels{/name}",
    "comments_url": "https://api.github.com/repos/bosens-China/blog/issues/14/comments",
    "events_url": "https://api.github.com/repos/bosens-China/blog/issues/14/events",
    "html_url": "https://github.com/bosens-China/blog/issues/14",
    "id": 479671441,
    "node_id": "MDU6SXNzdWU0Nzk2NzE0NDE=",
    "number": 14,
    "title": "javascript专题系列之理解原型和原型链",
    "user": {
      "login": "bosens-China",
      "id": 39508895,
      "node_id": "MDQ6VXNlcjM5NTA4ODk1",
      "avatar_url": "https://avatars.githubusercontent.com/u/39508895?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/bosens-China",
      "html_url": "https://github.com/bosens-China",
      "followers_url": "https://api.github.com/users/bosens-China/followers",
      "following_url": "https://api.github.com/users/bosens-China/following{/other_user}",
      "gists_url": "https://api.github.com/users/bosens-China/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/bosens-China/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/bosens-China/subscriptions",
      "organizations_url": "https://api.github.com/users/bosens-China/orgs",
      "repos_url": "https://api.github.com/users/bosens-China/repos",
      "events_url": "https://api.github.com/users/bosens-China/events{/privacy}",
      "received_events_url": "https://api.github.com/users/bosens-China/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [
      {
        "id": 1602397157,
        "node_id": "MDU6TGFiZWwxNjAyMzk3MTU3",
        "url": "https://api.github.com/repos/bosens-China/blog/labels/%E4%B8%93%E9%A2%98%E7%9B%B8%E5%85%B3",
        "name": "专题相关",
        "color": "719192",
        "default": false,
        "description": "主要介绍实现的思路"
      }
    ],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 0,
    "created_at": "2019-08-12T14:17:35Z",
    "updated_at": "2019-12-18T03:12:37Z",
    "closed_at": null,
    "author_association": "OWNER",
    "active_lock_reason": null,
    "body": "> 参考： [深入理解javascript原型和闭包（完结）](https://www.cnblogs.com/wangfupeng1988/p/3977924.html)\r\n\r\nJavaScript是弱类型，除了基本类型都可以理解为对象，这也是为什么说JavaScript中一切皆对象的原因。\r\n\r\n不过在对象中函数比较特殊，对象就是由函数创造出来的，这听起来是不是有点先有鸡后有蛋，先有蛋后有鸡的感觉，这也跟后面要说到的原型有关。\r\n\r\n先说`prototype`属性，这个属性是`函数`所独有的，函数也是对象也可以在自身定义属性和方法，那这个`prototype`属性有什么用呢？\r\n``` js\r\nvar a = {};\r\na.toString();\r\n```\r\n这里我并没有为a定义toString的方法，为什么可以调用呢？就跟prototype属性有关。\r\n\r\n上面只是简写，如果通过构造函数是这样的\r\n``` js\r\nvar a = new Object();\r\na.toString();\r\n```\r\n![https://pic1.zhimg.com/80/v2-038c5818398efc6b4e990b3c2fb3b54c_hd.jpg](https://pic1.zhimg.com/80/v2-038c5818398efc6b4e990b3c2fb3b54c_hd.jpg)\r\n这里可以看到toString的方法，这也是为什么没有定义却没有报错的原因。\r\n\r\n一个对象通过构造函数生成会执行下面四个步骤\r\n1. 创建一个新对象，作为要返回的实例\r\n2. 将新对象的原型（__proto__）指向构造函数的`prototype`属性\r\n3. 将内部的this指向新对象\r\n4. 执行内部代码，如果没有执行返回对象，则返回`this`（新对象）\r\n\r\n从上面可以看到，对象的原型会指向生成对象函数的`prototype`属性，对象本身如果没有属性或者方法，会向原型链查找，如果没有找到会一直找到`Object.prototype`属性上，如果还没有找到就会返回`undefined`。\r\n`Object.prototype`属性上还有原型链么？答案是有，是`Null`。\r\n\r\n上面简短的说了一下，下面通过例子的形式来结合\r\n\r\n## 示例\r\n``` js\r\nvar a = {};\r\n```\r\n这里我定义了一个对象a，根据上面说的每个对象都有一个原型，执行构造函数的`prototype`下面就是原型图。\r\n![https://pic4.zhimg.com/80/v2-c93843e5905a3990c0b1147d0dad7f03_hd.jpg](https://pic4.zhimg.com/80/v2-c93843e5905a3990c0b1147d0dad7f03_hd.jpg)\r\n上面就是一个简单的原型图，下面说一下`constructor`属性，这个属性有什么作用呢？\r\n`constructor`是`prototype`对象下的一个属性，他指向一个函数，与函数的相互依存，还是通过上面变量a来说明吧。\r\n![https://pic1.zhimg.com/80/v2-94e4180728a52844d1204a830249c10c_hd.jpg](https://pic1.zhimg.com/80/v2-94e4180728a52844d1204a830249c10c_hd.jpg)\r\n\r\n可以看到，通过`constructor`可以访问到构造函数，这个属性通常没有什么用，不过可以通用这个属性调用一些构造函数所独有的方法，比如`Date`函数的`now`方法\r\n``` js\r\nvar a = new Date();\r\na.__proto__.constructor.now();\r\n```\r\n这里为了方便演示使用了`_proto_`，不过在实际中不要这样写，因为这个属性只有浏览器才部署。\r\n![https://pic3.zhimg.com/80/v2-3ee04ff512a68800c014b66de0f6b3f2_hd.jpg](https://pic3.zhimg.com/80/v2-3ee04ff512a68800c014b66de0f6b3f2_hd.jpg)\r\n说了这么多，最后根据一张图，来总结一下。\r\n\r\n首先对象是由构造函数创建的（Object），你可能有疑问，函数也是对象，那么函数的`__proto__`指向什么？\r\n答案是`Function.prototype`，所有函数都是由`Fcuntion`创建的，举个例子\r\n``` js\r\nvar a = new Function('a', 'b', 'return a + b');\r\na(1, 2);\r\n```\r\n这里a的`__proto__`等于`Function.prototype`，之前说过prototype是一个对象，所以`Function.prototype`指向`Object.prototype`。\r\n最后说一点，`Function.__proto__`指向的是`Function`自身，他是唯一一个通过自身生成函数的例子，这里只需要了解一下。\r\n\r\n## 最后\r\n说了这么多，原型链好像还没有被提起，每个对象都有自己的原型，原型的对象也是对象，一方面对象可以作为另一个对象的原型，这样层层链接起来的原型就成为原型链。\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/bosens-China/blog/issues/14/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/bosens-China/blog/issues/14/timeline",
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/bosens-China/blog/issues/13",
    "repository_url": "https://api.github.com/repos/bosens-China/blog",
    "labels_url": "https://api.github.com/repos/bosens-China/blog/issues/13/labels{/name}",
    "comments_url": "https://api.github.com/repos/bosens-China/blog/issues/13/comments",
    "events_url": "https://api.github.com/repos/bosens-China/blog/issues/13/events",
    "html_url": "https://github.com/bosens-China/blog/issues/13",
    "id": 479666633,
    "node_id": "MDU6SXNzdWU0Nzk2NjY2MzM=",
    "number": 13,
    "title": "javascript专题系列之相等(==)运算符的转换规则",
    "user": {
      "login": "bosens-China",
      "id": 39508895,
      "node_id": "MDQ6VXNlcjM5NTA4ODk1",
      "avatar_url": "https://avatars.githubusercontent.com/u/39508895?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/bosens-China",
      "html_url": "https://github.com/bosens-China",
      "followers_url": "https://api.github.com/users/bosens-China/followers",
      "following_url": "https://api.github.com/users/bosens-China/following{/other_user}",
      "gists_url": "https://api.github.com/users/bosens-China/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/bosens-China/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/bosens-China/subscriptions",
      "organizations_url": "https://api.github.com/users/bosens-China/orgs",
      "repos_url": "https://api.github.com/users/bosens-China/repos",
      "events_url": "https://api.github.com/users/bosens-China/events{/privacy}",
      "received_events_url": "https://api.github.com/users/bosens-China/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [
      {
        "id": 1602397157,
        "node_id": "MDU6TGFiZWwxNjAyMzk3MTU3",
        "url": "https://api.github.com/repos/bosens-China/blog/labels/%E4%B8%93%E9%A2%98%E7%9B%B8%E5%85%B3",
        "name": "专题相关",
        "color": "719192",
        "default": false,
        "description": "主要介绍实现的思路"
      }
    ],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 0,
    "created_at": "2019-08-12T14:08:20Z",
    "updated_at": "2019-12-18T03:12:24Z",
    "closed_at": null,
    "author_association": "OWNER",
    "active_lock_reason": null,
    "body": "> 看《你所不知道的JavaScript》一书，发现对相等运算符的描述推翻了许多人的固有影响，如果熟悉其机制，可以方便我们快速开发\r\n``` js\r\nfunction foo(s) {\r\n  s = s == null ?  true: s;\r\n  // ...\r\n};\r\n```\r\n上面这段代码我们估计经常使用，其实就是使用了隐式转换，下面就来聊聊相等运算符\r\n\r\n## 规则\r\n1. 数值与字符串比较，转化为数值比较\r\n``` js\r\n42 == \"42\";\r\n// 等于\r\n42 == Number(\"42\");\r\n```\r\n2. 布尔型与其他类型比较，转化为数值，之后比较\r\n``` js\r\n\"42\" == true;\r\n// 等于\r\n\"42\" == Number(true);\r\n\"42\" == 1;\r\nNumber(\"42\") == 1;\r\n```\r\n3. undefined 只与 null 相等，其他返回 false\r\n``` js\r\n// 全部false\r\nnull == false;\r\nnull == true;\r\nnull == \"\";\r\nnull == 0;\r\nundefined == true;\r\nundefined == false;\r\nundefined == \"\";\r\nundefined == 0;\r\n```\r\n4. 对象\r\n对象与基本类型比较，会将对象转化为基本类型之后再进行比较；\r\n转化规则很简单，默认调用 `valueOf`，如果返回不是基本类型继续调用 `toStirng`，如果返回还不是基本类型会报错。\r\n``` js\r\n[42] == 42;\r\n// 等于\r\n\"42\" == 42;\r\nNumber(\"42\") == 42;\r\n\r\n\"abc\" == new String(\"abc\");\r\n// 等于\r\n\"abc\" == \"abc\";\r\n```\r\n根据对象转化规则，我们自定义返回的值，比如：\r\n``` js\r\nvar a = [];\r\na.valueOf = function() {\r\n  return 42;\r\n};\r\na.toString = function() {\r\n  return \"123\";\r\n};\r\na == 42; //true\r\n```\r\n\r\n## 实战\r\n上面简单介绍了一下规则，再来看一下隐形的问题\r\n1. [] = ![]\r\n这里会返回 true 原因很简单，根据上述规则其实也就是\"\" == 0比较\r\n2. 0 == '\\n' \r\n这里会返回 true，因为空格和一些其他制表符会被忽略掉。 再来看一些常见的陷阱\r\n``` js\r\n\"0\" == false; // true\r\nfalse == 0; // true\r\nfalse == \"\"; // true\r\nfalse == []; // true\r\n\"\" == []; // true\r\n0 == []; // true\r\n\"\" == 0; // true\r\n```\r\n3. [null] == \"\"\r\n这里为true，可能你在想[null]返回的不就是字符串 null 么，不过很遗憾，**null 和 undefined，在数组中转化为字符串为\"\"**，这是 JavaScript 所规定的。\r\n``` js\r\n[null] == \"\";\r\n// 转化为\r\n\"\" == \"\";\r\n```\r\n\r\n## 最后\r\n``` js\r\n// a可能为true执行下去么\r\nif (a == 2 && a == 3) {\r\n  // 执行里面的代码\r\n}\r\n```",
    "reactions": {
      "url": "https://api.github.com/repos/bosens-China/blog/issues/13/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/bosens-China/blog/issues/13/timeline",
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/bosens-China/blog/issues/11",
    "repository_url": "https://api.github.com/repos/bosens-China/blog",
    "labels_url": "https://api.github.com/repos/bosens-China/blog/issues/11/labels{/name}",
    "comments_url": "https://api.github.com/repos/bosens-China/blog/issues/11/comments",
    "events_url": "https://api.github.com/repos/bosens-China/blog/issues/11/events",
    "html_url": "https://github.com/bosens-China/blog/issues/11",
    "id": 479656673,
    "node_id": "MDU6SXNzdWU0Nzk2NTY2NzM=",
    "number": 11,
    "title": "javascript专题系列之变量提升知多少",
    "user": {
      "login": "bosens-China",
      "id": 39508895,
      "node_id": "MDQ6VXNlcjM5NTA4ODk1",
      "avatar_url": "https://avatars.githubusercontent.com/u/39508895?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/bosens-China",
      "html_url": "https://github.com/bosens-China",
      "followers_url": "https://api.github.com/users/bosens-China/followers",
      "following_url": "https://api.github.com/users/bosens-China/following{/other_user}",
      "gists_url": "https://api.github.com/users/bosens-China/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/bosens-China/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/bosens-China/subscriptions",
      "organizations_url": "https://api.github.com/users/bosens-China/orgs",
      "repos_url": "https://api.github.com/users/bosens-China/repos",
      "events_url": "https://api.github.com/users/bosens-China/events{/privacy}",
      "received_events_url": "https://api.github.com/users/bosens-China/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [
      {
        "id": 1602397157,
        "node_id": "MDU6TGFiZWwxNjAyMzk3MTU3",
        "url": "https://api.github.com/repos/bosens-China/blog/labels/%E4%B8%93%E9%A2%98%E7%9B%B8%E5%85%B3",
        "name": "专题相关",
        "color": "719192",
        "default": false,
        "description": "主要介绍实现的思路"
      }
    ],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 0,
    "created_at": "2019-08-12T13:49:40Z",
    "updated_at": "2019-12-18T03:12:11Z",
    "closed_at": null,
    "author_association": "OWNER",
    "active_lock_reason": null,
    "body": "> 这里只是用伪代码的形式来说明，实际上变量声明只是执行上下文有关，推荐阅读[\r\nJavaScript深入之变量对象](https://github.com/mqyqingfeng/Blog/issues/5)\r\n\r\n## 太长不看篇\r\n函数参数 > 函数声明 > 变量声明\r\n\r\n## 变量声明\r\n首先想用一个伪生命周期来说这个事情，假设这段代码分为两个阶段，初始化阶段和赋值阶段； 看下面一段代码，用伪系统的话来阐述\r\n``` js\r\nconsole.log(a);\r\nvar a = 10;\r\n```\r\n如果按照上面的声明周期来说，首先变量 a 会在作用域注册一个变量(如果没有)默认赋值为 `undefined`\r\n\r\n初始化完成后，开始执行代码，第一行语句的时候因为变量 a 未经过赋值阶段，这一阶段的值是 `ndefined`，所以打印的结果自然也就是 `undefined`;\r\n\r\n在第二行的时候变量 a 会经过赋值阶段，这时变量 a 的值就是 10 了。\r\n\r\n## 函数声明\r\n函数声明与变量声明规则基本一致，优先级比变量声明要高\r\n\r\n是不是只说这一句话大家有些失望，如果只是单独来说函数声明未免太没意思，下面就结合变量声明来说说函数声明，毕竟代码只有变量声明就做不到有趣了。\r\n``` js\r\na();\r\nvar a = 10;\r\nfunction a() {\r\n  console.log(5);\r\n}\r\n```\r\n上面的执行结果是打印数字 5，为什么会出现这种情况呢？上面我们已经说了函数声明优先于变量声明，那么上面代码实际可以拆封成下面形式\r\n``` js\r\nfunction a() {\r\n  // ...\r\n}\r\na();\r\na = 10;\r\n```\r\n你可能还有疑惑，事实上如果变量提升的时候发现已经存在变量就会默默忽略掉，比如上面的代码变量 a 已经是一个函数了，那么变量声明的 a 会被忽略。\r\n\r\n最后说下函数参数，参数也是变量的一种形式，它的优先级最高，但是同样会受到函数声明的影响\r\n``` js\r\nfunction a(x) {\r\n  console.log(x);\r\n  function x() {}\r\n}\r\na(5);\r\n```\r\n这里输出结果是函数 x，原因是函数声明提升的时候会执行一个覆盖操作，就像我们写代码`x = 5`这样\r\n\r\n## 最后\r\n这里说的有很多地方不足，只是自己的见解，更推荐一篇文章[10 分钟理解执行上下文](https://zhuanlan.zhihu.com/p/25879753)\r\n\r\n最后根据上面的内容讲解一下他布置的一到题目\r\n``` js\r\nconsole.log(x);\r\nvar x = 10;\r\n\r\nconsole.log(x);\r\nx = 20;\r\n\r\nfunction x() {}\r\nconsole.log(x);\r\n\r\nif (true) {\r\n  var a = 1;\r\n} else {\r\n  var b = true;\r\n}\r\n\r\nconsole.log(a);\r\nconsole.log(b);\r\n```\r\n首先初始化阶段，`function x` 最先被提升，后面的变量提升因为已经存在函数 x 的原因会被忽略 第一个 console 输出的是函数` x`，\r\n\r\n之后执行到第二行代码的时候 `x` 被改变变成` 10`，第二个 `console` 输出为 `10`，之后继续被赋值为 `20`，第三个` console` 输出为 `20`，\r\n\r\n第四个和第五个 `console` 的输出分别为 `1` 和` undefined`，这是因为 es5 的环境下并不存在块级作用域，变量 `a` 和 `b` 会执行变量提升这一步骤， \r\n不同的是 `a` 被赋值为了 `1`，而 `b` 因为没有执行到 `var b = true` 所以值还是 `undefined`。",
    "reactions": {
      "url": "https://api.github.com/repos/bosens-China/blog/issues/11/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/bosens-China/blog/issues/11/timeline",
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/bosens-China/blog/issues/5",
    "repository_url": "https://api.github.com/repos/bosens-China/blog",
    "labels_url": "https://api.github.com/repos/bosens-China/blog/issues/5/labels{/name}",
    "comments_url": "https://api.github.com/repos/bosens-China/blog/issues/5/comments",
    "events_url": "https://api.github.com/repos/bosens-China/blog/issues/5/events",
    "html_url": "https://github.com/bosens-China/blog/issues/5",
    "id": 479484473,
    "node_id": "MDU6SXNzdWU0Nzk0ODQ0NzM=",
    "number": 5,
    "title": "javascript专题系列之实现一个节流函数",
    "user": {
      "login": "bosens-China",
      "id": 39508895,
      "node_id": "MDQ6VXNlcjM5NTA4ODk1",
      "avatar_url": "https://avatars.githubusercontent.com/u/39508895?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/bosens-China",
      "html_url": "https://github.com/bosens-China",
      "followers_url": "https://api.github.com/users/bosens-China/followers",
      "following_url": "https://api.github.com/users/bosens-China/following{/other_user}",
      "gists_url": "https://api.github.com/users/bosens-China/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/bosens-China/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/bosens-China/subscriptions",
      "organizations_url": "https://api.github.com/users/bosens-China/orgs",
      "repos_url": "https://api.github.com/users/bosens-China/repos",
      "events_url": "https://api.github.com/users/bosens-China/events{/privacy}",
      "received_events_url": "https://api.github.com/users/bosens-China/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [
      {
        "id": 1602397157,
        "node_id": "MDU6TGFiZWwxNjAyMzk3MTU3",
        "url": "https://api.github.com/repos/bosens-China/blog/labels/%E4%B8%93%E9%A2%98%E7%9B%B8%E5%85%B3",
        "name": "专题相关",
        "color": "719192",
        "default": false,
        "description": "主要介绍实现的思路"
      }
    ],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 0,
    "created_at": "2019-08-12T06:23:18Z",
    "updated_at": "2019-12-18T03:11:58Z",
    "closed_at": null,
    "author_association": "OWNER",
    "active_lock_reason": null,
    "body": "本来打算从零写一个，不过意外看到一篇好文，下面就根据他的思路来实现一个节流，[JavaScript专题之跟着 underscore 学节流 ](https://github.com/mqyqingfeng/Blog/issues/26)\r\n\r\n## 前言\r\n节流有两种实现，第一种使用定时器，另外一种则是根据时间戳，判断两次执行的时间间隔，下面简单些一下这两种的实现。\r\n- 定时器\r\n``` js\r\nfunction throttle(fn, time) {\r\n  let timing = null;\r\n  return function(...rest) {\r\n    if(!timing) {\r\n      timing = setTimeout(() => {\r\n        timing = null;\r\n        fn.apply(this, rest);\r\n      }, time);\r\n    }\r\n  };\r\n};\r\n```\r\n- 时间戳\r\n``` js\r\nfunction throttle (fn, time) {\r\n  let times = 0;\r\n  return function (...rest) {\r\n    const s = time - (new Date().getTime() - times)\r\n    if (s <= 0) {\r\n      times = new Date().getTime();\r\n      fn.apply(this, rest);\r\n    }\r\n  };\r\n};\r\n```\r\n下面就是将两者结合起来\r\n\r\n## 节流\r\n``` js\r\n// 节流\r\n// initial初始立即执行，front最后执行一次\r\nfunction throttle (fn, time, { initial = true, front = false } = {}) {\r\n  // 上一次执行时间\r\n  let times = 0;\r\n  // 定时器\r\n  let timing = null;\r\n  function next (...args) {\r\n    // 判断条件，如果不是初始执行，改用定时器方法执行\r\n    if (!initial && !times) {\r\n      times = new Date().getTime();\r\n    }\r\n    const now = time - (new Date().getTime() - times);\r\n    // now > time是判断更改系统时间的边界问题，now正常情况下，肯定小于time\r\n    if (now <= 0 || now > time) {\r\n      if (!timing) {\r\n        clearTimeout(timing);\r\n        timing = null;\r\n      }\r\n      times = new Date().getTime();\r\n      fn.apply(this, args);\r\n      // 清理一下内存\r\n      if (!timing) {\r\n        args = null;\r\n      }\r\n    } else if (!timing && front) {\r\n      timing = setTimeout(() => {\r\n        timing = null;\r\n        times = initial ? 0 : new Date().getTime();\r\n        fn.apply(this, args);\r\n        if (!timing) {\r\n          args = null;\r\n        }\r\n      }, time);\r\n    }\r\n  }\r\n  // 取消\r\n  next.cancel = function () {\r\n    clearTimeout(timing);\r\n    timing = null;\r\n    // 为0即可，上面有初始判断条件\r\n    times = 0;\r\n  };\r\n  return next;\r\n};\r\n```\r\n## 注意\r\n上面有两个参数，但是不能同时设置为false",
    "reactions": {
      "url": "https://api.github.com/repos/bosens-China/blog/issues/5/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/bosens-China/blog/issues/5/timeline",
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/bosens-China/blog/issues/3",
    "repository_url": "https://api.github.com/repos/bosens-China/blog",
    "labels_url": "https://api.github.com/repos/bosens-China/blog/issues/3/labels{/name}",
    "comments_url": "https://api.github.com/repos/bosens-China/blog/issues/3/comments",
    "events_url": "https://api.github.com/repos/bosens-China/blog/issues/3/events",
    "html_url": "https://github.com/bosens-China/blog/issues/3",
    "id": 475021768,
    "node_id": "MDU6SXNzdWU0NzUwMjE3Njg=",
    "number": 3,
    "title": "javascript专题系列之从零实现一个防抖函数",
    "user": {
      "login": "bosens-China",
      "id": 39508895,
      "node_id": "MDQ6VXNlcjM5NTA4ODk1",
      "avatar_url": "https://avatars.githubusercontent.com/u/39508895?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/bosens-China",
      "html_url": "https://github.com/bosens-China",
      "followers_url": "https://api.github.com/users/bosens-China/followers",
      "following_url": "https://api.github.com/users/bosens-China/following{/other_user}",
      "gists_url": "https://api.github.com/users/bosens-China/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/bosens-China/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/bosens-China/subscriptions",
      "organizations_url": "https://api.github.com/users/bosens-China/orgs",
      "repos_url": "https://api.github.com/users/bosens-China/repos",
      "events_url": "https://api.github.com/users/bosens-China/events{/privacy}",
      "received_events_url": "https://api.github.com/users/bosens-China/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [
      {
        "id": 1602397157,
        "node_id": "MDU6TGFiZWwxNjAyMzk3MTU3",
        "url": "https://api.github.com/repos/bosens-China/blog/labels/%E4%B8%93%E9%A2%98%E7%9B%B8%E5%85%B3",
        "name": "专题相关",
        "color": "719192",
        "default": false,
        "description": "主要介绍实现的思路"
      }
    ],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 0,
    "created_at": "2019-07-31T09:01:16Z",
    "updated_at": "2019-12-18T03:11:53Z",
    "closed_at": null,
    "author_association": "OWNER",
    "active_lock_reason": null,
    "body": "## 前言\r\n\r\n1. 为什么需要使用防抖函数\r\n   当一个事件触发太多的时候会出现性能问题，比如`mousemove`、`resize`、`scroll`等，看一个没有任何防抖的`mousemove`事件\r\n\r\n![1](https://user-images.githubusercontent.com/39508895/62198507-526ef780-b3b4-11e9-8019-21e510329930.gif)\r\n\r\n2. 什么是防抖?\r\n   简单就是你任意触发我只执行最后一次操作\r\n\r\n根据上面的定义可以很轻松编写出一个简单的防抖函数\r\n\r\n### 实现\r\n\r\n```js\r\n// 第一版\r\nfunction antiShake(call, time) {\r\n  var i = null;\r\n  return function() {\r\n    clearTimeout(i);\r\n    i = setTimeout(call, time);\r\n  };\r\n}\r\n```\r\n\r\n![2](https://user-images.githubusercontent.com/39508895/62198572-77fc0100-b3b4-11e9-8ad5-a46ac6a5a2e1.gif)\r\n\r\n### this 以及参数\r\n\r\n不过这样有一个问题，就是 this 指向不正确以及参数丢失，这里以`mousemove`为例，触发函数的时候会有一个`MouseEvent`对象，如果打印函数参数会发现为`undefined`，下面就来修复一下\r\n\r\n```js\r\n//  第二版\r\nfunction antiShake(call, time) {\r\n  var i = null;\r\n  return function() {\r\n    var that = this;\r\n    var rest = arguments;\r\n    clearTimeout(i);\r\n    i = setTimeout(function() {\r\n      call.apply(that, rest);\r\n    }, time);\r\n  };\r\n}\r\n```\r\n\r\n### 立即执行\r\n\r\n有时候我不想让他等待时间结束在执行，而是一开始就触发\r\n![4](https://user-images.githubusercontent.com/39508895/62198651-99f58380-b3b4-11e9-9fbc-78e805b13910.gif)\r\n\r\n```js\r\n// 第三版\r\nfunction antiShake(call, time, immediately) {\r\n  var i = null;\r\n  return function() {\r\n    var that = this;\r\n    var rest = arguments;\r\n    clearTimeout(i);\r\n    if (immediately) {\r\n      var reversal = !i;\r\n      i = setTimeout(function() {\r\n        i = null;\r\n      }, time);\r\n\r\n      if (reversal) {\r\n        call.apply(that, rest);\r\n      }\r\n    } else {\r\n      i = setTimeout(function() {\r\n        call.apply(that, rest);\r\n      }, time);\r\n    }\r\n  };\r\n}\r\n```\r\n\r\n### 返回值\r\n\r\n异步执行的函数我们没办法同步返回他的值，但是对于立即执行的函数，我们应当把值返回\r\n\r\n```js\r\n// 第四版\r\nfunction antiShake(call, time, immediately) {\r\n  var i = null;\r\n  return function() {\r\n    var that = this;\r\n    var rest = arguments;\r\n    clearTimeout(i);\r\n    if (immediately) {\r\n      var reversal = !i;\r\n      i = setTimeout(function() {\r\n        i = null;\r\n      }, time);\r\n\r\n      if (reversal) {\r\n        return call.apply(that, rest);\r\n      }\r\n    } else {\r\n      i = setTimeout(function() {\r\n        call.apply(that, rest);\r\n      }, time);\r\n    }\r\n  };\r\n}\r\n```\r\n\r\n### 取消\r\n\r\n到这里基本上防抖函数就基本写完了，上述我们用`mousemove`事件举例，但是我想当鼠标移开的时候我想取消这个事件，这也是正常的需求，下面就来实现取消功能\r\n\r\n```js\r\nfunction antiShake(call, time, immediately) {\r\n  var i = null;\r\n  function _private() {\r\n    var that = this;\r\n    var rest = arguments;\r\n    clearTimeout(i);\r\n    if (immediately) {\r\n      var reversal = !i;\r\n      i = setTimeout(function() {\r\n        i = null;\r\n      }, time);\r\n\r\n      if (reversal) {\r\n        return call.apply(that, rest);\r\n      }\r\n    } else {\r\n      i = setTimeout(function() {\r\n        call.apply(that, rest);\r\n      }, time);\r\n    }\r\n  }\r\n  _private.cancel = function() {\r\n    clearTimeout(i);\r\n    i = null;\r\n  };\r\n  return _private;\r\n}\r\n```\r\n\r\n![5](https://user-images.githubusercontent.com/39508895/62198673-a5e14580-b3b4-11e9-9ced-acc7814031dc.gif)\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/bosens-China/blog/issues/3/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/bosens-China/blog/issues/3/timeline",
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/bosens-China/blog/issues/31",
    "repository_url": "https://api.github.com/repos/bosens-China/blog",
    "labels_url": "https://api.github.com/repos/bosens-China/blog/issues/31/labels{/name}",
    "comments_url": "https://api.github.com/repos/bosens-China/blog/issues/31/comments",
    "events_url": "https://api.github.com/repos/bosens-China/blog/issues/31/events",
    "html_url": "https://github.com/bosens-China/blog/issues/31",
    "id": 503856924,
    "node_id": "MDU6SXNzdWU1MDM4NTY5MjQ=",
    "number": 31,
    "title": "javascript专题系列之模拟实现bind",
    "user": {
      "login": "bosens-China",
      "id": 39508895,
      "node_id": "MDQ6VXNlcjM5NTA4ODk1",
      "avatar_url": "https://avatars.githubusercontent.com/u/39508895?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/bosens-China",
      "html_url": "https://github.com/bosens-China",
      "followers_url": "https://api.github.com/users/bosens-China/followers",
      "following_url": "https://api.github.com/users/bosens-China/following{/other_user}",
      "gists_url": "https://api.github.com/users/bosens-China/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/bosens-China/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/bosens-China/subscriptions",
      "organizations_url": "https://api.github.com/users/bosens-China/orgs",
      "repos_url": "https://api.github.com/users/bosens-China/repos",
      "events_url": "https://api.github.com/users/bosens-China/events{/privacy}",
      "received_events_url": "https://api.github.com/users/bosens-China/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [
      {
        "id": 1602397157,
        "node_id": "MDU6TGFiZWwxNjAyMzk3MTU3",
        "url": "https://api.github.com/repos/bosens-China/blog/labels/%E4%B8%93%E9%A2%98%E7%9B%B8%E5%85%B3",
        "name": "专题相关",
        "color": "719192",
        "default": false,
        "description": "主要介绍实现的思路"
      }
    ],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 0,
    "created_at": "2019-10-08T06:35:47Z",
    "updated_at": "2019-12-18T03:11:32Z",
    "closed_at": null,
    "author_association": "OWNER",
    "active_lock_reason": null,
    "body": "之前说了[模拟实现 call 和 apply](https://github.com/bosens-China/blog/issues/30)，下面就来实现 bind，首先先看一下定义 bind 定义\r\n\r\n> bind()方法创建一个新的函数，在 bind()被调用时，这个新函数的 this 被 bind 的第一个参数指定，其余的参数将作为新函数的参数供调用时使用。\r\n\r\n## 第一版\r\n\r\n根据定义我们尝试写一下\r\n\r\n```js\r\nFunction.prototype.binds = function(con) {\r\n  var fn = this;\r\n  var args = Array.prototype.slice.call(arguments, 1);\r\n  return function() {\r\n    return fn.apply(con, args);\r\n  };\r\n};\r\n```\r\n\r\n我们来测试一下上面的函数\r\n\r\n```js\r\nvar obj = {\r\n  value: \"zhangsan\"\r\n};\r\nfunction foo(name, age) {\r\n  console.log(this.value); //zhangsan\r\n  console.log(name); // name\r\n  console.log(age); // undefined\r\n}\r\nvar f = foo.binds(obj, \"name\");\r\nf(19);\r\n```\r\n\r\n`age` 输出的跟我们预期的不太一致，这是因为我们没有处理返回函数的参数，用 concat 把参数合并在一起就可以了。\r\n\r\n```js\r\nFunction.prototype.binds = function(con) {\r\n  var fn = this;\r\n  var args = Array.prototype.slice.call(arguments, 1);\r\n  return function() {\r\n    return fn.apply(con, args.concat(Array.prototype.slice.call(arguments)));\r\n  };\r\n};\r\n```\r\n\r\n## 第二版\r\n\r\n上面简单实现了函数的 bind，不过我们来看一下 bind 与构造函数相遇会怎么样\r\n\r\n```js\r\nvar obj = {\r\n  value: \"zhangsan\"\r\n};\r\nfunction Foo(name, age) {\r\n  console.log(this.value); //undefined\r\n  console.log(name);\r\n  console.log(age);\r\n}\r\nvar f = Foo.bind(obj, \"name\");\r\nnew f(19);\r\n```\r\n\r\n上面 `this.value` 的输出为 `undefined`，这是因为 **调用绑定函数时作为 this 参数传递给目标函数的值。 如果使用 new 运算符构造绑定函数，则忽略该值**。\r\n\r\n另外作为构造函数是可以获取到绑定 bind 函数的 `prototype` 的\r\n\r\n```js\r\nfunction Foo() {\r\n  console.log(this.gender); //male\r\n}\r\nFoo.prototype.gender = \"male\";\r\nvar f = Foo.bind(null, \"name\");\r\nnew f();\r\n```\r\n\r\n下面就是来实现上面两点：\r\n\r\n- 怎么来判断是否通过 new 来调用呢？可以通过`instanceof`\r\n\r\n```js\r\nfunction Foo() {\r\n  if (!(this instanceof Foo)) {\r\n    throw Error(\"请通过new调用\");\r\n  }\r\n}\r\nFoo();\r\n```\r\n\r\n- 继承的话我们可以通过寄生组合式继承，这类文章比较多，这里就简单举一个例子\r\n\r\n```js\r\nfunction create(con) {\r\n  var f = function() {};\r\n  f.prototype = con;\r\n  return new f();\r\n}\r\nfunction Par(name) {\r\n  this.name = name;\r\n}\r\nPar.prototype.getName = function() {\r\n  return this.name;\r\n};\r\nfunction Chi(name, age) {\r\n  Par.call(this, name);\r\n  this.age = age;\r\n}\r\nChi.prototype = create(Par.prototype);\r\nChi.prototype.constructor = Chi;\r\nChi.prototype.getDetails = function() {\r\n  var n = this.getName();\r\n  console.log(n, this.age);\r\n};\r\nvar d = new Chi(\"zhangsan\", 16);\r\nd.getDetails();\r\n```\r\n\r\nOK，上面两点解决后我们再来实现一版\r\n\r\n```js\r\nFunction.prototype.binds = function(con) {\r\n  var fn = this;\r\n  var args = Array.prototype.slice.call(arguments, 1);\r\n  var f = function() {};\r\n  if (this.prototype) {\r\n    f.prototype = this.prototype;\r\n  }\r\n  var result = function() {\r\n    return fn.apply(\r\n      this instanceof result ? this : con,\r\n      args.concat(Array.prototype.slice.call(arguments))\r\n    );\r\n  };\r\n  result.prototype = new f();\r\n  return result;\r\n};\r\n```\r\n\r\n## 优化\r\n\r\n观察上面的不难发现 bind 调用的必须是函数，而通过继承我们可能会调用到 bind 所以这里显示报错一下\r\n\r\n```js\r\nvar obj = Object.create(Function.prototype);\r\nconsole.log(obj.bind);\r\n```\r\n\r\n另外对于我们上面定义的`binds`肯定不太优雅，污染了命名空间，这里可以判断一下如果存在 `bind` 就用 `bind` 否则在定义\r\n\r\n## 最终\r\n\r\n```js\r\nif (!Function.prototype.bind) {\r\n  Function.prototype.bind = function(con) {\r\n    if (typeof this !== \"function\") {\r\n      throw new TypeError(\r\n        \"Function.prototype.bind - what is trying to be bound is not callable\"\r\n      );\r\n    }\r\n    var fn = this;\r\n    var args = Array.prototype.slice.call(arguments, 1);\r\n    var f = function() {};\r\n    if (this.prototype) {\r\n      f.prototype = this.prototype;\r\n    }\r\n    var result = function() {\r\n      return fn.apply(\r\n        this instanceof result ? this : con,\r\n        args.concat(Array.prototype.slice.call(arguments))\r\n      );\r\n    };\r\n    result.prototype = new f();\r\n    return result;\r\n  };\r\n}\r\n```\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/bosens-China/blog/issues/31/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/bosens-China/blog/issues/31/timeline",
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/bosens-China/blog/issues/30",
    "repository_url": "https://api.github.com/repos/bosens-China/blog",
    "labels_url": "https://api.github.com/repos/bosens-China/blog/issues/30/labels{/name}",
    "comments_url": "https://api.github.com/repos/bosens-China/blog/issues/30/comments",
    "events_url": "https://api.github.com/repos/bosens-China/blog/issues/30/events",
    "html_url": "https://github.com/bosens-China/blog/issues/30",
    "id": 503803775,
    "node_id": "MDU6SXNzdWU1MDM4MDM3NzU=",
    "number": 30,
    "title": "javascript专题系列之模拟实现call和apply",
    "user": {
      "login": "bosens-China",
      "id": 39508895,
      "node_id": "MDQ6VXNlcjM5NTA4ODk1",
      "avatar_url": "https://avatars.githubusercontent.com/u/39508895?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/bosens-China",
      "html_url": "https://github.com/bosens-China",
      "followers_url": "https://api.github.com/users/bosens-China/followers",
      "following_url": "https://api.github.com/users/bosens-China/following{/other_user}",
      "gists_url": "https://api.github.com/users/bosens-China/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/bosens-China/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/bosens-China/subscriptions",
      "organizations_url": "https://api.github.com/users/bosens-China/orgs",
      "repos_url": "https://api.github.com/users/bosens-China/repos",
      "events_url": "https://api.github.com/users/bosens-China/events{/privacy}",
      "received_events_url": "https://api.github.com/users/bosens-China/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [
      {
        "id": 1602397157,
        "node_id": "MDU6TGFiZWwxNjAyMzk3MTU3",
        "url": "https://api.github.com/repos/bosens-China/blog/labels/%E4%B8%93%E9%A2%98%E7%9B%B8%E5%85%B3",
        "name": "专题相关",
        "color": "719192",
        "default": false,
        "description": "主要介绍实现的思路"
      }
    ],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 0,
    "created_at": "2019-10-08T03:31:31Z",
    "updated_at": "2019-12-18T03:11:18Z",
    "closed_at": null,
    "author_association": "OWNER",
    "active_lock_reason": null,
    "body": "> call() 方法使用一个指定的 this 值和单独给出的一个或多个参数来调用一个函数\r\n\r\n上面是 call 的定义，apply 与 call 类似只是第二个参数是一个数组而 call 接收的则是一个参数列表。\r\n\r\n看一个例子\r\n\r\n```js\r\nvar obj = {\r\n  name: \"obj\"\r\n};\r\nfunction foo() {\r\n  return this.name;\r\n}\r\nfoo.call(obj); //obj\r\n```\r\n\r\n上面通过 call 改变了 this 的指向，下面就是模拟实现\r\n\r\n## 实现\r\n\r\ncall 和 apply 是 es5 的方法，既然是模拟实现那肯定不能用 es5 方法了，我们先分析一下怎么来指定 this，this 跟动态作用域类似是在执行时确定，那我们在指定 this 的属性上添加一个方法并且执行，那么这个方法的 this 就是指定 this\r\n\r\n```js\r\nvar obj = {\r\n  name: \"obj\",\r\n  foo: function foo() {\r\n    return this.name;\r\n  }\r\n};\r\n\r\nobj.foo();\r\n```\r\n\r\n上面解决了 this，下面来看下怎么实现参数的传递，call 方法可以传递任意参数列表，我们可以通过`arguments`来获取，它是一个类数组。\r\n\r\n```js\r\nfunction getName() {\r\n  console.log(arguments); //Arguments(5) [1, 2, 3, 4, 5]\r\n}\r\nfunction foo() {\r\n  var args = [];\r\n  for (var i = 0; i < arguments.length; i++) {\r\n    args.push(\"arguments[\" + i + \"]\");\r\n  }\r\n  eval(\"getName(\" + args + \")\");\r\n}\r\nfoo(1, 2, 3, 4, 5);\r\n```\r\n\r\nOK，这两块已经搞定了，下面就是实现\r\n\r\n### call\r\n\r\n```js\r\nFunction.prototype.calls = function(con) {\r\n  con.fn = this;\r\n  // 获取参数\r\n  var args = [];\r\n  for (var i = 1; i < arguments.length; i++) {\r\n    args.push(\"arguments[\" + i + \"]\");\r\n  }\r\n  var result = eval(\"con.fn(\" + args + \")\");\r\n  delete con.fn;\r\n  return result;\r\n};\r\n```\r\n\r\n上面删除属性是为了避免污染，这里的`fn`可以是任意属性名只要保证不重复就行了，不过仔细观察上面函数还是有问题\r\n\r\n1. call 的 this 可以是 `null` 或者 `undefined`；\r\n2. 可以是字符串数字之类的，会转化为包装对象；\r\n\r\n```js\r\nFunction.prototype.calls = function(con) {\r\n  if (con == null) {\r\n    con = typeof window === \"object\" ? window : global;\r\n  }\r\n  con = Object(con);\r\n  con.fn = this;\r\n  // 获取参数\r\n  var args = [];\r\n  for (var i = 1; i < arguments.length; i++) {\r\n    args.push(\"arguments[\" + i + \"]\");\r\n  }\r\n  var result = eval(\"con.fn(\" + args + \")\");\r\n  delete con.fn;\r\n  return result;\r\n};\r\n```\r\n\r\n测试一下\r\n\r\n```js\r\nfunction foo() {\r\n  return this.length;\r\n}\r\nconsole.log(foo.calls(\"obj\")); // 3\r\n```\r\n\r\n撒花，这样就实现了 call\r\n\r\n### apply\r\n\r\n与 call 十分类似，这里就直接贴代码了\r\n\r\n```js\r\nFunction.prototype.applys = function(con, arr) {\r\n  if (con == null) {\r\n    con = typeof window === \"object\" ? window : global;\r\n  }\r\n  con = Object(con);\r\n  con.fn = this;\r\n  var result;\r\n  if (typeof arr === \"object\" && arr.length) {\r\n    var args = [];\r\n    for (var i = 0; i < arr.length; i++) {\r\n      args.push(\"arr[\" + i + \"]\");\r\n    }\r\n    result = eval(\"con.fn(\" + args + \")\");\r\n  } else {\r\n    result = eval(\"con.fn()\");\r\n  }\r\n  delete con.fn;\r\n  return result;\r\n};\r\n```\r\n\r\n## 参考\r\n\r\n1. https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/call\r\n2. https://github.com/mqyqingfeng/Blog/issues/11\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/bosens-China/blog/issues/30/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/bosens-China/blog/issues/30/timeline",
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/bosens-China/blog/issues/7",
    "repository_url": "https://api.github.com/repos/bosens-China/blog",
    "labels_url": "https://api.github.com/repos/bosens-China/blog/issues/7/labels{/name}",
    "comments_url": "https://api.github.com/repos/bosens-China/blog/issues/7/comments",
    "events_url": "https://api.github.com/repos/bosens-China/blog/issues/7/events",
    "html_url": "https://github.com/bosens-China/blog/issues/7",
    "id": 479646858,
    "node_id": "MDU6SXNzdWU0Nzk2NDY4NTg=",
    "number": 7,
    "title": "使用rollup编写一个现代化的模块",
    "user": {
      "login": "bosens-China",
      "id": 39508895,
      "node_id": "MDQ6VXNlcjM5NTA4ODk1",
      "avatar_url": "https://avatars.githubusercontent.com/u/39508895?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/bosens-China",
      "html_url": "https://github.com/bosens-China",
      "followers_url": "https://api.github.com/users/bosens-China/followers",
      "following_url": "https://api.github.com/users/bosens-China/following{/other_user}",
      "gists_url": "https://api.github.com/users/bosens-China/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/bosens-China/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/bosens-China/subscriptions",
      "organizations_url": "https://api.github.com/users/bosens-China/orgs",
      "repos_url": "https://api.github.com/users/bosens-China/repos",
      "events_url": "https://api.github.com/users/bosens-China/events{/privacy}",
      "received_events_url": "https://api.github.com/users/bosens-China/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [
      {
        "id": 1740577858,
        "node_id": "MDU6TGFiZWwxNzQwNTc3ODU4",
        "url": "https://api.github.com/repos/bosens-China/blog/labels/%E5%B7%A5%E5%85%B7%E7%9B%B8%E5%85%B3",
        "name": "工具相关",
        "color": "f73d62",
        "default": false,
        "description": ""
      }
    ],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 0,
    "created_at": "2019-08-12T13:30:02Z",
    "updated_at": "2019-12-18T03:04:12Z",
    "closed_at": null,
    "author_association": "OWNER",
    "active_lock_reason": null,
    "body": "> 之所有选用 rollup 是因为它可以减少打包体积和提高构建速度，下面介绍不会详细讲解配置，你可以自行查阅官方文档\r\n\r\nES6 已经出现很久了，但是为了兼容以前的浏览器，我们还是需要使用各种构建工具，例如 webpack，在使用的时候很方便，可以通过 babel 转换 es6 的语法，比如下面导入一个模块\r\n\r\n`import moduleName from 'module';`\r\n\r\n不过编写一个现代化模块呢，预定目标应该有三点\r\n\r\n1.  支持 typescript，将 ES6 代码转化为 ES5 环境使用\r\n2.  支持构建工具和`script type=\"module\"`的导入\r\n3.  支持 umd 格式引用\r\n\r\n就以下面这段代码为演示，实现上述的目标\r\n\r\n```js\r\nexport default (arr = []) => {\r\n  return Array.from(arr).length;\r\n};\r\n```\r\n\r\n## 准备\r\n\r\n```sh\r\nnpm init -y\r\nnpm i rollup -D\r\ncd.>rollup.config.js\r\nmd src\r\ncd.>src/index.js\r\n```\r\n\r\n这样就创建好我们想要的基本结构了，将上面例子复制到 `index.js` 文件下。\r\n\r\n`rollup`可以通过命令行也可以通过脚本来调用，这里在`package.json`的`scripts`字段，通过脚本调用\r\n\r\n```json\r\n  \"scripts\": {\r\n    \"build\": \"rollup -c\"\r\n  }\r\n```\r\n\r\n`-c`是指配置文件，默认就是`rollup.config.js`所以不需要额外配置了\r\n\r\n## 编写第一个例子\r\n\r\nrollup.config.js\r\n\r\n```js\r\nexport default {\r\n  input: \"./src/index.js\",\r\n  output: [\r\n    {\r\n      file: \"dist/index.esm.browser.js\",\r\n      format: \"es\",\r\n      sourcemap: true\r\n    }\r\n  ]\r\n};\r\n```\r\n\r\n上面配置信息`input`指的是入口文件，`output` 是出口文件，`file`是输出的文件路径，`sourcemap`是是否输出 map 文件，他可以方便调试错误，在开发模块中应该是必须的，`format`是指输出的格式\r\n\r\n- amd\r\n  异步模块定义，用于像 RequireJS 这样的模块加载器\r\n- cjs\r\n  CommonJS，适用于 Node 和 Browserify/Webpack\r\n- es\r\n  将软件包保存为 ES 模块文件\r\n- iife\r\n  一个自动执行的功能，适合作为<\\script>标签。（如果要为应用程序创建一个捆绑包，您可能想要使用它，因为它会使文件大小变小。）\r\n- umd\r\n  通用模块定义，以 amd，cjs 和 iife 为一体\r\n\r\n执行`npm run build`\r\n\r\ndist/index.esm.browser.js\r\n\r\n```js\r\nvar index = (arr = []) => {\r\n  return Array.from(arr).length;\r\n};\r\n\r\nexport default index;\r\n//# sourceMappingURL=index.esm.browser.js.map\r\n```\r\n\r\n可以看到生成的信息十分简洁，上面说到要同时支持`umd` 格式和 `import` 导入，`import`可以通过`es`的形式来供构建工具和`script type=\"module\"`使用，下面就来定义一下 umd 格式\r\n\r\n```js\r\nexport default {\r\n  input: \"./src/index.js\",\r\n  output: [\r\n    {\r\n      file: \"dist/index.esm.browser.js\",\r\n      format: \"es\",\r\n      sourcemap: true\r\n    },\r\n    {\r\n      file: \"dist/index.js\",\r\n      format: \"umd\",\r\n      sourcemap: true,\r\n      name: \"index\"\r\n    }\r\n  ]\r\n};\r\n```\r\n\r\n**注意**使用`umd`或者`iife`必须指定 name 字段，他决定了暴露在全局作用下的变量名，再次执行可以看到`index.js`的信息了。\r\n\r\n## babel\r\n\r\n上面完成了需求的第一步，不过对于 es6 的代码，并没有转化为 es5 的形式，只是将语法转换了，`Array.from`依旧存在，下面使用`babel`来完成需求\r\n\r\n```sh\r\nnpm i @babel/core @babel/preset-env  core-js rollup-plugin-babel rollup-plugin-node-resolve rollup-plugin-commonjs -D\r\n```\r\n\r\nbabel.config.js\r\n\r\n```js\r\nmodule.exports = {\r\n  presets: [\r\n    [\r\n      \"@babel/preset-env\",\r\n      {\r\n        useBuiltIns: \"usage\",\r\n        corejs: 3,\r\n        modules: false\r\n      }\r\n    ]\r\n  ]\r\n};\r\n```\r\n\r\n上面代码的`useBuiltIns`的`usage`是 babel7 的实验性特性，他支持按需加载\r\n\r\nrollup.config.js\r\n\r\n```js\r\nimport babel from \"rollup-plugin-babel\";\r\nimport resolve from \"rollup-plugin-node-resolve\";\r\nimport commonjs from \"rollup-plugin-commonjs\";\r\nexport default {\r\n  input: \"./src/index.js\",\r\n  output: [\r\n    {\r\n      file: \"dist/index.esm.browser.js\",\r\n      format: \"es\",\r\n      sourcemap: true\r\n    },\r\n    {\r\n      file: \"dist/index.js\",\r\n      format: \"umd\",\r\n      sourcemap: true,\r\n      name: \"index\"\r\n    }\r\n  ],\r\n  plugins: [\r\n    commonjs(),\r\n    resolve(),\r\n    babel({\r\n      exclude: [/\\/core-js\\//],\r\n      runtimeHelpers: true,\r\n      sourceMap: true,\r\n      extensions: [\".js\", \".jsx\", \".es6\", \".es\", \".mjs\", \".ts\"]\r\n    })\r\n  ]\r\n};\r\n```\r\n\r\n再次执行可以看到`Arrar.from`已经被`babel`转换为 ES5 的环境了\r\n\r\n## typescript\r\n\r\n这个我们用`babel`提供给我们的`@babel/preset-typescript`即可完成，不过为了支持`typescript`一些其他扩展语法，我们还需要安装一些插件\r\n\r\n```sh\r\nnpm i @babel/preset-typescript @babel/plugin-transform-typescript @babel/plugin-syntax-dynamic-import @babel/plugin-proposal-class-properties -D\r\n```\r\n\r\nbabel.config.js\r\n\r\n```js\r\nmodule.exports = {\r\n  presets: [\r\n    [\r\n      \"@babel/preset-env\",\r\n      {\r\n        useBuiltIns: \"usage\",\r\n        corejs: 3,\r\n        modules: false\r\n      }\r\n    ],\r\n    [\"@babel/preset-typescript\"]\r\n  ],\r\n  plugins: [\r\n    \"@babel/plugin-transform-typescript\",\r\n    \"@babel/plugin-syntax-dynamic-import\",\r\n    \"@babel/plugin-proposal-class-properties\"\r\n  ]\r\n};\r\n```\r\n\r\n修改一下 `src/index.js` 为 `index.ts`，`rollup.config.js` 下`input`字段\r\n\r\n```js\r\nexport default (arr: Array<any> = []): number => {\r\n  return Array.from(arr).length;\r\n};\r\n```\r\n\r\n再次执行`npm run build`，成功输出\r\n\r\n## 优化\r\n\r\n1. 输出代码没有被压缩\r\n2. 每次输出的时候文件夹没有被删除\r\n\r\n上面两个问题，可以通过插件来解决\r\n\r\n```sh\r\nnpm i rollup-plugin-terser rollup-plugin-clear -D\r\n```\r\n\r\nrollup.config.js\r\n\r\n```js\r\nimport babel from \"rollup-plugin-babel\";\r\nimport clear from \"rollup-plugin-clear\";\r\nimport resolve from \"rollup-plugin-node-resolve\";\r\nimport commonjs from \"rollup-plugin-commonjs\";\r\nimport { terser } from \"rollup-plugin-terser\";\r\nexport default {\r\n  input: \"./src/index.ts\",\r\n  output: [\r\n    {\r\n      file: \"dist/index.esm.browser.js\",\r\n      format: \"es\",\r\n      sourcemap: true\r\n    },\r\n    {\r\n      file: \"dist/index.js\",\r\n      format: \"umd\",\r\n      sourcemap: true,\r\n      name: \"index\"\r\n    }\r\n  ],\r\n  plugins: [\r\n    clear({\r\n      targets: [\"dist\"]\r\n    }),\r\n    resolve(),\r\n    commonjs(),\r\n    terser(),\r\n    babel({\r\n      exclude: [/\\/core-js\\//],\r\n      runtimeHelpers: true,\r\n      sourceMap: true,\r\n      extensions: [\".js\", \".jsx\", \".es6\", \".es\", \".mjs\", \".ts\"]\r\n    })\r\n  ]\r\n};\r\n```\r\n这样基本的模块的基本功能就编写完成了",
    "reactions": {
      "url": "https://api.github.com/repos/bosens-China/blog/issues/7/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/bosens-China/blog/issues/7/timeline",
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/bosens-China/blog/issues/19",
    "repository_url": "https://api.github.com/repos/bosens-China/blog",
    "labels_url": "https://api.github.com/repos/bosens-China/blog/issues/19/labels{/name}",
    "comments_url": "https://api.github.com/repos/bosens-China/blog/issues/19/comments",
    "events_url": "https://api.github.com/repos/bosens-China/blog/issues/19/events",
    "html_url": "https://github.com/bosens-China/blog/issues/19",
    "id": 479944938,
    "node_id": "MDU6SXNzdWU0Nzk5NDQ5Mzg=",
    "number": 19,
    "title": "javascript设计模式之单例模式",
    "user": {
      "login": "bosens-China",
      "id": 39508895,
      "node_id": "MDQ6VXNlcjM5NTA4ODk1",
      "avatar_url": "https://avatars.githubusercontent.com/u/39508895?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/bosens-China",
      "html_url": "https://github.com/bosens-China",
      "followers_url": "https://api.github.com/users/bosens-China/followers",
      "following_url": "https://api.github.com/users/bosens-China/following{/other_user}",
      "gists_url": "https://api.github.com/users/bosens-China/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/bosens-China/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/bosens-China/subscriptions",
      "organizations_url": "https://api.github.com/users/bosens-China/orgs",
      "repos_url": "https://api.github.com/users/bosens-China/repos",
      "events_url": "https://api.github.com/users/bosens-China/events{/privacy}",
      "received_events_url": "https://api.github.com/users/bosens-China/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [
      {
        "id": 1740561541,
        "node_id": "MDU6TGFiZWwxNzQwNTYxNTQx",
        "url": "https://api.github.com/repos/bosens-China/blog/labels/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F",
        "name": "设计模式",
        "color": "d1a540",
        "default": false,
        "description": "javascript设计模式的实现"
      }
    ],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 0,
    "created_at": "2019-08-13T03:44:23Z",
    "updated_at": "2019-12-18T02:58:15Z",
    "closed_at": null,
    "author_association": "OWNER",
    "active_lock_reason": null,
    "body": "单例模式是很常见的一种设计模式，保证一个类仅有一个实例，并提供一个访问它的全局访问点。\r\n\r\n## 单例实现\r\n\r\n根据上面定义很容易想到用闭包来实现\r\n\r\n```js\r\nvar dom = (function() {\r\n  var d;\r\n  function createdDiv(html) {\r\n    if (d) {\r\n      return d;\r\n    }\r\n    this.html = html;\r\n    this.init();\r\n    return (d = this);\r\n  }\r\n  createdDiv.prototype.init = function() {\r\n    var dom = document.createElement(\"div\");\r\n    dom.innerHTML = this.html;\r\n    document.body.append(dom);\r\n  };\r\n  return createdDiv;\r\n})();\r\nvar d1 = new dom(\"hello wrold\");\r\nvar d2 = new dom(\"你好世界\");\r\nconsole.log(d1 === d2); // true\r\n```\r\n\r\n上面通过变量`d`来判断，没有就生成一个`div`，有的话就返回`d`，不过上面代码生成和保证单一组合在一起实际上违反了面向对象的单一职责，下面就用代理的方式来清除这种耦合。\r\n\r\n## 代理\r\n\r\n还是通过上面代码为例，我们通过观察发现`createdDiv`函数负责`div`的创建和生成，如何保证类的单一，我们可以使用另外一个函数来检测和返回。\r\n\r\n```js\r\nvar dom = (function() {\r\n  var d;\r\n  function createdDiv(html) {\r\n    this.html = html;\r\n    this.init();\r\n  }\r\n  createdDiv.prototype.init = function() {\r\n    var dom = document.createElement(\"div\");\r\n    dom.innerHTML = this.html;\r\n    document.body.append(dom);\r\n  };\r\n  return function(h) {\r\n    if (!d) {\r\n      d = new createdDiv(h);\r\n    }\r\n    return d;\r\n  };\r\n})();\r\nvar d1 = new dom(\"hello wrold\");\r\nvar d2 = new dom(\"你好世界\");\r\nconsole.log(d1 === d2); // true\r\n```\r\n\r\n## 惰性\r\n\r\n以兼容 dom 事件为例，ie 有自己的 dom 事件添加方法，如果我们要写一个兼容的函数可能会这样写\r\n\r\n```js\r\nfunction addEvent(type, el, fn) {\r\n  if (window.addEventListener) {\r\n    el.addEventListener(type, fn, false);\r\n  } else if (window.attachEvent) {\r\n    el.attachEvent(\"on\" + type, fn);\r\n  }\r\n}\r\n```\r\n\r\n不过这里每次运行函数都会判断一次，实际上没有必要，我们可以通过闭包的形式只判断一次\r\n\r\n```js\r\nfunction addEvent(type, el, fn) {\r\n  if (window.addEventListener) {\r\n    return function() {\r\n      el.addEventListener(type, fn, false);\r\n    };\r\n  } else if (window.attachEvent) {\r\n    return function() {\r\n      el.attachEvent(\"on\" + type, fn);\r\n    };\r\n  }\r\n}\r\n```\r\n\r\n惰性的应用很广泛，许多优化也牵扯其中，比如 webpack 对`import()`可以做到代码分割，减少首屏加载时间。\r\n\r\n## 信任函数\r\n\r\n还是通过惰性的例子为例，我们用了一个闭包来实现，不过也可以通过改写这个函数来实现\r\n\r\n```js\r\nfunction addEvent(type, el, fn) {\r\n  if (window.addEventListener) {\r\n    addEvent = function(type, el, fn) {\r\n      el.addEventListener(type, fn, false);\r\n    };\r\n  } else if (window.attachEvent) {\r\n    addEvent = function(type, el, fn) {\r\n      el.attachEvent(\"on\" + type, fn);\r\n    };\r\n  }\r\n}\r\n```\r\n\r\n## es6 之后的单例\r\n\r\n在 javascript 中单例实际上有些特殊，因为并没有类，而且单例的作用只是为了保证类的单一性，那我们可以直接定义一个全局变量就可以做到了\r\n\r\n```js\r\nvar a = {};\r\n```\r\n\r\n这里`a`在全局只会存在一次，不过缺点也很明显，就是会被覆盖和修改以及污染了全局变量，而从 es6 开始引用了模块的机制，它有些特殊，它是运行前加载，而且会将模块的值动态同步，怎么理解这句话呢？\r\n\r\n```js\r\nlet d = 5;\r\nsetTimeout(() => {\r\n  d = 10;\r\n}, 1000);\r\nexport { d };\r\n// 引用\r\n\r\nimport { d } from \"./demo.js\";\r\nconsole.log(d);\r\nsetTimeout(() => {\r\n  console.log(d);\r\n}, 1000);\r\n```\r\n\r\n上面会输出 5 和 10,所以根据模块这一特性可以很轻松实现单例模式\r\n\r\n```js\r\nlet event;\r\nif (!event) {\r\n  if (window.addEventListener) {\r\n    event = function(type, el, fn) {\r\n      el.addEventListener(type, fn, false);\r\n    };\r\n  } else if (window.attachEvent) {\r\n    event = function(type, el, fn) {\r\n      el.attachEvent(\"on\" + type, fn);\r\n    };\r\n  }\r\n}\r\nexport default event;\r\n```\r\n\r\n## 最后\r\n\r\n上面简单介绍了单例的传统实现，以及在 javascript 中的实现，最后额外提一下，es6 新增的`symbol`也可以跟单例想结合使用，它确保了这个属性名是唯一的，我们可以通过`symbol.for`来判断有没有这个`symbol`\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/bosens-China/blog/issues/19/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/bosens-China/blog/issues/19/timeline",
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/bosens-China/blog/issues/20",
    "repository_url": "https://api.github.com/repos/bosens-China/blog",
    "labels_url": "https://api.github.com/repos/bosens-China/blog/issues/20/labels{/name}",
    "comments_url": "https://api.github.com/repos/bosens-China/blog/issues/20/comments",
    "events_url": "https://api.github.com/repos/bosens-China/blog/issues/20/events",
    "html_url": "https://github.com/bosens-China/blog/issues/20",
    "id": 480491465,
    "node_id": "MDU6SXNzdWU0ODA0OTE0NjU=",
    "number": 20,
    "title": "javascript设计模式之观察者模式",
    "user": {
      "login": "bosens-China",
      "id": 39508895,
      "node_id": "MDQ6VXNlcjM5NTA4ODk1",
      "avatar_url": "https://avatars.githubusercontent.com/u/39508895?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/bosens-China",
      "html_url": "https://github.com/bosens-China",
      "followers_url": "https://api.github.com/users/bosens-China/followers",
      "following_url": "https://api.github.com/users/bosens-China/following{/other_user}",
      "gists_url": "https://api.github.com/users/bosens-China/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/bosens-China/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/bosens-China/subscriptions",
      "organizations_url": "https://api.github.com/users/bosens-China/orgs",
      "repos_url": "https://api.github.com/users/bosens-China/repos",
      "events_url": "https://api.github.com/users/bosens-China/events{/privacy}",
      "received_events_url": "https://api.github.com/users/bosens-China/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [
      {
        "id": 1740561541,
        "node_id": "MDU6TGFiZWwxNzQwNTYxNTQx",
        "url": "https://api.github.com/repos/bosens-China/blog/labels/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F",
        "name": "设计模式",
        "color": "d1a540",
        "default": false,
        "description": "javascript设计模式的实现"
      }
    ],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 0,
    "created_at": "2019-08-14T05:44:57Z",
    "updated_at": "2019-12-18T02:58:02Z",
    "closed_at": null,
    "author_association": "OWNER",
    "active_lock_reason": null,
    "body": "## 前言\r\n\r\n观察者模式也成为了发布订阅模式，以下面三部分组成\r\n\r\n1. 发布者\r\n2. 订阅者\r\n3. 消息队列\r\n\r\n上面介绍了组成可能你还有疑惑，下面就举一个例子，小明打算去售楼处去买一套房子，销售小姐告诉他这套住宅暂时没有房源，小明于是留了手机号码给他，某一天有房源的时候通知他。\r\n上面例子中，发布者就是售楼中心，订阅者就是小明，消息队列就是小明留的手机号码，观察者模式可以让对象松耦合在一起。\r\n\r\n## 实现\r\n\r\n> 下面使用 ES6 的语法来写，如果没有基础，推荐看一遍 es6 入门再来\r\n\r\n上面介绍了定义，就根据上面的定义编写一个可以取消以及支持传递参数的观察者实例\r\n\r\n```js\r\nconst Event = new (class Watch {\r\n  constructor() {\r\n    // 消息队列\r\n    this.list = {};\r\n  }\r\n  // 订阅\r\n  subscribe(key, fn) {\r\n    if (!this.list[key]) {\r\n      // 避免重复\r\n      this.list[key] = new Set();\r\n    }\r\n    this.list[key].add(fn);\r\n  }\r\n  // 触发\r\n  trigger(key, ...args) {\r\n    const v = this.list[key];\r\n    if (!v) {\r\n      return;\r\n    }\r\n    v.forEach(f => f.apply(this, args), this);\r\n  }\r\n  // 删除，key是必须的\r\n  remove(key, fn) {\r\n    const v = this.list[key];\r\n    if (!v) {\r\n      return false;\r\n    }\r\n    if (v.has(fn)) {\r\n      return v.delete(fn);\r\n    }\r\n    // clear没有返回值，这里返回一个true\r\n    return v.clear() || true;\r\n  }\r\n})();\r\nEvent.subscribe(\"abc\", function(a) {\r\n  console.log(a); // x\r\n});\r\nEvent.trigger(\"abc\", \"x\");\r\n```\r\n\r\n上面就实现了简单的观察者模式，不过可以观察上面代码可以发现观察者运行的机制是*先订阅后发布*，有没有办法类似于 QQ 消息一样，可以接收到离线消息，当然这个离线消息只能接收一次。\r\n\r\n## 支持先发布后订阅\r\n\r\n实现的思路很简单，就是通过一个离线消息队列，发布的时候判断这个离线消息队列存在么，如果存在，将消息存放在离线消息队列，当订阅的时候如果发现有离线消息队列就执行一次，之后清空\r\n\r\n```js\r\nconst Event = new (class Watch {\r\n  constructor() {\r\n    // 消息队列\r\n    this.list = {};\r\n    this.offLine = new Set();\r\n  }\r\n  // 订阅\r\n  subscribe(key, fn) {\r\n    if (!this.list[key]) {\r\n      // 避免重复\r\n      this.list[key] = new Set();\r\n    }\r\n    this.list[key].add(fn);\r\n    if (this.offLine) {\r\n      this.offLine.forEach(f => f(), this);\r\n    }\r\n    this.offLine = null;\r\n  }\r\n  // 触发\r\n  trigger(key, ...args) {\r\n    // 关键代码\r\n    const fn = () => {\r\n      const v = this.list[key];\r\n      if (!v) {\r\n        return;\r\n      }\r\n      v.forEach(f => f.apply(this, args), this);\r\n    };\r\n    if (this.offLine) {\r\n      this.offLine.add(fn);\r\n    }\r\n    fn();\r\n  }\r\n  // 删除，key是必须的\r\n  remove(key, fn) {\r\n    const v = this.list[key];\r\n    if (!v) {\r\n      return false;\r\n    }\r\n    if (v.has(fn)) {\r\n      return v.delete(fn);\r\n    }\r\n    // clear没有返回值，这里返回一个true\r\n    return v.clear() || true;\r\n  }\r\n})();\r\nEvent.trigger(\"abc\", \"x\");\r\nEvent.subscribe(\"abc\", function(a) {\r\n  console.log(a); // x\r\n});\r\n```\r\n\r\n撒花，一个支持取消和先发布后订阅的观察者模式已经实现了，不过还是有待优化的地方，比如命名，我们能不能通过`Event.created('zhangsan').trigger`的形式来调用呢？\r\n\r\n## 命名\r\n\r\n动手写之前，我们先缕清一下头绪\r\n\r\n- 命名是否必须，能不能不通过`created`先调用，比如直接就是`Event.trigger`发布之后再订阅\r\n\r\nok，下面就是针对上面问题实现\r\n\r\n```js\r\n// 定义一个基础类，这个类是实现的核心层\r\nclass Basics {\r\n  _obj = {};\r\n  _default = \"default\";\r\n  _created(name = this._default) {\r\n    // 定义消息队列和离线消息队列\r\n    const list = {};\r\n    let offLine = new Set();\r\n    const then = this;\r\n    const obj = {\r\n      // 触发，如果第一次触发就添加到离线队列中\r\n      trigger(key, ...rest) {\r\n        const fn = () => {\r\n          const arr = [list, key, ...rest];\r\n          return then._trigger.apply(then, arr);\r\n        };\r\n        if (offLine) {\r\n          offLine.add(fn);\r\n        }\r\n        return fn();\r\n      },\r\n      // 添加订阅者同时执行离线队列\r\n      subscribe(key, fn) {\r\n        then._subscribe(...[list, key, fn]);\r\n        if (offLine) {\r\n          offLine.forEach(f => f());\r\n        }\r\n        offLine = null;\r\n      },\r\n      // 删除，key是必须的\r\n      remove(key, fn) {\r\n        const v = this.list[key];\r\n        if (!v) {\r\n          return false;\r\n        }\r\n        if (v.has(fn)) {\r\n          return v.delete(fn);\r\n        }\r\n        // clear没有返回值，这里返回一个true\r\n        return v.clear() || true;\r\n      }\r\n    };\r\n    // 判断命名来决定返回\r\n    return name\r\n      ? this._obj[name]\r\n        ? this._obj[name]\r\n        : (this._obj[name] = obj)\r\n      : obj;\r\n  }\r\n  // 触发\r\n  _trigger(l, k, ...args) {\r\n    const v = l[k];\r\n    if (!v || !v.size) {\r\n      return;\r\n    }\r\n    return Array.from(v, f => f.apply(this, args), this);\r\n  }\r\n  _subscribe(list, key, fn) {\r\n    if (!list[key]) {\r\n      list[key] = new Set();\r\n    }\r\n    list[key].add(fn);\r\n  }\r\n}\r\n// 这个是实现类\r\nclass Watch extends Basics {\r\n  constructor() {\r\n    // 必须，es6规定\r\n    super();\r\n    this.created = super._created;\r\n  }\r\n  trigger(key, ...rest) {\r\n    const v = this.created();\r\n    v.trigger(key, ...rest);\r\n  }\r\n  subscribe(key, fn) {\r\n    const v = this.created();\r\n    v.subscribe(key, fn);\r\n  }\r\n  remove(key, fn) {\r\n    const v = this.created();\r\n    v.remove(key, fn);\r\n  }\r\n}\r\nconst Event = new Watch();\r\nEvent.trigger(\"abc\");\r\nEvent.subscribe(\"abc\", function() {\r\n  console.log(123);\r\n});\r\nEvent.created(\"zhangsan\").subscribe(\"abc\", function(c) {\r\n  console.log(c);\r\n});\r\nEvent.created(\"zhangsan\").trigger(\"abc\", 456);\r\n```\r\n\r\n在实际中我们使用观察者模式的例子也有很多，比如一个网站，分为导航和侧边，当用户信息更新的时候展示部分需要更换就可以用到，还有我们用的框架，比如`vue、React`等\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/bosens-China/blog/issues/20/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/bosens-China/blog/issues/20/timeline",
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/bosens-China/blog/issues/21",
    "repository_url": "https://api.github.com/repos/bosens-China/blog",
    "labels_url": "https://api.github.com/repos/bosens-China/blog/issues/21/labels{/name}",
    "comments_url": "https://api.github.com/repos/bosens-China/blog/issues/21/comments",
    "events_url": "https://api.github.com/repos/bosens-China/blog/issues/21/events",
    "html_url": "https://github.com/bosens-China/blog/issues/21",
    "id": 482752452,
    "node_id": "MDU6SXNzdWU0ODI3NTI0NTI=",
    "number": 21,
    "title": "javascript设计模式之代理模式",
    "user": {
      "login": "bosens-China",
      "id": 39508895,
      "node_id": "MDQ6VXNlcjM5NTA4ODk1",
      "avatar_url": "https://avatars.githubusercontent.com/u/39508895?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/bosens-China",
      "html_url": "https://github.com/bosens-China",
      "followers_url": "https://api.github.com/users/bosens-China/followers",
      "following_url": "https://api.github.com/users/bosens-China/following{/other_user}",
      "gists_url": "https://api.github.com/users/bosens-China/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/bosens-China/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/bosens-China/subscriptions",
      "organizations_url": "https://api.github.com/users/bosens-China/orgs",
      "repos_url": "https://api.github.com/users/bosens-China/repos",
      "events_url": "https://api.github.com/users/bosens-China/events{/privacy}",
      "received_events_url": "https://api.github.com/users/bosens-China/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [
      {
        "id": 1740561541,
        "node_id": "MDU6TGFiZWwxNzQwNTYxNTQx",
        "url": "https://api.github.com/repos/bosens-China/blog/labels/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F",
        "name": "设计模式",
        "color": "d1a540",
        "default": false,
        "description": "javascript设计模式的实现"
      }
    ],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 0,
    "created_at": "2019-08-20T09:37:17Z",
    "updated_at": "2019-12-18T02:57:32Z",
    "closed_at": null,
    "author_association": "OWNER",
    "active_lock_reason": null,
    "body": "## 前言\r\n\r\n代理模式是为一个对象提供一个代用品或占位符，以便控制对它的访问。\r\n例如：\r\n![1](https://user-images.githubusercontent.com/39508895/63336089-23272700-c371-11e9-8bf0-f31c74e016b6.jpg)\r\n\r\n下面就介绍最常用的几种场景\r\n\r\n## 保护代理\r\n\r\n例如作为孩子我们总希望他健康成长，在成长路上遇到的烦恼会被家长解决，这样来看其实就是保护代理，下面用一段伪代码来实现。\r\n\r\n```js\r\nfunction Children() {\r\n  this.knowledge = [];\r\n}\r\nChildren.prototype.Study = function(content) {\r\n  // ...学习，增加知识\r\n  this.knowledge.push(content);\r\n};\r\nvar Parent = (function() {\r\n  var small = new Children();\r\n  return {\r\n    knowledge: function(content) {\r\n      if (content === \"bad\") {\r\n        // 坏的，过滤掉\r\n      } else {\r\n        small.Study(content);\r\n      }\r\n    }\r\n  };\r\n})();\r\n```\r\n\r\n上面用伪代码的形式来实现了一个保护例子，不过你可能会困惑，这样不是多此一举么，我们完全可以在`Children`内部实现，不过这样做\r\n\r\n1. 增加了程序耦合度，如果想要过滤更多，或者某一天不过滤了，还要更改代码\r\n2. 违背了单一原则，对于代码的阅读和维护，造成了更多的成本\r\n\r\n## 缓存代理\r\n\r\n缓存代理是很实用的一个例子，例如一个`阶乘函数`，计算 n 的阶乘，最多需要保存 n 个调用记录，我们可能这样写\r\n\r\n```js\r\nfunction factorial(n) {\r\n  if (n === 1) return 1;\r\n  return n * factorial(n - 1);\r\n}\r\nfactorial(5); // 120\r\n```\r\n\r\n不过如果重复计算 5 或者 10，很明显造成了多次浪费，这个时候就可以使用代理，把结果缓存下来，如果存在就直接返回。\r\n\r\n```js\r\nfunction next(n, total) {\r\n  if (n === 1) return 1;\r\n  return n * factorial(n - 1);\r\n}\r\nvar factorial = (function() {\r\n  var obj = {};\r\n  return function(v) {\r\n    if (obj[v]) {\r\n      return obj[v];\r\n    }\r\n    obj[v] = next(v);\r\n    return obj[v];\r\n  };\r\n})();\r\nfactorial(5); // 120\r\nfactorial(5); // 120\r\n```\r\n\r\n上面就将结果缓存了下来，除此之外还可以引用在异步请求中可以节省加载的时间。\r\n\r\n## 应用场景\r\n\r\n上面简单介绍了两种模式，实际上还有很多，比如虚拟代理、远程代理、防火墙代理等，不过这里不做介绍了，下面看看使用场景。\r\n\r\n### jquery\r\n\r\n`jquery`基于链式调用，比如`$('.a').html('').text('')`，不过你会不会很好奇，`$()`调用的时候它是怎么记录这个值的呢，每次调用`$()`存储的 dom 都不相同，实际上它就是借用了代理模式，这里直接贴代码了\r\n\r\n```js\r\nfunction Jquery(dom) {\r\n  this.dom = dom;\r\n}\r\n// 代理者\r\nfunction $(dom) {\r\n  return new Jquery(dom);\r\n}\r\n$.prototype = Jquery.prototype = {\r\n  // 只做演示，不涉及具体代码\r\n  html() {\r\n    return this;\r\n  },\r\n  text() {\r\n    return this;\r\n  }\r\n};\r\n$(\".a\")\r\n  .html(\"\")\r\n  .text(\"\");\r\n```\r\n\r\n### vue\r\n\r\n我们在使用 vue 的时候给定了配置项`data`，它是一个对象，里面的属性会被 vue 响应式处理，我们可以通过`this.`的方式来简单访问，也是用了代理模式，下面就用一段伪 vue 代码来说明\r\n\r\n```js\r\nclass Mvvm {\r\n  constructor(option = {}) {\r\n    this.$option = option;\r\n    this._data = option.data || {};\r\n    // 代理数据\r\n    for (const name in this._data) {\r\n      Object.defineProperty(this, name, {\r\n        configurable: true,\r\n        enumerable: true,\r\n        get() {\r\n          return this._data[name];\r\n        },\r\n        set(v) {\r\n          return (this._data[name] = v);\r\n        }\r\n      });\r\n    }\r\n  }\r\n}\r\nexport default Mvvm;\r\n```\r\n\r\n可以复制上面代码，自己简单试下。\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/bosens-China/blog/issues/21/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/bosens-China/blog/issues/21/timeline",
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/bosens-China/blog/issues/23",
    "repository_url": "https://api.github.com/repos/bosens-China/blog",
    "labels_url": "https://api.github.com/repos/bosens-China/blog/issues/23/labels{/name}",
    "comments_url": "https://api.github.com/repos/bosens-China/blog/issues/23/comments",
    "events_url": "https://api.github.com/repos/bosens-China/blog/issues/23/events",
    "html_url": "https://github.com/bosens-China/blog/issues/23",
    "id": 489595663,
    "node_id": "MDU6SXNzdWU0ODk1OTU2NjM=",
    "number": 23,
    "title": "长列表虚拟优化的实现",
    "user": {
      "login": "bosens-China",
      "id": 39508895,
      "node_id": "MDQ6VXNlcjM5NTA4ODk1",
      "avatar_url": "https://avatars.githubusercontent.com/u/39508895?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/bosens-China",
      "html_url": "https://github.com/bosens-China",
      "followers_url": "https://api.github.com/users/bosens-China/followers",
      "following_url": "https://api.github.com/users/bosens-China/following{/other_user}",
      "gists_url": "https://api.github.com/users/bosens-China/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/bosens-China/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/bosens-China/subscriptions",
      "organizations_url": "https://api.github.com/users/bosens-China/orgs",
      "repos_url": "https://api.github.com/users/bosens-China/repos",
      "events_url": "https://api.github.com/users/bosens-China/events{/privacy}",
      "received_events_url": "https://api.github.com/users/bosens-China/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [
      {
        "id": 1371686609,
        "node_id": "MDU6TGFiZWwxMzcxNjg2NjA5",
        "url": "https://api.github.com/repos/bosens-China/blog/labels/js%20%E7%9B%B8%E5%85%B3",
        "name": "js 相关",
        "color": "F7DF1E",
        "default": false,
        "description": ""
      }
    ],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 0,
    "created_at": "2019-09-05T08:10:06Z",
    "updated_at": "2019-12-18T02:56:20Z",
    "closed_at": null,
    "author_association": "OWNER",
    "active_lock_reason": null,
    "body": "## 前言\r\n\r\n在项目中如果能分页实现那最好不过了，不过很多时候长列表不可避免，这里又分两种情况\r\n\r\n1. 第一次不用全部加载完成，这种可以使用懒加载或者说无限滚动的方式来实现\r\n2. 另外一种则是一次要渲染全部数据出现\r\n\r\n下面就来讨论这两种情况如何进行优化，可以对比[列表优化具体实现](https://github.com/bosens-China/VirtualList)的源码来看\r\n(注：下面是用 Vue 实现的，使用其他框架并不影响)\r\n\r\n## 无限滚动\r\n\r\n实现的思路很简单就是根据滚动条是否滚动到底部（总高度 - 可见高度 - 滚动条高度），滚动到底部就添加新的数据\r\n\r\n```js\r\nfunction scroll({ target }) {\r\n  const DISTANCE = 40;\r\n  const h = target.scrollHeight - (target.clientHeight + target.scrollTop);\r\n  if (h < DISTANCE) {\r\n    for (let i = 0, j = this.list.length, l = this.list.length; i < l; i++) {\r\n      this.list.push(j + i);\r\n    }\r\n  }\r\n}\r\n```\r\n\r\n## 虚拟列表\r\n\r\n![v2-f00bb3f5d9815d660d7bcbd87236af86_hd](https://user-images.githubusercontent.com/39508895/64329195-6cc67180-d001-11e9-8104-1256738a1cc2.jpg)\r\n\r\n引用一张图，可以看见我们实现的思路就是只渲染可见部分的列表，每次滚动条变化的时候更改展示的列表，在下面的演示中，我们都会用到一个基础的 html 结构，这里先贴一下\r\n\r\n```html\r\n<div class=\"root\">\r\n  <div class=\"container\"></div>\r\n  <ul class=\"content\">\r\n    <li class=\"item\" v-for=\"item of nowList\" :key=\"item.value\">\r\n      {{ item.value }}\r\n    </li>\r\n  </ul>\r\n</div>\r\n```\r\n\r\n```less\r\n.root {\r\n  border: 1px solid #999;\r\n  list-style: none;\r\n  overflow: auto;\r\n  height: 400px;\r\n  position: relative;\r\n  .container {\r\n    position: absolute;\r\n    left: 0;\r\n    top: 0;\r\n    right: 0;\r\n    z-index: -1;\r\n  }\r\n  .content {\r\n    .container();\r\n    z-index: 1;\r\n    margin: 0;\r\n    padding: 0;\r\n    list-style: none;\r\n  }\r\n  .item {\r\n    border-bottom: 1px solid #ccc;\r\n    padding-left: 40px;\r\n  }\r\n}\r\n```\r\n\r\n上面结构做了两件事情\r\n\r\n1. 固定总列表的高度，让其出现滚动条\r\n2. 用一个遮罩 div 撑起整个列表的高度\r\n\r\n### 固定\r\n\r\n这里假设每个列表的高度为 30px，剩下的部分就是计算出列表的`总体高度`以及`开始索引`和`结束索引`，核心代码只有不到 10 行\r\n\r\n```js\r\nscroll() {\r\n  const dom = this.$refs.root;\r\n  const total = Math.ceil(dom.clientHeight / this.height);\r\n  const start = Math.floor(dom.scrollTop / this.height);\r\n  const end = start + total;\r\n  this.start = start;\r\n  this.end = end;\r\n}\r\n```\r\n\r\n总索引: 当前视图的高度 / 子项的高度，不过注意需要向上取整；\r\n开始索引: 滚动的距离 / 子项的高度\r\n结束索: 总索引 + 开始索引\r\n下面是完整的代码\r\n\r\n```html\r\n<template>\r\n  <div>\r\n    <div class=\"root\" ref=\"root\" @scroll=\"scroll\">\r\n      <div class=\"container\" :style=\"{ height: totalHeight }\"></div>\r\n      <ul class=\"content\" :style=\"{ transform: getTransform }\">\r\n        <li\r\n          class=\"item\"\r\n          :style=\"{ height: height + 'px', lineHeight: height + 'px' }\"\r\n          v-for=\"(item, i) of nowList\"\r\n          :key=\"i\"\r\n        >\r\n          {{ item }}\r\n        </li>\r\n      </ul>\r\n    </div>\r\n  </div>\r\n</template>\r\n\r\n<script>\r\n  export default {\r\n    data() {\r\n      return {\r\n        list: Array(10000)\r\n          .fill(1)\r\n          .map((f, i) => i),\r\n        height: 30,\r\n        start: 0,\r\n        end: 0\r\n      };\r\n    },\r\n    computed: {\r\n      totalHeight() {\r\n        return this.height * this.list.length + \"px\";\r\n      },\r\n      nowList() {\r\n        return this.list.slice(this.start, this.end);\r\n      },\r\n      getTransform() {\r\n        return `translate3d(0,${this.start * this.height}px,0)`;\r\n      }\r\n    },\r\n    mounted() {\r\n      this.scroll();\r\n    },\r\n    methods: {\r\n      scroll() {\r\n        const dom = this.$refs.root;\r\n        const total = Math.ceil(dom.clientHeight / this.height);\r\n        const start = Math.floor(dom.scrollTop / this.height);\r\n        const end = start + total;\r\n        this.start = start;\r\n        this.end = end;\r\n      }\r\n    }\r\n  };\r\n</script>\r\n\r\n<style lang=\"less\" scoped>\r\n  .root {\r\n    border: 1px solid #999;\r\n    list-style: none;\r\n    overflow: auto;\r\n    height: 400px;\r\n    position: relative;\r\n    .container {\r\n      position: absolute;\r\n      left: 0;\r\n      top: 0;\r\n      right: 0;\r\n      z-index: -1;\r\n    }\r\n    .content {\r\n      .container();\r\n      z-index: 1;\r\n      margin: 0;\r\n      padding: 0;\r\n      list-style: none;\r\n    }\r\n    .item {\r\n      border-bottom: 1px solid #ccc;\r\n      padding-left: 40px;\r\n    }\r\n  }\r\n</style>\r\n```\r\n\r\n### 非固定\r\n\r\n非固定需要考虑的更多则是性能的问题，下面先贴一个完整的代码，在需要说明部分已经注释了\r\n\r\n```html\r\n<template>\r\n  <div>\r\n    <div class=\"root\" ref=\"root\" @scroll=\"scroll\">\r\n      <div class=\"container\" :style=\"{ height: totalHeight }\"></div>\r\n      <ul class=\"content\" :style=\"{ transform: getTransform }\">\r\n        <li\r\n          class=\"item\"\r\n          v-for=\"item of nowList\"\r\n          :style=\"{\r\n            height: item.height + 'px',\r\n            lineHeight: item.height + 'px'\r\n          }\"\r\n          :key=\"item.value\"\r\n        >\r\n          {{ item.value }}\r\n        </li>\r\n      </ul>\r\n    </div>\r\n  </div>\r\n</template>\r\n\r\n<script>\r\n  export default {\r\n    data() {\r\n      return {\r\n        list: Array(10000)\r\n          .fill(1)\r\n          .map((f, i) => {\r\n            return {\r\n              value: i,\r\n              height: this.getRandom(10, 100)\r\n            };\r\n          }),\r\n        start: 0,\r\n        end: 0,\r\n        // 指针\r\n        pointer: -1,\r\n        // 缓存\r\n        cache: {},\r\n        // 初始总数\r\n        initialHeight: 50\r\n      };\r\n    },\r\n    computed: {\r\n      totalHeight() {\r\n        // 这里是获取总体高度，判断了两种情况，第一种是给定初始总数，另外一种则是没有，如果没有的话，高度就是已缓存的 + 未缓存的部分\r\n        if (this.initialtotal >= 0) {\r\n          const { top, height } =\r\n            this.pointer >= 0\r\n              ? this.getIndexOffset(this.pointer)\r\n              : { top: 0, height: 0 };\r\n          return `${top +\r\n            height +\r\n            (this.list.length - 1 - this.pointer) * this.initialHeight}px`;\r\n        }\r\n        const { height } = this.list.reduce(function(x, y) {\r\n          return {\r\n            height: x.height + y.height\r\n          };\r\n        });\r\n        return height + \"px\";\r\n      },\r\n      // 可视数据\r\n      nowList() {\r\n        return this.list.slice(\r\n          this.start,\r\n          Math.min(this.end + 1, this.list.length)\r\n        );\r\n      },\r\n      getTransform() {\r\n        return `translate3d(0,${this.getIndexOffset(this.start).top}px,0)`;\r\n      }\r\n    },\r\n    mounted() {\r\n      this.scroll();\r\n    },\r\n    methods: {\r\n      // 滚动事件\r\n      scroll() {\r\n        const dom = this.$refs.root;\r\n        // 获取索引\r\n        const start = this.getIndex(dom.scrollTop);\r\n        // 把当前可视的高度 + 滚动条的高度，再去取索引\r\n        const end = this.getIndex(dom.scrollTop + dom.clientHeight);\r\n        this.start = start;\r\n        this.end = end;\r\n      },\r\n      // 取出指定范围随机数\r\n      getRandom(min, max) {\r\n        return Math.floor(Math.random() * (max - min + 1)) + min;\r\n      },\r\n      // 根据滚动条y获取指定坐标\r\n      getIndex(scrollTop) {\r\n        // 判断思路很简单，如果高度大于滚动条肯定就出现了，另外一种则是判断了边界问题\r\n        let total = 0;\r\n        for (let i = 0, j = this.list.length; i < j; i++) {\r\n          if (total >= scrollTop || j - 1 === i) {\r\n            return i;\r\n          }\r\n          // 这里主要是起缓存作用的\r\n          total += this.getIndexOffset(i).height;\r\n        }\r\n        return 0;\r\n      },\r\n      // 获取指定坐标的位置和高度\r\n      getIndexOffset(index) {\r\n        // 如果存在缓存中直接返回\r\n        if (this.pointer >= index) {\r\n          return this.cache[index];\r\n        }\r\n        let total = 0;\r\n        // 这里是为了比较没有取到的情况\r\n        if (this.pointer >= 0) {\r\n          const li = this.cache[this.pointer];\r\n          total = li.top + li.height;\r\n        }\r\n        // 注意上面因为取的值是li.top + li.height，所以i从 + 1开始\r\n        for (let i = this.pointer + 1; i <= index; i++) {\r\n          const size = this.list[i].height;\r\n          this.cache[i] = {\r\n            top: total,\r\n            height: size\r\n          };\r\n          total += size;\r\n        }\r\n        if (index > this.pointer) {\r\n          this.pointer = index;\r\n        }\r\n\r\n        return this.cache[index];\r\n      }\r\n    }\r\n  };\r\n</script>\r\n\r\n<style lang=\"less\" scoped>\r\n  .root {\r\n    border: 1px solid #999;\r\n    list-style: none;\r\n    overflow: auto;\r\n    height: 400px;\r\n    position: relative;\r\n    .container {\r\n      position: absolute;\r\n      left: 0;\r\n      top: 0;\r\n      right: 0;\r\n      z-index: -1;\r\n    }\r\n    .content {\r\n      .container();\r\n      z-index: 1;\r\n      margin: 0;\r\n      padding: 0;\r\n      list-style: none;\r\n    }\r\n    .item {\r\n      border-bottom: 1px solid #ccc;\r\n      padding-left: 40px;\r\n    }\r\n  }\r\n</style>\r\n```\r\n\r\n上面只最终的实现，实际上跟固定高度相比就是增加了获取索引的方法，固定高度我们是知道对应子项的高度，所以可以通过可视高度来计算，而这里我用了随机数来设置高度，所以需要获取到对应的索引。\r\n上面代码同时也做了两点优化，一是缓存，二是总高度优化\r\n\r\n总高度的实现有两种思路：\r\n\r\n1. 计算所有的高度，这种实际上有点浪费性能；\r\n2. 给定一个大概的值，拿缓存的值 + 没有缓存的值，没有缓存的值就是对应数据的长度 - 已缓存的坐标，之后每次缓存变化的时候再计算；\r\n\r\n缓存则比较简单了，每次计算的时候把指针移动到计算的位置，同时将值添加上\r\n\r\n## 参考文章\r\n\r\n1. https://zhuanlan.zhihu.com/p/34585166\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/bosens-China/blog/issues/23/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/bosens-China/blog/issues/23/timeline",
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/bosens-China/blog/issues/35",
    "repository_url": "https://api.github.com/repos/bosens-China/blog",
    "labels_url": "https://api.github.com/repos/bosens-China/blog/issues/35/labels{/name}",
    "comments_url": "https://api.github.com/repos/bosens-China/blog/issues/35/comments",
    "events_url": "https://api.github.com/repos/bosens-China/blog/issues/35/events",
    "html_url": "https://github.com/bosens-China/blog/issues/35",
    "id": 517023871,
    "node_id": "MDU6SXNzdWU1MTcwMjM4NzE=",
    "number": 35,
    "title": "移动端fixed定位输入法错位的解决方式",
    "user": {
      "login": "bosens-China",
      "id": 39508895,
      "node_id": "MDQ6VXNlcjM5NTA4ODk1",
      "avatar_url": "https://avatars.githubusercontent.com/u/39508895?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/bosens-China",
      "html_url": "https://github.com/bosens-China",
      "followers_url": "https://api.github.com/users/bosens-China/followers",
      "following_url": "https://api.github.com/users/bosens-China/following{/other_user}",
      "gists_url": "https://api.github.com/users/bosens-China/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/bosens-China/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/bosens-China/subscriptions",
      "organizations_url": "https://api.github.com/users/bosens-China/orgs",
      "repos_url": "https://api.github.com/users/bosens-China/repos",
      "events_url": "https://api.github.com/users/bosens-China/events{/privacy}",
      "received_events_url": "https://api.github.com/users/bosens-China/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [
      {
        "id": 1371686611,
        "node_id": "MDU6TGFiZWwxMzcxNjg2NjEx",
        "url": "https://api.github.com/repos/bosens-China/blog/labels/%E5%85%B6%E4%BB%96",
        "name": "其他",
        "color": "f6ecbf",
        "default": false,
        "description": "暂定为分享之类的"
      }
    ],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 0,
    "created_at": "2019-11-04T09:04:23Z",
    "updated_at": "2019-12-18T02:47:40Z",
    "closed_at": null,
    "author_association": "OWNER",
    "active_lock_reason": null,
    "body": "> 最近在做后台有一个需求是点击图文生成一个二维码，手机扫码之后进入特定页面进行操作，废话不多说拿起键盘就是干，不过不出所料果然在安卓下遇到了坑，使用`fixed`定位在底部的登录按钮在遇到输入框获取焦点展开键盘后发生了重叠，下面就是踩坑过来的总结。\r\n\r\n![1](https://user-gold-cdn.xitu.io/2019/11/4/16e35a187a81a5f7?w=811&h=519&f=png&s=68735)\r\n为了方便演示我写了一个简单的布局，点击输入框的时候登录按钮会被顶上去，下面就是消灭它！\r\n\r\n## :focus-within\r\n\r\n首先看一下兼容性\r\n![back](https://user-gold-cdn.xitu.io/2019/11/4/16e35a187aa7db5f?w=1336&h=670&f=png&s=65547)\r\n移动端项目已经可以愉快的玩耍了，废话不多说，首先介绍一下`:focus-within`，可以简单理解成它是`focus`的升级版，最大的区别在于它可以捕捉冒泡的`focus`，举一个例子来理解。\r\n\r\n```html\r\n<div class=\"item\">\r\n  <label for=\"name\">input获取焦点我会加粗</label>\r\n  <input type=\"text\" id=\"name\" />\r\n</div>\r\n<style>\r\n  .item:focus-within label {\r\n    font-weight: 600;\r\n  }\r\n</style>\r\n```\r\n\r\n在不使用`:focus-within`的情况下我们要让 label 样式放生变化，常见的改变 input 和 label 的位置之后通过定位的方式让其展示是正常的，之后通过 `:focus + 兄弟选择器`来实现，现在只要一行代码就可以实现了，是不是很感动呢。\r\n\r\n说了这么多，我们上面的例子怎么用`:focus-within`实现呢？\r\n首先缕一下思路，最简单的方法当然是全局使用`:focus-within`之后更改登录按钮的来实现，不过这样可能导致 a 链接获取焦点也会生效。\r\n\r\n所以下面用一个标签将元素包裹起来之后通过兄弟兄弟选择器来实现\r\n\r\n```html\r\n<!-- React的jsx不过并不影响观看 -->\r\n<div className=\"App\">\r\n  <div className=\"item focus\">\r\n    <label htmlFor=\"name\">用户名</label>\r\n    <input type=\"text\" id=\"name\" />\r\n  </div>\r\n  <div className=\"item focus\">\r\n    <label htmlFor=\"password\">密码</label>\r\n    <input type=\"password\" id=\"password\" />\r\n  </div>\r\n  <pre className=\"content\">\r\n        <!-- 内容文章，先屏蔽掉 -->\r\n      </pre>\r\n  <div className=\"item change\">\r\n    <button className=\"btn\">登录</button>\r\n  </div>\r\n</div>\r\n```\r\n\r\ncss，只放关键代码\r\n\r\n```css\r\n.focus:focus-within ~ .change .btn {\r\n  position: static;\r\n  /* 方便看出效果 */\r\n  color: red;\r\n}\r\n```\r\n\r\n撒花，这里我们实现了第一种方法，不过可以看的出来对于页面的布局还是有一定要求的，如果你确定页面没有多余的元素可以直接使用`.focus:focus-within`来操纵元素。\r\n\r\n## javascript\r\n\r\n这一种方法兼容性最好，常见的就是通过这种方法实现，通过监听元素获取焦点和失去焦点来处理登录按钮的 css 样式，当然也可以通过 resize 事件，具体看你的使用场景，这里用`focus`的方法实现。\r\n\r\n**注意**，`focus、blur`不会触发冒泡事件，这里改用`focusin、focusout`来实现。\r\n\r\n```js\r\nconst btn = document.querySelector(\".btn\");\r\nconst app = document.querySelector(\".app\");\r\n// 获得焦点\r\napp.addEventListener(\"focusin\", function(e) {\r\n  const target = e.target;\r\n  if (target.nodeName !== \"INPUT\") {\r\n    return;\r\n  }\r\n  btn.style.position = \"static\";\r\n});\r\n// 失去焦点\r\napp.addEventListener(\"focusout\", function(e) {\r\n  const target = e.target;\r\n  if (target.nodeName !== \"INPUT\") {\r\n    return;\r\n  }\r\n  btn.style.position = \"fixed\";\r\n});\r\n```\r\n\r\n## flex\r\n\r\n> 开拓思路不错，不过实际项目中使用价值不高\r\n\r\n这一种方法对页面的高度有要求，不能超过一屏，超出之后按钮肯定会在下方展示，这种方法的实现思路是利用 flex 的弹性盒子，通过改变流向从上往下之后给内容区域设置`flex:1`来保证自适应。\r\n这里给一个简单的示例,\r\n\r\n```html\r\n<div class=\"root\">\r\n  <form class=\"form\">\r\n    <label\r\n      >用户名:\r\n      <input type=\"text\" />\r\n    </label>\r\n    <div class=\"box\"></div>\r\n  </form>\r\n  <button class=\"btn\">登录</button>\r\n</div>\r\n<style>\r\n  html,\r\n  body {\r\n    height: 100%;\r\n    margin: 0;\r\n    padding: 0;\r\n  }\r\n  .root {\r\n    height: 100%;\r\n    display: flex;\r\n    flex-direction: column;\r\n  }\r\n  .form {\r\n    flex: 1;\r\n  }\r\n  .btm {\r\n    width: 100%;\r\n  }\r\n  .box {\r\n    height: 80vh;\r\n    background: #333;\r\n  }\r\n</style>\r\n```\r\n\r\n## 最后\r\n\r\n稍微总结一下，如果对项目兼容性要求不高推荐使用`:focus-within`实现，如果需要兼容或者需要定制更多细节那还是老老实实的使用`javascript`吧\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/bosens-China/blog/issues/35/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/bosens-China/blog/issues/35/timeline",
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/bosens-China/blog/issues/29",
    "repository_url": "https://api.github.com/repos/bosens-China/blog",
    "labels_url": "https://api.github.com/repos/bosens-China/blog/issues/29/labels{/name}",
    "comments_url": "https://api.github.com/repos/bosens-China/blog/issues/29/comments",
    "events_url": "https://api.github.com/repos/bosens-China/blog/issues/29/events",
    "html_url": "https://github.com/bosens-China/blog/issues/29",
    "id": 499886565,
    "node_id": "MDU6SXNzdWU0OTk4ODY1NjU=",
    "number": 29,
    "title": "jsonp的实现原理",
    "user": {
      "login": "bosens-China",
      "id": 39508895,
      "node_id": "MDQ6VXNlcjM5NTA4ODk1",
      "avatar_url": "https://avatars.githubusercontent.com/u/39508895?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/bosens-China",
      "html_url": "https://github.com/bosens-China",
      "followers_url": "https://api.github.com/users/bosens-China/followers",
      "following_url": "https://api.github.com/users/bosens-China/following{/other_user}",
      "gists_url": "https://api.github.com/users/bosens-China/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/bosens-China/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/bosens-China/subscriptions",
      "organizations_url": "https://api.github.com/users/bosens-China/orgs",
      "repos_url": "https://api.github.com/users/bosens-China/repos",
      "events_url": "https://api.github.com/users/bosens-China/events{/privacy}",
      "received_events_url": "https://api.github.com/users/bosens-China/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [
      {
        "id": 1371686609,
        "node_id": "MDU6TGFiZWwxMzcxNjg2NjA5",
        "url": "https://api.github.com/repos/bosens-China/blog/labels/js%20%E7%9B%B8%E5%85%B3",
        "name": "js 相关",
        "color": "F7DF1E",
        "default": false,
        "description": ""
      }
    ],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 0,
    "created_at": "2019-09-29T09:16:55Z",
    "updated_at": "2019-12-18T02:45:19Z",
    "closed_at": null,
    "author_association": "OWNER",
    "active_lock_reason": null,
    "body": "简单说一下存在的历史，浏览器存在同源政策，即域名+端口+协议必须一致，很多时候我们需要跨域访问，当然在现在我们可以借助 webpack 的反向代理配合服务器设置 cors 实现访问，但是在之前工程化还没出现的时候就需要有一种方法可以访问所以 jsonp 就出现了。\r\njsonp 的原理就是浏览器的 `script` 标签可以加载不同源的资源，配合后端通过执行函数传递参数，这也是 **jsonp 只支持 get** 的原因，同理的标签还有`img`，我们可以用它来实现访问站点次数的统计，根据上面的原理我们来实现一个模拟的版本\r\n\r\n## 第一版\r\n\r\n```html\r\n<script>\r\n  function callback(v) {\r\n    console.log(\"参数是：\");\r\n    console.log(v);\r\n  }\r\n</script>\r\n<script>\r\n  callback({\r\n    name: \"zhangsan\",\r\n    age: 18\r\n  });\r\n</script>\r\n```\r\n\r\n可以看到就是这个思路，后面的脚本调用这个参数即可。\r\n\r\n## 简单实现一个 jsonp 的函数\r\n\r\n```js\r\ninterface Iparams {\r\n  [propName: string]: any;\r\n}\r\ninterface Ioptions {\r\n  params?: Iparams;\r\n  timeout?: number;\r\n  name?: string;\r\n}\r\nlet uid = 0;\r\nconst jsonp = function jsonp(this: any, url: string, option: Ioptions = {}) {\r\n  return new Promise((resolve, reject) => {\r\n    // 注意，这个id不能重复\r\n    const id = `__uid${uid++}`;\r\n    Reflect.set(window, id, (...rest: any[]) => {\r\n      clear();\r\n      return resolve.call(this, ...rest);\r\n    });\r\n    const { name = \"callback\", params = {}, timeout = 6000 } = option;\r\n    // 清理\r\n    const clear = () => {\r\n      Reflect.set(window, id, () => {});\r\n      script.parentNode.removeChild(script);\r\n      if (timer) {\r\n        clearTimeout(timer);\r\n      }\r\n    };\r\n    // 创建超时任务\r\n    let timer: NodeJS.Timeout;\r\n    if (typeof timeout === \"number\") {\r\n      timer = setTimeout(() => {\r\n        clear();\r\n        return reject(new Error(`Task timeout`));\r\n      }, timeout);\r\n    }\r\n    const script: HTMLScriptElement = document.createElement(\"script\");\r\n    // 处理一下参数最终合并\r\n    const par = new URLSearchParams(params);\r\n    par.append(name, id);\r\n    const href = `${url}?${par}`;\r\n    // 编码一下防止出现中文之类的\r\n    script.src = encodeURI(href);\r\n    document.body.appendChild(script);\r\n    script.addEventListener(\"error\", () => {\r\n      clear();\r\n      return reject(\r\n        new Error(`Failed to create jsonp, request target address is:${url}`)\r\n      );\r\n    });\r\n  });\r\n};\r\nexport default jsonp;\r\n```\r\n\r\n这里为了方便演示使用了`URLSearchParams`对象，它是浏览器的原生对象，用来构造、解析和处理 URL 的查询字符串，当然在生产中还需要`polyfill`，如果不满足兼容性建议手写一个工具处理。\r\n\r\n## 最后\r\n\r\n代码我已经放置到了仓库，欢迎来 [Star](https://github.com/bosens-China/promise-jsonp)\r\n\r\n参考：\r\n\r\n- https://github.com/webmodules/jsonp\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/bosens-China/blog/issues/29/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/bosens-China/blog/issues/29/timeline",
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/bosens-China/blog/issues/4",
    "repository_url": "https://api.github.com/repos/bosens-China/blog",
    "labels_url": "https://api.github.com/repos/bosens-China/blog/issues/4/labels{/name}",
    "comments_url": "https://api.github.com/repos/bosens-China/blog/issues/4/comments",
    "events_url": "https://api.github.com/repos/bosens-China/blog/issues/4/events",
    "html_url": "https://github.com/bosens-China/blog/issues/4",
    "id": 477680676,
    "node_id": "MDU6SXNzdWU0Nzc2ODA2NzY=",
    "number": 4,
    "title": "小技巧分享",
    "user": {
      "login": "bosens-China",
      "id": 39508895,
      "node_id": "MDQ6VXNlcjM5NTA4ODk1",
      "avatar_url": "https://avatars.githubusercontent.com/u/39508895?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/bosens-China",
      "html_url": "https://github.com/bosens-China",
      "followers_url": "https://api.github.com/users/bosens-China/followers",
      "following_url": "https://api.github.com/users/bosens-China/following{/other_user}",
      "gists_url": "https://api.github.com/users/bosens-China/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/bosens-China/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/bosens-China/subscriptions",
      "organizations_url": "https://api.github.com/users/bosens-China/orgs",
      "repos_url": "https://api.github.com/users/bosens-China/repos",
      "events_url": "https://api.github.com/users/bosens-China/events{/privacy}",
      "received_events_url": "https://api.github.com/users/bosens-China/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [
      {
        "id": 1473940161,
        "node_id": "MDU6TGFiZWwxNDczOTQwMTYx",
        "url": "https://api.github.com/repos/bosens-China/blog/labels/Vue%20%E7%9B%B8%E5%85%B3",
        "name": "Vue 相关",
        "color": "42b883",
        "default": false,
        "description": "Vue 相关"
      }
    ],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 0,
    "created_at": "2019-08-07T02:56:16Z",
    "updated_at": "2019-12-18T02:27:09Z",
    "closed_at": null,
    "author_association": "OWNER",
    "active_lock_reason": null,
    "body": "## loading\r\n\r\n> 为了避免白屏时间过长，通过会给一个动画来提示用户正在加载，下面就是简单说下在`Vue`加载之前如何实现动画效果\r\n\r\n### 原理\r\n\r\n在初始化`Vue`的时候我们需要提供一个节点或者节点名称，作为根元素来使用，但是这个根元素在`new Vue`执行的时候内容会被销毁，不信来测试一个例子\r\n\r\n```html\r\n<div id=\"app\">\r\n  hello wrold\r\n</div>\r\n```\r\n\r\n```js\r\n// 省略\r\nnew Vue({\r\n  el: \"#app\"\r\n});\r\n```\r\n\r\n可以复制一下上面代码，当上面代码执行的时候，`#app`下的内容会被清空，根据这个思路就很容易实现我们想要的效果了\r\n\r\n### 实现简单一版\r\n\r\n```html\r\n<div id=\"app\">正在加载中<dot>...</dot></div>\r\n```\r\n\r\n```css\r\ndot {\r\n  display: inline-block;\r\n  height: 1em;\r\n  line-height: 1;\r\n  text-align: left;\r\n  vertical-align: -0.25em;\r\n  overflow: hidden;\r\n}\r\ndot::before {\r\n  display: block;\r\n  content: \"...\\A..\\A.\";\r\n  white-space: pre-wrap;\r\n  animation: dot 3s infinite step-start both;\r\n}\r\n@keyframes dot {\r\n  33% {\r\n    transform: translateY(-2em);\r\n  }\r\n  66% {\r\n    transform: translateY(-1em);\r\n  }\r\n}\r\n```\r\n\r\n这样就实现了一个简单的动画效果了\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/bosens-China/blog/issues/4/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/bosens-China/blog/issues/4/timeline",
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/bosens-China/blog/issues/2",
    "repository_url": "https://api.github.com/repos/bosens-China/blog",
    "labels_url": "https://api.github.com/repos/bosens-China/blog/issues/2/labels{/name}",
    "comments_url": "https://api.github.com/repos/bosens-China/blog/issues/2/comments",
    "events_url": "https://api.github.com/repos/bosens-China/blog/issues/2/events",
    "html_url": "https://github.com/bosens-China/blog/issues/2",
    "id": 473943664,
    "node_id": "MDU6SXNzdWU0NzM5NDM2NjQ=",
    "number": 2,
    "title": "漫谈一下es5有意思的地方",
    "user": {
      "login": "bosens-China",
      "id": 39508895,
      "node_id": "MDQ6VXNlcjM5NTA4ODk1",
      "avatar_url": "https://avatars.githubusercontent.com/u/39508895?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/bosens-China",
      "html_url": "https://github.com/bosens-China",
      "followers_url": "https://api.github.com/users/bosens-China/followers",
      "following_url": "https://api.github.com/users/bosens-China/following{/other_user}",
      "gists_url": "https://api.github.com/users/bosens-China/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/bosens-China/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/bosens-China/subscriptions",
      "organizations_url": "https://api.github.com/users/bosens-China/orgs",
      "repos_url": "https://api.github.com/users/bosens-China/repos",
      "events_url": "https://api.github.com/users/bosens-China/events{/privacy}",
      "received_events_url": "https://api.github.com/users/bosens-China/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [
      {
        "id": 1371686608,
        "node_id": "MDU6TGFiZWwxMzcxNjg2NjA4",
        "url": "https://api.github.com/repos/bosens-China/blog/labels/%E6%BC%AB%E8%B0%88%E7%B3%BB%E5%88%97",
        "name": "漫谈系列",
        "color": "e7f3ee",
        "default": false,
        "description": "漫谈系列"
      }
    ],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 0,
    "created_at": "2019-07-29T09:23:22Z",
    "updated_at": "2019-12-18T02:22:56Z",
    "closed_at": null,
    "author_association": "OWNER",
    "active_lock_reason": null,
    "body": "## 块级作用域\r\n\r\n> ES6 引用了 let 和 const，这实际上带来了块级作用域，不过在 ES6 之前只存在全局作用域和函数作用域，相信小伙伴对着句话应该不陌生吧，不过下面就来聊聊一个 ES6 之前的块级作用域\r\n\r\n思考下面一个例子代码输出值为多少\r\n\r\n```js\r\nfor (var i = 0; i < 10; i++) {\r\n  setTimeout(function() {\r\n    console.log(i);\r\n  }, 100);\r\n}\r\n```\r\n\r\n这里会输出 10 个 10，因为只存在一个全局变量`i`，我们可以通过立即执行函数来解决这个问题\r\n\r\n```js\r\nfor (var i = 0; i < 10; i++) {\r\n  (function(i) {\r\n    setTimeout(function() {\r\n      console.log(i);\r\n    }, 100);\r\n  })(i);\r\n}\r\n```\r\n\r\n如果在 ES6 环境下可以简单使用 let 命令，它会在每次循环的时候创建一个作用域，至于为什么能记住上一次的值，那是因为 js 引擎会记住上一次循环的值。\r\n\r\n```js\r\nfor (let i = 0; i < 10; i++) {\r\n  setTimeout(() => {\r\n    console.log(i);\r\n  }, 100);\r\n}\r\n```\r\n\r\n上面的例子只是简单回顾一下没有块级作用域的痛苦之一，实际上我们写项目的时候可能早早的就使用了`babel`，这里也是后面需要说的，它会通过怎么样的形式将`let`和`const`转化为支持 ES5 的环境。\r\n\r\n铺垫了这么久，下面就来说说这个特殊的作用域，看下面一个例子\r\n\r\n```js\r\ntry {\r\n  throw 5;\r\n} catch (e) {\r\n  console.log(e);\r\n}\r\nconsole.log(e); //error e is not defined\r\n```\r\n\r\n这里 try 会创建一个块级作用域，在全局环境下 a 不存在，所以报错了。\r\n聪明的小伙伴可能已经想到了，可以使用 try 来创建块级作用域，理论上是可行的，不过实际上有两点问题\r\n\r\n1. 性能太慢\r\n2. 语法丑陋，要显示的报错\r\n\r\n我们来看下`babel`怎么处理上面的例子\r\n\r\n```js\r\n\"use strict\";\r\n\r\nvar _loop = function _loop(i) {\r\n  setTimeout(function() {\r\n    console.log(i);\r\n  }, 100);\r\n};\r\n\r\nfor (var i = 0; i < 10; i++) {\r\n  _loop(i);\r\n}\r\n```\r\n\r\n可以看到与立即执行函数基本相同，不过使用立即执行函数创建块级作用域需要注意一点`this`的指向\r\n例如这个例子\r\n\r\n```js\r\nconst obj = {\r\n  foo() {\r\n    for (let i = 0; i < 5; i += 1) {\r\n      setTimeout(() => {\r\n        console.log(this.arr[i]);\r\n      }, 1000);\r\n    }\r\n  },\r\n  arr: [1, 2, 3, 4, 5]\r\n};\r\n```\r\n\r\n箭头函数没有自己的 this 对象，是定义时的对象而不是运行时的对象，在这个例子中指向的是 obj；\r\n如果要把上面的代码转化为 ES5 环境支持的代码，我们可以通过作用域的规则来实现\r\n\r\n```js\r\n(function() {\r\n  var _this = this;\r\n  setTimeout(function() {\r\n    console.log(_this.arr[i]);\r\n  }, 1000);\r\n})();\r\n```\r\n\r\n上面就实现了所需的功能\r\n\r\n## 隐藏的 global 对象\r\n\r\n下面代码假设环境为浏览器环境，JavaScript 有许多设计缺陷，其中不使用声明声明变量，会自动将变量创建在`global`上就是其一，不过下面就来漫谈特殊的`global`对象\r\n\r\n```js\r\nvar a = 10;\r\nb = 20;\r\nwindow.a; //10\r\nwindow.b; //20\r\n```\r\n\r\n### 正文\r\n\r\n创建一个带有 id 的 DOM 元素，html 内的 id 元素也会自动反映在`global`对象上，例如下面\r\n\r\n```html\r\n<div id=\"div\"></div>\r\n<script>\r\n  console.log(typeof div); //object\r\n</script>\r\n```\r\n\r\n通过`id`的 DOM 元素，可以直接使用 DOM 上的一些方法，算是一个奇淫巧技\r\n\r\n```js\r\nconsole.log(div.nodeType); //1\r\nconsole.log(div.nodeName); //DIV\r\n//...\r\n```\r\n\r\n不过应该避免使用 id 的 DOM 元素，不易于代码的可读性，更推荐使用标准获取 dom 的方法。\r\n最后提示一点，如果存在相同的`id`dom，css 代码会作用两个相同的元素\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/bosens-China/blog/issues/2/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/bosens-China/blog/issues/2/timeline",
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/bosens-China/blog/issues/38",
    "repository_url": "https://api.github.com/repos/bosens-China/blog",
    "labels_url": "https://api.github.com/repos/bosens-China/blog/issues/38/labels{/name}",
    "comments_url": "https://api.github.com/repos/bosens-China/blog/issues/38/comments",
    "events_url": "https://api.github.com/repos/bosens-China/blog/issues/38/events",
    "html_url": "https://github.com/bosens-China/blog/issues/38",
    "id": 526470420,
    "node_id": "MDU6SXNzdWU1MjY0NzA0MjA=",
    "number": 38,
    "title": "聊一聊兼容移动端的那些的事情",
    "user": {
      "login": "bosens-China",
      "id": 39508895,
      "node_id": "MDQ6VXNlcjM5NTA4ODk1",
      "avatar_url": "https://avatars.githubusercontent.com/u/39508895?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/bosens-China",
      "html_url": "https://github.com/bosens-China",
      "followers_url": "https://api.github.com/users/bosens-China/followers",
      "following_url": "https://api.github.com/users/bosens-China/following{/other_user}",
      "gists_url": "https://api.github.com/users/bosens-China/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/bosens-China/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/bosens-China/subscriptions",
      "organizations_url": "https://api.github.com/users/bosens-China/orgs",
      "repos_url": "https://api.github.com/users/bosens-China/repos",
      "events_url": "https://api.github.com/users/bosens-China/events{/privacy}",
      "received_events_url": "https://api.github.com/users/bosens-China/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [
      {
        "id": 1371686611,
        "node_id": "MDU6TGFiZWwxMzcxNjg2NjEx",
        "url": "https://api.github.com/repos/bosens-China/blog/labels/%E5%85%B6%E4%BB%96",
        "name": "其他",
        "color": "f6ecbf",
        "default": false,
        "description": "暂定为分享之类的"
      }
    ],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 0,
    "created_at": "2019-11-21T09:33:17Z",
    "updated_at": "2019-11-21T09:33:17Z",
    "closed_at": null,
    "author_association": "OWNER",
    "active_lock_reason": null,
    "body": "最近在做移动端的项目，踩了许多坑，下面就是一些总结\r\n\r\n> 2019 年 11 月 21 日\r\n\r\n## px 适配\r\n\r\n关于适配网上有很多文章总结了，这里就不做概括了，简单来说如果为了兼容低版本一些的可以用 rem 布局，如果对兼容没有太多要求可以尝试一下`vw、vh`适配。\r\n\r\n- [rem](https://github.com/bosens-China/lib-flexible)\r\n- [如何在 Vue 项目中使用 vw 实现移动端适配](https://www.w3cplus.com/mobile/vw-layout-in-vue.html)\r\n\r\n## 1px\r\n\r\n出现的问题跟设备像素比有关，设计稿一般为 750，那么 375 的屏幕 1px 就是 0.5px，安卓对 0.5px 的写法并不支持，解决的方法下面这篇文章概括很全面\r\n[移动端 1px 解决方案](https://juejin.im/post/5d19b729f265da1bb2774865)\r\n\r\n## click 点击延迟事件\r\n\r\n一般而言这个问题只有比较老的浏览器才会出现，很不幸我就遇到了，出现的原因跟事件的执行有关，当你点击的时候浏览器需要判断后面会不会继续跟一个点击，如果是就执行双击缩放的功能，下面说一下常见的解决方法\r\n\r\n- [移动端 300ms 点击延迟和点击穿透](https://juejin.im/post/5b3cc9836fb9a04f9a5cb0e0#heading-7)\r\n\r\n## 浮层滚动\r\n\r\n浮层弹出对话框之类的都是很常见的需求，我们一般而言会用`fixed`来实现，不过在移动端上依然是可以滚动的，下面就分享一种方法\r\n\r\n```js\r\nvar bodyEl = document.body;\r\nvar top = 0;\r\n\r\nfunction stopBodyScroll(isFixed) {\r\n  if (isFixed) {\r\n    top = window.scrollY;\r\n    bodyEl.style.position = \"fixed\";\r\n    bodyEl.style.top = -top + \"px\";\r\n  } else {\r\n    bodyEl.style.position = \"\";\r\n    bodyEl.style.top = \"\";\r\n    // 回到原先的top\r\n    window.scrollTo(0, top);\r\n  }\r\n}\r\n```\r\n\r\n其他文章推荐\r\n\r\n- [【前端词典】滚动穿透问题的解决方案](https://juejin.im/post/5c2dc9cce51d45690a254b79#heading-5)\r\n\r\n## ios 底部安全区\r\n\r\n出现原因是因为 ios 取消了物理按键改用虚拟按钮\r\n\r\n- [H5 页面适配 iPhone X，就是那么简单](https://juejin.im/post/5d6cb884f265da03ae788f28)\r\n\r\n## 安卓 fixed 定位输入框输入出现错位\r\n\r\n不要脸推荐一下自己之前写的文章，这个是安卓上才有，ios 不存在，建议的话就是不要使用`fixed`定位改用`absolute`;\r\n\r\n- [键盘顶起引发的血案](https://juejin.im/post/5dbfe9416fb9a020333c3d83)\r\n\r\n## position:fixed/absolute 随屏幕滚动\r\n\r\n可以在`fixed/absolute`样式内添加\r\n\r\n```css\r\noverflow-y: auto;\r\n-webkit-transform: translateZ(0);\r\n```\r\n\r\n## ios 点击失效\r\n\r\n简单一些可以直接在点击的元素上设置\r\n\r\n```css\r\ncursor: pointer;\r\n```\r\n\r\n- [iOS 下的点击事件失效解决方法](https://segmentfault.com/a/1190000009231024)\r\n\r\n## 前进后退事件(暂时没找到实现方法)\r\n\r\n最近在有一个需求就是从 A 文件 跳转到 B 文件，在 B 执行了一些请求之类的操作，但是 A 也要刷新，当然是不同的页面不是 SAP 的单页面，当时想了一下直接通过监听`popstate`事件不就可以获取么\r\n\r\n```html\r\n<!-- 缩减代码 -->\r\n<a href=\"help.html\">子页面</a>\r\n<script>\r\n  window.onpopstate = function(event) {\r\n    // 执行一些操作\r\n  };\r\n</script>\r\n```\r\n\r\n不过很遗憾这种方法是不行的，因为`popstate`事件针对的是 `history`对象发生变化时，另外，该事件只针对同一个文档，如果浏览历史的切换，导致加载不同的文档，该事件也不会触发，类似的还有`popstate`也不会触发，暂时没找到解决方法，如果有找到解决方法的小伙伴分享一下下。\r\n\r\n## 最后\r\n\r\n如果为内联样式动态辅助的时候注意兼容性的写法，常见的浏览器前缀如下\r\n\r\n```js\r\n[\"Moz\", \"Webkit\", \"O\", \"ms\", \"Khtml\"];\r\n```\r\n\r\n推荐一篇文章，觉得写得十分不错\r\n[前端认知：PPI、DPI、设备像素等概念](https://juejin.im/post/5d5e867fe51d4557ca7fdd4f)\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/bosens-China/blog/issues/38/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/bosens-China/blog/issues/38/timeline",
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/bosens-China/blog/issues/36",
    "repository_url": "https://api.github.com/repos/bosens-China/blog",
    "labels_url": "https://api.github.com/repos/bosens-China/blog/issues/36/labels{/name}",
    "comments_url": "https://api.github.com/repos/bosens-China/blog/issues/36/comments",
    "events_url": "https://api.github.com/repos/bosens-China/blog/issues/36/events",
    "html_url": "https://github.com/bosens-China/blog/issues/36",
    "id": 522570348,
    "node_id": "MDU6SXNzdWU1MjI1NzAzNDg=",
    "number": 36,
    "title": "漫谈一下权限设计相关",
    "user": {
      "login": "bosens-China",
      "id": 39508895,
      "node_id": "MDQ6VXNlcjM5NTA4ODk1",
      "avatar_url": "https://avatars.githubusercontent.com/u/39508895?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/bosens-China",
      "html_url": "https://github.com/bosens-China",
      "followers_url": "https://api.github.com/users/bosens-China/followers",
      "following_url": "https://api.github.com/users/bosens-China/following{/other_user}",
      "gists_url": "https://api.github.com/users/bosens-China/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/bosens-China/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/bosens-China/subscriptions",
      "organizations_url": "https://api.github.com/users/bosens-China/orgs",
      "repos_url": "https://api.github.com/users/bosens-China/repos",
      "events_url": "https://api.github.com/users/bosens-China/events{/privacy}",
      "received_events_url": "https://api.github.com/users/bosens-China/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [
      {
        "id": 1371686611,
        "node_id": "MDU6TGFiZWwxMzcxNjg2NjEx",
        "url": "https://api.github.com/repos/bosens-China/blog/labels/%E5%85%B6%E4%BB%96",
        "name": "其他",
        "color": "f6ecbf",
        "default": false,
        "description": "暂定为分享之类的"
      }
    ],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 0,
    "created_at": "2019-11-14T01:35:53Z",
    "updated_at": "2019-11-14T01:35:53Z",
    "closed_at": null,
    "author_association": "OWNER",
    "active_lock_reason": null,
    "body": "> 这里不会介绍具体实现的方式，要根据公司的业务来进行调整，下面就聊一聊基本设计的思路。\r\n\r\n权限的设计对于一个后台来说至关重要，不过也要根据情况来选择，比如我们不会在一个博客或者个人网站的后台中写上权限控制，因为这是没有必要的，但是对于面向不同用户的产品来说就很有必要了，举个例子来说，滴滴打车的乘客和车主肯定是两个不同的用户产品，如何管理里面的数据就需要引用权限设计的功能了。\r\n\r\n权限设计可以帮助我们增加信息安全、保证页面的简洁不至于出现误操作的事情，下面就来说下基本的组成\r\n\r\n## 组成\r\n\r\n- 权限\r\n  ![](https://user-gold-cdn.xitu.io/2019/11/14/16e6786c0af135b6?w=1080&h=638&f=webp&s=9744)\r\n  权限这块可以分为页面权限、功能权限和数据权限，页面权限就是指是否能访问当前页面，功能权限对应的则是（增加、删除、修改等），而数据权限则是可以访问的数据范围。\r\n\r\n- 角色\r\n\r\n  在一个成熟的后台设计中必然要出现角色，这是为了避免每新增一个用户就还要重新为他勾选一遍权限，由角色赋值给用户权限，角色这层就相当于一个中间层，同时也方便维护。\r\n\r\n- 用户\r\n\r\n  每个用户对应一个账号，在默认状态下会给予用户一个最小的操作权限，权限的赋值由角色给予，多个角色的权限是可以叠加的。\r\n\r\n## 延伸\r\n\r\n上面介绍的其实就是`RBAC`模型的简单概念，在实际开发中觉得至少有以下几点需要注意：\r\n\r\n- admin\r\n\r\n在开发完成后需要在角色预留一个 admin 或者超级管理员，方便开发人员的维护\r\n\r\n- 权限的优先级\r\n\r\n上面介绍了权限的组成，但是页面的权限应当是大于操作的权限，只有页面的权限可见，功能的权限才是有意义的\r\n\r\n- tips\r\n\r\n无权限访问页面、页面不存在、服务器发生错误等方面的提示\r\n\r\n## 最后\r\n\r\n最后说一下前端对`tips`这块的处理\r\n403、404、500 的处理思路\r\n\r\n##### 500\r\n\r\n500 的处理可以通过`axions`的拦截器来实现，现在后端默认返回的基本格式都是\r\n\r\n```js\r\n{\r\n  // 状态码\r\n  status: 200,\r\n  data: {},\r\n  // ...\r\n  }\r\n```\r\n\r\n所以判断服务器发生错误，我们可以直接通过\r\n\r\n```js\r\n// 添加请求拦截器\r\naxios.interceptors.request.use(\r\n  function(config) {\r\n    // 在发送请求之前做些什么\r\n    return config;\r\n  },\r\n  function(error) {\r\n    // 对请求错误做些什么，这一步可以直接返回服务器发生错误，方便提示信息的定制\r\n    return Promise.reject(`服务器发生错误`);\r\n  }\r\n);\r\n```\r\n\r\n##### 404\r\n\r\n404 的实现可以通过`router`来实现，这里我用的是`vue router`就以这个举例，假设有一组路由为\r\n\r\n```js\r\nconst router = new VueRouter({\r\n  routes: [\r\n    {\r\n      path: \"/user\",\r\n      component: User,\r\n      children: [\r\n        {\r\n          path: \"profile\",\r\n          component: UserProfile\r\n        },\r\n        {\r\n          path: \"posts\",\r\n          component: UserPosts\r\n        }\r\n      ]\r\n    },\r\n    {\r\n      path: \"/sign\",\r\n      component: sign\r\n    }\r\n  ]\r\n});\r\n```\r\n\r\n那我们就通过递归将所有路由拼成一维数组（注意对比的条件，这里我对比的是 path 所以在递归过程中要将父 path 相加），具体的递归实现取决于你的常见，这里不做演示，之后对比访问的路径存不存在路由信息中，不存在则说明页面不存在返回`404`\r\n\r\n##### 403\r\n\r\n403 的实现需要配合后端来实现，一般情况下会请求用户的操作权限会返回当前用户权限所能操作的菜单，之后将能访问的菜单和路由信息对比，如果访问的路径在路由信息中但是不在用户返回的菜单说明没有页面访问的权限。\r\n\r\n最后说下为什么没有用`*`的原因，因为不太好定制，在默认状态下以`'/'`的形式访问我们要给予一个用户菜单的第一项，但是如果`'/'`不存在路由中我们还要写额外的判断，不如全部自己来自行处理了。\r\n\r\n## 参考\r\n\r\n1. [角色权限设计的 100 种解法](<https://mp.weixin.qq.com/s?__biz=MzI1ODY0NTg0MA==&mid=2247484799&idx=1&sn=5467e1452356e36607d938752805eb7d&chksm=ea044f40dd73c6563e72b1f34d0c27a23d06d5bcd80255568a9caa359ef2d03cd89713f0449b&scene=0&key=7fa4b6bcf3a05ff6a03f1d892329a3a1fcb4a9dd572857d0b82f72ec1386dfb5bd66a733158b657f4524063e1b5b4ade5442b1f23c89adbc9cfa818a68f64fbb4e725cc4baa55d048efe25d963e9e391&ascene=0&uin=MTAyMzI5NDA0Mw%3D%3D&devicetype=iMac+MacBookPro11%2C4+OSX+OSX+10.11.6+build(15G22010)&version=12020010&nettype=WIFI&lang=en&fontScale=100&pass_ticket=GR%2BJaO%2FEpgB4z%2BZuVHJsrM8QYhyiZAEBCQll6nnnN5CpbcQ%2FhZ5WoCr%2Fxr5QWiOL>)\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/bosens-China/blog/issues/36/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/bosens-China/blog/issues/36/timeline",
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/bosens-China/blog/issues/34",
    "repository_url": "https://api.github.com/repos/bosens-China/blog",
    "labels_url": "https://api.github.com/repos/bosens-China/blog/issues/34/labels{/name}",
    "comments_url": "https://api.github.com/repos/bosens-China/blog/issues/34/comments",
    "events_url": "https://api.github.com/repos/bosens-China/blog/issues/34/events",
    "html_url": "https://github.com/bosens-China/blog/issues/34",
    "id": 512000452,
    "node_id": "MDU6SXNzdWU1MTIwMDA0NTI=",
    "number": 34,
    "title": "聊聊选择器的一些事",
    "user": {
      "login": "bosens-China",
      "id": 39508895,
      "node_id": "MDQ6VXNlcjM5NTA4ODk1",
      "avatar_url": "https://avatars.githubusercontent.com/u/39508895?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/bosens-China",
      "html_url": "https://github.com/bosens-China",
      "followers_url": "https://api.github.com/users/bosens-China/followers",
      "following_url": "https://api.github.com/users/bosens-China/following{/other_user}",
      "gists_url": "https://api.github.com/users/bosens-China/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/bosens-China/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/bosens-China/subscriptions",
      "organizations_url": "https://api.github.com/users/bosens-China/orgs",
      "repos_url": "https://api.github.com/users/bosens-China/repos",
      "events_url": "https://api.github.com/users/bosens-China/events{/privacy}",
      "received_events_url": "https://api.github.com/users/bosens-China/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [
      {
        "id": 1371686610,
        "node_id": "MDU6TGFiZWwxMzcxNjg2NjEw",
        "url": "https://api.github.com/repos/bosens-China/blog/labels/css%20%E7%9B%B8%E5%85%B3",
        "name": "css 相关",
        "color": "42b883",
        "default": false,
        "description": "css 技巧和基础为主"
      }
    ],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 0,
    "created_at": "2019-10-24T14:56:12Z",
    "updated_at": "2019-10-24T14:56:12Z",
    "closed_at": null,
    "author_association": "OWNER",
    "active_lock_reason": null,
    "body": "> 失踪人口冒个泡\r\n\r\n## 优先级\r\n\r\n入门学习的时候一定就听说过这些概念，在菜鸟教程之类的网站上也肯定学习过，比如类的优先级为 10、标签的优先级为 1，这些都是辅助我们记忆的，下面就来说一说容易出错的点。\r\n\r\n```css\r\n.top {\r\n  margin: 10px;\r\n}\r\n[class] {\r\n  margin: 20px;\r\n}\r\n```\r\n\r\n这里输出的`margin`为多少？\r\n\r\n答案是`20px`，对于类和属性选择器以及伪类优先级是一致的，当然这个例子只是帮你温习的，再来看一个\r\n\r\n```css\r\n/*第一条*/\r\nbody [class] {\r\n  color: #666;\r\n}\r\n/*第二条*/\r\nhtml:not([dir]) {\r\n  color: red;\r\n}\r\n```\r\n\r\n这里两条属性的优先级相等么？\r\n\r\n答案是相等的，对于`:not`这样的逻辑组合伪类影响优先级的是里面的元素，上面第一条是一个标签加上属性选择器优先级为 11，第二条 html 标签加上属性选择器优先级也是 11。\r\n\r\n## 渲染顺序\r\n\r\n上面举了一个例子最终颜色生效为`red`，这是因为后来居上的原则，不过注意这个后来居上说的是整体文档而言。\r\n\r\n```html\r\n<link rel=\"stylesheet\" href=\"a.css\" /> <link rel=\"stylesheet\" href=\"b.css\" />\r\n```\r\n\r\na.css\r\n\r\n```css\r\nbody .foo {\r\n  color: red;\r\n}\r\n```\r\n\r\nb.css\r\n\r\n```css\r\nhtml .foo {\r\n  color: #666;\r\n}\r\n```\r\n\r\n最终`color`的值为`#666`，同时还提醒一下 css 最终生效并不是看元素的距离的远近，而是根据优先级和位置，比如上面的 body 肯定比 html 离得近，但是因为后来居上所以并没有生效。\r\n\r\n## 选择器是否能跨级？\r\n\r\n在开头说了方便记忆我们会给类和标签之类的优先级添加上数字，但是如果你想用数量多就覆盖高一层级的是不可能的\r\n\r\n```css\r\n.a {\r\n  color: red;\r\n}\r\na,\r\na,\r\na,\r\na,\r\na,\r\na,\r\na,\r\na,\r\na,\r\na,\r\na,\r\na,\r\na,\r\na,\r\na,\r\na,\r\na,\r\na {\r\n  color: #666;\r\n}\r\n```\r\n\r\n输出结果还是红色。\r\n\r\n## 增加优先级\r\n\r\n传统添加优先级我们可能会通过给标签添加 id 或者继续嵌套来实现，不过这样做肯定不合适因为后面在想修改可能就需要使用`style`或者`important`了，下面就说下两个小技巧\r\n\r\n1. 使用属性选择器\r\n\r\n```css\r\n.a[class] {\r\n  color: red;\r\n}\r\n.a {\r\n  color: #666;\r\n}\r\n```\r\n\r\n2. 嵌套选择自己\r\n\r\n```css\r\n.a.a {\r\n  color: red;\r\n}\r\n.a {\r\n  color: #666;\r\n}\r\n```\r\n\r\n## 匹配顺序\r\n\r\n说一点新手噩梦，css 的匹配顺序是从右往左，所以嵌套太多层的 css 语句就不要在写了，一般而言 id 选择器和类选择器的解析最快，标签选择器的速度很慢，所以在项目中不要嵌入太多的标签选择器有利于项目的优化。\r\n\r\n## 是否区分大小写\r\n\r\n说这个首先要说一下 html 是否区分大小写，html 对于标签和属性是不区分大小写的，而对属性值则是区分的，css 与 html 保持一致\r\n\r\n```html\r\n<style>\r\n  p {\r\n    color: #666;\r\n  }\r\n  [CLASS] {\r\n    color: red;\r\n  }\r\n  .foo {\r\n    color: white;\r\n  }\r\n</style>\r\n<p class=\"FOO\">hello wrold</p>\r\n```\r\n\r\n这里 p 的 `color` 为 `red`，说明了标签和属性选择器不区分大小写，而对于 class 则是区分的。\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/bosens-China/blog/issues/34/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/bosens-China/blog/issues/34/timeline",
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/bosens-China/blog/issues/28",
    "repository_url": "https://api.github.com/repos/bosens-China/blog",
    "labels_url": "https://api.github.com/repos/bosens-China/blog/issues/28/labels{/name}",
    "comments_url": "https://api.github.com/repos/bosens-China/blog/issues/28/comments",
    "events_url": "https://api.github.com/repos/bosens-China/blog/issues/28/events",
    "html_url": "https://github.com/bosens-China/blog/issues/28",
    "id": 499359943,
    "node_id": "MDU6SXNzdWU0OTkzNTk5NDM=",
    "number": 28,
    "title": "MatchMedia API",
    "user": {
      "login": "bosens-China",
      "id": 39508895,
      "node_id": "MDQ6VXNlcjM5NTA4ODk1",
      "avatar_url": "https://avatars.githubusercontent.com/u/39508895?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/bosens-China",
      "html_url": "https://github.com/bosens-China",
      "followers_url": "https://api.github.com/users/bosens-China/followers",
      "following_url": "https://api.github.com/users/bosens-China/following{/other_user}",
      "gists_url": "https://api.github.com/users/bosens-China/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/bosens-China/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/bosens-China/subscriptions",
      "organizations_url": "https://api.github.com/users/bosens-China/orgs",
      "repos_url": "https://api.github.com/users/bosens-China/repos",
      "events_url": "https://api.github.com/users/bosens-China/events{/privacy}",
      "received_events_url": "https://api.github.com/users/bosens-China/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [
      {
        "id": 1580833992,
        "node_id": "MDU6TGFiZWwxNTgwODMzOTky",
        "url": "https://api.github.com/repos/bosens-China/blog/labels/%E5%AE%9E%E9%AA%8C%E6%80%A7%20API",
        "name": "实验性 API",
        "color": "7aa9d6",
        "default": false,
        "description": ""
      }
    ],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 0,
    "created_at": "2019-09-27T10:12:54Z",
    "updated_at": "2019-09-27T10:14:33Z",
    "closed_at": null,
    "author_association": "OWNER",
    "active_lock_reason": null,
    "body": "\r\n![456](https://user-images.githubusercontent.com/39508895/65761913-63d54580-e152-11e9-89e1-76f82d5df39f.jpg)\r\n\r\n\r\n> 注意`matchMedia`为实验性语法文档可能被重新修订，后面有可能会改变语法，在生产中请配合[matchMedia polyfill](https://github.com/paulirish/matchMedia.js)使用\r\n\r\n通过媒体查询，您可以根据各种设备特征和参数的值或者是否存在来调整您的网站或应用；\r\n\r\n上面是 MDN 对媒体查询的定义，简单情况通过 css 媒体查询 调整页面已经足够了，不过现在页面交互和功能越来越多，比如一个页面要响应式布局，同时在不同屏幕下页面结构不同，是不是感觉有些力不从心了，下面介绍一下`matchMedia`。\r\n\r\n## 使用方法\r\n\r\n```js\r\nvar mqList = window.matchMedia(mediaQueryString);\r\n```\r\n\r\nmatchMedia 可以实现编程方法式媒体查询，参数`mediaQueryString`为媒体语句，返回类型为`MediaQueryList`，下面是一个例子\r\n\r\n```js\r\nif (window.matchMedia(\"(min-width: 400px)\").matches) {\r\n  // 窗口大于等于400 情况\r\n} else {\r\n  // 窗口小于400\r\n}\r\n```\r\n\r\n## MediaQueryList \r\n\r\n- 属性\r\n\r\n  - matches:boolean： 如果当前 document 匹配该媒体查询列表则其值为 true；反之其值为 false。只读；\r\n  - media:DOMString 序列化的媒体查询列表；\r\n\r\n- 方法\r\n  - addListener(call: Function):void\r\n  - removeListener(call: Function):void\r\n\r\n### addListener\r\n\r\n```js\r\nMediaQueryList.addListener(func);\r\n```\r\n\r\nfunc 接收一个参数，初版参数的类型为[MediaQueryListListener ](https://developer.mozilla.org/en-US/docs/Web/API/MediaQueryListListener)新修订的参数类型为[MediaQueryListEvent,](https://developer.mozilla.org/en-US/docs/Web/API/MediaQueryListEvent)\r\n\r\n```js\r\nvar mql = window.matchMedia(\"(max-width: 600px)\");\r\n\r\nfunction screenTest(e) {\r\n  if (e.matches) {\r\n    // 屏幕小于等于600\r\n  } else {\r\n    // 屏幕大于600\r\n  }\r\n}\r\nmql.addListener(screenTest);\r\n```\r\n\r\n### removeListener\r\n\r\n```js\r\nMediaQueryList.removeListener(func);\r\n```\r\n\r\nfunc 表示要删除的回调函数的函数或函数引用\r\n\r\n```js\r\nvar mql = window.matchMedia(\"(max-width: 600px)\");\r\n\r\nfunction screenTest(e) {\r\n  if (e.matches) {\r\n    // 屏幕小于等于600\r\n  } else {\r\n    // 屏幕大于600\r\n  }\r\n}\r\n\r\nmql.addListener(screenTest);\r\n\r\n// 取消监听\r\nmql.removeListener(screenTest);\r\n```\r\n\r\n## 参考\r\n\r\nhttps://developer.mozilla.org/en-US/docs/Web/API/MediaQueryList/media\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/bosens-China/blog/issues/28/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/bosens-China/blog/issues/28/timeline",
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/bosens-China/blog/issues/25",
    "repository_url": "https://api.github.com/repos/bosens-China/blog",
    "labels_url": "https://api.github.com/repos/bosens-China/blog/issues/25/labels{/name}",
    "comments_url": "https://api.github.com/repos/bosens-China/blog/issues/25/comments",
    "events_url": "https://api.github.com/repos/bosens-China/blog/issues/25/events",
    "html_url": "https://github.com/bosens-China/blog/issues/25",
    "id": 492562332,
    "node_id": "MDU6SXNzdWU0OTI1NjIzMzI=",
    "number": 25,
    "title": "如何判断ie版本？",
    "user": {
      "login": "bosens-China",
      "id": 39508895,
      "node_id": "MDQ6VXNlcjM5NTA4ODk1",
      "avatar_url": "https://avatars.githubusercontent.com/u/39508895?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/bosens-China",
      "html_url": "https://github.com/bosens-China",
      "followers_url": "https://api.github.com/users/bosens-China/followers",
      "following_url": "https://api.github.com/users/bosens-China/following{/other_user}",
      "gists_url": "https://api.github.com/users/bosens-China/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/bosens-China/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/bosens-China/subscriptions",
      "organizations_url": "https://api.github.com/users/bosens-China/orgs",
      "repos_url": "https://api.github.com/users/bosens-China/repos",
      "events_url": "https://api.github.com/users/bosens-China/events{/privacy}",
      "received_events_url": "https://api.github.com/users/bosens-China/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [
      {
        "id": 1371686611,
        "node_id": "MDU6TGFiZWwxMzcxNjg2NjEx",
        "url": "https://api.github.com/repos/bosens-China/blog/labels/%E5%85%B6%E4%BB%96",
        "name": "其他",
        "color": "f6ecbf",
        "default": false,
        "description": "暂定为分享之类的"
      }
    ],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 0,
    "created_at": "2019-09-12T03:16:50Z",
    "updated_at": "2019-09-27T04:42:53Z",
    "closed_at": null,
    "author_association": "OWNER",
    "active_lock_reason": null,
    "body": "## 前言\r\n\r\n在开发中对不兼容的 ie 浏览器提示是很常见的需求，下面就来聊聊如何实现判断 ie 的版本\r\n\r\n## 条件注释\r\n\r\nIE 条件注释是微软从 IE5 开始就提供的一种非标准逻辑语句，作用是可以灵活的为不同 IE 版本浏览器导入不同 html 元素。很显然这种方法的最大好处就在于属于微软官方给出的兼容解决办法而且还能通过 W3C 的效验，从 IE10 开始，IE 浏览器已经不再支持条件注释。所以下面的写法，只能识别 IE9-浏览器\r\n\r\n下面就来介绍常见的语法\r\n\r\n### 识别单一\r\n\r\n1.  [if IE 6]\r\n    ie 版本为 6\r\n2.  [if IE 7]\r\n    ie 版本为 7\r\n\r\n### 范围识别\r\n\r\n| api | 描述     |\r\n| --- | -------- |\r\n| gt  | 　大于   |\r\n| gte | 大于等于 |\r\n| lt  | 小于     |\r\n| lte | 小于等于 |\r\n\r\n比如判断 ie 版本大于 7 的\r\n\r\n```html\r\n<!--[if get IE 7]>\r\n  <div class=\"box\" id=\"box\"></div>\r\n<![endif]-->\r\n```\r\n\r\n## 第一版\r\n\r\n根据上面的条件注释，我们很容易想到实现第一版功能，至于 ie10 和 ie11 怎么判断我们后面再说\r\n\r\n```js\r\nfunction isIe(edition) {\r\n  const dom = document.createElement(\"div\");\r\n  dom.innerHTML = `\r\n  <!--[if IE ${edition}]>\r\n    <div class=\"box\"></div>\r\n  <![endif]-->`.trim();\r\n  return dom.getElementsByTagName(\"div\").length == 1;\r\n}\r\n```\r\n\r\n可以打开 ie 浏览器简单的测试一下，撒花第一版功能已经实现了，下面就修复怎么来判断 ie10 和 ie11 的问题了\r\n\r\n`window.navigator`属性指向一个包含浏览器和系统信息的 `Navigator` 对象。脚本通过这个属性了解用户的环境信息，我们可以根据字段来正则判断 ie 的版本\r\n\r\n## 第二版\r\n\r\n下面的`navigator.userAgent`信息，我已经取到了，下面就是判断一下对应的关键词\r\n\r\n- ie10:\r\n  `Mozilla/5.0 (compatible; MSIE 10.0; Windows NT 6.1; WOW64; Trident/7.0; SLCC2; .NET CLR 2.0.50727; .NET CLR 3.5.30729; .NET CLR 3.0.30729; .NET4.0C; .NET4.0E)`\r\n\r\n- ie11:\r\n  `Mozilla/5.0 (Windows NT 6.1; WOW64; Trident/7.0; SLCC2; .NET CLR 2.0.50727; .NET CLR 3.5.30729; .NET CLR 3.0.30729; .NET4.0C; .NET4.0E; rv:11.0) like Gecko`\r\n\r\n```js\r\nfunction ie10() {\r\n  var reg = /MSIE\\s+(\\d+)/;\r\n  var exec = reg.exec(navigator.userAgent);\r\n  return exec && exec[1] == \"10\";\r\n}\r\nfunction ie11() {\r\n  var reg = /rv:(\\d+)/;\r\n  var exec = reg.exec(navigator.userAgent);\r\n  return exec && exec[1] == \"11\";\r\n}\r\n```\r\n\r\n这里就完成了 ie10 和 ie11 的判断，下面就是整合\r\n\r\n```js\r\nfunction ie10() {\r\n  var reg = /MSIE\\s+(\\d+)/;\r\n  var exec = reg.exec(navigator.userAgent);\r\n  return exec && exec[1] == \"10\";\r\n}\r\nfunction ie11() {\r\n  var reg = /rv:(\\d+)/;\r\n  var exec = reg.exec(navigator.userAgent);\r\n  return exec && exec[1] == \"11\";\r\n}\r\nfunction isIe(edition) {\r\n  var dom = document.createElement(\"div\");\r\n  dom.innerHTML = (\r\n    \"\\n  <!--[if IE \" +\r\n    edition +\r\n    ']>\\n    <div class=\"box\"></div>\\n  <![endif]-->'\r\n  ).trim();\r\n  return dom.getElementsByTagName(\"div\").length == 1;\r\n}\r\nfunction ie(edition) {\r\n  if (edition <= 9) {\r\n    return isIe(edition);\r\n  } else if (edition == 10) {\r\n    return ie10();\r\n  } else if (edition == 11) {\r\n    return ie11();\r\n  }\r\n  return false;\r\n}\r\n```\r\n\r\n## 兼容双核\r\n\r\n上面的版本在 ie 上运行是正常的，不过在国产的一些兼容模式下会存在问题，主要是条件注释语句失效了，解决这个问题也很简单，我们直接通过上面判断 ie10 的方法即可，我们取到对应的版本号判断\r\n\r\n```js\r\nfunction isIe(edition) {\r\n  var reg = /MSIE\\s+(\\d+)/;\r\n  var exec = reg.exec(navigator.userAgent);\r\n  return exec && exec[1] == String(edition);\r\n}\r\n\r\nfunction ie11() {\r\n  var reg = /rv:(\\d+)/;\r\n  var exec = reg.exec(navigator.userAgent);\r\n  return exec && exec[1] == \"11\";\r\n}\r\n\r\nfunction ie(edition) {\r\n  if (edition <= 10) {\r\n    return isIe(edition);\r\n  } else if (edition == 11) {\r\n    return ie11();\r\n  }\r\n  return false;\r\n}\r\n```\r\n\r\n## 最后\r\n封装了一个工具函数，如果你喜欢欢迎来[Star](https://github.com/bosens-China/ie-judgement)\r\n\r\n## 参考\r\n\r\n1. https://www.xiaohuochai.site/HTML/grammar/grammar_IEComment.html\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/bosens-China/blog/issues/25/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/bosens-China/blog/issues/25/timeline",
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/bosens-China/blog/issues/26",
    "repository_url": "https://api.github.com/repos/bosens-China/blog",
    "labels_url": "https://api.github.com/repos/bosens-China/blog/issues/26/labels{/name}",
    "comments_url": "https://api.github.com/repos/bosens-China/blog/issues/26/comments",
    "events_url": "https://api.github.com/repos/bosens-China/blog/issues/26/events",
    "html_url": "https://github.com/bosens-China/blog/issues/26",
    "id": 498112062,
    "node_id": "MDU6SXNzdWU0OTgxMTIwNjI=",
    "number": 26,
    "title": "ResizeObserver API",
    "user": {
      "login": "bosens-China",
      "id": 39508895,
      "node_id": "MDQ6VXNlcjM5NTA4ODk1",
      "avatar_url": "https://avatars.githubusercontent.com/u/39508895?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/bosens-China",
      "html_url": "https://github.com/bosens-China",
      "followers_url": "https://api.github.com/users/bosens-China/followers",
      "following_url": "https://api.github.com/users/bosens-China/following{/other_user}",
      "gists_url": "https://api.github.com/users/bosens-China/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/bosens-China/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/bosens-China/subscriptions",
      "organizations_url": "https://api.github.com/users/bosens-China/orgs",
      "repos_url": "https://api.github.com/users/bosens-China/repos",
      "events_url": "https://api.github.com/users/bosens-China/events{/privacy}",
      "received_events_url": "https://api.github.com/users/bosens-China/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [
      {
        "id": 1580833992,
        "node_id": "MDU6TGFiZWwxNTgwODMzOTky",
        "url": "https://api.github.com/repos/bosens-China/blog/labels/%E5%AE%9E%E9%AA%8C%E6%80%A7%20API",
        "name": "实验性 API",
        "color": "7aa9d6",
        "default": false,
        "description": ""
      }
    ],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 0,
    "created_at": "2019-09-25T07:51:27Z",
    "updated_at": "2019-09-27T02:03:01Z",
    "closed_at": null,
    "author_association": "OWNER",
    "active_lock_reason": null,
    "body": "\r\n![123](https://user-images.githubusercontent.com/39508895/65580529-6d24ad80-dfac-11e9-868f-328d7427391e.jpg)\r\n\r\n无意之间看到这个 API，发现这个 API 十分实用特来分享一下。\r\n\r\nResizeObserver 可以监听到 Element 的元素的变化，例如大小变化，在之前我们可能要监听 window 对象，因为 resize 定义在 window 上，不过注意这个 API 还是处于实验性阶段，在项目中要配合 [polyfill](https://github.com/que-etc/resize-observer-polyfill) 来使用\r\n\r\n## constructor\r\n\r\n```js\r\nvar ResizeObserver = new ResizeObserver(callback);\r\n```\r\n\r\n使用方法很简单，ResizeObserver 接收一个回调函数作为参数，当尺寸发生变化的时候 `callback` 函数接收一个 `ResizeObserverEntry` 数组，下面看一个例子\r\n\r\n```html\r\n<div class=\"box\"></div>\r\n<script>\r\n  const box = document.querySelector(\".box\");\r\n  const resizeObserver = new ResizeObserver(entries => {\r\n    for (let entry of entries) {\r\n      const dimensions = entry.contentRect;\r\n      console.log(`${dimensions.width} x ${dimensions.height}`);\r\n    }\r\n  });\r\n  resizeObserver.observe(box);\r\n  setTimeout(() => {\r\n    box.style.width = \"99px\";\r\n  }, 1000);\r\n</script>\r\n```\r\n\r\n上面定义了一个 box 的元素，并在一秒后更改宽度 `ResizeObserver` 可以监听到这一更改。\r\n\r\n> 特别提醒一下，添加初始元素的时候默认就会执行执行一次回调，也就是说不用手动执行一次获取初始信息了。\r\n\r\n## ResizeObserverEntry\r\n\r\n你可能好奇 ResizeObserverEntry 会返回什么格式的数据？\r\n它由两部分组成\r\n\r\n- target\r\n  target 很好理解就是我们添加的元素\r\n\r\n- contentRect\r\n  contentRect 其实就是一个盒子信息，它的类型是 [DOMRectReadOnly](https://developer.mozilla.org/zh-CN/docs/Web/API/DOMRectReadOnly),有以下几个属性\r\n  - bottom\r\n    返回的底部坐标值（通常与 y + 高度相同）\r\n  - height\r\n    高度\r\n  - width\r\n    宽度\r\n  - left\r\n    返回的左坐标值（通常与 x 相同）\r\n  - right\r\n    返回的右坐标值（通常与 x + width 相同）\r\n  - top\r\n    返回的顶部坐标值（通常与 y 相同）\r\n  - x\r\n    原点的 x 坐标\r\n  - y\r\n    原点的 y 坐标\r\n\r\n## 方法\r\n\r\n### observe\r\n\r\n```js\r\nresizeObserver.observe(target);\r\n```\r\n\r\n上面的示例中也有用到这个方法，用于添加监听的元素，注意 target 的类型必须是 Element 或 SVGElement 引用。\r\n\r\n### disconnect\r\n\r\n```js\r\nresizeObserver.disconnect();\r\n```\r\n\r\n停止和取消目标对象上所有对 Element 或 SVGElement 的监听。\r\n\r\n### unobserve\r\n\r\n```js\r\nresizeObserver.unobserve(target);\r\n```\r\n\r\n接收一个参数，停止对指定目标的监听，target 的类型为 Element 或 SVGElement 引用\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/bosens-China/blog/issues/26/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/bosens-China/blog/issues/26/timeline",
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/bosens-China/blog/issues/18",
    "repository_url": "https://api.github.com/repos/bosens-China/blog",
    "labels_url": "https://api.github.com/repos/bosens-China/blog/issues/18/labels{/name}",
    "comments_url": "https://api.github.com/repos/bosens-China/blog/issues/18/comments",
    "events_url": "https://api.github.com/repos/bosens-China/blog/issues/18/events",
    "html_url": "https://github.com/bosens-China/blog/issues/18",
    "id": 479907836,
    "node_id": "MDU6SXNzdWU0Nzk5MDc4MzY=",
    "number": 18,
    "title": "无效的height100%？",
    "user": {
      "login": "bosens-China",
      "id": 39508895,
      "node_id": "MDQ6VXNlcjM5NTA4ODk1",
      "avatar_url": "https://avatars.githubusercontent.com/u/39508895?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/bosens-China",
      "html_url": "https://github.com/bosens-China",
      "followers_url": "https://api.github.com/users/bosens-China/followers",
      "following_url": "https://api.github.com/users/bosens-China/following{/other_user}",
      "gists_url": "https://api.github.com/users/bosens-China/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/bosens-China/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/bosens-China/subscriptions",
      "organizations_url": "https://api.github.com/users/bosens-China/orgs",
      "repos_url": "https://api.github.com/users/bosens-China/repos",
      "events_url": "https://api.github.com/users/bosens-China/events{/privacy}",
      "received_events_url": "https://api.github.com/users/bosens-China/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [
      {
        "id": 1371686610,
        "node_id": "MDU6TGFiZWwxMzcxNjg2NjEw",
        "url": "https://api.github.com/repos/bosens-China/blog/labels/css%20%E7%9B%B8%E5%85%B3",
        "name": "css 相关",
        "color": "42b883",
        "default": false,
        "description": "css 技巧和基础为主"
      }
    ],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 0,
    "created_at": "2019-08-13T00:34:13Z",
    "updated_at": "2019-08-13T00:34:13Z",
    "closed_at": null,
    "author_association": "OWNER",
    "active_lock_reason": null,
    "body": "之所以写 height，是因为它出现的场所比较多\r\n``` css\r\nbody {\r\n  height: 100%;\r\n}\r\n```\r\n不知道你们有没有这样写过 css 属性，不过很遗憾这是无效的。\r\n\r\n父级没有给定明确的高度么？ 这样说有一定正确性，不过不够全面，在 height 的规范中规定了两种情况 100%可以解析出来\r\n\r\n1. 父级给定明确的高度\r\n这个没什么好说的，平时我们也是这样写的 比如上面 body 没有生效就是因为没有指定 html 的高度，所以要这样写\r\n``` css\r\nhtml,\r\nbody {\r\n  height: 100%;\r\n}\r\n```\r\n\r\n2. 使用绝对定位元素\r\n``` css\r\n.box {\r\n  position: relative;\r\n  .child {\r\n    position: absolute;\r\n    height: 100%;\r\n    widows: 100%;\r\n  }\r\n}\r\n```\r\n这样就获取到了高度，不过注意绝对定位获取的高度与父级给定高度有一定区别\r\n\r\n## 区别\r\ncss 是存在盒子模型的，平时高度和宽度都是作用在 `content-box` 上的，而上面说的第一种方式，高度获取到的就是父级 content 盒子的高度，怎么来证明呢？ `box-sizing` 可以改变作用高度和宽度的盒子，我们来用这个实验。\r\n``` html\r\n<div class=\"box\">\r\n  <div class=\"child\"></div>\r\n</div>\r\n.box {\r\n  width: 180px;\r\n  background: #ddd;\r\n  height: 150px;\r\n  padding: 30px;\r\n  box-sizing: border-box;\r\n  .child {\r\n    height: 100%;\r\n    background: #666;\r\n  }\r\n}\r\n```\r\n可以将上面代码复制到本地运行一下，可以看到子元素的高度并没有占用父元素的 100%。 改写一下，改成绝对定位来实现\r\n``` css\r\n.box {\r\n  width: 180px;\r\n  background: #ddd;\r\n  height: 150px;\r\n  padding: 30px;\r\n  box-sizing: border-box;\r\n  position: relative;\r\n  border: 20px solid;\r\n  .child {\r\n    height: 100%;\r\n    background: #666;\r\n    position: absolute;\r\n    width: 100%;\r\n  }\r\n}\r\n```\r\n对比一下可以看到绝对定位的高度是包含` padding` 区域的\r\n\r\n最后以一个示例结尾\r\n``` html\r\n<div class=\"box\">\r\n  <a href=\"javascript:\" class=\"nav\"></a>\r\n  <a href=\"javascript:\" class=\"nav nav1\"></a>\r\n  <img src=\"https://demo.cssworld.cn/images/common/l/1.jpg\" alt=\"\" />\r\n</div>\r\n.box {\r\n  display: inline-block;\r\n  position: relative;\r\n  .nav {\r\n    position: absolute;\r\n    height: 100%;\r\n    left: 0;\r\n    width: 50%;\r\n    opacity: 0.7;\r\n    background: #ddd;\r\n  }\r\n  .nav1 {\r\n    left: 50%;\r\n    background: #34538b;\r\n  }\r\n}\r\n```\r\n借助绝对定位实现了高度自适应的效果\r\n\r\n## 参考\r\n《css 世界》",
    "reactions": {
      "url": "https://api.github.com/repos/bosens-China/blog/issues/18/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/bosens-China/blog/issues/18/timeline",
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/bosens-China/blog/issues/15",
    "repository_url": "https://api.github.com/repos/bosens-China/blog",
    "labels_url": "https://api.github.com/repos/bosens-China/blog/issues/15/labels{/name}",
    "comments_url": "https://api.github.com/repos/bosens-China/blog/issues/15/comments",
    "events_url": "https://api.github.com/repos/bosens-China/blog/issues/15/events",
    "html_url": "https://github.com/bosens-China/blog/issues/15",
    "id": 479674402,
    "node_id": "MDU6SXNzdWU0Nzk2NzQ0MDI=",
    "number": 15,
    "title": "vue CLI3的优化",
    "user": {
      "login": "bosens-China",
      "id": 39508895,
      "node_id": "MDQ6VXNlcjM5NTA4ODk1",
      "avatar_url": "https://avatars.githubusercontent.com/u/39508895?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/bosens-China",
      "html_url": "https://github.com/bosens-China",
      "followers_url": "https://api.github.com/users/bosens-China/followers",
      "following_url": "https://api.github.com/users/bosens-China/following{/other_user}",
      "gists_url": "https://api.github.com/users/bosens-China/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/bosens-China/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/bosens-China/subscriptions",
      "organizations_url": "https://api.github.com/users/bosens-China/orgs",
      "repos_url": "https://api.github.com/users/bosens-China/repos",
      "events_url": "https://api.github.com/users/bosens-China/events{/privacy}",
      "received_events_url": "https://api.github.com/users/bosens-China/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [
      {
        "id": 1473940161,
        "node_id": "MDU6TGFiZWwxNDczOTQwMTYx",
        "url": "https://api.github.com/repos/bosens-China/blog/labels/Vue%20%E7%9B%B8%E5%85%B3",
        "name": "Vue 相关",
        "color": "42b883",
        "default": false,
        "description": "Vue 相关"
      }
    ],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 0,
    "created_at": "2019-08-12T14:23:06Z",
    "updated_at": "2019-08-12T14:23:06Z",
    "closed_at": null,
    "author_association": "OWNER",
    "active_lock_reason": null,
    "body": ">之前入职前，前任同事留了一份 vue CLI2 的代码给我，不得不说修修补补最讨厌了，所以上周升级了一下，也就是这篇文章的由来，使用的是 vue CLI3，未优化之前打包大小 24M，下面就分享一下我的优化之路。\r\n\r\n## 升级版本\r\n通常情况下，把版本升级到最新不仅可以提高编译速度，也可以避免一些出现过的问题( 惨遭打脸选用的 `Ant Design of Vue` 就重大更新了一次，又重新写的 )。\r\n\r\n## 按需加载\r\n比如常见的 `lodash` 库，我们显然不需要全部都用到，所以要采用按需加载的方式来引用，对一些常见的方法进行提取统一进行处理，一般来说如果支持的话，文档都会标注，如果没有又不想要体积太大就自己写一个，这方面不在过多阐述了。\r\n\r\n\r\n## webpack 方面\r\n`vue CLI3` 对 webpack 的相关配置在`vue.config.js`文件内进行设置，分析了一下打包大小原因，对于一些图片还可以进行压缩减少体积，我采用的是`image-webpack-loader`，直接配置\r\n``` js\r\nchainWebpack: config => {\r\n  config.module\r\n    .rule(\"image-webpack-loader\")\r\n    .test(/\\.(gif|png|jpe?g|svg)$/i)\r\n    .use(\"file-loader\")\r\n    .loader(\"image-webpack-loader\")\r\n    .tap(() => ({\r\n      disable: process.env.NODE_ENV !== \"production\"\r\n    }))\r\n    .end();\r\n};\r\n```\r\n上述做完，体积还是在 18M 左右。\r\n\r\n## Gzip\r\n下一步就是启用gzip压缩，具体内容可以去谷歌一下，这里只说如何实现，按照 vue CLI 文档在 `plugins` 内添加`compression-webpack-plugin`，做完上述之后已经成功将体积缩小一半了。\r\n\r\n## CDN\r\n推荐一下一个工具`webpack-bundle-analyzer`可视化分析打包大小。\r\n\r\n从上面查看打包分析，发现主要集中在百度的富文本和`@antv/data-set` 这两块，占用了近 12M，不过在文档方面没看到`@antv/data-set`的按需加载，有发现的小伙伴可以在下面留言，决定把这两部分放到公司内部的服务器上，采用` CND` 的形式来进行加载。\r\n\r\n这里推荐一下一篇文章[CDN 是什么？使用 CDN 有什么优势？ - 视界云的回答 - 知乎](https://www.zhihu.com/question/36514327/answer/184247188)，如果符合上面就直接上手吧。\r\n\r\n## 异步加载\r\nes6 有一个` import()`命令，在 webpack 中已经可以抢先体验，对于直接加载和异步加载最主要的区别加载的方式，比如` vue-router` 中的路由，完全可以采用异步加载的形式，这样可以大大缩小打包体积和首屏时间。\r\n\r\n## 其他\r\n1. 剔除 `console` 和 `debugger` 代码，这里我直接贴上我的配置了\r\n``` js\r\nminimizer: [new UglifyJsPlugin({\r\n    uglifyOptions: {\r\n      output: {\r\n        // 删除注释\r\n        comments: true,\r\n      },\r\n      chunkFilter: () => true,\r\n      compress: {\r\n        warnings: false,\r\n        // 删除console\r\n        drop_console: true,\r\n        ie8: false,\r\n        // 删除debugger\r\n        drop_debugger: true,\r\n      },\r\n    },\r\n    cache: true,\r\n     parallel: true,\r\n  })],\r\n```\r\n2. browserslistrc\r\n虽然默认配置已经很合理了，不过还可以针对受众群体进一步优化，这里公司不支持 ie 所以直接把版本锁定在了 ie > 11，可以减少一小部分的体积。\r\n\r\n## 最后\r\n因为 vue CLI 本身对这一方面优化的已经很成功了，所以其实并没有太多值得优化的地方，更多应该是代码本身。\r\n\r\n优化结束后，文件只有 3M 左右。",
    "reactions": {
      "url": "https://api.github.com/repos/bosens-China/blog/issues/15/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/bosens-China/blog/issues/15/timeline",
    "performed_via_github_app": null
  }
]
