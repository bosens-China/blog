{
  "label": [
    {
      "id": 1371686610,
      "node_id": "MDU6TGFiZWwxMzcxNjg2NjEw",
      "url": "https://api.github.com/repos/bosens-China/blog/labels/css%20%E7%9B%B8%E5%85%B3",
      "name": "css 相关",
      "color": "42b883",
      "default": false,
      "description": "css 技巧和基础为主"
    },
    {
      "id": 1908144759,
      "node_id": "MDU6TGFiZWwxOTA4MTQ0NzU5",
      "url": "https://api.github.com/repos/bosens-China/blog/labels/ES6%E7%B3%BB%E5%88%97",
      "name": "ES6系列",
      "color": "0366d6",
      "default": false,
      "description": "ES6的最新语法"
    },
    {
      "id": 1371686609,
      "node_id": "MDU6TGFiZWwxMzcxNjg2NjA5",
      "url": "https://api.github.com/repos/bosens-China/blog/labels/JavaScript",
      "name": "JavaScript",
      "color": "F7DF1E",
      "default": false,
      "description": "JavaScript系列的文章"
    },
    {
      "id": 3661377607,
      "node_id": "LA_kwDOCzPAy87aPDBH",
      "url": "https://api.github.com/repos/bosens-China/blog/labels/Node%E7%B3%BB%E5%88%97",
      "name": "Node系列",
      "color": "9F9262",
      "default": false,
      "description": "和node.js相关内容"
    },
    {
      "id": 3041947800,
      "node_id": "MDU6TGFiZWwzMDQxOTQ3ODAw",
      "url": "https://api.github.com/repos/bosens-China/blog/labels/%E4%BB%A3%E7%A0%81%E4%BA%BA%E7%94%9F",
      "name": "代码人生",
      "color": "7B17E3",
      "default": false,
      "description": "和技术无关，人生的感悟"
    },
    {
      "id": 3661376441,
      "node_id": "LA_kwDOCzPAy87aPCu5",
      "url": "https://api.github.com/repos/bosens-China/blog/labels/%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83",
      "name": "代码规范",
      "color": "5319e7",
      "default": false,
      "description": "团队规范、代码规范、技术选型等相关内容"
    },
    {
      "id": 1371686611,
      "node_id": "MDU6TGFiZWwxMzcxNjg2NjEx",
      "url": "https://api.github.com/repos/bosens-China/blog/labels/%E5%85%B6%E4%BB%96",
      "name": "其他",
      "color": "f6ecbf",
      "default": false,
      "description": "未找到分类，暂定的文章"
    },
    {
      "id": 6273949336,
      "node_id": "LA_kwDOCzPAy88AAAABdfTemA",
      "url": "https://api.github.com/repos/bosens-China/blog/labels/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA",
      "name": "博客搭建",
      "color": "b60205",
      "default": false,
      "description": "介绍博客简单的过程"
    },
    {
      "id": 1580833992,
      "node_id": "MDU6TGFiZWwxNTgwODMzOTky",
      "url": "https://api.github.com/repos/bosens-China/blog/labels/%E5%AE%9E%E9%AA%8C%E6%80%A7%20API",
      "name": "实验性 API",
      "color": "7aa9d6",
      "default": false,
      "description": "还未定稿的API"
    },
    {
      "id": 1740577858,
      "node_id": "MDU6TGFiZWwxNzQwNTc3ODU4",
      "url": "https://api.github.com/repos/bosens-China/blog/labels/%E5%B7%A5%E5%85%B7%E7%9B%B8%E5%85%B3",
      "name": "工具相关",
      "color": "f73d62",
      "default": false,
      "description": "工程化相关的东西"
    },
    {
      "id": 1935755992,
      "node_id": "MDU6TGFiZWwxOTM1NzU1OTky",
      "url": "https://api.github.com/repos/bosens-China/blog/labels/%E5%BE%85%E5%AE%8C%E6%88%90%E7%B3%BB%E5%88%97",
      "name": "待完成系列",
      "color": "cc6e43",
      "default": false,
      "description": "等待完成的文章..."
    },
    {
      "id": 1473940161,
      "node_id": "MDU6TGFiZWwxNDczOTQwMTYx",
      "url": "https://api.github.com/repos/bosens-China/blog/labels/%E6%A1%86%E6%9E%B6%E7%9B%B8%E5%85%B3",
      "name": "框架相关",
      "color": "42b883",
      "default": false,
      "description": "目前Vue和React为主"
    },
    {
      "id": 1602397157,
      "node_id": "MDU6TGFiZWwxNjAyMzk3MTU3",
      "url": "https://api.github.com/repos/bosens-China/blog/labels/%E6%B7%B1%E5%85%A5%E7%B3%BB%E5%88%97",
      "name": "深入系列",
      "color": "719192",
      "default": false,
      "description": "主要介绍实现的思路"
    },
    {
      "id": 1371686608,
      "node_id": "MDU6TGFiZWwxMzcxNjg2NjA4",
      "url": "https://api.github.com/repos/bosens-China/blog/labels/%E6%BC%AB%E8%B0%88%E7%B3%BB%E5%88%97",
      "name": "漫谈系列",
      "color": "e7f3ee",
      "default": false,
      "description": "浅谈类文章"
    },
    {
      "id": 1740561541,
      "node_id": "MDU6TGFiZWwxNzQwNTYxNTQx",
      "url": "https://api.github.com/repos/bosens-China/blog/labels/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F",
      "name": "设计模式",
      "color": "d1a540",
      "default": false,
      "description": "设计模式在JavaScript的实现"
    }
  ],
  "issuesData": [
    {
      "url": "https://api.github.com/repos/bosens-China/blog/issues/101",
      "repository_url": "https://api.github.com/repos/bosens-China/blog",
      "labels_url": "https://api.github.com/repos/bosens-China/blog/issues/101/labels{/name}",
      "comments_url": "https://api.github.com/repos/bosens-China/blog/issues/101/comments",
      "events_url": "https://api.github.com/repos/bosens-China/blog/issues/101/events",
      "html_url": "https://github.com/bosens-China/blog/issues/101",
      "id": 1998957787,
      "node_id": "I_kwDOCzPAy853Jazb",
      "number": 101,
      "title": "前端面试回顾",
      "user": {
        "login": "bosens-China",
        "id": 39508895,
        "node_id": "MDQ6VXNlcjM5NTA4ODk1",
        "avatar_url": "https://avatars.githubusercontent.com/u/39508895?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bosens-China",
        "html_url": "https://github.com/bosens-China",
        "followers_url": "https://api.github.com/users/bosens-China/followers",
        "following_url": "https://api.github.com/users/bosens-China/following{/other_user}",
        "gists_url": "https://api.github.com/users/bosens-China/gists{/gist_id}",
        "starred_url": "https://api.github.com/users/bosens-China/starred{/owner}{/repo}",
        "subscriptions_url": "https://api.github.com/users/bosens-China/subscriptions",
        "organizations_url": "https://api.github.com/users/bosens-China/orgs",
        "repos_url": "https://api.github.com/users/bosens-China/repos",
        "events_url": "https://api.github.com/users/bosens-China/events{/privacy}",
        "received_events_url": "https://api.github.com/users/bosens-China/received_events",
        "type": "User",
        "site_admin": false
      },
      "labels": [
        {
          "id": 3041947800,
          "node_id": "MDU6TGFiZWwzMDQxOTQ3ODAw",
          "url": "https://api.github.com/repos/bosens-China/blog/labels/%E4%BB%A3%E7%A0%81%E4%BA%BA%E7%94%9F",
          "name": "代码人生",
          "color": "7B17E3",
          "default": false,
          "description": "和技术无关，人生的感悟"
        }
      ],
      "state": "open",
      "locked": false,
      "assignee": null,
      "assignees": [],
      "milestone": null,
      "comments": 0,
      "created_at": "2023-11-17T12:00:41Z",
      "updated_at": "2024-03-06T09:11:39Z",
      "closed_at": null,
      "author_association": "OWNER",
      "active_lock_reason": null,
      "body": "\r\n趁现在有时间稍微总结一下面试的一些问题\r\n\r\n## one\r\n\r\n- Promise 为什么可以链式调用\r\n- 如果在.then 返回一个值，这个新的 Promise 状态是什么\r\n- 如果想要阻止链式调用，让后续的.then 一直暂停状态有哪些方法\r\n- all 和 allSettled 区别\r\n- 设计一个调度程序，可以让 Promise 并发执行，但是最多只能有 5 个任务在执行\r\n- 说一下什么是事件循环\r\n- nextTick 的实现原理\r\n- 聊一下 Promise 解决了什么问题，以及相关历史\r\n- async 和 await 如果要捕获错误需要怎么做，await 可以单独使用吗\r\n- 项目中使用了那些设计模式\r\n- 发布订阅模式和观察者模式有什么区别\r\n- Vue2 的响应式模式是怎么实现的\r\n- 除了 Promise 还有哪些微任务，以及如果考虑设计一个数据埋点，需要怎么设计\r\n\r\n总体在聊 Promise 这块，顺路说了一下 Vue2，不过初次面试还是当时有点紧张有点问题回答不是很好，面试的结果是通过，不过开的薪资跟我目标还是有很大差异，遂放弃。\r\n\r\n\r\n## two\r\n- 如果要你设计一个低代码，需要考虑哪些问题\r\n- 如何储存开发的公共组件，使用什么形式来保存，注入到页面中\r\n- 对于定制化需求，如何进行代码管理\r\n- 看你写的有关于团队规范的东西，可以简单介绍下吗\r\n- 聊一下什么是状态机\r\n- 什么是状态模式\r\n\r\n总体没怎么聊技术，可能面试官不是前端有关把。给的薪资还是不满意给拒绝掉了。\r\n\r\n### three\r\n\r\n- 什么是 BFC\r\n- 内容盒子和 IE 盒子区别\r\n- 在开发过程中怎么联调接口的（介绍下如何处理跨域）\r\n- TypeScript 使用 interface 还是 type 比较多，为什么\r\n- 怎么实现无痕刷新 token 的\r\n- 怎么部署产品的，聊一下思路\r\n- Docker 常见使用命令\r\n- 如果初始加载需要渲染 3d 模型，但是所需的 vtp 资源比较大，有什么办法可以优化吗\r\n\r\n这个也是搞医疗的，不过是做牙医相关的，感觉面试过程挺一般的，这个面试没通过。\r\n\r\n### four\r\n\r\n- 什么是节流和防抖，什么场景使用，怎么实现\r\n- webpack 和 rollup 有什么不同，打包的大小体积为什么有区别\r\n- CSS 重叠样式表，重叠怎么理解\r\n- Vue 的 diff 和 React 的 diff 有什么不同\r\n- 虚拟 Dom 是什么，为什么要用虚拟 Dom\r\n- 为什么很多框架采用无虚拟 Dom，例如 svelte\r\n- 为什么浏览器只有 body 在界面展示，head 这部分在浏览器中是什么处理的\r\n- cssos 是什么计算的\r\n- tc39 关注了那些最新语法\r\n- 如果后端一直返回数据，需要对 table 进行数据展示要怎么来设计，需要考虑内存储存不够场景\r\n- 怎么实现组件库的整体引用和分别引用，对于 css 样式怎么来实现呢？\r\n- 时间切片是什么，为什么 Vue 没有使用\r\n- React fiber 是什么\r\n- Vue 为什么有静态提升，React 没有，以及 solidjs 怎么实现的\r\n- tree Shink 基于什么实现的\r\n- ESM 和 commonjs 有什么不同\r\n- webpack tree Shink 和 rollup 有什么不同\r\n- Vite 和 Esbuild 的关系怎么来理解\r\n- 什么是 babel，它的作用是什么，以及和 Swc 的区别是什么\r\n- css 动画为什么比 js 动画流畅\r\n\r\n这个面试感觉很多问题没有回答上来，本来觉得都凉了，但是后面通知过了，就感觉还挺有意思。\r\n\r\n## five\r\n- 对于一个数组怎么转换为树结构\r\n- 对于闭包和浅拷贝的理解\r\n- 节流函数如何编写，后执行\r\n- React受控组件和非受控组件区别\r\n- 对于usememo和usecallback你是怎么理解的\r\n- 对于nuxt14的app和pages有什么区别\r\n- app下的增量模式有使用过吗\r\n- app下的img组件要怎么来进行优化\r\n- 对于nuxt布局方面有了解吗\r\n- TypeScript和静态语言方面的类型检查有什么不同吗\r\n- 使用monorepo的形式是什么，为什么这么做\r\n- 有使用过Lighthouse吗，知道它的原理是什么吗？\r\n- 对于性能优化你做了哪些措施，让Lighthouse的指标提升50%\r\n- 有使用过typeScript的验证库吗，可以保证线上运行时和接口返回值的类型一致\r\n- express的实现原理\r\n- 对于大文件的优化措施，对于流模式如何保证客户端断开之后继续从初始位置继续下载\r\n- 对于React的render谈一谈\r\n- Vue3和Vue2的提升点在于什么地方\r\n- TypeScript的泛型如何理解\r\n- TypeScript infercase和type的区别\r\n- TypeScript的协变和逆变区别\r\n- Webpack的插件有哪些钩子，是通过什么来管理整理流程的\r\n- Webpack从打包到构建中间经历了什么\r\n- nest的健康检查使用过没，对于服务挂了有什么应对措施\r\n- 使用过mongodb吗是如何编写的\r\n- 对于脚手架项目你做了哪些，有考虑哪些方面的维度吗\r\n- 对于项目中TypeScript使用any场景，你们公司有什么规范要求吗\r\n- 如何避免使用any呢？\r\n- 谈一谈你做的性能优化方面的举措，从页面加载开始说\r\n- 对于响应式页面你的做法是什么，如果存在多个项目和一个项目你觉得哪种更合适，需要考虑seo的抓取\r\n- 了解事件循环机制吗\r\n- 为什么js是单线程语言\r\n- Tailwind有使用过吗，你的实践做法是什么\r\n\r\n## 最后\r\n\r\n面试过程其实就是查缺补漏的过程，感觉 2023 年对于框架源码以及一个构建工具的实现细节还是要了解很多的。\r\n\r\n这里推荐一个介绍范文来聊自己，对于面试通过怎么和公司聊具体的薪资啥的，可以看我之前的文章 [如何选择合适的公司？](https://juejin.cn/post/6967742961262002190)\r\n\r\n```txt\r\n面试官你好很荣幸参加今天的面试，我叫xxx，毕业于xxx，\r\n距今已经有x年工作经验，擅长React + vue 技术栈，在上家公司担任前端工程师岗位，主要负责其中的xxx和xxx部分的工作，\r\n20xx-20xx年主要在做xx项目，这个项目是结合xxx而出现的，我在里面负责主要开发，以及底层工具的升级优化，最终xxx，\r\n平时还关注前沿技术，对于tc39和新的工具出现第一时间关注，平时还爱好写作，会定期复盘，以上就是我的自我介绍，谢谢。\r\n```\r\n",
      "reactions": {
        "url": "https://api.github.com/repos/bosens-China/blog/issues/101/reactions",
        "total_count": 0,
        "+1": 0,
        "-1": 0,
        "laugh": 0,
        "hooray": 0,
        "confused": 0,
        "heart": 0,
        "rocket": 0,
        "eyes": 0
      },
      "timeline_url": "https://api.github.com/repos/bosens-China/blog/issues/101/timeline",
      "performed_via_github_app": null,
      "state_reason": null
    },
    {
      "url": "https://api.github.com/repos/bosens-China/blog/issues/102",
      "repository_url": "https://api.github.com/repos/bosens-China/blog",
      "labels_url": "https://api.github.com/repos/bosens-China/blog/issues/102/labels{/name}",
      "comments_url": "https://api.github.com/repos/bosens-China/blog/issues/102/comments",
      "events_url": "https://api.github.com/repos/bosens-China/blog/issues/102/events",
      "html_url": "https://github.com/bosens-China/blog/issues/102",
      "id": 2020292180,
      "node_id": "I_kwDOCzPAy854azZU",
      "number": 102,
      "title": "Next.js 构建博客之资源抓取 ",
      "user": {
        "login": "bosens-China",
        "id": 39508895,
        "node_id": "MDQ6VXNlcjM5NTA4ODk1",
        "avatar_url": "https://avatars.githubusercontent.com/u/39508895?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bosens-China",
        "html_url": "https://github.com/bosens-China",
        "followers_url": "https://api.github.com/users/bosens-China/followers",
        "following_url": "https://api.github.com/users/bosens-China/following{/other_user}",
        "gists_url": "https://api.github.com/users/bosens-China/gists{/gist_id}",
        "starred_url": "https://api.github.com/users/bosens-China/starred{/owner}{/repo}",
        "subscriptions_url": "https://api.github.com/users/bosens-China/subscriptions",
        "organizations_url": "https://api.github.com/users/bosens-China/orgs",
        "repos_url": "https://api.github.com/users/bosens-China/repos",
        "events_url": "https://api.github.com/users/bosens-China/events{/privacy}",
        "received_events_url": "https://api.github.com/users/bosens-China/received_events",
        "type": "User",
        "site_admin": false
      },
      "labels": [
        {
          "id": 6273949336,
          "node_id": "LA_kwDOCzPAy88AAAABdfTemA",
          "url": "https://api.github.com/repos/bosens-China/blog/labels/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA",
          "name": "博客搭建",
          "color": "b60205",
          "default": false,
          "description": "介绍博客简单的过程"
        }
      ],
      "state": "open",
      "locked": false,
      "assignee": null,
      "assignees": [],
      "milestone": null,
      "comments": 0,
      "created_at": "2023-12-01T07:36:23Z",
      "updated_at": "2023-12-27T06:47:51Z",
      "closed_at": null,
      "author_association": "OWNER",
      "active_lock_reason": null,
      "body": "![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/93a4556e832740f0b44cb081a6a70b9e~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2998&h=1464&s=549772&e=png&b=fefefe)\r\n\r\n1.  [Next.js 构建博客之资源抓取](https://github.com/bosens-China/blog/issues/102)\r\n2.  [Next.js 构建博客之博客搭建](https://github.com/bosens-China/blog/issues/103)\r\n3.  [Next.js 构建博客之打包 SSG](https://github.com/bosens-China/blog/issues/104)\r\n4.  [Next.js 构建博客之常见问题处理](https://github.com/bosens-China/blog/issues/105)\r\n5.  [Next.js 构建博客之功能拓展](https://github.com/bosens-China/blog/issues/107)\r\n6.  [Next.js 构建博客之自动构建](https://github.com/bosens-China/blog/issues/108)\r\n\r\n这是 Next.js 搭建博客的第一章，整个系列会详细介绍如何结合 GitHub 和 Next.js 搭建自己的博客。\r\n\r\n如果你想看已经部署博客的地址可以[点击查看](https://bosens-china.github.io/blog/)，代码仓库地址[点击查看](https://github.com/bosens-China/blog)。\r\n\r\n在正式开始之前，使用坚果云画了一份流程图，方便后续的理解。\r\n\r\n![image-3.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/755c68b609ea44c6a5ef70fd43cc30da~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1172&h=946&s=293944&e=png&b=fdfdfd)\r\n\r\n整个流程都高度依赖 issues 和 labels，所以在正式讲解 Next.js 之前还需要思考怎么把当前仓库的所有 issues 和 labels 爬取下来，这里 GitHub 官方已经给出了相关的 api 文档，只需要参考调用即可。\r\n不过这里额外补充一下，为什么需要把整体 issues 和 labels 拉取下来再进行 Next.js 拉取呢，主要有三个原因：\r\n\r\n1.  GitHub api 并没有给出总页数多少，我们需要重复调用才知道是否结束，不会像开发项目中知道第几页从当前页数拉取就行；\r\n2.  每天调用的 api 也是有额度限制的，但是在开发环境调用频率很高会导致不能使用就太糟糕了；\r\n3.  可以对拉下来的数据进行拓展；\r\n\r\n## 项目初始化\r\n\r\n整体项目会最终采用一个 MonoRepo 的设计，采用的技术是 pnpm + workspace 形式，下面详细讲解下步骤。\r\n\r\n1.  新建 package.json 文件\r\n\r\n```sh\r\npnpm init -y\r\n```\r\n\r\n2.  创建 pnpm-workspace.yaml 文件，调整文件内容为\r\n\r\n```sh\r\npackages:\r\n  # 所有在 packages/  子目录下的 package\r\n  - \"packages/**\"\r\n  # 不包括在 test 文件夹下的 package\r\n  - \"!**/test/**\"\r\n```\r\n\r\n3.  在 packages 下创建 sideEffect 文件夹，在 sideEffect 下创建 package.json\r\n\r\n```sh\r\ncd packages/sideEffect\r\npnpm init -y\r\n```\r\n\r\n这个 sideEffect 文件最终就是我们加载各种副作用的一个文件夹，拉取 issues 的操作也在这里完成。\r\n\r\n经过上面一些步骤，目前项目的大概雏形已经有了，下面安装一些必备的依赖项方便后续的操作\r\n\r\n```sh\r\npnpm install axios dayjs dotenv fs-extra\r\n```\r\n\r\n之后进入[settings/tokens](https://github.com/settings/tokens)设置个人令牌，在开发环境传递给 GitHub api 接口使用，否则会受到限制[每小时只能请求 60 次](https://docs.github.com/zh/rest/overview/rate-limits-for-the-rest-api?apiVersion=2022-11-28)。\r\n\r\n![image-2.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/37c2c045830c42438cdb8bcad7bfada4~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=3754&h=1316&s=972620&e=png&b=ffffff)\r\n\r\n这里贴一下官方的文档地址 [issues](https://docs.github.com/en/rest/issues/issues?apiVersion=2022-11-28)，下一步就是把当前仓库所有信息拉取下来。\r\n\r\n## 拉取 issues and labels\r\n\r\n创建一个新的 api/index.ts 文件，我们所有相关的跟 GitHub api 都通过这个完成。\r\n\r\n上面在 settings/tokens 创建一个新的 token 保存下来，在 sideEffect 下新建一个.env 文件，将 token 保存成下面键值对形式。\r\n\r\n```sh\r\nAUTHORIZATION=xxx\r\n# GITHUB_REPOSITORY是你的用户名+仓库名组成，根据你自己的仓库调整\r\nGITHUB_REPOSITORY=bosens-China/blog\r\n```\r\n\r\n之后新建一个 utils/request.ts 文件，这个文件就是封装一下 axios 方便使用。\r\n\r\n```js\r\nimport axios from \"axios\";\r\n\r\nexport const instance = axios.create({\r\n  baseURL: \"https://api.github.com/\",\r\n  timeout: 10000,\r\n  headers: {\r\n    Accept: \"application/vnd.github+json\",\r\n    Authorization: `Bearer ${process.env.AUTHORIZATION}`,\r\n    \"X-GitHub-Api-Version\": \"2022-11-28\",\r\n  },\r\n});\r\n```\r\n\r\n之后返回到 api/index.ts 文件\r\n\r\n```js\r\nimport { instance } from \"../utils/request\";\r\nconst { GITHUB_REPOSITORY } = process.env;\r\n\r\nexport const issues = async (page = 1) => {\r\n  const { data } = await instance.get<IssuesDaum[]>(\r\n    `/repos/${GITHUB_REPOSITORY}/issues`,\r\n    {\r\n      params: {\r\n        filter: \"created\",\r\n        state: \"open\",\r\n        sort: \"updated\",\r\n        per_page: 100,\r\n        page,\r\n      },\r\n    }\r\n  );\r\n  return data;\r\n};\r\n\r\nexport const labels = async (page = 1) => {\r\n  const { data } = await instance.get<Label[]>(\r\n    `/repos/${GITHUB_REPOSITORY}/labels`,\r\n    {\r\n      params: {\r\n        per_page: 100,\r\n        page,\r\n      },\r\n    }\r\n  );\r\n  return data;\r\n};\r\n```\r\n\r\n> IssuesDaum 和 Label 是详细的类型定义文件这里忽略掉，如果需要相关类型文件可以[点击访问](https://github.com/bosens-China/blog/blob/main/packages/sideEffect/src/api/type.ts)。\r\n\r\n之后新建 implement.ts 文件，这个文件就是调用 issues 和 labels 接口，然后把信息保存下来。\r\n\r\n上面有说到根据 GitHub 的文档可以看到 labels 和 issues 都是返回一个数组，但是我们并不知道有没有拉取完，所以这边的思路就是创建一个新的文件，让他调用自身直到返回空数组为止。\r\n\r\n```js\r\nconst continued = async <T extends (page?: number) => Promise<unknown[]>>(\r\n  fn: T,\r\n  page = 1\r\n) => {\r\n  const result = (await fn(page)) as ReturnType<T>;\r\n  if (Array.isArray(result) && result.length) {\r\n    const arr = await continued(fn, page + 1);\r\n    result.push(...arr);\r\n  }\r\n  return result;\r\n};\r\n```\r\n\r\n最初的时候创建了一个.env 文件，这个文件是保存开发环境的一些信息，不过根据 esm 加载顺序我们必须要保证在调用其他模块的时候 dotenv 信息已经正确加载，所以这边思路如下。\r\n\r\n创建一个立即执行函数，把需要执行的代码放里面执行即可，或者使用顶层 await 也可以，下面是完整代码\r\n\r\n```js\r\nimport dotenv from \"dotenv\";\r\nimport fs from \"fs-extra\";\r\nimport path from \"path\";\r\n\r\ndotenv.config();\r\n\r\nconst { GITHUB_REPOSITORY } = process.env;\r\n\r\n(async () => {\r\n  console.time(`Start crawling the required data...`);\r\n  const { labels, issues } = await import(\"./api\");\r\n  try {\r\n    const [labelsData, issuesData] = await Promise.all([\r\n      continued(labels),\r\n      continued(issues),\r\n    ]);\r\n    // 考虑到后续可能别人直接拷贝这个项目使用，对label一次插入\r\n    let other = labelsData.find((f) => f.name === \"其他\")!;\r\n    if (!other) {\r\n      other = {\r\n        id: 1000000000,\r\n        node_id: \"MDU6TGFiZWwxMzcxNjg2NjEx\",\r\n        url: `https://api.github.com/repos/${GITHUB_REPOSITORY}/labels/其他`,\r\n        name: \"其他\",\r\n        color: \"f6ecbf\",\r\n        default: false,\r\n        description: \"未找到分类，暂定的文章分类\",\r\n      };\r\n      labelsData.push(other);\r\n    }\r\n    const map: Map<string, typeof issuesData> = new Map();\r\n    issuesData.forEach((item) => {\r\n      if (!item.labels.length) {\r\n        item.labels.push(other);\r\n      }\r\n      item.labels.forEach((label) => {\r\n        const id = `${label.id}`;\r\n        if (!map.has(id)) {\r\n          map.set(id, []);\r\n        }\r\n        map.get(id)?.push(item);\r\n      });\r\n    });\r\n\r\n    await fs.writeJson(\r\n      path.join(__dirname, \"./data.json\"),\r\n      {\r\n        label: labelsData,\r\n        issuesData: issuesData,\r\n        labelsMap: [...map],\r\n      },\r\n      { spaces: 2 }\r\n    );\r\n  } catch (e) {\r\n    console.log(e instanceof Error ? e.message : e);\r\n  }\r\n  console.timeEnd(`Start crawling the required data...`);\r\n})();\r\n```\r\n\r\n## 提供资产\r\n\r\n上面的代码都是 TypeScript，不能直接运行，这里安装 tsx\r\n\r\n```sh\r\npnpm add tsx\r\n```\r\n\r\n它的作用就是调用 TypeScript 代码，相比 ts-node 它不会进行类型检查，速度很快。\r\n\r\n之后在 package.json 下的 scripts 下创建命令，方便快速调用\r\n\r\n```js\r\nscripts: {\r\n  \"crawlingResource\": \"tsx ./src/implement.ts\",\r\n}\r\n```\r\n\r\n之后执行 `pnpm run crawlingResource`，就可以看到在 src 下生成了一个 `data.json` 的文件。\r\n\r\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/29a7e5f878274eda968171222b3bfa12~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2020&h=1478&s=867275&e=png&b=ffffff)\r\n\r\n这里再新建一个 index.ts 文件，方便对 data.json 进行一些封装查询操作。\r\n\r\n```js\r\nimport data from \"./data.json\";\r\n\r\n// 对数据进行封装，方便调用\r\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\r\nexport const classification = new Map(data.labelsMap as any) as Map<\r\n  string,\r\n  typeof data.issuesData\r\n>;\r\n\r\nconst map = new Map<string, (typeof data.label)[number] | undefined>();\r\n\r\nexport const getLabel = (id: string) => {\r\n  if (map.has(id)) {\r\n    return map.get(id);\r\n  }\r\n  const result = data.label.find((f) => f.id === +id);\r\n  map.set(id, result);\r\n  return result;\r\n};\r\n\r\nexport default data;\r\n```\r\n\r\n到这里就把拉取资源的相关写完了，不过还需要在 package.json 暴露出口，让其他模块安装之后可以进行调用\r\n\r\n```js\r\n\"main\": \"./src/index.ts\",\r\n```\r\n\r\n## 最后\r\n\r\n最后记得在当前目录创建一个新的[.gitignore](https://github.com/bosens-China/blog/blob/main/packages/sideEffect/.gitignore \".gitignore\") 文件，将.env 文件忽略。\r\n\r\n第一节内容就讲完了，下一节会介绍 [Next.js 构建博客之博客搭建](https://github.com/bosens-China/blog/issues/103)，如果有书写错误欢迎指出。\r\n",
      "reactions": {
        "url": "https://api.github.com/repos/bosens-China/blog/issues/102/reactions",
        "total_count": 0,
        "+1": 0,
        "-1": 0,
        "laugh": 0,
        "hooray": 0,
        "confused": 0,
        "heart": 0,
        "rocket": 0,
        "eyes": 0
      },
      "timeline_url": "https://api.github.com/repos/bosens-China/blog/issues/102/timeline",
      "performed_via_github_app": null,
      "state_reason": null
    },
    {
      "url": "https://api.github.com/repos/bosens-China/blog/issues/103",
      "repository_url": "https://api.github.com/repos/bosens-China/blog",
      "labels_url": "https://api.github.com/repos/bosens-China/blog/issues/103/labels{/name}",
      "comments_url": "https://api.github.com/repos/bosens-China/blog/issues/103/comments",
      "events_url": "https://api.github.com/repos/bosens-China/blog/issues/103/events",
      "html_url": "https://github.com/bosens-China/blog/issues/103",
      "id": 2020398367,
      "node_id": "I_kwDOCzPAy854bNUf",
      "number": 103,
      "title": "Next.js 构建博客之博客搭建",
      "user": {
        "login": "bosens-China",
        "id": 39508895,
        "node_id": "MDQ6VXNlcjM5NTA4ODk1",
        "avatar_url": "https://avatars.githubusercontent.com/u/39508895?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bosens-China",
        "html_url": "https://github.com/bosens-China",
        "followers_url": "https://api.github.com/users/bosens-China/followers",
        "following_url": "https://api.github.com/users/bosens-China/following{/other_user}",
        "gists_url": "https://api.github.com/users/bosens-China/gists{/gist_id}",
        "starred_url": "https://api.github.com/users/bosens-China/starred{/owner}{/repo}",
        "subscriptions_url": "https://api.github.com/users/bosens-China/subscriptions",
        "organizations_url": "https://api.github.com/users/bosens-China/orgs",
        "repos_url": "https://api.github.com/users/bosens-China/repos",
        "events_url": "https://api.github.com/users/bosens-China/events{/privacy}",
        "received_events_url": "https://api.github.com/users/bosens-China/received_events",
        "type": "User",
        "site_admin": false
      },
      "labels": [
        {
          "id": 6273949336,
          "node_id": "LA_kwDOCzPAy88AAAABdfTemA",
          "url": "https://api.github.com/repos/bosens-China/blog/labels/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA",
          "name": "博客搭建",
          "color": "b60205",
          "default": false,
          "description": "介绍博客简单的过程"
        }
      ],
      "state": "open",
      "locked": false,
      "assignee": null,
      "assignees": [],
      "milestone": null,
      "comments": 0,
      "created_at": "2023-12-01T08:47:28Z",
      "updated_at": "2023-12-27T06:46:30Z",
      "closed_at": null,
      "author_association": "OWNER",
      "active_lock_reason": null,
      "body": "![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/93a4556e832740f0b44cb081a6a70b9e~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2998&h=1464&s=549772&e=png&b=fefefe)\r\n\r\n1.  [Next.js 构建博客之资源抓取](https://github.com/bosens-China/blog/issues/102)\r\n2.  [Next.js 构建博客之博客搭建](https://github.com/bosens-China/blog/issues/103)\r\n3.  [Next.js 构建博客之打包 SSG](https://github.com/bosens-China/blog/issues/104)\r\n4.  [Next.js 构建博客之常见问题处理](https://github.com/bosens-China/blog/issues/105)\r\n5.  [Next.js 构建博客之功能拓展](https://github.com/bosens-China/blog/issues/107)\r\n6.  [Next.js 构建博客之自动构建](https://github.com/bosens-China/blog/issues/108)\r\n\r\n在上一篇 [Next.js 构建博客之资源抓取](https://github.com/bosens-China/blog/issues/102) 介绍了如何把 GitHub 上的 issues 和 labels 资源拉取下来，方便构建使用。下面就介绍如何使用 Next.js 来完成博客的搭建，以及介绍一下常见会遇到的一些问题。\r\n\r\n如果你想看已经部署博客的地址可以[点击查看](https://bosens-china.github.io/blog/)，代码仓库地址[点击查看](https://github.com/bosens-China/blog)。\r\n\r\n不过需要注意这里不会介绍博客的样式和布局要怎么设计，这个全凭心意。本节主要注重怎么把 issues 和 labels 进行展示，以及路由和详情页面的展示要使用什么技术，可能会遇到的问题等。\r\n\r\n> 这里也不会花费时间来介绍 Next.js 相关的概念，阅读本节默认你已经知道 Next.js 要怎么使用了。\r\n\r\n## 创建\r\n\r\n这里按照[文档的做法](https://nextjs.org/docs/getting-started/installation)\r\n\r\n```sh\r\ncd packages\r\nnpx create-next-app@latest\r\n```\r\n\r\n然后根据提示一步步选择，这里我附一下自己的选择\r\n\r\n```sh\r\nWhat is your project named? view\r\nWould you like to use TypeScript? Yes\r\nWould you like to use ESLint? Yes\r\nWould you like to use Tailwind CSS? No\r\nWould you like to use `src/` directory? N\r\nWould you like to use App Router? (recommended) Yes\r\nWould you like to customize the default import alias (@/*)? Yes\r\nWhat import alias would you like configured? @/*\r\n```\r\n\r\n不过 Next.js 的版本可能会在后面发生变化，以及 api 也可能会调整，这里贴一下自己在写这篇文章时的 Next.js 版本\r\n\r\n```sh\r\n\"next\": \"14.0.2\",\r\n```\r\n\r\n## 首页搭建\r\n\r\n这里分析一下我们现在已经有的信息：\r\n\r\n1.  知道所有 issues\r\n2.  知道所有的 labels\r\n\r\n其中每一个 issue 对应的就是一篇文章，这篇文章可能会存在多个 labels 下，labels 可以简单理解为栏目。\r\n\r\n布局这块，首页和详情变化的部分只是中间区域不同\r\n\r\n![image-1.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f2e5baf970c84267a174ac68161d5115~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2918&h=1508&s=1548515&e=png&b=fefefe)\r\n\r\n![image-2.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f4606d13783a4d2ab41831760d02902f~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2962&h=1494&s=1905526&e=png&b=fefefe)\r\n\r\n其他部分基本是复用的，所以这里就有了思路，在 Next.js 文档中 app/layout.tsx 这个文件是布局文件，每个页面都会默认复用这个文件，除非你显示在子页面创建新的 layout.tsx 文件。\r\n\r\n```js\r\nimport \"./styles/index.scss\";\r\nimport { RightSide } from \"./components/rightSide\";\r\nimport Side from \"./components/side\";\r\n\r\nexport const dynamic = \"error\";\r\n\r\nexport default function RootLayout({\r\n  children,\r\n}: {\r\n  children: React.ReactNode,\r\n}) {\r\n  return (\r\n    <html lang=\"zh\">\r\n      <head></head>\r\n      <body>\r\n        <div id=\"qzhai-net\" className=\"wp qzhai-net\">\r\n          <Side></Side>\r\n          <div className=\"qzhai-net-main\">{children}</div>\r\n          <RightSide></RightSide>\r\n        </div>\r\n      </body>\r\n    </html>\r\n  );\r\n}\r\n```\r\n\r\n之后就是在每次路由变化的时候改变 layout.tsx 下的 children 即可，整个博客系统大概存在 4 个路由：\r\n\r\n- 首页，路由对应 /\r\n- pages 页面，跟首页类似，但是首页路由是 /，如果跳转到第二页就会跳转在这里，路由会变成 page/2，后面的 2 代表具体的页数\r\n- 详情页面，从首页点击文章进行详情，会跳转到具体的详情页面，对应路由为 details/id\r\n- 分类页面，文章会存在分页，对应路由为 types/id\r\n\r\n这里首页的搭建其实跟具体的 pages 页面是一回事，我们新建一个 `components/content/index.tsx 文件`，把相同的功能抽离出来。\r\n\r\n这里首页数据其实就是固定展示前面 20 条，如果存在分页也就是把 issues 的数据进行截取条数进行展示。基于分析的这个情况，我们定义一个 Props，它的内容如下：\r\n\r\n```js\r\ntype Props = {\r\n  // 当前页数\r\n  page: number,\r\n};\r\n```\r\n\r\n之后安装一下依赖，把上一节爬取下来的数据拿来使用\r\n\r\n```sh\r\npnpm add @blog/side-effect\r\n```\r\n\r\n之后简单描述一下 `content/index.tsx`\r\n\r\n```js\r\nimport React, { FC } from \"react\";\r\nimport all from \"@blog/side-effect\";\r\n\r\ninterface Props {\r\n  page: number;\r\n}\r\n\r\nexport const Content: FC<Props> = ({ page }) => {\r\n  const data = all.issuesData.slice((page - 1) * 20, page * 20);\r\n\r\n  return (\r\n    <ul>\r\n      {data.map((f) => {\r\n        return (\r\n          <li key={f.id}>\r\n            <p>{f.title}</p>\r\n            ...\r\n            <p>{f.created_at}</p>\r\n          </li>\r\n        );\r\n      })}\r\n    </ul>\r\n  );\r\n};\r\n```\r\n\r\n之后在 app/page.tsx 中，直接这个页面传递 Content 组件 page 传递 1，就完成了调用，不过在实际的开发中还需要考虑其他额外的情况，例如分页、文章简介截取、图片提取等，这里会专门出一篇文章进行介绍，这里快速略过关注怎么来构建。\r\n\r\n## 详情\r\n\r\n打开爬取 data.json，可以看到文章内容储存在 body 中，那么思路就很简单了，在首页中添加一个 a 标签，在跳转过来的时候携带文章对应的 id，之后把对应的数据进行渲染出来即可。\r\n\r\n![image-3.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ef33b8521c02406b8119c3f9188fabff~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2746&h=954&s=254778&e=png&b=1d1d1d)\r\n\r\n使用 a 标签在 Next.js 中是不推荐的行为，Next.js 提供了 Link 标签，它的作用跟 a 标签一致，遇到需要路由跳转的使用 Link 即可。\r\n\r\n之后创建 details/\\[id]/page.tsx 页面，这里 \\[id] 代表了一个动态参数，会根据传递过来的 id 不同来进行变化，在 Next.js 中还有其他可选参数等，这里不展开一一介绍了，之后重点讲一下详情页面要怎么展示 md 内容。\r\n\r\n```js\r\nimport { useMemo } from \"react\";\r\nimport data, { classification } from \"@blog/side-effect\";\r\n\r\ninterface Params {\r\n  id: string;\r\n}\r\ninterface Props {\r\n  params: Params;\r\n  searchParams: Record<string, string>;\r\n}\r\n\r\nexport default function Page({ params: { id } }: Props) {\r\n  const current = useMemo(() => {\r\n    return data.issuesData.find((f) => f.id === +id);\r\n  }, [id]);\r\n}\r\n```\r\n\r\n上面直接根据 id 来对 issues 进行搜索，之后从 current.body 就可以获取到具体的文章内容，这里推荐使用 bytemd 作为内容展示，bytemd 就是掘金同款编辑器，它包含两部分 Editor, Viewer，这里显然只需要使用 Viewer。\r\n\r\n![image-4.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e0908614c4654f82b416b5902d1e4d0e~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2890&h=1274&s=993564&e=png&b=fefefe)\r\n\r\n对于样式之类的可以参考这个仓库 [juejin-markdown-themes](https://github.com/xitu/juejin-markdown-themes)。\r\n\r\n这一步搭建完成大概会得到一个这样的界面\r\n\r\n![image-5.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/629be287e06243f1bd9b523dd3158d06~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1770&h=1374&s=672378&e=png&b=fdfdfd)\r\n\r\n说明内容已经被成功渲染了。\r\n\r\n> 如果在使用 bytemd 过程中提示，提示使用了 useEffect 之类的钩子，直接在文件顶部添加\r\n>\r\n> ```js\r\n> \"use client\";\r\n> // ...\r\n> ```\r\n>\r\n> 把当前组件渲染方式变成客户端渲染。\r\n\r\n## 栏目\r\n\r\n对于栏目页面则更简单一些，只需要把爬取下来的 labels 的标签进行展示即可，下面是一个示例\r\n\r\n```js\r\n// side.tsx\r\n\r\nimport data from \"@blog/side-effect\";\r\nimport Link from \"next/link\";\r\nimport { classification } from \"@blog/side-effect\";\r\n\r\nexport const Side = () => {\r\n  return (\r\n    <>\r\n      <h4>分类查看</h4>\r\n      <ul>\r\n        {data.label.map((item) => {\r\n          const length = classification.get(`${item.id}`)?.length || 0;\r\n          return (\r\n            <li key={item.id}>\r\n              <Link href={`/types/${item.id}`} title={item.description}>\r\n                {item.name}\r\n                <span className=\"types-notes\">[{length}]</span>\r\n              </Link>\r\n            </li>\r\n          );\r\n        })}\r\n      </ul>\r\n    </>\r\n  );\r\n};\r\n```\r\n\r\n## 分页\r\n\r\n对于分页上面其实也有提及，首页以及分页和点击栏目跳转的页面其实都高度依赖 content 这个组件，所以这个组件的灵活性需要保证。\r\n\r\n1.  需要保证可以自定义 header 区域，例如在首页中，展示的应当是最新文章；\r\n2.  如果是栏目跳转那么需要展示对应的栏目名称；\r\n\r\n其他的其实就是把对应 pages/id，传递给 content 这个组件即可，下面是一个示例\r\n\r\n```js\r\n// page/[page]/page.tsx\r\n\r\ninterface Params {\r\n  // 当前页数\r\n  page: string;\r\n}\r\n\r\ninterface Props {\r\n  params: Params;\r\n  searchParams: Record<string, string>;\r\n}\r\n\r\nexport default function Page(props: Props) {\r\n  const {\r\n    params: { page },\r\n  } = props;\r\n\r\n  return (\r\n    <>\r\n      <Content page={+page}></Content>\r\n    </>\r\n  );\r\n}\r\n```\r\n\r\n## 最后\r\n\r\n这节简单探讨了下如何结合 issues 和 labels 进行使用，在下一节 [Next.js 构建博客之打包 SSG](https://github.com/bosens-China/blog/issues/104) 会介绍如何构建 SSG 的应用。\r\n\r\n如果文章有错别字之类也欢迎指出。\r\n",
      "reactions": {
        "url": "https://api.github.com/repos/bosens-China/blog/issues/103/reactions",
        "total_count": 0,
        "+1": 0,
        "-1": 0,
        "laugh": 0,
        "hooray": 0,
        "confused": 0,
        "heart": 0,
        "rocket": 0,
        "eyes": 0
      },
      "timeline_url": "https://api.github.com/repos/bosens-China/blog/issues/103/timeline",
      "performed_via_github_app": null,
      "state_reason": null
    },
    {
      "url": "https://api.github.com/repos/bosens-China/blog/issues/104",
      "repository_url": "https://api.github.com/repos/bosens-China/blog",
      "labels_url": "https://api.github.com/repos/bosens-China/blog/issues/104/labels{/name}",
      "comments_url": "https://api.github.com/repos/bosens-China/blog/issues/104/comments",
      "events_url": "https://api.github.com/repos/bosens-China/blog/issues/104/events",
      "html_url": "https://github.com/bosens-China/blog/issues/104",
      "id": 2032365832,
      "node_id": "I_kwDOCzPAy855I3EI",
      "number": 104,
      "title": "Next.js 构建博客之打包SSG",
      "user": {
        "login": "bosens-China",
        "id": 39508895,
        "node_id": "MDQ6VXNlcjM5NTA4ODk1",
        "avatar_url": "https://avatars.githubusercontent.com/u/39508895?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bosens-China",
        "html_url": "https://github.com/bosens-China",
        "followers_url": "https://api.github.com/users/bosens-China/followers",
        "following_url": "https://api.github.com/users/bosens-China/following{/other_user}",
        "gists_url": "https://api.github.com/users/bosens-China/gists{/gist_id}",
        "starred_url": "https://api.github.com/users/bosens-China/starred{/owner}{/repo}",
        "subscriptions_url": "https://api.github.com/users/bosens-China/subscriptions",
        "organizations_url": "https://api.github.com/users/bosens-China/orgs",
        "repos_url": "https://api.github.com/users/bosens-China/repos",
        "events_url": "https://api.github.com/users/bosens-China/events{/privacy}",
        "received_events_url": "https://api.github.com/users/bosens-China/received_events",
        "type": "User",
        "site_admin": false
      },
      "labels": [
        {
          "id": 6273949336,
          "node_id": "LA_kwDOCzPAy88AAAABdfTemA",
          "url": "https://api.github.com/repos/bosens-China/blog/labels/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA",
          "name": "博客搭建",
          "color": "b60205",
          "default": false,
          "description": "介绍博客简单的过程"
        }
      ],
      "state": "open",
      "locked": false,
      "assignee": null,
      "assignees": [],
      "milestone": null,
      "comments": 0,
      "created_at": "2023-12-08T10:09:16Z",
      "updated_at": "2023-12-27T06:45:00Z",
      "closed_at": null,
      "author_association": "OWNER",
      "active_lock_reason": null,
      "body": "![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/93a4556e832740f0b44cb081a6a70b9e~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2998&h=1464&s=549772&e=png&b=fefefe)\r\n\r\n1.  [Next.js 构建博客之资源抓取](https://github.com/bosens-China/blog/issues/102)\r\n2.  [Next.js 构建博客之博客搭建](https://github.com/bosens-China/blog/issues/103)\r\n3.  [Next.js 构建博客之打包 SSG](https://github.com/bosens-China/blog/issues/104)\r\n4.  [Next.js 构建博客之常见问题处理](https://github.com/bosens-China/blog/issues/105)\r\n5.  [Next.js 构建博客之功能拓展](https://github.com/bosens-China/blog/issues/107)\r\n6.  [Next.js 构建博客之自动构建](https://github.com/bosens-China/blog/issues/108)\r\n\r\n这是 Next.js 构建博客的第三篇文章，上一篇文章 [Next.js 构建博客之博客搭建](https://github.com/bosens-China/blog/issues/103) 介绍了博客的搭建过程，这篇文章则重点介绍一下如何将资源打包成 SSG。\r\n\r\n如果你想看已经部署博客的地址可以[点击查看](https://bosens-china.github.io/blog/)，代码仓库地址[点击查看](https://github.com/bosens-China/blog)。\r\n\r\nSSG 的全称是 Static Site Generation 即静态渲染，不过在介绍之前先说一下主流的渲染方式：\r\n\r\n1.  客户端渲染，我们常见的 Vue、React 等默认就是客户端渲染，不过这种方式最大弊端就是首屏速度以及 seo 抓取，这刚好不符合我们博客场景；\r\n\r\n![image-1.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/dd3d25c67a3846509bc58286a50c5ffb~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1080&h=1139&s=312855&e=png&b=fefefe)\r\n\r\n2.  ssr，其实就是代码跑在 nodejs 上，然后输出渲染的 html 字符串，之后浏览器获取 js 资源后执行同构代码，并将 DOM 元素绑定事件等，不过这里也不符合场景，代码最终部署在 GitHub 上其实是没有额外的服务器让我们执行；\r\n\r\n![image-2.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5c352499970c4fa4a30c57e679b735a9~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1080&h=709&s=212161&e=png&b=ffffff)\r\n\r\n3.  SSG，就是将动态数据输出成固定的 html 文件，兼顾了文件缓存以及 seo 的需求，完美符合我们使用场景；\r\n\r\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0f3d1aaae5b64e15a584f8467d5fdf19~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1080&h=1464&s=341627&e=png&b=ffffff)\r\n\r\n## 开启 SSG\r\n\r\n上一篇中我们列举了一下页面的路由：\r\n\r\n- /：首页\r\n- pages：分页页面\r\n- details/:id：详情页面\r\n- types/:id：分类页面\r\n\r\n对于固定的页面我们不需要做什么，但是对于携带 `:id` 的动态页面，我们需要把所有的条件都枚举出来，只有这样才能输出所有的页面信息，不至于点击某一个文章直接 404 了。\r\n\r\n枚举所有条件可以使用 [generateStaticParams](https://nextjs.org/docs/app/api-reference/functions/generate-static-params) 完成，这里看一个官方给出的例子：\r\n\r\n```ts\r\n// app/blog/[slug]/page.js\r\n// Return a list of `params` to populate the [slug] dynamic segment\r\nexport async function generateStaticParams() {\r\n  const posts = await fetch(\"https://.../posts\").then((res) => res.json());\r\n\r\n  return posts.map((post) => ({\r\n    slug: post.slug,\r\n  }));\r\n}\r\n\r\n// Multiple versions of this page will be statically generated\r\n// using the `params` returned by `generateStaticParams`\r\nexport default function Page({ params }) {\r\n  const { slug } = params;\r\n  // ...\r\n}\r\n```\r\n\r\n其中 `[slug]` 代表 slug 这个必填，下面的 generateStaticParams 函数作用就是把所有 slug 通过数组的形式进行返回出来，之后 Page 就正常渲染即可。\r\n\r\n下面抛砖引玉对 types 页面进行改造\r\n\r\n```tsx\r\nimport { classification } from \"@blog/side-effect\";\r\n\r\ninterface Params {\r\n  id: [string];\r\n}\r\ninterface Props {\r\n  params: Params;\r\n  searchParams: Record<string, string>;\r\n}\r\n\r\nexport function generateStaticParams(): Params[] {\r\n  const result: Params[] = [];\r\n  classification.forEach((value, key) => {\r\n    result.push({\r\n      rest: [key],\r\n    });\r\n  });\r\n\r\n  return result;\r\n}\r\n```\r\n\r\n这里就把页面所需的参数给枚举结束，其他页面也这样处理即可，如果页面参数涉及的是多个，例如页面需要 id 和 name，那你也只需要在 generateStaticParams 按照顺序返回即可，例如：\r\n\r\n```js\r\n// app/pages/[...rest]/page.tsx\r\nreturn [\r\n  {\r\n    rest: [id, name],\r\n  },\r\n  {\r\n    rest: [id, name],\r\n  },\r\n  // ...\r\n];\r\n```\r\n\r\n之后调整 next.config.js 文件\r\n\r\n```js\r\nconst nextConfig = {\r\n  // ...\r\n  output: \"export\",\r\n};\r\n\r\nmodule.exports = nextConfig;\r\n```\r\n\r\n之后在 app/layout.tsx 文件添加\r\n\r\n```js\r\nexport const dynamic = \"error\";\r\n```\r\n\r\n这里防止在代码中引用 SSG 不支持的一些功能，具体不支持功能可以[点击查看](https://nextjs.org/docs/app/building-your-application/deploying/static-exports)。\r\n\r\n## 动态标题\r\n\r\n有一些页面，例如 types 这个分类页面其中标题应当是固定的，如果按照 Next 设置成一个固定的也不太符合要求，幸好可以使用 [generateMetadata](https://nextjs.org/docs/app/api-reference/functions/generate-metadata) 函数来完成动态设置。\r\n\r\n```js\r\nimport { Metadata } from \"next\";\r\n\r\n// either Static metadata\r\nexport const metadata: Metadata = {\r\n  title: \"...\",\r\n};\r\n\r\n// or Dynamic metadata\r\nexport async function generateMetadata({ params }) {\r\n  return {\r\n    title: \"...\",\r\n  };\r\n}\r\n```\r\n\r\n看一下给出的示例，大概就明白如何使用了，不过这里在涉及博客的场景通常有一部分的标题是固定的，例如 `yliu 的个人博客｜ css 选择器讲解`，其中前缀可能是固定的，一个个写也太繁琐了，下面就介绍一下如何编写动态标题以及固定前缀。\r\n\r\n### app/layout.tsx\r\n\r\n```js\r\nexport const metadata: Metadata = {\r\n  title: {\r\n    template: `%s | ${data.user.name} 的个人博客`,\r\n    default: `${data.user.name} 的个人博客`,\r\n  },\r\n  description: \"记录生活随笔以及技术博客\",\r\n};\r\n```\r\n\r\n这里 `%s` 是占位符，default 则是如果页面没有设置标题默认输出 xxx 的个人博客标题。\r\n\r\n### app/types/page.tsx\r\n\r\n```js\r\nexport async function generateMetadata({\r\n  params: {\r\n    rest: [id],\r\n  },\r\n}: Props) {\r\n  const current = data.label.find((f) => f.id === +id);\r\n\r\n  return {\r\n    title: current?.name,\r\n  };\r\n}\r\n```\r\n\r\n这里就达到我们的最终效果了，当然其实 Metadata 对象包含很多属性，例如 description、keywords 等，所以如果想针对每个文章输出关键词都不相同可以使用 generateMetadata 来达到效果。\r\n\r\n## 最后\r\n\r\n如果文章有书写错误地方欢迎指出。下一篇 [Next.js 构建博客之常见问题处理](https://github.com/bosens-China/blog/issues/105) 会介绍构建以及开发中常见的一些问题，以及如何处理。\r\n",
      "reactions": {
        "url": "https://api.github.com/repos/bosens-China/blog/issues/104/reactions",
        "total_count": 0,
        "+1": 0,
        "-1": 0,
        "laugh": 0,
        "hooray": 0,
        "confused": 0,
        "heart": 0,
        "rocket": 0,
        "eyes": 0
      },
      "timeline_url": "https://api.github.com/repos/bosens-China/blog/issues/104/timeline",
      "performed_via_github_app": null,
      "state_reason": null
    },
    {
      "url": "https://api.github.com/repos/bosens-China/blog/issues/105",
      "repository_url": "https://api.github.com/repos/bosens-China/blog",
      "labels_url": "https://api.github.com/repos/bosens-China/blog/issues/105/labels{/name}",
      "comments_url": "https://api.github.com/repos/bosens-China/blog/issues/105/comments",
      "events_url": "https://api.github.com/repos/bosens-China/blog/issues/105/events",
      "html_url": "https://github.com/bosens-China/blog/issues/105",
      "id": 2043060455,
      "node_id": "I_kwDOCzPAy855xqDn",
      "number": 105,
      "title": "Next.js 构建博客之常见问题处理",
      "user": {
        "login": "bosens-China",
        "id": 39508895,
        "node_id": "MDQ6VXNlcjM5NTA4ODk1",
        "avatar_url": "https://avatars.githubusercontent.com/u/39508895?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bosens-China",
        "html_url": "https://github.com/bosens-China",
        "followers_url": "https://api.github.com/users/bosens-China/followers",
        "following_url": "https://api.github.com/users/bosens-China/following{/other_user}",
        "gists_url": "https://api.github.com/users/bosens-China/gists{/gist_id}",
        "starred_url": "https://api.github.com/users/bosens-China/starred{/owner}{/repo}",
        "subscriptions_url": "https://api.github.com/users/bosens-China/subscriptions",
        "organizations_url": "https://api.github.com/users/bosens-China/orgs",
        "repos_url": "https://api.github.com/users/bosens-China/repos",
        "events_url": "https://api.github.com/users/bosens-China/events{/privacy}",
        "received_events_url": "https://api.github.com/users/bosens-China/received_events",
        "type": "User",
        "site_admin": false
      },
      "labels": [
        {
          "id": 6273949336,
          "node_id": "LA_kwDOCzPAy88AAAABdfTemA",
          "url": "https://api.github.com/repos/bosens-China/blog/labels/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA",
          "name": "博客搭建",
          "color": "b60205",
          "default": false,
          "description": "介绍博客简单的过程"
        }
      ],
      "state": "open",
      "locked": false,
      "assignee": null,
      "assignees": [],
      "milestone": null,
      "comments": 0,
      "created_at": "2023-12-15T07:33:00Z",
      "updated_at": "2023-12-27T06:42:59Z",
      "closed_at": null,
      "author_association": "OWNER",
      "active_lock_reason": null,
      "body": "![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/93a4556e832740f0b44cb081a6a70b9e~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2998&h=1464&s=549772&e=png&b=fefefe)\r\n\r\n1.  [Next.js 构建博客之资源抓取](https://github.com/bosens-China/blog/issues/102)\r\n2.  [Next.js 构建博客之博客搭建](https://github.com/bosens-China/blog/issues/103)\r\n3.  [Next.js 构建博客之打包 SSG](https://github.com/bosens-China/blog/issues/104)\r\n4.  [Next.js 构建博客之常见问题处理](https://github.com/bosens-China/blog/issues/105)\r\n5.  [Next.js 构建博客之功能拓展](https://github.com/bosens-China/blog/issues/107)\r\n6.  [Next.js 构建博客之自动构建](https://github.com/bosens-China/blog/issues/108)\r\n\r\n这是 Next.js 构建博客的第四篇文章，上一篇文章 [Next.js 构建博客之打包 SSG](https://github.com/bosens-China/blog/issues/104) 介绍了 Next.js 如何打包成 SSG 文件，这篇文章重点介绍一下在开发中容易遇到的问题。\r\n\r\n如果你想看已经部署博客的地址可以[点击查看](https://bosens-china.github.io/blog/)，代码仓库地址[点击查看](https://github.com/bosens-China/blog)。\r\n\r\n## 图片盗链\r\n\r\n有一些网站会有图片防盗处理，例如掘金，为了减少网站的压力，在其他网站访问资源的时候会直接 403，判断原理是在 http 请求中会有 referer 和 host 参数，当参数不一致就认定为非法。\r\n\r\n![example](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/35aa22292b3347b693fa046bedbe0ffb~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=640&h=494&s=36336&e=webp&b=fcfcfc)\r\n\r\n绕过这个的方式也很简单，就是对 referer 进行修改，默认值是 strict-origin-when-cross-origin。\r\n\r\n> 对于同源的请求，发送来源、路径以及查询字符串。对于在相同安全级别的情况下（HTTPS→HTTPS）的跨源请求，仅发送来源。在目标的安全级别下降的情况下（HTTPS→HTTP）则不发送 Referer 标头。\r\n\r\n那么直接修改 referer 为 no-referrer，整个 Referer 首部会被移除。访问来源信息不随着请求一起发送。\r\n\r\n下面是一个具体的实现代码，对图片加载失败进行拦截处理。\r\n\r\n```js\r\n\"use client\";\r\n\r\nimport { useEffect } from \"react\";\r\n\r\nconst map = new WeakMap();\r\n\r\n// 拦截图片错误，并且正确加载\r\nexport default function AssetsWatch() {\r\n  const replace = (dom: HTMLImageElement) => {\r\n    if (map.get(dom)) {\r\n      return;\r\n    }\r\n    const src = dom.src;\r\n    map.set(dom, 1);\r\n    dom.src = `${process.env.NEXT_PUBLIC_BASE_PATH}/error.svg`;\r\n    fetch(src, {\r\n      mode: \"cors\",\r\n      referrerPolicy: \"no-referrer\",\r\n    })\r\n      .then((response) => {\r\n        if (response.ok) {\r\n          return response.blob();\r\n        }\r\n\r\n        throw new Error(\"Image request failed\");\r\n      })\r\n      .then((blob) => {\r\n        const imageUrlObject = URL.createObjectURL(blob);\r\n        dom.src = imageUrlObject;\r\n      })\r\n      .catch((error) => {\r\n        dom.alt = `图片加载失败`;\r\n        dom.title = `图片加载失败，已回滚到默认图片`;\r\n        dom.setAttribute(\"data-src\", src);\r\n        console.error(\"Error:\", error.message);\r\n      });\r\n  };\r\n\r\n  useEffect(() => {\r\n    // 初始遍历一遍，因为插入时间已经很晚了\r\n    const forEach = () => {\r\n      Array.from(document.images).forEach((img) => {\r\n        const dom = new Image();\r\n        dom.src = img.src;\r\n        dom.onerror = () => {\r\n          replace(img);\r\n        };\r\n      });\r\n    };\r\n    const callback = (e: ErrorEvent) => {\r\n      const dom = e.target as HTMLElement;\r\n      if (!dom || !/img/i.test(dom.nodeName)) {\r\n        return;\r\n      }\r\n      replace(dom as HTMLImageElement);\r\n    };\r\n\r\n    window.addEventListener(\"error\", callback, true);\r\n    forEach();\r\n    return () => {\r\n      window.removeEventListener(\"error\", callback);\r\n    };\r\n  }, []);\r\n\r\n  return null;\r\n}\r\n\r\n```\r\n\r\n如果不太明白，可以参考我这篇文章阅读 [如何优雅处理图片异常](https://juejin.cn/post/6844904046705246216?searchId=202312151526128872E8DDAD9C6494A537)。\r\n\r\n## dynamic 和 Suspense 使用场景\r\n\r\n### dynamic\r\n\r\ndynamic 是 React.lazy 和 Suspense 结合体，一般有三种使用场景\r\n\r\n1.  跳过 ssr\r\n\r\n有一些场景不需要 ssr，例如我添加一个点击量的组件或者添加一个查看图片的功能，这种情况下 ssr 没有任何帮助，这个时候就可以使用 dynamic。\r\n\r\n```js\r\nimport dynamicNext from \"next/dynamic\";\r\n\r\nconst Statistics = dynamicNext(() => import(\"./statistics\"), { ssr: false });\r\n\r\nreturn (\r\n  <>\r\n    <Statistics></Statistics>\r\n  </>\r\n);\r\n```\r\n\r\n2.  延迟加载\r\n\r\n通过延迟加载来减少初始渲染路线，来提高初始加载性能。例如延迟加载客户端组件或者库，在用户点击的时候才进行渲染。\r\n\r\npage.tsx\r\n\r\n```js\r\n\"use client\";\r\n\r\nimport { useState } from \"react\";\r\nimport dynamic from \"next/dynamic\";\r\nconst ComponentA = dynamic(() => import(\"../components/A\"));\r\n\r\nexport default function () {\r\n  return (\r\n    <>\r\n      <ComponentA />\r\n    </>\r\n  );\r\n}\r\n```\r\n\r\ncomponents/A.tsx\r\n\r\n```js\r\n\"use client\";\r\n\r\nimport { useState } from \"react\";\r\n\r\nconst names = [\"Tim\", \"Joe\", \"Bel\", \"Lee\"];\r\n\r\nexport default function Page() {\r\n  const [results, setResults] = useState();\r\n\r\n  return (\r\n    <div>\r\n      <input\r\n        type=\"text\"\r\n        placeholder=\"Search\"\r\n        onChange={async (e) => {\r\n          const { value } = e.currentTarget;\r\n          // Dynamically load fuse.js\r\n          const Fuse = (await import(\"fuse.js\")).default;\r\n          const fuse = new Fuse(names);\r\n\r\n          setResults(fuse.search(value));\r\n        }}\r\n      />\r\n      <pre>Results: {JSON.stringify(results, null, 2)}</pre>\r\n    </div>\r\n  );\r\n}\r\n```\r\n\r\n3.  添加自定义加载组件\r\n\r\n```js\r\nimport dynamic from \"next/dynamic\";\r\n\r\nconst WithCustomLoading = dynamic(\r\n  () => import(\"../components/WithCustomLoading\"),\r\n  {\r\n    loading: () => <p>Loading...</p>,\r\n  }\r\n);\r\n\r\nexport default function Page() {\r\n  return (\r\n    <div>\r\n      <WithCustomLoading />\r\n    </div>\r\n  );\r\n}\r\n```\r\n\r\n### Suspense\r\n\r\n在一些组件中难免会使用到客户端组件，例如添加点击事件，或者使用 useState 等，这个时候就不是服务器组件了，一般要么把整个页面都变成客户端组件，但是这个会导致失去 seo 功能，另外一种则是使用 Suspense 对需要使用客户端的组件进行剥离，下面是一个示例。\r\n\r\n```js\r\nimport { Suspense } from \"react\";\r\nimport SearchBar from \"./search-bar\";\r\n\r\nfunction SearchBarFallback() {\r\n  return <>placeholder</>;\r\n}\r\n\r\nexport default function Page() {\r\n  return (\r\n    <>\r\n      <nav>\r\n        <Suspense fallback={<SearchBarFallback />}>\r\n          <SearchBar />\r\n        </Suspense>\r\n      </nav>\r\n      <h1>Dashboard</h1>\r\n    </>\r\n  );\r\n}\r\n```\r\n\r\n初始情况下 html 会加载 fallback 组件内容，之后水合过程将使用 SearchBar 组件。\r\n\r\n## 不要使用重定向\r\n\r\n因为博客的首页和 pages 页面其实是一个东西，所以想着 / 直接重定向到 page/1 就行，但是发现在使用过程中会有很明显白屏现象，就是 page 页面下的 loading 没有生效。\r\n\r\n所以建议还是不要在首屏使用重定向这个方式。\r\n\r\n## 不要使用 style 样式\r\n\r\n博客的 UI 框架部分使用了 antd，在页面加载的过程中会有一个骨架屏，不过因为 antd5 的版本使用 style 来重构样式，在组件运行的时候注入 `<style />` 方便定制和切换主题，导致 Next.js 使用的时候资源不会被缓存且导致骨架屏最初样式没有被加载出来。\r\n\r\n目前 issues 有相关讨论，但是还没解决。\r\n\r\n解决方法：\r\n\r\n1. 切换低版本 antd\r\n2. 换一个 loading 方案\r\n\r\n## 最后\r\n\r\n如果文章有书写错误地方欢迎指出。下一篇 [Next.js 构建博客之功能拓展](https://github.com/bosens-China/blog/issues/107) 会介绍如何给博客添加点击量以及图片放大缩小等功能。\r\n",
      "reactions": {
        "url": "https://api.github.com/repos/bosens-China/blog/issues/105/reactions",
        "total_count": 0,
        "+1": 0,
        "-1": 0,
        "laugh": 0,
        "hooray": 0,
        "confused": 0,
        "heart": 0,
        "rocket": 0,
        "eyes": 0
      },
      "timeline_url": "https://api.github.com/repos/bosens-China/blog/issues/105/timeline",
      "performed_via_github_app": null,
      "state_reason": null
    },
    {
      "url": "https://api.github.com/repos/bosens-China/blog/issues/107",
      "repository_url": "https://api.github.com/repos/bosens-China/blog",
      "labels_url": "https://api.github.com/repos/bosens-China/blog/issues/107/labels{/name}",
      "comments_url": "https://api.github.com/repos/bosens-China/blog/issues/107/comments",
      "events_url": "https://api.github.com/repos/bosens-China/blog/issues/107/events",
      "html_url": "https://github.com/bosens-China/blog/issues/107",
      "id": 2056162170,
      "node_id": "I_kwDOCzPAy856jot6",
      "number": 107,
      "title": "Next.js 构建博客之功能拓展",
      "user": {
        "login": "bosens-China",
        "id": 39508895,
        "node_id": "MDQ6VXNlcjM5NTA4ODk1",
        "avatar_url": "https://avatars.githubusercontent.com/u/39508895?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bosens-China",
        "html_url": "https://github.com/bosens-China",
        "followers_url": "https://api.github.com/users/bosens-China/followers",
        "following_url": "https://api.github.com/users/bosens-China/following{/other_user}",
        "gists_url": "https://api.github.com/users/bosens-China/gists{/gist_id}",
        "starred_url": "https://api.github.com/users/bosens-China/starred{/owner}{/repo}",
        "subscriptions_url": "https://api.github.com/users/bosens-China/subscriptions",
        "organizations_url": "https://api.github.com/users/bosens-China/orgs",
        "repos_url": "https://api.github.com/users/bosens-China/repos",
        "events_url": "https://api.github.com/users/bosens-China/events{/privacy}",
        "received_events_url": "https://api.github.com/users/bosens-China/received_events",
        "type": "User",
        "site_admin": false
      },
      "labels": [
        {
          "id": 6273949336,
          "node_id": "LA_kwDOCzPAy88AAAABdfTemA",
          "url": "https://api.github.com/repos/bosens-China/blog/labels/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA",
          "name": "博客搭建",
          "color": "b60205",
          "default": false,
          "description": "介绍博客简单的过程"
        }
      ],
      "state": "open",
      "locked": false,
      "assignee": null,
      "assignees": [],
      "milestone": null,
      "comments": 0,
      "created_at": "2023-12-26T08:18:10Z",
      "updated_at": "2023-12-27T06:41:26Z",
      "closed_at": null,
      "author_association": "OWNER",
      "active_lock_reason": null,
      "body": "![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/93a4556e832740f0b44cb081a6a70b9e~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2998&h=1464&s=549772&e=png&b=fefefe)\r\n\r\n1.  [Next.js 构建博客之资源抓取](https://github.com/bosens-China/blog/issues/102)\r\n2.  [Next.js 构建博客之博客搭建](https://github.com/bosens-China/blog/issues/103)\r\n3.  [Next.js 构建博客之打包 SSG](https://github.com/bosens-China/blog/issues/104)\r\n4.  [Next.js 构建博客之常见问题处理](https://github.com/bosens-China/blog/issues/105)\r\n5.  [Next.js 构建博客之功能拓展](https://github.com/bosens-China/blog/issues/107)\r\n6.  [Next.js 构建博客之自动构建](https://github.com/bosens-China/blog/issues/108)\r\n\r\n这是 Next.js 构建博客的第五篇文章，上一篇文章 [Next.js 构建博客之常见问题处理](https://github.com/bosens-China/blog/issues/105) 介绍了 Next.js 如何处理常见的问题，这一篇主要介绍给博客进行功能增强。\r\n\r\n如果你想看已经部署博客的地址可以[点击查看](https://bosens-china.github.io/blog/)，代码仓库地址[点击查看](https://github.com/bosens-China/blog)。\r\n\r\n## 图片放大缩小\r\n\r\n在详情页面会经常遇到图片，很多时候为了考虑排版只会放一个等比例缩小的图片，而不是任由图片展示初始尺寸，这个时候为了为了查看图片就需要考虑功能的增强了。\r\n\r\n这里介绍一下怎么来进行添加，不过在添加之前需要想一下，图片放大缩小这个功能，我们需要用服务器渲染还是客户端渲染？\r\n\r\n我的建议是客户端渲染即可，因为服务器渲染一方面适合比较通用的部分，另外则是 seo 抓取跟图片本身其实关联不大，默认情况下 html 携带图片 alt 属性就足够了。\r\n\r\n博客的渲染使用了 [@bytemd/react](https://github.com/bytedance/bytemd?tab=readme-ov-file)，看一个官方文档的示例\r\n\r\n```js\r\nimport gfm from \"@bytemd/plugin-gfm\";\r\nimport { Editor, Viewer } from \"@bytemd/react\";\r\n\r\nconst plugins = [\r\n  gfm(),\r\n  // Add more plugins here\r\n];\r\n\r\nconst App = () => {\r\n  const [value, setValue] = useState(\"\");\r\n\r\n  return (\r\n    <Editor\r\n      value={value}\r\n      plugins={plugins}\r\n      onChange={(v) => {\r\n        setValue(v);\r\n      }}\r\n    />\r\n  );\r\n};\r\n```\r\n\r\n传递 value 属性就得到一个完整的 view，不过这里不太符合我们要求，因为我们需要给 `<img />` 添加 `onClik` 事件，有两种思路可以做到：\r\n\r\n1. 一种是@bytemd/react 自定义插件\r\n2. 另外一种就是拦截整体整体区域的点击，利用冒泡机制即可。\r\n\r\n下面是一个示例，使用第二种方式\r\n\r\n```js\r\n const [visible, setVisible] = useState(false);\r\n  const [activeIndex, setActiveIndex] = useState(0);\r\n  useEffect(() => {\r\n    const dom = document.querySelector(\".markdown-body\") as HTMLDivElement;\r\n    const callback = (e: MouseEvent) => {\r\n      const dom = e.target as HTMLImageElement;\r\n      if (!/img/i.test(dom.nodeName)) {\r\n        return;\r\n      }\r\n      const index = imgAll.indexOf(dom.src);\r\n      setActiveIndex(index);\r\n      setVisible(true);\r\n    };\r\n    dom.addEventListener(\"click\", callback);\r\n    return () => {\r\n      dom.removeEventListener(\"click\", callback);\r\n    };\r\n  }, [imgAll]);\r\n```\r\n\r\n之后简单封装一下预览图片组件，这里使用了 [react-viewer](react-viewer)\r\n\r\n```js\r\n\"use client\";\r\nimport { Dispatch, SetStateAction, useEffect, useMemo } from \"react\";\r\nimport Viewer from \"react-viewer\";\r\n\r\ninterface Props {\r\n  imgAll: string[];\r\n  visible: boolean;\r\n  setVisible: Dispatch<SetStateAction<boolean>>;\r\n  activeIndex: number;\r\n}\r\n\r\nexport function Preview({ visible, imgAll, setVisible, activeIndex }: Props) {\r\n  const images = useMemo(() => {\r\n    return imgAll.map((f) => {\r\n      return {\r\n        src: f,\r\n        alt: f.split(\"/\").at(-1),\r\n      };\r\n    });\r\n  }, [imgAll]);\r\n  // 防止点开抖动\r\n  const id = \"article_style\";\r\n\r\n  useEffect(() => {\r\n    if (!visible) {\r\n      const dom = document.querySelector(`#${id}`);\r\n      if (dom) {\r\n        // 延迟去除，防止抖动\r\n        setTimeout(() => {\r\n          document.head.removeChild(dom);\r\n        }, 500);\r\n      }\r\n      return;\r\n    }\r\n    const { clientWidth } = window.document.documentElement;\r\n    const screenDifference = window.innerWidth - clientWidth;\r\n    const content = `\r\n      html body{\r\n        overflow-Y:hidden;\r\n        ${\r\n          screenDifference > 0 ? `width:calc(100% - ${screenDifference}px)` : \"\"\r\n        }\r\n      }\r\n  `;\r\n    const style =\r\n      document.querySelector(`#${id}`) || document.createElement(\"style\");\r\n    style.id = id;\r\n    style.innerHTML = content;\r\n    document.head.appendChild(style);\r\n  }, [visible]);\r\n\r\n  return (\r\n    <Viewer\r\n      visible={visible}\r\n      activeIndex={activeIndex}\r\n      onClose={() => {\r\n        setVisible(false);\r\n      }}\r\n      onMaskClick={() => {\r\n        setVisible(false);\r\n      }}\r\n      images={images}\r\n    />\r\n  );\r\n}\r\n```\r\n\r\n之后引入\r\n\r\n```js\r\nconst Preview = dynamic(() => import(\"./preview\").then((e) => e.Preview), {\r\n  ssr: false,\r\n});\r\n```\r\n\r\n## 点击量\r\n\r\n很多时候需要对文章点击量进行一个整体衡量，包括站点访问量之类的，这里用的是 [不蒜子 - 极简网页计数器](https://busuanzi.ibruce.info/)\r\n\r\n首先安装依赖\r\n\r\n```sh\r\npnpm i busuanzi.pure.js\r\n```\r\n\r\n之后在每次路由发生变化的时候进行监听\r\n\r\n```js\r\n\"use client\";\r\nimport { usePathname } from \"next/navigation\";\r\nimport { fetch } from \"busuanzi.pure.js\";\r\nimport { useUpdateEffect } from \"ahooks\";\r\n\r\n// 给文章添加点击量\r\nexport default function Statistics() {\r\n  const pathname = usePathname();\r\n  useUpdateEffect(() => {\r\n    fetch();\r\n  }, [pathname]);\r\n\r\n  return null;\r\n}\r\n```\r\n\r\n在 app/page.tsx 页面引入\r\n\r\n```js\r\nconst Statistics = dynamicNext(() => import(\"./statistics\"), { ssr: false });\r\n\r\nreturn () => {\r\n  <Statistics></Statistics>;\r\n};\r\n```\r\n\r\n在需要地方引入，例如我需要某一篇文章的访问量，那我就\r\n\r\n```html\r\n<span>\r\n  <i className=\"qzf qzf-eye\" />\r\n  <span id=\"busuanzi_value_page_pv\" suppressHydrationWarning> 0 </span>次\r\n</span>\r\n```\r\n\r\n其他的方式可以看一下文章，最后需要注意一下，需要设置 meta 属性为 `no-referrer-when-downgrade`，具体原因看[不蒜子在 Chrome 85 版本后所有页面统计是同一个数据](https://github.com/fluid-dev/hexo-theme-fluid/issues/376)\r\n\r\n```js\r\nexport const metadata: Metadata = {\r\n  referrer: \"no-referrer-when-downgrade\",\r\n};\r\n```\r\n\r\n## 添加收录\r\n\r\n这里以 Google 为例，可以[访问此网站](https://search.google.com/search-console?resource_id=https%3A%2F%2Fbosens-china.github.io%2Fblog%2F)，根据示例一步步来。\r\n\r\n然后在 app/layout.tsx 中添加下面这样的代码\r\n\r\n```js\r\n  return (\r\n    <html lang=\"zh\">\r\n        <meta\r\n          name=\"google-site-verification\"\r\n          content=\"4FVbyJeMZIl9kKhdo9gaJLqZviP6Z5En9GbS5VD8g6w\"\r\n        />\r\n      </head>\r\n      <body>\r\n\r\n      </body>\r\n    </html>\r\n  );\r\n```\r\n\r\n## 给代码添加复制和在线运行功能\r\n\r\n这块因为这段时间心情很糟糕，代码并没有写完，所以下面全部都是伪代码形式。\r\n\r\n因为渲染 md 用的组件是 [@bytemd/react](https://github.com/bytedance/bytemd?tab=readme-ov-file)，它其实是支持插件拓展的，放一张官方的图\r\n\r\n![example](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/772280b6ab3343eea64699995f4419d6~tplv-k3u1fbpfcp-image.image#?w=402&h=342&s=22477&e=svg&a=1&b=f5ddd5)\r\n\r\n有两个步骤可以完成添加的功能\r\n\r\n- The HTML AST could be manipulated by several rehype plugins\r\n- Some extra DOM manipulation after the HTML being rendered\r\n\r\n最后一种对 ssr 没有帮助，相当于客户端渲染了，不过对 dom 添加之类的操作十分方便我们做一些定制，例如添加复制，我们可以写一个 copy 组件，然后在 dom 元素出现的时候直接使用 `react-dom` `render()` 指定元素就下可以了。\r\n\r\n结合一个官方给出的示例来进行看下\r\n\r\n```js\r\nexport default function mathPlugin(): BytemdPlugin {\r\n  return {\r\n    remark: (processor) => processor.use(remarkMath),\r\n+   viewerEffect({ markdownBody }) {\r\n+     const renderMath = async (selector: string, displayMode: boolean) => {\r\n+       const katex = await import('katex').then((m) => m.default)\r\n+\r\n+       const els = markdownBody.querySelectorAll<HTMLElement>(selector)\r\n+       els.forEach((el) => {\r\n+         katex.render(el.innerText, el, { displayMode })\r\n+       })\r\n+     }\r\n+\r\n+     renderMath('.math.math-inline', false)\r\n+     renderMath('.math.math-display', true)\r\n+   },\r\n  }\r\n}\r\n\r\n```\r\n\r\n相当于就是操作 dom 元素了。\r\n\r\n## 添加搜索功能\r\n\r\n文章搜索也是一个很重要功能，这边分享一下我是怎么做的，首先对于关键词搜索啥的 SSG 是没办法收录的，因为你也不知道到底会有多少关键词。\r\n\r\n分享一下我的做法\r\n\r\n```jsx\r\n<form\r\n  id=\"search-form\"\r\n  method=\"get\"\r\n  action={`${process.env.NEXT_PUBLIC_BASE_PATH}/page/1`}\r\n  className=\"uk-search uk-search-navbar uk-width-1-1 qzhai_so uk-visible@s\"\r\n>\r\n  <input\r\n    className=\"uk-search-input\"\r\n    type=\"search\"\r\n    name=\"s\"\r\n    id=\"s\"\r\n    placeholder=\"搜索\"\r\n    defaultValue=\"\"\r\n  />\r\n</form>\r\n```\r\n\r\n当输入之后 enter 按键被触发会在 page 后面携带 `s?=xxx` 的参数，之后在客户端组件里面通过\r\n\r\n```js\r\nconst searchParams = useSearchParams();\r\nconst search = searchParams.get(\"s\");\r\n```\r\n\r\n来取到对应的值，之后就是对数据进行渲染加红即可，这里说下加红的做法，可以通过正则来替换，把搜索文本替换成\r\n\r\n```html\r\n<span style=\"color:red\">关键词</span>\r\n```\r\n\r\n之后 React 直接渲染 html 字符串就达到了一个高亮的效果。\r\n\r\n这里贴一下我的不完整代码\r\n\r\n```jsx\r\n<Link\r\n  href={path}\r\n  dangerouslySetInnerHTML={{\r\n    __html: s\r\n      ? title.replace(new RegExp(s, \"ig\"), (value: string) => {\r\n          return `<span style=\"color: red\">${value}</span>`;\r\n        })\r\n      : title,\r\n  }}\r\n></Link>\r\n```\r\n\r\n## 最后\r\n\r\n如果文章有错误之类的欢迎指出，顺便下一篇文章 [Next.js 构建博客之自动构建](https://github.com/bosens-China/blog/issues/108) 就是收尾了，主要介绍使用 Github Actions 来完成自动发布，在使用的时候只需要监听 issues 的变化就行。\r\n",
      "reactions": {
        "url": "https://api.github.com/repos/bosens-China/blog/issues/107/reactions",
        "total_count": 0,
        "+1": 0,
        "-1": 0,
        "laugh": 0,
        "hooray": 0,
        "confused": 0,
        "heart": 0,
        "rocket": 0,
        "eyes": 0
      },
      "timeline_url": "https://api.github.com/repos/bosens-China/blog/issues/107/timeline",
      "performed_via_github_app": null,
      "state_reason": null
    },
    {
      "url": "https://api.github.com/repos/bosens-China/blog/issues/108",
      "repository_url": "https://api.github.com/repos/bosens-China/blog",
      "labels_url": "https://api.github.com/repos/bosens-China/blog/issues/108/labels{/name}",
      "comments_url": "https://api.github.com/repos/bosens-China/blog/issues/108/comments",
      "events_url": "https://api.github.com/repos/bosens-China/blog/issues/108/events",
      "html_url": "https://github.com/bosens-China/blog/issues/108",
      "id": 2056976568,
      "node_id": "I_kwDOCzPAy856mvi4",
      "number": 108,
      "title": "Next.js 构建博客之自动构建",
      "user": {
        "login": "bosens-China",
        "id": 39508895,
        "node_id": "MDQ6VXNlcjM5NTA4ODk1",
        "avatar_url": "https://avatars.githubusercontent.com/u/39508895?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bosens-China",
        "html_url": "https://github.com/bosens-China",
        "followers_url": "https://api.github.com/users/bosens-China/followers",
        "following_url": "https://api.github.com/users/bosens-China/following{/other_user}",
        "gists_url": "https://api.github.com/users/bosens-China/gists{/gist_id}",
        "starred_url": "https://api.github.com/users/bosens-China/starred{/owner}{/repo}",
        "subscriptions_url": "https://api.github.com/users/bosens-China/subscriptions",
        "organizations_url": "https://api.github.com/users/bosens-China/orgs",
        "repos_url": "https://api.github.com/users/bosens-China/repos",
        "events_url": "https://api.github.com/users/bosens-China/events{/privacy}",
        "received_events_url": "https://api.github.com/users/bosens-China/received_events",
        "type": "User",
        "site_admin": false
      },
      "labels": [
        {
          "id": 6273949336,
          "node_id": "LA_kwDOCzPAy88AAAABdfTemA",
          "url": "https://api.github.com/repos/bosens-China/blog/labels/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA",
          "name": "博客搭建",
          "color": "b60205",
          "default": false,
          "description": "介绍博客简单的过程"
        }
      ],
      "state": "open",
      "locked": false,
      "assignee": null,
      "assignees": [],
      "milestone": null,
      "comments": 0,
      "created_at": "2023-12-27T06:37:19Z",
      "updated_at": "2023-12-27T06:39:13Z",
      "closed_at": null,
      "author_association": "OWNER",
      "active_lock_reason": null,
      "body": "![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/93a4556e832740f0b44cb081a6a70b9e~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2998&h=1464&s=549772&e=png&b=fefefe)\r\n\r\n1.  [Next.js 构建博客之资源抓取](https://github.com/bosens-China/blog/issues/102)\r\n2.  [Next.js 构建博客之博客搭建](https://github.com/bosens-China/blog/issues/103)\r\n3.  [Next.js 构建博客之打包 SSG](https://github.com/bosens-China/blog/issues/104)\r\n4.  [Next.js 构建博客之常见问题处理](https://github.com/bosens-China/blog/issues/105)\r\n5.  [Next.js 构建博客之功能拓展](https://github.com/bosens-China/blog/issues/107)\r\n6.  [Next.js 构建博客之自动构建](https://github.com/bosens-China/blog/issues/108)\r\n\r\n这是 Next.js 构建博客的第六篇文章，上一篇文章 [Next.js 构建博客之功能拓展](https://github.com/bosens-China/blog/issues/107) 介绍了 Next.js 如何添加额外的功能，这一篇主要介绍自动化提交部署相关的部分。\r\n\r\n如果你想看已经部署博客的地址可以[点击查看](https://bosens-china.github.io/blog/)，代码仓库地址[点击查看](https://github.com/bosens-China/blog)。\r\n\r\n在正式说之前需要对 Github Actions 有所了解，具体的文章这里推荐两篇\r\n\r\n- [GitHub Actions 入门教程](https://www.ruanyifeng.com/blog/2019/09/getting-started-with-github-actions.html)\r\n- [GitHub Actions 教程：定时发送天气邮件](https://www.ruanyifeng.com/blog/2019/12/github_actions.html)\r\n\r\n阅读完成上面两篇会大概对 Github Actions 是什么东西有所了解，之后就是跟着我一步步操作了\r\n\r\n## GitHub Pages\r\n\r\nNext build 之后是一堆静态文件，可以托管到自己的网站也可以白嫖一下 Github Pages，开启 Github Pages 的方法也很简单。\r\n仓库点击 Settings 找到 Pages，之后设置 GitHub Pages 为 Github Actions 即可。\r\n\r\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1db04c51b6174a35bfe7ef147398fa78~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=3024&h=1714&s=502308&e=png&b=fefefe)\r\n\r\n## nextjs.yml\r\n\r\n新建一个文件 .github/workflows/nextjs.yml\r\n\r\n```sh\r\n# Sample workflow for building and deploying a Next.js site to GitHub Pages\r\n#\r\n# To get started with Next.js see: https://nextjs.org/docs/getting-started\r\n#\r\nname: Deploy Next.js site to Pages\r\n\r\non:\r\n  # Runs on pushes targeting the default branch\r\n  push:\r\n    branches: [\"main\"]\r\n  issues:\r\n    types:\r\n      - opened\r\n      - edited\r\n      - deleted\r\n      - closed\r\n      - reopened\r\n  # Allows you to run this workflow manually from the Actions tab\r\n  workflow_dispatch:\r\n\r\n# Sets permissions of the GITHUB_TOKEN to allow deployment to GitHub Pages\r\npermissions:\r\n  contents: write\r\n  pages: write\r\n  id-token: write\r\n\r\n# Allow only one concurrent deployment, skipping runs queued between the run in-progress and latest queued.\r\n# However, do NOT cancel in-progress runs as we want to allow these production deployments to complete.\r\nconcurrency:\r\n  group: \"pages\"\r\n  cancel-in-progress: false\r\n\r\njobs:\r\n  # Build job\r\n  build:\r\n    runs-on: ubuntu-latest\r\n    steps:\r\n      - name: Checkout\r\n        uses: actions/checkout@v3\r\n\r\n      - uses: pnpm/action-setup@v2\r\n        with:\r\n          version: 8.10.2\r\n\r\n      - name: Setup Node\r\n        uses: actions/setup-node@v3\r\n        with:\r\n          node-version: \"20\"\r\n          cache: pnpm\r\n\r\n      - name: Restore cache\r\n        uses: actions/cache@v3\r\n        with:\r\n          path: |\r\n            .next/cache\r\n          # Generate a new cache whenever packages or source files change.\r\n          key: ${{ runner.os }}-nextjs-${{ hashFiles('**/package-lock.json') }}-${{ hashFiles('**/*.[jt]s', '**/*.[jt]sx') }}\r\n          # If source files changed but packages didn't, rebuild from a prior cache.\r\n          restore-keys: |\r\n            ${{ runner.os }}-nextjs-${{ hashFiles('**/package-lock.json') }}-\r\n\r\n      - name: Install dependencies\r\n        run: pnpm install\r\n\r\n      - name: Build userData\r\n        env:\r\n          GITHUB_REPOSITORY: ${{github.repository}}\r\n          AUTHORIZATION: ${{ secrets.ACTION_DEPLOY_KEY  }}\r\n        run: pnpm run -F @blog/side-effect build\r\n\r\n      - name: Commit and Push Changes\r\n        uses: crazy-max/ghaction-github-pages@v2\r\n        with:\r\n          target_branch: ${{github.ref_name}}\r\n          build_dir: ./\r\n          allow_empty_commit: false\r\n        env:\r\n          # @see https://docs.github.com/cn/actions/reference/authentication-in-a-workflow#about-the-github_token-secret\r\n          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}\r\n\r\n      - name: Setup Pages\r\n        uses: actions/configure-pages@v3\r\n        with:\r\n          # Automatically inject basePath in your Next.js configuration file and disable\r\n          # server side image optimization (https://nextjs.org/docs/api-reference/next/image#unoptimized).\r\n          #\r\n          # You may remove this line if you want to manage the configuration yourself.\r\n          static_site_generator: next\r\n\r\n      - name: Build with Next.js\r\n        run: pnpm run -F @blog/view build\r\n      - name: Upload artifact\r\n        uses: actions/upload-pages-artifact@v2\r\n        with:\r\n          path: ./packages/view/out\r\n\r\n  # Deployment job\r\n  deploy:\r\n    # Deploy to the github-pages environment\r\n    environment:\r\n      name: github-pages\r\n      url: ${{ steps.deployment.outputs.page_url }}\r\n\r\n    runs-on: ubuntu-latest\r\n    needs: build\r\n    steps:\r\n      - name: Deploy to GitHub Pages\r\n        id: deployment\r\n        uses: actions/deploy-pages@v2\r\n\r\n```\r\n\r\n上面放了一个完整的 yml 文件，用文字概述一下它做了哪些事情\r\n\r\n### jobs build\r\n\r\n- 安装系统 ubuntu-latest\r\n- 拉取代码\r\n- 安装 pnpm\r\n- 安装 node\r\n- 添加缓存\r\n- 安装 pnpm 依赖\r\n- 运行爬虫\r\n- 推送 README.md 文件到仓库\r\n- Next build 资源\r\n- 将输出资源上传到磁盘中\r\n\r\n### jobs deploy\r\n\r\n- 安装系统 ubuntu-latest\r\n- 将磁盘文件提交到 pages 下\r\n\r\n整体流程就是这样，结合 on 事件当你代码被提交或者 issues 发生变化，上面的 yml 文件就会被执行。\r\n\r\n> 额外说一下，Github Actions 十分强大，例如可以定时跑爬虫、npm 发版等。\r\n\r\n## 最后\r\n\r\n结合 on 事件可以指定触发的场景，例如我的配置如下\r\n\r\n```sh\r\non:\r\n  # Runs on pushes targeting the default branch\r\n  push:\r\n    branches: [\"main\"]\r\n  issues:\r\n    types:\r\n      - opened\r\n      - edited\r\n      - deleted\r\n      - closed\r\n      - reopened\r\n  # Allows you to run this workflow manually from the Actions tab\r\n  workflow_dispatch:\r\n```\r\n\r\n只有推送分支和 issues 发生变化的时候才执行 Action，例如我想更新我的博客只需要在仓库 new issue 就可以触发这个 Action 然后重新构建我的博客,如果遇到问题可以参考[我的仓库](https://github.com/bosens-China/blog/actions)进行查看。\r\n\r\n![image-1.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ad09cbc5c5ad4629bb272024e1f0ecbc~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=3018&h=1460&s=443589&e=png&b=ffffff)\r\n\r\n最后如果有什么错误或者不对地方欢迎指出，如果对你有帮助也可以 star 支持一下，整个 Nextjs 构建博客全系列就讲完了。\r\n",
      "reactions": {
        "url": "https://api.github.com/repos/bosens-China/blog/issues/108/reactions",
        "total_count": 0,
        "+1": 0,
        "-1": 0,
        "laugh": 0,
        "hooray": 0,
        "confused": 0,
        "heart": 0,
        "rocket": 0,
        "eyes": 0
      },
      "timeline_url": "https://api.github.com/repos/bosens-China/blog/issues/108/timeline",
      "performed_via_github_app": null,
      "state_reason": null
    },
    {
      "url": "https://api.github.com/repos/bosens-China/blog/issues/106",
      "repository_url": "https://api.github.com/repos/bosens-China/blog",
      "labels_url": "https://api.github.com/repos/bosens-China/blog/issues/106/labels{/name}",
      "comments_url": "https://api.github.com/repos/bosens-China/blog/issues/106/comments",
      "events_url": "https://api.github.com/repos/bosens-China/blog/issues/106/events",
      "html_url": "https://github.com/bosens-China/blog/issues/106",
      "id": 2056128095,
      "node_id": "I_kwDOCzPAy856jgZf",
      "number": 106,
      "title": "2023年终总结",
      "user": {
        "login": "bosens-China",
        "id": 39508895,
        "node_id": "MDQ6VXNlcjM5NTA4ODk1",
        "avatar_url": "https://avatars.githubusercontent.com/u/39508895?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bosens-China",
        "html_url": "https://github.com/bosens-China",
        "followers_url": "https://api.github.com/users/bosens-China/followers",
        "following_url": "https://api.github.com/users/bosens-China/following{/other_user}",
        "gists_url": "https://api.github.com/users/bosens-China/gists{/gist_id}",
        "starred_url": "https://api.github.com/users/bosens-China/starred{/owner}{/repo}",
        "subscriptions_url": "https://api.github.com/users/bosens-China/subscriptions",
        "organizations_url": "https://api.github.com/users/bosens-China/orgs",
        "repos_url": "https://api.github.com/users/bosens-China/repos",
        "events_url": "https://api.github.com/users/bosens-China/events{/privacy}",
        "received_events_url": "https://api.github.com/users/bosens-China/received_events",
        "type": "User",
        "site_admin": false
      },
      "labels": [
        {
          "id": 3041947800,
          "node_id": "MDU6TGFiZWwzMDQxOTQ3ODAw",
          "url": "https://api.github.com/repos/bosens-China/blog/labels/%E4%BB%A3%E7%A0%81%E4%BA%BA%E7%94%9F",
          "name": "代码人生",
          "color": "7B17E3",
          "default": false,
          "description": "和技术无关，人生的感悟"
        }
      ],
      "state": "open",
      "locked": false,
      "assignee": null,
      "assignees": [],
      "milestone": null,
      "comments": 0,
      "created_at": "2023-12-26T07:34:24Z",
      "updated_at": "2023-12-26T07:34:25Z",
      "closed_at": null,
      "author_association": "OWNER",
      "active_lock_reason": null,
      "body": "2023 年的即将走完，趁着现在还有一些时间，给今年发生了许多事情一个阶段性总结。本来很早之前就在计划就要写一篇文章回顾下半年这几个月（打到这行字还是觉得眼眶酸酸的，因为之前的文稿是我口述她敲的，现在在上面基础上加工）。但是中间一直懒散的拖下去直到今天才终于有时间来写这篇文章。\r\n\r\n## 买房\r\n\r\n20 年的时候其实就在关注，当时同事跟我说房价涨了，让我赶紧看房子，不过当时苦于老家有一套贷款房所以需要 5 成首付就一直不了了之这样。随着 7 月政策慢慢放开首付比例，我也把老家的贷款给结清了，所以就继续关注，当时主要看的是新房主打一个人多就参与，期间参与了很多楼盘。\r\n\r\n龙湖光年、朗诗里、臻悦等，不过都一直没摇中，后面时代星河开了，然后参加摇号职住+刚需的身份勉强摇中，顺序还挺靠前。当时工作就在高新区，房子也在附近所以觉得还挺 ok，也没有想太多总感觉自己迟早都要买，就下定决心交了首付。\r\n\r\n不过现在看这个事情，感觉自己做的还是很冲动，说白了就是抗风险能力不足，而且现在还是一个人，如果结婚了夫妻双方的话可能会好一些，而且我买房子当时想的是自住，但是我最近整理自己的思绪才发现，自己其实想的一直都是投资。如果房价下降很严重，其实我根本就不会考虑这个事情了，这还真是不知道说啥了。\r\n\r\n## 被裁\r\n\r\n9 月 16 号的时候公司突然通知裁员，我们领导和我说的，他说他自己也是被裁名单。我在这家公司已经待了 2 年半了，其实也蛮久了一直想着跳槽之类的，所以现在反而有一笔赔偿之类的内心也能接受，后面把年假休了到 21 号正式离职。\r\n\r\n站在目前来看在这家公司在我职业生涯占比达到一半，福利很好而且工作强度很适中，base 因为在合肥甚至还可以远程办公，唯一一点就是偶尔需要出差，我甚至觉得买房的原因就跟在这家公司待久了很有关联，因为公积金是全额缴纳的。当时算账面的时候就觉得压力其实也还好，但是没想到突然发生黑天鹅这样的事情吧，整个小组都被砍掉了。\r\n\r\n后面的一周就在整理简历断断续续投递，期间有 2 个 offer 不过薪资离我期待的目标还是有所差异，最终也没有入职。\r\n\r\n过了 11 月之后就非常焦虑，每天的工作就是找工作，进一步对寒冬有了新的认知，到了 11 月找到了一个薪水达到期待的但是距离很远的工作，勉强入职了。\r\n\r\n## 恋爱\r\n\r\n整体上半年其实过的非常轻松，一个人在陌生城市还是会觉得有些孤独吧，离上一段感情已经过去一年了。但是工作场景很单一，所以就在一些软件上尝试寻找，后面就在青藤认识到了一个女生，简称她为小刘。\r\n\r\n当时看她是 e 人，颜值其实只能说普通这样，但是因为性格是一个互补的这样，所以觉得还是可以继续相处下去。后面就经常一起语音和玩游戏，到后面第一次见面经常约出去玩，第一次牵手啥的，我觉得整体过程都很平顺，果然互相喜欢进度跟做火箭没有太多区别。到 21 号的时候约了一个上海的面试就问她要不要一起顺便玩一下，她同意了。\r\n\r\n去上海面试的过程还算 ok，不过薪水没有达到预期最终也没有去。\r\n\r\n后面两天就去了外滩和迪士尼去玩，其实一直觉得挺愧疚毕竟去上海的主要目的其实是面试，玩的话只是附带的。玩的场景还历历在目一起挑战了很多项目，尤其是极速光轮还挺刺激的。\r\n\r\n后面回到合肥之后就经常一起去吃饭做 diy、玩卡车去游乐园，去公园散步等，每天有这样的一个女生陪伴，真的觉得很幸福，而且她还是英语专业的，每天对我还能监督。我甚至跟她在一起把之后的生活都想象好了。\r\n\r\n## 失恋\r\n\r\n幸福总是短暂的，到了 12 月的时候我感觉她的状态很不对劲，就每天找她聊天都比较冷淡，晚上也不会主动打语音之类的。后面就打了一个电话问她，但是她只是说自己比较忙碌。当时我觉得就是说辞了，心里已经有了不好的感觉，然后晚上她哭着跟我说，家里在闹矛盾父母要闹离婚，当时觉得自己挺不是东西的，没有安慰反而一直想东想西的。\r\n\r\n但是过了一周依然是很冷淡这种，12 月 11 号的时候我有点忍受不了，下午 4 点多打了电话，但是没打通，隔半个小时打一个断断续续打了 11 个，到了 8 点半她微信给我回消息了，大概说\r\n\r\n```txt\r\n小杨我们分开吧，也不要继续给我打电话了。\r\n在一起就就是很懵懵懂懂这样，从一顿饭开始也不知道是不是爱情，但是她觉得不是合适的人，就这样结束吧。\r\n```\r\n\r\n当时说完觉得自己终于得到自己想要了答案了，但是第二天后遗症太大了一直想电话联系，后面短信跟她说，如果不同意就去公司找她，她才勉强接的。\r\n电话说了一些原因啥的，没有告别也没有送花，还有她经常过来找我我迟到这样，还有跟其他同事男朋友对比，觉得我做的很差。\r\n\r\n周四还是决心去尝试了一下，到之前跟她微信说了下，说之前的缺点现在都认知到了，现在自己想尝试改掉，给这样的机会。但是她态度很强烈说不喜欢就是不喜欢，为什么还要勉强，来见我的目的就是想复合我都知道，但是这个不是一时冲动，希望不要在纠结了，否则不要怪她撕破脸之类的。\r\n\r\n当时心里听了就很凉，但是还是说见一面吧，分开见最后一面聊聊。晚上勉强见了一面，但是什么话都说不出来因为她她一直在恳求说我们做朋友吧，我只能苦涩点头。晚上想送她回家，她说不用这样，我坚持送，在地铁上跟我说，现在我就像一个狗皮膏药一样。\r\n\r\n周末的时候抖音联系她室友，问她室友知不知道最近发生了什么事情和矛盾，晚上她给生气给我打了一大段话，大概就是说不是已经同意分手了，为什么还要烦她室友，语气很不客气而且骂了我一顿，里面很多话我觉得太恶毒了，就完全跟我心目中的她颠覆了。说我恶心，装深情，之类的可能就是单纯不喜欢没有感觉了，总之从 9 月到 12 月快到三个月的一个短暂感情就这样结束了。\r\n\r\n## 被裁\r\n\r\n其实就发生在今天（12 月 26 日），昨天部门领导找我谈话，说我最近工作态度太消极了，明天人事会找我聊一下。\r\n\r\n上午人事找到我，传达了部门的最终意见，这边也只能接受了，其实我一直觉得工作对我来说可有可无，没有的话就重新找一份，本来就打算只是过渡，只是感情这个事情一直在纠缠着我，让我觉得很疲倦这样。临近年底可能自己能做的就是休息一段时间，等待明年继续找工作了。\r\n\r\n而且今年在找工作的时候我会觉得技术要求很高，需要持续学习，而且会有淘汰风险的，但是产品岗位就相对而言更好一些，也比较方便晋升之类的。如果有转岗的建议真的可以考虑一下，不过就是不太适合 i 人。\r\n\r\n而且最近这段时间一直在想出路啥的，现在觉得程开发的岗位真的挺适合前端的，就是需要英语要求比较高，需要多补一下。\r\n\r\n## 退房\r\n\r\n这个事情其实思考了很久，当时 7 月份就决定要买，但是 9 月经历了裁员找工作也不是很顺利。就一直在想这个事情，中间也尝试很多方法，去找他们经理谈以及找关系退房等。但是都失败了，目前加上继续失业的这样一个 buff，实在没有心情继续搞下去了。\r\n\r\n而且房产我也持悲观态度，这样稳定 30 年的还贷款真的很有压力的事情，后面可能等结婚之后才会继续考虑了。\r\n\r\n下这个决定也没有想象中的这么痛快，中间一直在拉扯，自己的内心也一直处于纠结状态，但是现在继续上车搞不好真的征信黑了，笑。\r\n\r\n## 最后\r\n\r\n感觉今年应该是我人生非常黑暗的一年，但是也有一些美好的回忆，很喜欢曾国藩的一句话 `物来顺应，未来不迎，当时不杂，既过不恋`，还是需要降低对她人的期待，才能当事情不至于跟自己的内心有很大的这样一个差异。而且我觉得自己真的有点恋爱脑这样，又或者太精神依赖别人了，现在被抽离才这样痛苦吧。\r\n\r\n工作方面工作很久，我反而会觉得技术不是很重要的这样一个标准，尤其是跟我同时期工作的人已经坐上了 leader 的岗位，这让我觉得很有危机感。自己其实也想尝试往管理的岗位走下去，但是可能需要一个契机吧。\r\n\r\n感情方面我没有觉得她亏欠我很多，只是自己一下子接受不了失去吧，有美好的回忆就足够了，有这样的一个人陪伴过我这样一段时光，我觉得也算是一种收获。不过最近在看关于她的一些东西，也还是会有一些莫名复杂的感情吧。\r\n\r\n不过如何2023年就这样度过了，希望新的一年有好的心情与发展。\r\n\r\n最后用一张图结束今年的感情\r\n\r\n<img width=\"624\" alt=\"image\" src=\"https://github.com/bosens-China/blog/assets/39508895/4b36a30f-e840-485a-96ee-a108f023bf59\">\r\n\r\n",
      "reactions": {
        "url": "https://api.github.com/repos/bosens-China/blog/issues/106/reactions",
        "total_count": 0,
        "+1": 0,
        "-1": 0,
        "laugh": 0,
        "hooray": 0,
        "confused": 0,
        "heart": 0,
        "rocket": 0,
        "eyes": 0
      },
      "timeline_url": "https://api.github.com/repos/bosens-China/blog/issues/106/timeline",
      "performed_via_github_app": null,
      "state_reason": null
    },
    {
      "url": "https://api.github.com/repos/bosens-China/blog/issues/79",
      "repository_url": "https://api.github.com/repos/bosens-China/blog",
      "labels_url": "https://api.github.com/repos/bosens-China/blog/issues/79/labels{/name}",
      "comments_url": "https://api.github.com/repos/bosens-China/blog/issues/79/comments",
      "events_url": "https://api.github.com/repos/bosens-China/blog/issues/79/events",
      "html_url": "https://github.com/bosens-China/blog/issues/79",
      "id": 1085659613,
      "node_id": "I_kwDOCzPAy85Atdnd",
      "number": 79,
      "title": "从Vue3看组件开发新写法",
      "user": {
        "login": "bosens-China",
        "id": 39508895,
        "node_id": "MDQ6VXNlcjM5NTA4ODk1",
        "avatar_url": "https://avatars.githubusercontent.com/u/39508895?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bosens-China",
        "html_url": "https://github.com/bosens-China",
        "followers_url": "https://api.github.com/users/bosens-China/followers",
        "following_url": "https://api.github.com/users/bosens-China/following{/other_user}",
        "gists_url": "https://api.github.com/users/bosens-China/gists{/gist_id}",
        "starred_url": "https://api.github.com/users/bosens-China/starred{/owner}{/repo}",
        "subscriptions_url": "https://api.github.com/users/bosens-China/subscriptions",
        "organizations_url": "https://api.github.com/users/bosens-China/orgs",
        "repos_url": "https://api.github.com/users/bosens-China/repos",
        "events_url": "https://api.github.com/users/bosens-China/events{/privacy}",
        "received_events_url": "https://api.github.com/users/bosens-China/received_events",
        "type": "User",
        "site_admin": false
      },
      "labels": [
        {
          "id": 1473940161,
          "node_id": "MDU6TGFiZWwxNDczOTQwMTYx",
          "url": "https://api.github.com/repos/bosens-China/blog/labels/%E6%A1%86%E6%9E%B6%E7%9B%B8%E5%85%B3",
          "name": "框架相关",
          "color": "42b883",
          "default": false,
          "description": "目前Vue和React为主"
        }
      ],
      "state": "open",
      "locked": false,
      "assignee": null,
      "assignees": [],
      "milestone": null,
      "comments": 0,
      "created_at": "2021-12-21T10:11:38Z",
      "updated_at": "2023-12-08T10:31:52Z",
      "closed_at": null,
      "author_association": "OWNER",
      "active_lock_reason": null,
      "body": "这是一篇迟来的文章，原定是 21 年的文章，当时恰逢 Vue3 正式发布已经过去了一段时间，打算介绍一下在 Vue3 中的一些新写法，不过因为种种原因拖延到了今天才动笔。\r\n\r\n## Hooks\r\n\r\nVue3 最大的提升我觉得在于三点：\r\n\r\n- 第一引入了 Proxy 以及编译器的重写，让性能提升一个台阶；\r\n- 第二 TypeScript 的重写让开发过程更加丝滑；\r\n- 第三则是引入了 Composition API，它提供了一种新的组织组件逻辑的方式\r\n\r\n这里重点讲一下 Composition，它提供了一种全新组织逻辑的方法，在之前 Vue2 中我们只能对组件来进行复用，但是对里面的逻辑就无能无力，因此在 Vue2 中有两种方法：\r\n\r\n- 第一种是 Props 不断的拓展，但是缺点也显而易见，让代码混杂在一起，充满各种判断语句；\r\n- 第二则是使用混入，不过这种会让代码调试起来很麻烦，不知道提供的源头在哪里，且对智能推导也不太友好；\r\n\r\n而 Composition 解决的痛点就是组件逻辑这部分，例如我有一个轮播图的组件，在 Vue2 中我想把这个开源出去，我需要考虑很多场景，例如样式拓展、鼠标移动是否禁止下一页、是否支持键盘等，我需要把这个东西做的足够大而全才能覆盖 99%的场景，但是这样带来的问题就是组件很大，逻辑很多。\r\n但是如果在 Vue3 中我们使用 Composition 则有一种新的思路，我不再提供样式和 html，只提供好逻辑部分，用户自己结合所需场景自己来绘制样式，在需要切换的时候调用 Api 即可，下面是一个伪代码。\r\n\r\n```js\r\nconst { previous, nextPage } = useCarouselMap({ ref: dom });\r\n// 点击下一张\r\nnextPage();\r\n```\r\n\r\n在看一个常见的例子，对于网络请求在 Vue2 中一般放到生命周期 created or mounted 中来调用，不过更推荐在 created 中调用，因为可以时机更早一些，如果需要操纵 dom 相关使用 nextTick 即可，下面是一一个示例。\r\n\r\n```js\r\nexport {\r\n  created() {\r\n    this.loading = true;\r\n    getuser().then((data) => {\r\n      this.user = data;\r\n    }).catch((e) => {\r\n      this.$message.error(e.message);\r\n    }).finally(() => {\r\n      this.loading = false;\r\n    });\r\n  }\r\n}\r\n```\r\n\r\n上面的示例模拟请求了获取用户信息，然后加载 loading，对于错误进行提示。这种代码一天中经常会书写很多遍，但是写的次数很多，会在 data 里面充斥各种 loadingxx 以及 dataxxx 等信息，而且仔细分析代码我们写着么多 then 和 catch 都是对数据进行处理，能不能提炼出这部分关键信息呢？\r\n\r\n假设我们新建一个 useRequest，这里不讨论实现细节，只看我们要如何使用它\r\n\r\n```js\r\nfunction getUsername(): Promise<string> {\r\n  return new Promise((resolve) => {\r\n    setTimeout(() => {\r\n      resolve(Mock.mock(\"@name\"));\r\n    }, 1000);\r\n  });\r\n}\r\nconst { data, error, loading } = useRequest(getUsername);\r\n```\r\n\r\n之后如果发生错误之类的，直接在 watch 里面监听提示即可，结合 useRequest 还可以定制超时、重试、缓存等机制。\r\n\r\n在看一个实际的业务场景，对于 b 端项目经常会和表格打交道，通常布局如下：\r\n\r\n- 搜索栏，对表格的一些信息进行填写和搜索，通常来说就是一个 Input+重置和查询按钮；\r\n- table，对搜索的信息进行展示\r\n- 分页栏，对信息进行过滤展示\r\n\r\n而如果有十几个页面，就算我们封装了一些 hooks 还是会觉得有一些繁琐，这里思考一下上面的三部分我们可不可以继续封装呢？\r\n\r\n假设我有一个 useTable 的 hooks，它接受一个 form，以及一些初始的分页信息，在加上一个接口请求的函数，每次在点击查询的时候把 form 的信息传递给查询函数，在分页变化的时候也传递信息给查询函数。\r\n最后这个 hooks 返回 table 的 props 等信息，是不是就完成了上述的任务呢？\r\n\r\n继续看一段伪代码\r\n\r\n```js\r\nconst [form] = Form.useForm();\r\n\r\nconst { tableProps, submit, reset } = useAntdTable(getTableData, {\r\n  defaultPageSize: 5,\r\n  form,\r\n});\r\n// tableProps传递给table使用\r\n// submit绑定查询按钮，每次点击的时候查询\r\n// reset绑定重置按钮，调用把页面信息回到初始化\r\n```\r\n\r\n上面只是举了一些例子，但是实际开发中，我们基本上可以把很多重复的地方抽离出来进行封装，例如防抖节流、dom 元素是否出现、监听 dom 元素大小等。\r\n\r\n## 新组件\r\n\r\nVue3 中也出现了一些新的组件，算是和 React 全面对齐了，有了这些新的 Api 在日常开发中可以省略需要额外的步骤。\r\n\r\n### Teleport\r\n\r\n```html\r\n<Teleport to=\"#popup\" :disabled=\"displayVideoInline\">\r\n  <video src=\"./my-movie.mp4\">\r\n</Teleport>\r\n```\r\n\r\n看官方文档就是把 slot 元素渲染到指定的位置，那么如果自己想实现一个 message 的时候或者想实现返回顶部等功能的时候就不需要额外借助 dom 来处理之类。\r\n\r\n### Suspense\r\n\r\n```html\r\n<Suspense>\r\n  <!-- 具有深层异步依赖的组件 -->\r\n  <Dashboard />\r\n\r\n  <!-- 在 #fallback 插槽中显示 “正在加载中” -->\r\n  <template #fallback> Loading... </template>\r\n</Suspense>\r\n```\r\n\r\nSuspense 用于加载异步组件，给定一个提示，按照文档说话，以下两种情况可以考虑使用 Suspense：\r\n\r\n- 在 setup 中使用了顶层 await\r\n- setup 函数为 async\r\n\r\n不过该语法还在实验阶段，目前能想到的场景可能就是低代码平台下，远程请求组件使用 Suspense 提示用户正在加载中，请耐心等待。\r\n\r\n## template or jsx\r\n\r\n在日常写业务代码时候通常都是 template，因为这样效率足够高，且编译器会对此进行优化。不过在写组件的时候我更推荐使用 jsx，原因有下面几点：\r\n\r\n- 在写 jsx 的时候类型提示足够友好；\r\n- 习惯了 React 的 jsx，在写 jsx 有一种很舒服的感觉；\r\n- 对于一些很棘手的操作，template 需要传递 slot，但是在 jsx 中只需要包裹一下就结束了；\r\n- 逻辑很连贯，不需要考虑上下文切换了，可以看下面一个例子；\r\n\r\n```js\r\n// 1\r\nexport default {\r\n  setup() {\r\n    return () => <div>...</div>\r\n  }\r\n}\r\n//2\r\n\r\n<script setup></script>\r\n\r\n<template>\r\n  <div>...</div>\r\n</template>\r\n```\r\n\r\n## 其他\r\n\r\n在 Vue2 中经常会把功能挂载到 this 上来进行调用，不过这样的问题在于使用不够清晰。Vue3 现在可以创建多个实例，所以对应的挂载挂载操作也变成\r\n\r\n```js\r\napp.config.globalProperties.$message = message;\r\n```\r\n\r\n其次，对于经常使用的 message 也发生了一些变化，之前\r\n\r\n```js\r\nimport { createVNode, render } from 'vue'\r\n  const vnode = createVNode(\r\n    MessageConstructor,\r\n    props,\r\n    isFunction(props.message) || isVNode(props.message)\r\n      ? {\r\n          default: isFunction(props.message)\r\n            ? props.message\r\n            : () => props.message,\r\n        }\r\n      : null\r\n  )\r\n  vnode.appContext = context || message._context\r\n\r\n  render(vnode, container)\r\n  // instances will remove this item when close function gets called. So we do not need to worry about it.\r\n  appendTo.appendChild(container.firstElementChild!)\r\n\r\n  const vm = vnode.component!\r\n```\r\n\r\n如果在 Vue2 中则是这样写\r\n\r\n```js\r\nlet MessageConstructor = Vue.extend(Main);\r\ninstance = new MessageConstructor({\r\n  data: options,\r\n});\r\ninstance.$mount();\r\ndocument.body.appendChild(instance.$el);\r\n```\r\n\r\n## 最后\r\n\r\n如果文章有书写错误欢迎指出。\r\n",
      "reactions": {
        "url": "https://api.github.com/repos/bosens-China/blog/issues/79/reactions",
        "total_count": 0,
        "+1": 0,
        "-1": 0,
        "laugh": 0,
        "hooray": 0,
        "confused": 0,
        "heart": 0,
        "rocket": 0,
        "eyes": 0
      },
      "timeline_url": "https://api.github.com/repos/bosens-China/blog/issues/79/timeline",
      "performed_via_github_app": null,
      "state_reason": null
    },
    {
      "url": "https://api.github.com/repos/bosens-China/blog/issues/84",
      "repository_url": "https://api.github.com/repos/bosens-China/blog",
      "labels_url": "https://api.github.com/repos/bosens-China/blog/issues/84/labels{/name}",
      "comments_url": "https://api.github.com/repos/bosens-China/blog/issues/84/comments",
      "events_url": "https://api.github.com/repos/bosens-China/blog/issues/84/events",
      "html_url": "https://github.com/bosens-China/blog/issues/84",
      "id": 1085661897,
      "node_id": "I_kwDOCzPAy85AteLJ",
      "number": 84,
      "title": "如何编写爬虫",
      "user": {
        "login": "bosens-China",
        "id": 39508895,
        "node_id": "MDQ6VXNlcjM5NTA4ODk1",
        "avatar_url": "https://avatars.githubusercontent.com/u/39508895?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bosens-China",
        "html_url": "https://github.com/bosens-China",
        "followers_url": "https://api.github.com/users/bosens-China/followers",
        "following_url": "https://api.github.com/users/bosens-China/following{/other_user}",
        "gists_url": "https://api.github.com/users/bosens-China/gists{/gist_id}",
        "starred_url": "https://api.github.com/users/bosens-China/starred{/owner}{/repo}",
        "subscriptions_url": "https://api.github.com/users/bosens-China/subscriptions",
        "organizations_url": "https://api.github.com/users/bosens-China/orgs",
        "repos_url": "https://api.github.com/users/bosens-China/repos",
        "events_url": "https://api.github.com/users/bosens-China/events{/privacy}",
        "received_events_url": "https://api.github.com/users/bosens-China/received_events",
        "type": "User",
        "site_admin": false
      },
      "labels": [
        {
          "id": 3661377607,
          "node_id": "LA_kwDOCzPAy87aPDBH",
          "url": "https://api.github.com/repos/bosens-China/blog/labels/Node%E7%B3%BB%E5%88%97",
          "name": "Node系列",
          "color": "9F9262",
          "default": false,
          "description": "和node.js相关内容"
        }
      ],
      "state": "open",
      "locked": false,
      "assignee": null,
      "assignees": [],
      "milestone": null,
      "comments": 0,
      "created_at": "2021-12-21T10:13:58Z",
      "updated_at": "2023-11-17T11:59:21Z",
      "closed_at": null,
      "author_association": "OWNER",
      "active_lock_reason": null,
      "body": "这是一篇鸽了许久的文章，最近失业在家重构博客的时候发现还有一些文章没有来的及写，就有了这篇文章。\r\n\r\n最终代码放到了 [codesandbox](https://codesandbox.io/p/sandbox/busy-wildflower-q43lt2?layout=%257B%2522sidebarPanel%2522%253A%2522EXPLORER%2522%252C%2522rootPanelGroup%2522%253A%257B%2522direction%2522%253A%2522horizontal%2522%252C%2522contentType%2522%253A%2522UNKNOWN%2522%252C%2522type%2522%253A%2522PANEL_GROUP%2522%252C%2522id%2522%253A%2522ROOT_LAYOUT%2522%252C%2522panels%2522%253A%255B%257B%2522type%2522%253A%2522PANEL_GROUP%2522%252C%2522contentType%2522%253A%2522UNKNOWN%2522%252C%2522direction%2522%253A%2522vertical%2522%252C%2522id%2522%253A%2522clp2k6dly0007356kqdw5bh31%2522%252C%2522sizes%2522%253A%255B70%252C30%255D%252C%2522panels%2522%253A%255B%257B%2522type%2522%253A%2522PANEL_GROUP%2522%252C%2522contentType%2522%253A%2522EDITOR%2522%252C%2522direction%2522%253A%2522horizontal%2522%252C%2522id%2522%253A%2522EDITOR%2522%252C%2522panels%2522%253A%255B%257B%2522type%2522%253A%2522PANEL%2522%252C%2522contentType%2522%253A%2522EDITOR%2522%252C%2522id%2522%253A%2522clp2k6dly0003356klqgb2kzt%2522%257D%255D%252C%2522sizes%2522%253A%255B100%255D%257D%252C%257B%2522type%2522%253A%2522PANEL_GROUP%2522%252C%2522contentType%2522%253A%2522SHELLS%2522%252C%2522direction%2522%253A%2522horizontal%2522%252C%2522id%2522%253A%2522SHELLS%2522%252C%2522panels%2522%253A%255B%257B%2522type%2522%253A%2522PANEL%2522%252C%2522contentType%2522%253A%2522SHELLS%2522%252C%2522id%2522%253A%2522clp2k6dly0005356kspa50kd2%2522%257D%255D%252C%2522sizes%2522%253A%255B100%255D%257D%255D%257D%252C%257B%2522type%2522%253A%2522PANEL_GROUP%2522%252C%2522contentType%2522%253A%2522DEVTOOLS%2522%252C%2522direction%2522%253A%2522vertical%2522%252C%2522id%2522%253A%2522DEVTOOLS%2522%252C%2522panels%2522%253A%255B%257B%2522type%2522%253A%2522PANEL%2522%252C%2522contentType%2522%253A%2522DEVTOOLS%2522%252C%2522id%2522%253A%2522clp2k6dly0006356kl2fsaioe%2522%257D%255D%252C%2522sizes%2522%253A%255B100%255D%257D%255D%252C%2522sizes%2522%253A%255B100%252C0%255D%257D%252C%2522tabbedPanels%2522%253A%257B%2522clp2k6dly0003356klqgb2kzt%2522%253A%257B%2522id%2522%253A%2522clp2k6dly0003356klqgb2kzt%2522%252C%2522activeTabId%2522%253A%2522clp2k7p3q010g356klvqy0ikb%2522%252C%2522tabs%2522%253A%255B%257B%2522id%2522%253A%2522clp2k6dly0002356k4946imr6%2522%252C%2522mode%2522%253A%2522permanent%2522%252C%2522type%2522%253A%2522FILE%2522%252C%2522filepath%2522%253A%2522%252Fpackage.json%2522%252C%2522state%2522%253A%2522IDLE%2522%257D%252C%257B%2522type%2522%253A%2522FILE%2522%252C%2522filepath%2522%253A%2522%252Ftsconfig.json%2522%252C%2522id%2522%253A%2522clp2k6zz1008e356kiq200e70%2522%252C%2522mode%2522%253A%2522permanent%2522%252C%2522state%2522%253A%2522IDLE%2522%257D%252C%257B%2522type%2522%253A%2522FILE%2522%252C%2522filepath%2522%253A%2522%252Fsrc%252Futils.ts%2522%252C%2522id%2522%253A%2522clp2k7p3q010g356klvqy0ikb%2522%252C%2522mode%2522%253A%2522permanent%2522%252C%2522state%2522%253A%2522IDLE%2522%257D%252C%257B%2522type%2522%253A%2522FILE%2522%252C%2522filepath%2522%253A%2522%252Fsrc%252Findex.ts%2522%252C%2522id%2522%253A%2522clp2k8c8m01jj356kcv37xobs%2522%252C%2522mode%2522%253A%2522permanent%2522%252C%2522state%2522%253A%2522IDLE%2522%257D%252C%257B%2522type%2522%253A%2522FILE%2522%252C%2522filepath%2522%253A%2522%252Fsrc%252Faxios.ts%2522%252C%2522id%2522%253A%2522clp2k8ox101s6356ka9fnaetk%2522%252C%2522mode%2522%253A%2522permanent%2522%252C%2522state%2522%253A%2522IDLE%2522%257D%252C%257B%2522type%2522%253A%2522FILE%2522%252C%2522filepath%2522%253A%2522%252Fsrc%252Fapi.ts%2522%252C%2522id%2522%253A%2522clp2k9ayh02d7356krmh12x58%2522%252C%2522mode%2522%253A%2522permanent%2522%257D%255D%257D%252C%2522clp2k6dly0006356kl2fsaioe%2522%253A%257B%2522tabs%2522%253A%255B%255D%252C%2522id%2522%253A%2522clp2k6dly0006356kl2fsaioe%2522%257D%252C%2522clp2k6dly0005356kspa50kd2%2522%253A%257B%2522id%2522%253A%2522clp2k6dly0005356kspa50kd2%2522%252C%2522tabs%2522%253A%255B%257B%2522id%2522%253A%2522clp2k6dly0004356k7xhf76kd%2522%252C%2522mode%2522%253A%2522permanent%2522%252C%2522type%2522%253A%2522TASK_LOG%2522%252C%2522taskId%2522%253A%2522start%2522%257D%255D%252C%2522activeTabId%2522%253A%2522clp2k6dly0004356k7xhf76kd%2522%257D%257D%252C%2522showDevtools%2522%253Afalse%252C%2522showShells%2522%253Atrue%252C%2522showSidebar%2522%253Atrue%252C%2522sidebarPanelSize%2522%253A15%257D)\r\n\r\n## 准备工作\r\n\r\n编写爬虫之前需要调查一下需要爬取的网站是什么形式来渲染的\r\n\r\n1. 如果是 spa 页面则只需要拿到账号信息，通常是 token 或者 cookie 之类的，之后直接调取接口即可；\r\n2. 如果是服务器渲染返回的，则可能需要对 dom 结构解析来获取到正确的答案。\r\n\r\n这里主要介绍场景 2，今年的时候买房就是我用爬虫 + 邮箱来定时推送，来保证获取新房的第一手信息，这里也主要结合我做的这个场景来讲解。\r\n\r\n\r\n![image-20231116161442987.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1e30d1813d6444feb361c25b697bb991~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2164&h=974&s=511265&e=png&b=ffffff)\r\n\r\n观察一下页面，可以发现思路就是把 html 结构解析，然后 forEach 子项，然后添加到数组，循环这个过程就可以。\r\n\r\n因为是 node 环境实际上是没有 dom 结构的，所以我们还需要使用特定库来完成解析，这里用的是[cheerio](https://github.com/cheeriojs/cheerio)，它提供类似 jQuery 的语法\r\n\r\n```js\r\nconst cheerio = require(\"cheerio\");\r\nconst $ = cheerio.load('<h2 class=\"title\">Hello world</h2>');\r\n\r\n$(\"h2.title\").text(\"Hello there!\");\r\n$(\"h2\").addClass(\"welcome\");\r\n\r\n$.html();\r\n//=> <html><head></head><body><h2 class=\"title welcome\">Hello there!</h2></body></html>\r\n```\r\n\r\n最后在观察一下页面 url，发现如果跳转第二页变成了 https://www.hfzfzlw.com/spf/Scheme/?p=2&xmmc=&qy=&djzt=\r\n\r\n所以这里很明显了，只需要更改 p 的内容就可以得到一个遍历的效果。\r\n\r\n## 编写\r\n\r\n网络请求库这里使用了 axios，它支持 web 和 node 环境下使用，当然也可以使用其他的请求库。\r\n\r\n```sh\r\nnpm i cheerio axios dayjs\r\n```\r\n\r\n首先需要对 axios 进行一层封装\r\n\r\n```js\r\n// axios.ts\r\nimport axios from \"axios\";\r\nexport const instance = axios.create({\r\n  headers: {\r\n    \"User-Agent\":\r\n      \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/113.0.0.0 Safari/537.36\",\r\n  },\r\n});\r\n```\r\n\r\n这里 User-Agent 字段是描述请求发起的设备信息，这里多准备一些，然后随机发送，例如可以使用 [random-useragent](https://www.npmjs.com/package/random-useragent)，在 instance.interceptors.request.use 中进行拦截，动态更改。\r\n\r\n之后定义一下所需的接口格式\r\n\r\n```ts\r\nexport interface ListProps {\r\n  id: string;\r\n  // 详情url方便后续拓展需求\r\n  url: string;\r\n  // 项目名称\r\n  entryName: string;\r\n  // 楼栋\r\n  building: string[];\r\n  // 开发商\r\n  enterpriseName: string;\r\n  // 区域\r\n  region: string;\r\n  // 开始时间 number\r\n  startTime: number;\r\n  // 结束时间，number\r\n  endTime: number;\r\n  // 总数量\r\n  total: number;\r\n  // 状态\r\n  registrationStatus: string;\r\n  // 开始时间\r\n  start: string;\r\n  // 结束时间\r\n  end: string;\r\n}\r\n```\r\n\r\n剩下就是开始编写，首先：\r\n\r\n1. 获取初始页面内容，这里要解析第一页数据，然后查找需要循环次数；\r\n2. forEach 其他页面，然后储存结果\r\n\r\n```js\r\n// api.ts\r\nimport { instance } from \"./axios\";\r\n\r\nexport const getPage = async (page = 1) => {\r\n  const { data } = await instance.get<string>(`https://www.hfzfzlw.com/spf/Scheme/?p=${page}&xmmc=&qy=&djzt=`;)\r\n  return data;\r\n};\r\n```\r\n\r\n首先定义一个接口的文件，方便后续添加其他页面的接口，之后定义 utils.ts 文件，添加解析 html 的功能。\r\n\r\n```ts\r\nimport { load } from \"cheerio\";\r\nimport dayjs from \"dayjs\";\r\n\r\nexport const BASE_URL = \"http://www.hfzfzlw.com\";\r\n\r\nexport interface ListProps {\r\n  id: string;\r\n  // 详情url方便后续拓展需求\r\n  url: string;\r\n  // 项目名称\r\n  entryName: string;\r\n  // 楼栋\r\n  building: string[];\r\n  // 开发商\r\n  enterpriseName: string;\r\n  // 区域\r\n  region: string;\r\n  // 开始时间 number\r\n  startTime: number;\r\n  // 结束时间，number\r\n  endTime: number;\r\n  // 总数量\r\n  total: number;\r\n  // 状态\r\n  registrationStatus: string;\r\n  // 开始时间\r\n  start: string;\r\n  // 结束时间\r\n  end: string;\r\n}\r\n\r\nexport const analysis = (html: string): ListProps[] => {\r\n  const $ = load(html);\r\n  const arr: ListProps[] = [];\r\n  $(\"tr:not(.table_bg)\").each((_i, el) => {\r\n    // eslint-disable-next-line @typescript-eslint/consistent-type-assertions\r\n    const obj = {} as ListProps;\r\n\r\n    $(el)\r\n      .find(\"td\")\r\n      .each((index, item) => {\r\n        const a = $(item).find(\"a\");\r\n        const value = $(item).text().trim();\r\n        switch (index) {\r\n          case 0:\r\n            obj.id = $(item).find(\"span\").text().trim();\r\n            obj.url = `${BASE_URL}${a.attr(\"href\") ?? \"\"}`;\r\n            obj.entryName = a.text().trim();\r\n            return;\r\n          case 1:\r\n            obj.building = value.split(\",\");\r\n            return;\r\n          case 2:\r\n            obj.enterpriseName = value;\r\n            return;\r\n          case 3:\r\n            obj.region = value;\r\n            return;\r\n          case 4:\r\n            // eslint-disable-next-line no-case-declarations\r\n            const [start, end] = value\r\n              .split(\"至\")\r\n              .map((f) => dayjs(f.trim()).valueOf()) as [number, number];\r\n            obj.startTime = start;\r\n            obj.endTime = end;\r\n            obj.start = dayjs(start).format(\"YYYY-MM-DD HH:mm:ss\");\r\n            obj.end = dayjs(end).format(\"YYYY-MM-DD HH:mm:ss\");\r\n            return;\r\n          case 5:\r\n            obj.total = +value;\r\n            return;\r\n          case 6:\r\n            obj.registrationStatus = value;\r\n        }\r\n      });\r\n    arr.push(obj);\r\n  });\r\n  return arr;\r\n};\r\n\r\nexport const getTotal = (html: string) => {\r\n  const $ = load(html);\r\n  return +$(\".green-black a\")\r\n    .eq(-3)\r\n    .attr(\"href\")\r\n    .match(/p=(\\d+)&/)[1];\r\n};\r\n```\r\n\r\n之后在 index.ts 编写具体的爬取逻辑\r\n\r\n```ts\r\n// index.ts\r\nimport { getPage } from \"./api\";\r\nimport { getTotal, analysis } from \"./utils\";\r\n\r\nconst App = async () => {\r\n  const html = await getPage();\r\n  const len = getTotal(html);\r\n  const tasks = await Promise.all(\r\n    Array.from({ length: len - 1 }).map((_, index) => {\r\n      return getPage(index + 2);\r\n    })\r\n  );\r\n  const result = [html, ...tasks].map((f) => {\r\n    return analysis(f);\r\n  });\r\n  return result;\r\n};\r\nApp();\r\n```\r\n\r\n## ...404\r\n\r\n上面状态下是理想情况，但是如果你真的这样运行会发现突然服务器没有响应了，然后你用其他 ip 的设备来访问，发现还是可以运行的。\r\n\r\n那么问题出在哪里呢？很大概率就是被对方网站进行了拉黑，恶意爬取网站会大量占用服务器的资源和带宽，对于有经验的后端都会考虑到这种场景，对访问频繁的 IP 进行限制，例如 IP 封锁，提示验证码等。\r\n\r\n下面就介绍一些常见绕过的方法。\r\n\r\n## 限速\r\n\r\n上面的代码我们仔细观察一下，发现其实是一下子并发很多条过去，这种场景下可能会导致触发对方的安全机制，那么换个角度来说，我们给每个任务进行限速，然后让其排队来完成是不是就可以减少被发现的概率呢。\r\n\r\n说干就干，更新一下 utils 方法\r\n\r\n```ts\r\nconst wait = (time: number) => {\r\n  return new Promise((resolve, reject) => {\r\n    setTimeout(() => {\r\n      resolve(true);\r\n    }, time);\r\n  });\r\n};\r\n\r\nexport const rateLimiting = async <T extends (...rest: any) => any>(\r\n  arr: T[],\r\n  time: number\r\n) => {\r\n  let i = 0;\r\n  const result: ReturnType<T>[] = [];\r\n  for (const iterator of arr) {\r\n    const o = await iterator();\r\n    result.push(o);\r\n    if (++i < arr.length - 1) {\r\n      await wait(time);\r\n    }\r\n  }\r\n\r\n  return result as Array<Awaited<ReturnType<T>>>;\r\n};\r\n```\r\n\r\n```ts\r\nimport { getPage } from \"./api\";\r\nimport { getTotal, analysis, rateLimiting } from \"./utils\";\r\n\r\nconst App = async () => {\r\n  const html = await getPage();\r\n  const len = getTotal(html);\r\n  const arr = Array.from({ length: len - 1 }).map((_, index) => {\r\n    return () => getPage(index + 2);\r\n  });\r\n  const tasks = await rateLimiting(arr, 3000);\r\n  const result = [html, ...tasks].map((f) => {\r\n    return () => analysis(f);\r\n  });\r\n  return result;\r\n};\r\n```\r\n\r\nok，这样就完成了限速相关的编写，当然实际场景中还需要考虑重试等机制。那么除了限速还有其他方式吗？\r\n\r\n## IP 池\r\n\r\n除了上面的方式，我们还可以维护一个 ip 来进行操作，例如我有大概 100 个代理 IP\r\n\r\n1. 维护一个队列，每次请求之后记录爬取时间和响应时间；\r\n2. 依次请求，排除掉正在爬取的代理 IP；\r\n3. 之后对照响应的时间 - 现在时间，如果大于正常人类浏览时间就继续下一次；\r\n\r\n这里推荐几个我正在使用的代理池，推荐使用 docker 的形式来进行启动\r\n\r\n```yml\r\n// docker-compose.yml\r\nversion: '2'\r\nservices:\r\n  proxy1:\r\n    image: 'jhao104/proxy_pool'\r\n    ports:\r\n      - '5010:5010'\r\n    depends_on:\r\n      - proxy_redis\r\n    environment:\r\n      DB_CONN: 'redis://@proxy_redis:6379/0'\r\n\r\n  proxy_redis:\r\n    image: 'redis'\r\n\r\n  proxy2:\r\n    image: 'boses/ipproxypool'\r\n    restart: always\r\n    privileged: true\r\n    ports:\r\n      - 8000:8000\r\n```\r\n\r\n具体如何维护代理池，然后请求重试这里就不一一写出来了，如果有兴趣可以看我写的这个项目 [Hefei-NewHouse](https://github.com/bosens-China/Hefei-NewHouse/tree/master/packages/reptile/src/utils/proxyPool)。\r\n\r\n如果为了稳定也可以考虑一些付费的IP池，对于验证码之类的措施可以接入到验证码平台，当然这个是收费的。\r\n\r\n## robots.txt\r\n\r\n在编写爬虫中，需要注意一下对方网站根目录是否存在 robots.txt 文件，这个相当于一个默认规则来告诉网络爬虫哪些页面可以被抓取，哪些不应该被抓取。这是遵循网络爬虫协议（Robots Exclusion Protocol）的标准做法。\r\n\r\n```txt\r\nUser-agent: *\r\nDisallow: /private/\r\nAllow: /public/\r\n```\r\n\r\n上述示例表示，对于所有爬虫（User-agent: \\*），不允许访问 \"/private/\" 目录下的页面，但允许访问 \"/public/\" 目录下的页面。\r\n\r\n> 虽然这个不是强制的，但是还是建议遵循这个规则，否则出现法律相关问题可能蹲局子。\r\n\r\n## 最后\r\n\r\n这里只简单介绍了一些编写爬虫的规则，对于规则 1 没有进行额外的拓展，有兴趣的小伙伴可以思考一下知乎如何写一个爬虫。\r\n\r\n最后提醒一下，在法律层面上，未经允许的爬取可能违反计算机犯罪法、数据保护法或其他相关法规，这可能导致法律责任。因此，最好在进行任何形式的爬取之前，仔细阅读目标网站的使用条款和服务协议，并确保你的行为是合法的。\r\n",
      "reactions": {
        "url": "https://api.github.com/repos/bosens-China/blog/issues/84/reactions",
        "total_count": 0,
        "+1": 0,
        "-1": 0,
        "laugh": 0,
        "hooray": 0,
        "confused": 0,
        "heart": 0,
        "rocket": 0,
        "eyes": 0
      },
      "timeline_url": "https://api.github.com/repos/bosens-China/blog/issues/84/timeline",
      "performed_via_github_app": null,
      "state_reason": null
    },
    {
      "url": "https://api.github.com/repos/bosens-China/blog/issues/100",
      "repository_url": "https://api.github.com/repos/bosens-China/blog",
      "labels_url": "https://api.github.com/repos/bosens-China/blog/issues/100/labels{/name}",
      "comments_url": "https://api.github.com/repos/bosens-China/blog/issues/100/comments",
      "events_url": "https://api.github.com/repos/bosens-China/blog/issues/100/events",
      "html_url": "https://github.com/bosens-China/blog/issues/100",
      "id": 1955954444,
      "node_id": "I_kwDOCzPAy850lX8M",
      "number": 100,
      "title": "resso 源码解析",
      "user": {
        "login": "bosens-China",
        "id": 39508895,
        "node_id": "MDQ6VXNlcjM5NTA4ODk1",
        "avatar_url": "https://avatars.githubusercontent.com/u/39508895?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bosens-China",
        "html_url": "https://github.com/bosens-China",
        "followers_url": "https://api.github.com/users/bosens-China/followers",
        "following_url": "https://api.github.com/users/bosens-China/following{/other_user}",
        "gists_url": "https://api.github.com/users/bosens-China/gists{/gist_id}",
        "starred_url": "https://api.github.com/users/bosens-China/starred{/owner}{/repo}",
        "subscriptions_url": "https://api.github.com/users/bosens-China/subscriptions",
        "organizations_url": "https://api.github.com/users/bosens-China/orgs",
        "repos_url": "https://api.github.com/users/bosens-China/repos",
        "events_url": "https://api.github.com/users/bosens-China/events{/privacy}",
        "received_events_url": "https://api.github.com/users/bosens-China/received_events",
        "type": "User",
        "site_admin": false
      },
      "labels": [
        {
          "id": 1473940161,
          "node_id": "MDU6TGFiZWwxNDczOTQwMTYx",
          "url": "https://api.github.com/repos/bosens-China/blog/labels/%E6%A1%86%E6%9E%B6%E7%9B%B8%E5%85%B3",
          "name": "框架相关",
          "color": "42b883",
          "default": false,
          "description": "目前Vue和React为主"
        }
      ],
      "state": "open",
      "locked": false,
      "assignee": null,
      "assignees": [],
      "milestone": null,
      "comments": 0,
      "created_at": "2023-10-22T15:57:10Z",
      "updated_at": "2023-10-22T15:57:25Z",
      "closed_at": null,
      "author_association": "OWNER",
      "active_lock_reason": null,
      "body": "在之前用 React 写一些小项目的时候有时也需要用到状态管理，但是用 Redux 有一种“大材小用”感觉，就在寻找有没有很精巧的实现，最好是响应式的，最后搜索了一番在 Github 发现了两个满足我需求的库：\r\n\r\n- [valtio](https://github.com/pmndrs/valtio)\r\n- [resso](https://github.com/nanxiaobei/resso)\r\n\r\n```jsx\r\n// valtio\r\nimport resso from 'resso';\r\nimport { proxy, useSnapshot } from 'valtio';\r\n\r\nconst state = proxy({ count: 0, text: 'hello' });\r\n\r\nfunction Counter() {\r\n  const snap = useSnapshot(state);\r\n  return (\r\n    <div>\r\n      {snap.count}\r\n      <button onClick={() => ++state.count}>+1</button>\r\n    </div>\r\n  );\r\n}\r\n// resso\r\nconst store = resso({ count: 0, text: 'hello' });\r\n\r\nfunction App() {\r\n  const { count } = store; // data used in UI → must destructure at top first 🥷\r\n  return (\r\n    <>\r\n      {count}\r\n      <button onClick={() => (store.count += 1)}>+</button>\r\n    </>\r\n  );\r\n}\r\n```\r\n\r\n结合官方给出的文档示例还是最终在项目用了 resso，所以就有了这篇文章，同时作者在知乎也专门写了一篇文章介绍他的思路实现[resso，世界上最简单的 React 状态管理器](https://zhuanlan.zhihu.com/p/468417292)。有兴趣小伙伴可以专门去瞅瞅。\r\n\r\n不过在阅读源码实现，需要先了解两个 API：\r\n\r\n- useSyncExternalStore\r\n- ReactDOM.unstable_batchedUpdates\r\n\r\n## useSyncExternalStore\r\n\r\n这个 API 可能你完全陌生，事实上我也是，后面专门去官方文档查阅了一下 [useSyncExternalStore](https://zh-hans.react.dev/reference/react/useSyncExternalStore)，它的作用可以简单理解为订阅外部的 store，例如我们在使用 redux 之类的时候，它可能不是通过 useState 的形式而是在外部维护了一个 store，然后结合发布订阅模式来实现数据的更新。\r\n\r\n下面用官方给出的切换离线和在线 hooks 例子快速看下这个 api\r\n\r\n```js\r\nimport { useSyncExternalStore } from 'react';\r\n\r\nfunction getSnapshot() {\r\n  return navigator.onLine;\r\n}\r\nfunction subscribe(callback) {\r\n  window.addEventListener('online', callback);\r\n  window.addEventListener('offline', callback);\r\n  return () => {\r\n    window.removeEventListener('online', callback);\r\n    window.removeEventListener('offline', callback);\r\n  };\r\n}\r\n\r\nfunction ChatIndicator() {\r\n  const isOnline = useSyncExternalStore(subscribe, getSnapshot);\r\n  // ...\r\n}\r\n```\r\n\r\n这里每次 online 或者 offline 发生变化执行回调函数，而每次执行 getSnapshot 如果返回值不同，就会让 React 重新渲染组件。\r\n\r\n> 每次对比 getSnapshot 返回值使用的是 Object.is。\r\n\r\n## unstable_batchedUpdates\r\n\r\n之所以介绍这个 API 其实和性能优化有关，在 React18 之前对于非同步代码和不是 react 事件处理函数 setState 不会进行批处理，例如下面代码：\r\n\r\n```js\r\nimport React, { useEffect, useState } from 'react';\r\n\r\nconst App: React.FC = () => {\r\n  console.log('App组件渲染了！');\r\n  const [count1, setCount1] = useState(0);\r\n  const [count2, setCount2] = useState(0);\r\n  useEffect(() => {\r\n    document.body.addEventListener('click', () => {\r\n      setCount1((count) => count + 1);\r\n      setCount2((count) => count + 1);\r\n    });\r\n    // 在原生js事件中不会进行批处理\r\n  }, []);\r\n  return (\r\n    <>\r\n      <div>count1： {count1}</div>\r\n      <div>count2： {count2}</div>\r\n    </>\r\n  );\r\n};\r\n\r\nexport default App;\r\n```\r\n\r\n这里每次点击组件都会渲染两次，共计输出六次 console.log 信息。\r\n\r\n但是有什么办法可以改变呢？下面用 ReactDOM.unstable_batchedUpdates 重写上面这个例子\r\n\r\n```js\r\nimport React, { useEffect, useState } from 'react';\r\n\r\nconst App: React.FC = () => {\r\n  console.log('App组件渲染了！');\r\n  const [count1, setCount1] = useState(0);\r\n  const [count2, setCount2] = useState(0);\r\n  useEffect(() => {\r\n    document.body.addEventListener('click', () => {\r\n      ReactDOM.unstable_batchedUpdates(() => {\r\n        setCount1((count) => count + 1);\r\n        setCount2((count) => count + 1);\r\n      });\r\n    });\r\n  }, []);\r\n  return (\r\n    <>\r\n      <div>count1： {count1}</div>\r\n      <div>count2： {count2}</div>\r\n    </>\r\n  );\r\n};\r\n\r\nexport default App;\r\n```\r\n\r\n这样就会每次更新状态组件只渲染一次了，最后提示一下 **unstable_batchedUpdates 是同步代码**。\r\n\r\n## 实现思想\r\n\r\n在代码阅读之前有必要说下它的设计实现思想是啥子。\r\n\r\n在使用 redux 的时候，我们更新可能是通过 `dispatch` 这样的一个函数来完成，但是有没有其他方式呢？ES6 引入了 proxy 可以对对象的值进行劫持，每次更新都可以获取到对应的 key 和 value。\r\n\r\n> 事实上在 Vue2 中也可以通过监听属性的 seter 来实现监听，虽然效果不完整。\r\n\r\n试着定义一个 store\r\n\r\n```js\r\nexport const store = { a: 123, b: 456 };\r\n```\r\n\r\n在组件中分别使用\r\n\r\n```js\r\n// 组件 A\r\nconst {a} = store;\r\n\r\n// 组件B\r\nconst {a,b} = store;\r\n```\r\n\r\n更新方式也很简单，直接更改 store 属性就行，例如：\r\n\r\n```js\r\n// 组件 A 和 B 都得到更新\r\nstore.b = 'b';\r\n```\r\n\r\n那么要怎么实现上述我们定义的这样一个使用方式呢？\r\n\r\n作者是通过 proxy 每次 get 的时候自动把对应的 key 值保存到 map 键名，而对应的 setState 作为 value，例如在组件 A 和 B 它们可能是这样储存的。\r\n\r\n```js\r\n// 组件 A\r\nconst [a, setA] = useState(store.a);\r\n// 组件 B\r\nconst [a, setA] = useState(store.a);\r\nconst [b, setB] = useState(store.b);\r\n// map\r\nconst listenerMap = {\r\n  a: [setA, setA],\r\n  b: [setB],\r\n};\r\n\r\n```\r\n\r\n之后监听修改的属性，如果有更新直接调用对应 key 下的 setState 就可以做到更新。\r\n``` js\r\n// 假设更新 A\r\nlistenerMap.a.forEach((setA) => setA(store.a));\r\n```\r\n\r\n## 源码分析\r\n\r\n作者是通过 TypeScript 来实现的，但是这里关注具体的实现，对于类型直接删除了，如果有需要小伙伴可以自行去阅读。\r\n\r\n因为代码量不是很大，所以这里直接通过贴代码+注释的形式来进行讲解。\r\n\r\n```js\r\n// 这里因为是状态库，需要考虑不同的 React 版本，React18 可以直接 import React 来获取 useSyncExternalStore\r\nimport { useSyncExternalStore } from 'use-sync-external-store/shim';\r\n\r\n// 判断是否为开发环境\r\nconst __DEV__ = process.env.NODE_ENV !== 'production';\r\n\r\n// 判断是否为对象， {} 这样的，通用的 map、set 之类的对象都统统不可以\r\nconst isObj = (val) => {\r\n  return Object.prototype.toString.call(val) === '[object Object]';\r\n};\r\n\r\n// 这里是一个标识符后面讲解\r\nlet isGetStateInMethod = false;\r\n\r\nlet run = (fn) => {\r\n  fn();\r\n};\r\n\r\nconst resso = (obj) => {\r\n  // 初始检查\r\n  if (__DEV__ && !isObj(obj)) {\r\n    throw new Error('object required');\r\n  }\r\n\r\n  /*\r\n   * 它储存的形式为 {[key:string]: Set()}\r\n   */\r\n  const state = {};\r\n  /*\r\n   * 它储存的形式为 {key: Function}\r\n   */\r\n  const methods = {};\r\n\r\n  Object.keys(obj).forEach((key) => {\r\n    const initVal = obj[key];\r\n    // 给 methods 添加属性\r\n    if (initVal instanceof Function) {\r\n      methods[key] = (...args) => {\r\n        isGetStateInMethod = true;\r\n        const res = initVal(...args);\r\n        isGetStateInMethod = false;\r\n        return res;\r\n      };\r\n      return;\r\n    }\r\n    // 给 state 添加属性\r\n    const listeners = new Set();\r\n\r\n    state[key] = {\r\n      // 添加 getSnapshot 到 listeners\r\n      subscribe: (listener) => {\r\n        listeners.add(listener);\r\n        return () => listeners.delete(listener);\r\n      },\r\n      // 数据快照\r\n      getSnapshot: () => obj[key],\r\n      // 更新方法\r\n      setSnapshot: (val) => {\r\n        if (val !== obj[key]) {\r\n          obj[key] = val;\r\n          run(() => listeners.forEach((listener) => listener()));\r\n        }\r\n      },\r\n      useSnapshot: () => {\r\n        return useSyncExternalStore(\r\n          state[key].subscribe,\r\n          state[key].getSnapshot,\r\n          state[key].getSnapshot\r\n        );\r\n      },\r\n    };\r\n  });\r\n\r\n  const setState = (key, val) => {\r\n    // 只更新初始 obj 定义属性\r\n    if (key in obj) {\r\n      if (key in state) {\r\n        // 判断是属性更新还是函数调用更新\r\n        const newVal = val instanceof Function ? val(obj[key]) : val;\r\n        // 调用上文的 setSnapshot\r\n        state[key].setSnapshot(newVal);\r\n      } else if (__DEV__) {\r\n        throw new Error(`\\`${key}\\` is a method, can not update`);\r\n      }\r\n    } else if (__DEV__) {\r\n      throw new Error(`\\`${key}\\` is not initialized in store`);\r\n    }\r\n  };\r\n\r\n  return new Proxy(() => undefined, {\r\n    get: (_target, key) => {\r\n      if (key in methods) {\r\n        return methods[key];\r\n      }\r\n      // 重点讲下这段代码，首先判断是否为 state，也就是上文中初始传递的对象非函数部分\r\n      if (key in state) {\r\n        // 这里判断是否 isGetStateInMethod 主要是因为可能存在在 methods 中来引用 store 中的属性，所以如果是这种情况直接返回\r\n        if (isGetStateInMethod) {\r\n          return obj[key];\r\n        }\r\n        // 这里从外部拿到对应的值返回，如果不是在最外层使用（React 限制，不可以在回调之类的函数内使用use之类方法，这里直接返回 obj 下的值）\r\n        try {\r\n          return state[key].useSnapshot();\r\n        } catch (err) {\r\n          return obj[key];\r\n        }\r\n      }\r\n      if (__DEV__) {\r\n        if (key !== 'prototype' && key !== 'name' && key !== 'displayName') {\r\n          throw new Error(`\\`${key}\\` is not initialized in store`);\r\n        }\r\n      }\r\n    },\r\n    // 这里监听属性变动，例如这种形式调用更新 store.count = 60;\r\n    set: (_target, key, val) => {\r\n      setState(key, val);\r\n      return true;\r\n    },\r\n\r\n    /* \r\n    * apple是指函数调用，官方文档是支持下面这种形式来更新的\r\n    * store({ count: 60, text: 'world' });\r\n    * 参数分别是目标对象、目标对象的上下文对象（this）和目标对象的参数数组\r\n    * 这里之所以解构成 [firstArg, oneAction] 形式是因为，除了上面这种方式还可以\r\n      store('count', (prev) => prev + 1); \r\n      store((prev) => ({\r\n        count: prev.count + 1,\r\n        text: prev.text === 'hello' ? 'world' : 'hello',\r\n      }));\r\n    */\r\n    apply: (_target, _thisArg, [firstArg, oneAction]) => {\r\n      // store('count', (prev) => prev + 1);\r\n      if (typeof firstArg === 'string') {\r\n        setState(firstArg, oneAction);\r\n        return;\r\n      }\r\n      // store({ count: 60, text: 'world' });\r\n      if (isObj(firstArg)) {\r\n        const newObj = firstArg;\r\n        Object.keys(newObj).forEach((key) => {\r\n          setState(key, newObj[key]);\r\n        });\r\n        return;\r\n      }\r\n      //  store((prev) => ({\r\n      //   count: prev.count + 1,\r\n      //   text: prev.text === 'hello' ? 'world' : 'hello',\r\n      // }));\r\n      if (typeof firstArg === 'function') {\r\n        const newObj = firstArg(obj);\r\n        Object.keys(newObj).forEach((key) => {\r\n          setState(key, newObj[key]);\r\n        });\r\n      }\r\n    },\r\n  });\r\n};\r\n\r\n// 这里是给用户暴露配置，例如上面说的，你想要在异步代码中执行批量更新 unstable_batchedupdates\r\nresso.config = ({ batch }) => {\r\n  run = batch;\r\n};\r\n\r\nexport default resso;\r\n```\r\n\r\n## 最后\r\n\r\n这是一篇很早之前就想写的文章，一直拖到现在才完成，最后如果有理解错误或者文笔错误欢迎指出，同时有可以内推的岗位欢迎滴滴。\r\n\r\n文章参考：\r\n\r\n- [React 性能优化之 unstable_batchedupdates（batch）用法详解](https://juejin.cn/post/6860308689313693709)\r\n- [React18 新特性解读 & 完整版升级指南](https://juejin.cn/post/7094037148088664078)\r\n",
      "reactions": {
        "url": "https://api.github.com/repos/bosens-China/blog/issues/100/reactions",
        "total_count": 0,
        "+1": 0,
        "-1": 0,
        "laugh": 0,
        "hooray": 0,
        "confused": 0,
        "heart": 0,
        "rocket": 0,
        "eyes": 0
      },
      "timeline_url": "https://api.github.com/repos/bosens-China/blog/issues/100/timeline",
      "performed_via_github_app": null,
      "state_reason": null
    },
    {
      "url": "https://api.github.com/repos/bosens-China/blog/issues/99",
      "repository_url": "https://api.github.com/repos/bosens-China/blog",
      "labels_url": "https://api.github.com/repos/bosens-China/blog/issues/99/labels{/name}",
      "comments_url": "https://api.github.com/repos/bosens-China/blog/issues/99/comments",
      "events_url": "https://api.github.com/repos/bosens-China/blog/issues/99/events",
      "html_url": "https://github.com/bosens-China/blog/issues/99",
      "id": 1951726236,
      "node_id": "I_kwDOCzPAy850VPqc",
      "number": 99,
      "title": "koa洋葱结构解析",
      "user": {
        "login": "bosens-China",
        "id": 39508895,
        "node_id": "MDQ6VXNlcjM5NTA4ODk1",
        "avatar_url": "https://avatars.githubusercontent.com/u/39508895?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bosens-China",
        "html_url": "https://github.com/bosens-China",
        "followers_url": "https://api.github.com/users/bosens-China/followers",
        "following_url": "https://api.github.com/users/bosens-China/following{/other_user}",
        "gists_url": "https://api.github.com/users/bosens-China/gists{/gist_id}",
        "starred_url": "https://api.github.com/users/bosens-China/starred{/owner}{/repo}",
        "subscriptions_url": "https://api.github.com/users/bosens-China/subscriptions",
        "organizations_url": "https://api.github.com/users/bosens-China/orgs",
        "repos_url": "https://api.github.com/users/bosens-China/repos",
        "events_url": "https://api.github.com/users/bosens-China/events{/privacy}",
        "received_events_url": "https://api.github.com/users/bosens-China/received_events",
        "type": "User",
        "site_admin": false
      },
      "labels": [
        {
          "id": 3661377607,
          "node_id": "LA_kwDOCzPAy87aPDBH",
          "url": "https://api.github.com/repos/bosens-China/blog/labels/Node%E7%B3%BB%E5%88%97",
          "name": "Node系列",
          "color": "9F9262",
          "default": false,
          "description": "和node.js相关内容"
        }
      ],
      "state": "open",
      "locked": false,
      "assignee": null,
      "assignees": [],
      "milestone": null,
      "comments": 0,
      "created_at": "2023-10-19T09:33:07Z",
      "updated_at": "2023-10-19T09:33:17Z",
      "closed_at": null,
      "author_association": "OWNER",
      "active_lock_reason": null,
      "body": "![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/dbf97f99bdf142bbb9c18449b82700e3~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1149&h=1000&s=159098&e=png&b=fefefe)\r\n\r\n经常在使用 koa 的时候，通过 `.use` 的形式来注册各种中间件，例如下面一段代码\r\n\r\n```js\r\napp.use(async (ctx, next) => {\r\n  console.log(1);\r\n  await next();\r\n  console.log(2);\r\n});\r\napp.use(async (ctx, next) => {\r\n  console.log(3);\r\n  await next();\r\n  console.log(4);\r\n});\r\n```\r\n\r\n这里会输出 1,3,4,2，下面就来翻看一下源码看看这个中间件实现的具体原理。\r\n\r\n在看具体代码之前，先温习一下，使用 koa 的最小运行代码是什么样的\r\n\r\n```js\r\nconst Koa = require(\"koa\");\r\nconst app = new Koa();\r\n\r\n// response\r\napp.use((ctx) => {\r\n  ctx.body = \"Hello Koa\";\r\n});\r\n\r\napp.listen(3000);\r\n```\r\n\r\n可以看到，最后通过 listen 方法来启动服务，那我们重点先看下 use 和 listen 做了什么事情。\r\n\r\n## [use](https://github.com/koajs/koa/blob/master/lib/application.js#L140C1-L145C4)\r\n\r\n```js\r\n  use (fn) {\r\n    if (typeof fn !== 'function') throw new TypeError('middleware must be a function!')\r\n    debug('use %s', fn._name || fn.name || '-')\r\n    this.middleware.push(fn)\r\n    return this\r\n  }\r\n```\r\n\r\n代码比较少，这里直接贴上去了，use 的主要作用就是给 middleware 添加相对应的 fn。\r\n\r\n## [listen](https://github.com/koajs/koa/blob/master/lib/application.js#L97)\r\n\r\n```js\r\n  listen (...args) {\r\n    debug('listen')\r\n    const server = http.createServer(this.callback())\r\n    return server.listen(...args)\r\n  }\r\n```\r\n\r\n这里 server 是 http 的库的方法，我们先不管，主要看一下 this.callback 做了什么事情。\r\n\r\n```js\r\n  callback () {\r\n    const fn = this.compose(this.middleware)\r\n\r\n    if (!this.listenerCount('error')) this.on('error', this.onerror)\r\n\r\n    const handleRequest = (req, res) => {\r\n      const ctx = this.createContext(req, res)\r\n      if (!this.ctxStorage) {\r\n        return this.handleRequest(ctx, fn)\r\n      }\r\n      return this.ctxStorage.run(ctx, async () => {\r\n        return await this.handleRequest(ctx, fn)\r\n      })\r\n    }\r\n\r\n    return handleRequest\r\n  }\r\n```\r\n\r\nhandleRequest 这个函数的实现如下\r\n\r\n```js\r\n  handleRequest (ctx, fnMiddleware) {\r\n    const res = ctx.res\r\n    res.statusCode = 404\r\n    const onerror = err => ctx.onerror(err)\r\n    const handleResponse = () => respond(ctx)\r\n    onFinished(res, onerror)\r\n    return fnMiddleware(ctx).then(handleResponse).catch(onerror)\r\n  }\r\n\r\n```\r\n\r\n可以看到，最终是把 this.compose 返回的 fn 进行了调用，那么由此可以知道 this.compose 就是具体中间件调度的具体实现。\r\n\r\n## compose\r\n\r\nthis.compose 可以在 constructor 中看到，默认情况下就是 [koa-compose](https://github.com/koajs/compose)，这个库也非常精简只有 50 行代码，下面会通过注释的形式来对源码进行一个说明。\r\n\r\n```js\r\n// 省略部分注释和部分代码\r\n\r\nfunction compose(middleware) {\r\n  // 判断传递是否为数组，且每个数组都必须为函数，否则抛出异常\r\n  if (!Array.isArray(middleware))\r\n    throw new TypeError(\"Middleware stack must be an array!\");\r\n  for (const fn of middleware) {\r\n    if (typeof fn !== \"function\")\r\n      throw new TypeError(\"Middleware must be composed of functions!\");\r\n  }\r\n  // 这里默认返回一个函数，handleRequest函数会调用这个返回的函数，并且传递 context\r\n  return function (context, next) {\r\n    let index = -1;\r\n    // 默认情况下执行一次 dispatch ，dispatch因为是函数声明所以会提升到做作用域顶部\r\n    return dispatch(0);\r\n    function dispatch(i) {\r\n      // 通常情况下不会遇到，但是如果执行两次就会抛出异常，例如第一次调用index为-1，i为0，第二次执行则变成index为0，i也为0则抛出错误\r\n      if (i <= index)\r\n        return Promise.reject(new Error(\"next() called multiple times\"));\r\n      index = i;\r\n      let fn = middleware[i];\r\n      // 这里从koa的实现可以看到，是没有传递next的，所以这行代码可以跳过\r\n      if (i === middleware.length) fn = next;\r\n      // 执行到最后一项的时候直接返回不再继续递归下去\r\n      if (!fn) return Promise.resolve();\r\n      try {\r\n        // 这里实现很巧妙，利用了bind的原理，bind的第一个参数为this，之后的参数为函数的预设值，最后返回一个函数\r\n        // 然后根据Promise.resolve的实现规范，如果传递的Promise.resolve是一个Promise要等待新的Promise执行完成之后决定状态\r\n        // 这里推荐看下PromiseA+规范实现\r\n        return Promise.resolve(fn(context, dispatch.bind(null, i + 1)));\r\n      } catch (err) {\r\n        return Promise.reject(err);\r\n      }\r\n    }\r\n  };\r\n}\r\n```\r\n\r\nok，这里基本上就讲完了，还是对照最初的示例来看\r\n\r\n```js\r\napp.use(async (ctx, next) => {\r\n  console.log(1);\r\n  await next();\r\n  console.log(2);\r\n});\r\napp.use(async (ctx, next) => {\r\n  console.log(3);\r\n  await next();\r\n  console.log(4);\r\n});\r\n```\r\n\r\n这里传递给 compose([fn1, fn2])，之后 i 为 0，返回\r\n\r\n```js\r\nconst fn = async (ctx, next) => {\r\n  console.log(1);\r\n  await next();\r\n  console.log(2);\r\n};\r\nreturn Promise.resolve(fn(context, dispatch.bind(null, i + 1)));\r\n```\r\n\r\n之后 i 为 1 的时候\r\n\r\n```js\r\nconst fn = async (ctx, next) => {\r\n  console.log(3);\r\n  await next();\r\n  console.log(4);\r\n};\r\nreturn Promise.resolve(fn(context, dispatch.bind(null, i + 1)));\r\n```\r\n\r\n此时 i 为 2，发现数组取不到值了，执行\r\n\r\n```js\r\nif (!fn) return Promise.resolve();\r\n```\r\n\r\n回到最最后一步，还没有解释为什么会洋葱结构这样来执行代码\r\n\r\n```js\r\napp.use(async (ctx, next) => {\r\n  console.log(1);\r\n  await next();\r\n  console.log(2);\r\n});\r\napp.use(async (ctx, next) => {\r\n  console.log(3);\r\n  await next();\r\n  console.log(4);\r\n});\r\n```\r\n\r\n这里我们知道先执行第一个函数\r\n\r\n1. 输出 console.log(1);\r\n2. 执行的过程中遇到 `await next()` 会执行 next，而从源码 `dispatch.bind(null, i + 1)` 可以知道下一项就是第二个函数\r\n3. 执行第二个函数\r\n4. 输出 console.log(3)\r\n5. 继续执行 `await next()` 从源码知道 i 为 2 的时候，返回的是 `if (!fn) return Promise.resolve();`\r\n6. 执行 conosle.log(4)，返回 Promise 状态为已完成，结果为 undefined\r\n7. 执行 console.log(2)\r\n\r\n上面可能有点绕，但是其实 koa-compose 利用了事件循环的机制，对于微任务每次执行都会放到微任务队列，等待主线程执行栈调用，而栈的特点就是先进后出，所以这也是为什么会输出 1,3,4,2 的原因了。\r\n\r\n## 最后\r\n\r\n如果文章有说的不对地方欢迎指出，最后本人正在找工作，有相关 hc 岗位欢迎滴滴。\r\n",
      "reactions": {
        "url": "https://api.github.com/repos/bosens-China/blog/issues/99/reactions",
        "total_count": 0,
        "+1": 0,
        "-1": 0,
        "laugh": 0,
        "hooray": 0,
        "confused": 0,
        "heart": 0,
        "rocket": 0,
        "eyes": 0
      },
      "timeline_url": "https://api.github.com/repos/bosens-China/blog/issues/99/timeline",
      "performed_via_github_app": null,
      "state_reason": null
    },
    {
      "url": "https://api.github.com/repos/bosens-China/blog/issues/98",
      "repository_url": "https://api.github.com/repos/bosens-China/blog",
      "labels_url": "https://api.github.com/repos/bosens-China/blog/issues/98/labels{/name}",
      "comments_url": "https://api.github.com/repos/bosens-China/blog/issues/98/comments",
      "events_url": "https://api.github.com/repos/bosens-China/blog/issues/98/events",
      "html_url": "https://github.com/bosens-China/blog/issues/98",
      "id": 1849714138,
      "node_id": "I_kwDOCzPAy85uQGXa",
      "number": 98,
      "title": "[javaScript]ES2023 引入非破坏性方法",
      "user": {
        "login": "bosens-China",
        "id": 39508895,
        "node_id": "MDQ6VXNlcjM5NTA4ODk1",
        "avatar_url": "https://avatars.githubusercontent.com/u/39508895?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bosens-China",
        "html_url": "https://github.com/bosens-China",
        "followers_url": "https://api.github.com/users/bosens-China/followers",
        "following_url": "https://api.github.com/users/bosens-China/following{/other_user}",
        "gists_url": "https://api.github.com/users/bosens-China/gists{/gist_id}",
        "starred_url": "https://api.github.com/users/bosens-China/starred{/owner}{/repo}",
        "subscriptions_url": "https://api.github.com/users/bosens-China/subscriptions",
        "organizations_url": "https://api.github.com/users/bosens-China/orgs",
        "repos_url": "https://api.github.com/users/bosens-China/repos",
        "events_url": "https://api.github.com/users/bosens-China/events{/privacy}",
        "received_events_url": "https://api.github.com/users/bosens-China/received_events",
        "type": "User",
        "site_admin": false
      },
      "labels": [
        {
          "id": 1908144759,
          "node_id": "MDU6TGFiZWwxOTA4MTQ0NzU5",
          "url": "https://api.github.com/repos/bosens-China/blog/labels/ES6%E7%B3%BB%E5%88%97",
          "name": "ES6系列",
          "color": "0366d6",
          "default": false,
          "description": "ES6的最新语法"
        }
      ],
      "state": "open",
      "locked": false,
      "assignee": null,
      "assignees": [],
      "milestone": null,
      "comments": 0,
      "created_at": "2023-08-14T12:49:24Z",
      "updated_at": "2023-08-14T12:51:32Z",
      "closed_at": null,
      "author_association": "OWNER",
      "active_lock_reason": null,
      "body": "对于 Array 的一些操作，例如 reverse、sort 等都会改变原数组，ES2023 对以下这些方法进行了拓展，提供了相同功能但是返回新副本的方法。\r\n\r\n- toReversed\r\n- toSorted\r\n- toSpliced\r\n- with\r\n\r\n下面进行一个详细的介绍。\r\n\r\n## toReversed\r\n\r\n- reverse：反转数组元素，但是会改变数组本身\r\n- toReversed：跟 reverse 功能相同，但是返回新副本不会改变数组本身\r\n\r\n示例 1.js\r\n\r\n```\r\n// reverse\r\nconst a = [1, 2, 3];\r\nconst b = a.reverse();\r\n\r\nconsole.log(a); // [3, 2, 1]\r\nconsole.log(b); // [3, 2, 1]\r\n\r\n// toReversed 👍\r\nconst c = [1, 2, 3];\r\nconst d = c.toReversed();\r\n\r\nconsole.log(c); // [1, 2, 3]\r\nconsole.log(d); // [3, 2, 1]\r\n```\r\n\r\n## toSorted\r\n\r\n- sort：对数组进行排序，但是会改变数组本身\r\n- toSorted：跟 sort 方法一样，但是返回新副本\r\n\r\n示例 2.js\r\n\r\n```\r\n// sort\r\nconst a = [3, 1, 2];\r\nconst b = a.sort();\r\n\r\nconsole.log(a); // [1, 2, 3]\r\nconsole.log(b); // [1, 2, 3]\r\n\r\n// toSorted 👍\r\nconst c = [3, 1, 2];\r\nconst d = c.toSorted();\r\n\r\nconsole.log(c); // [3, 1, 2]\r\nconsole.log(d); // [1, 2, 3]\r\n```\r\n\r\n## toSpliced\r\n\r\n- splice：非常万能的方法可以对数组进行删除、替换数元素以及添加新元素\r\n- toSpliced：跟 splice 一样，但是操作不会对原数组进行改变\r\n\r\n不过，由于 splice 和 toSpliced 的返回值存在以下差异，因此处理它们时似乎需要小心。\r\n\r\n- splice 的返回值被删除值的数组\r\n- toSpliced 的返回值返回从数组中删除元素的副本\r\n\r\n示例 3.js\r\n\r\n```\r\n// splice\r\nconst a = [1, 2, 3, 4];\r\nconst b = a.splice(1,2);\r\n\r\nconsole.log(a); // [1,4]\r\nconsole.log(b); // [2,3]　返回值是删除的值排列的值\r\n\r\n// toSpliced 👍\r\nconst c = [1, 2, 3, 4];\r\nconst d = c.toSpliced(1,2);\r\n\r\nconsole.log(c); // [1,2,3,4]\r\nconsole.log(d); // [1,4]　返回从数组中删除元素的副本\r\n```\r\n\r\n## with\r\n\r\n在第一个参数中指定数组的索引号，并将该元素替换为第二个参数的值。\r\n\r\nJS 已经有一个单独的 [with](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/with)\r\n语句，但它已被弃用，所以它很混乱，因为它与这次添加的数组操作的 with 方法重叠。\r\n\r\n示例 4.js\r\n\r\n```\r\n// with 👍\r\nconst c = [1, 2, 3, 4];\r\nconst d = c.with(1,'👍');\r\n\r\nconsole.log(c); // [1, 2, 3, 4]\r\nconsole.log(d); // [1, '👍', 3, 4]\r\n```\r\n\r\n## 最后\r\n\r\n这些方法的出现，使得你不需要每次都浅复制，代码看起来很清爽。\r\n",
      "reactions": {
        "url": "https://api.github.com/repos/bosens-China/blog/issues/98/reactions",
        "total_count": 0,
        "+1": 0,
        "-1": 0,
        "laugh": 0,
        "hooray": 0,
        "confused": 0,
        "heart": 0,
        "rocket": 0,
        "eyes": 0
      },
      "timeline_url": "https://api.github.com/repos/bosens-China/blog/issues/98/timeline",
      "performed_via_github_app": null,
      "state_reason": null
    },
    {
      "url": "https://api.github.com/repos/bosens-China/blog/issues/97",
      "repository_url": "https://api.github.com/repos/bosens-China/blog",
      "labels_url": "https://api.github.com/repos/bosens-China/blog/issues/97/labels{/name}",
      "comments_url": "https://api.github.com/repos/bosens-China/blog/issues/97/comments",
      "events_url": "https://api.github.com/repos/bosens-China/blog/issues/97/events",
      "html_url": "https://github.com/bosens-China/blog/issues/97",
      "id": 1745358720,
      "node_id": "I_kwDOCzPAy85oCA-A",
      "number": 97,
      "title": "使用jsx来编写模板",
      "user": {
        "login": "bosens-China",
        "id": 39508895,
        "node_id": "MDQ6VXNlcjM5NTA4ODk1",
        "avatar_url": "https://avatars.githubusercontent.com/u/39508895?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bosens-China",
        "html_url": "https://github.com/bosens-China",
        "followers_url": "https://api.github.com/users/bosens-China/followers",
        "following_url": "https://api.github.com/users/bosens-China/following{/other_user}",
        "gists_url": "https://api.github.com/users/bosens-China/gists{/gist_id}",
        "starred_url": "https://api.github.com/users/bosens-China/starred{/owner}{/repo}",
        "subscriptions_url": "https://api.github.com/users/bosens-China/subscriptions",
        "organizations_url": "https://api.github.com/users/bosens-China/orgs",
        "repos_url": "https://api.github.com/users/bosens-China/repos",
        "events_url": "https://api.github.com/users/bosens-China/events{/privacy}",
        "received_events_url": "https://api.github.com/users/bosens-China/received_events",
        "type": "User",
        "site_admin": false
      },
      "labels": [
        {
          "id": 1371686608,
          "node_id": "MDU6TGFiZWwxMzcxNjg2NjA4",
          "url": "https://api.github.com/repos/bosens-China/blog/labels/%E6%BC%AB%E8%B0%88%E7%B3%BB%E5%88%97",
          "name": "漫谈系列",
          "color": "e7f3ee",
          "default": false,
          "description": "浅谈类文章"
        }
      ],
      "state": "open",
      "locked": false,
      "assignee": null,
      "assignees": [],
      "milestone": null,
      "comments": 0,
      "created_at": "2023-06-07T08:36:19Z",
      "updated_at": "2023-06-07T08:36:19Z",
      "closed_at": null,
      "author_association": "OWNER",
      "active_lock_reason": null,
      "body": "## 前言\r\n\r\n模板引擎这个应该都不陌生，最早可以追溯到前后端还没分离的时候，后端为了循环、判断值之类简化编写流程而使用的，毕竟手动拼接字符串之类的也太麻烦了。\r\n\r\n下面是 php [easytpl](https://github.com/phppkg/easytpl) 的一个示例，从这个可以看到模板引擎的基本用途。\r\n\r\n```php\r\nuse PhpPkg\\EasyTpl\\EasyTemplate;\r\n\r\n$tplCode = <<<'CODE'\r\nMy name is {{ $name | strtoupper }},\r\nMy develop tags:\r\n\r\n{{ foreach($tags as $tag) }}\r\n- {{ $tag }}\r\n\r\n{{ endforeach }}\r\nCODE;\r\n\r\n$t = new EasyTemplate();\r\n\r\n$str = $t->renderString($tplCode, [\r\n    'name' => 'inhere',\r\n    'tags' => ['php', 'go', 'java'],\r\n]);\r\n\r\necho $str;\r\n```\r\n\r\n上面这对代码会输出\r\n\r\n```md\r\nMy name is INHERE,\r\nMy develop tags:\r\n\r\n- php\r\n- go\r\n- java\r\n```\r\n\r\n回到 JavaScript，随着职能的不断提升前端也面临同样的问题，于是社区涌现了一堆库，例如：\r\n\r\n- [ejs](https://ejs.co/)\r\n- [nunjucks](http://mozilla.github.io/nunjucks/templating.html)\r\n- [pug](https://pugjs.org/api/getting-started.html)\r\n- ...\r\n\r\n上面的几个使用方法都大同小异，都是通过内置一些语法来简化重复的书写。不过思考一下使用模板引擎会有什么缺点？\r\n\r\n下面是一段 ejs 代码示例\r\n\r\n```html\r\n<% if (resultPreSale.length) { %>\r\n<h2>本次新增入网楼栋：<%= resultPreSale.length %>个</h2>\r\n<ul>\r\n  <% resultPreSale.forEach(function(item){ %>\r\n  <li>\r\n    <p>\r\n      <a href=\"<%= item.url %>\"> 项目名称：<%= item.entryName %> </a>\r\n    </p>\r\n    <p>楼幢号：<%= item.buildingNumber %></p>\r\n    <p>许可面积(㎡)：<%= item.permittedArea %></p>\r\n    <p>发放日期：<%= item.time %></p>\r\n  </li>\r\n  <% }); %>\r\n</ul>\r\n<% } %>\r\n```\r\n\r\n从上面的示例可以看到以下缺点：\r\n\r\n1. 缺少语法提示：在使用编辑器的时候使用相对应语法都会有提示，但是上面在使用 `forEach` 之类的根本不会有提示；\r\n2. 不能借助 Eslint、TypeScript 来提前检查编写错误：例如有一些 props 没有传递或者类型缺少，以及变量不存在而引用等错误，必须运行之后才会发现错误；\r\n3. 有额外的学习成本，每个模板引擎的语法其实都不一样，例如 ejs 和 pug 就不一致；\r\n\r\n## jsx\r\n\r\n回归到最熟悉的 jsx 本身，得益于 React 的流行 jsx 这种灵活方便的语法就是首选，首先生态很丰富可以跟 TypeScript 和 eslint 无缝衔接，且语法跟 js 基本一致不会增加额外的学习成本，且跟编辑器配合很好可以有语法提示。\r\n\r\n下面是一段示例\r\n\r\n```jsx\r\nconst App = (props: Props) => {\r\n  return (\r\n    <>\r\n      <PreSale resultPreSale={props.resultPreSale}></PreSale>\r\n      <List resultList={props.resultList}></List>\r\n      <List resultList={props.residueList} title={<h2>其他正在摇号项目（{props.residueList.length}个）：</h2>}></List>\r\n      <p>本次爬取时间：{props.currentTime}</p>\r\n      <style>{style}</style>\r\n    </>\r\n  );\r\n};\r\n```\r\n\r\njsx 基础的语法和如何解析这里并不关心，说回主题如何使用 jsx 来编写模板呢？\r\n\r\n### 解析 jsx\r\n\r\n模板返回的都是字符串的形式，但是上面示例的 App 明显是一个函数，所以首先需要把 jsx 转换为字符串，幸运的是社区有相关的库，这里使用的是 [preact-render-to-string](https://github.com/preactjs/preact-render-to-string)，[preact](https://preactjs.com/)是一个跟 React 实现很接近的库，你可以理解为 mini React。\r\n\r\n> 这里其实并不会使用 hooks 之类的功能，使用的只是 jsx 语法本身，所以选用什么框架并不关键。\r\n\r\n```jsx\r\nimport { render } from 'preact-render-to-string';\r\nconst html = render(<App {...props}></App>);\r\n```\r\n\r\n如果结合 TypeScript 使用，还需要做一些额外的配置\r\n\r\n- 安装 preact\r\n\r\n- 修改 tsconfig.json\r\n\r\n```json\r\n{\r\n  \"compilerOptions\": {\r\n    \"jsx\": \"react-jsx\",\r\n    \"jsxImportSource\": \"preact\"\r\n  }\r\n}\r\n```\r\n\r\n### node 环境使用\r\n\r\n这里并没有万事大吉，在 node 环境使用模板引擎也是一个很正常的事情，但是 tsx 或者 jsx 文件都是属于需要编译来进行处理的，否则 node 并不认识。\r\n\r\n1. [tsx](https://github.com/esbuild-kit/tsx)，使用 tsx 这个库，它通过 esbuild 来运行 TypeScript 和 ESM 文件；\r\n2. webpack\r\n\r\n下面是一个完整的 webpack 示例\r\n\r\n```js\r\nconst path = require('path');\r\nconst nodeExternals = require('webpack-node-externals');\r\nconst RunNodeWebpackPlugin = require('run-node-webpack-plugin');\r\n\r\nmodule.exports = {\r\n  entry: {\r\n    index: './src/index.ts',\r\n  },\r\n  target: 'node',\r\n  devtool: 'source-map',\r\n  externalsPresets: { node: true },\r\n  output: {\r\n    path: path.resolve(__dirname, 'dist'),\r\n    filename: '[name].cjs',\r\n    clean: true,\r\n  },\r\n  resolve: {\r\n    extensions: ['.js', '.jsx', '.ts', '.tsx'],\r\n  },\r\n  module: {\r\n    rules: [\r\n      {\r\n        test: /\\.(js|jsx|ts|tsx)$/,\r\n        exclude: /node_modules/,\r\n        use: [\r\n          {\r\n            loader: 'esbuild-loader',\r\n            options: {\r\n              target: 'es2022',\r\n            },\r\n          },\r\n        ],\r\n      },\r\n    ],\r\n  },\r\n};\r\n```\r\n\r\n## 最后\r\n\r\n如果文章有错误欢迎留言指出。\r\n",
      "reactions": {
        "url": "https://api.github.com/repos/bosens-China/blog/issues/97/reactions",
        "total_count": 0,
        "+1": 0,
        "-1": 0,
        "laugh": 0,
        "hooray": 0,
        "confused": 0,
        "heart": 0,
        "rocket": 0,
        "eyes": 0
      },
      "timeline_url": "https://api.github.com/repos/bosens-China/blog/issues/97/timeline",
      "performed_via_github_app": null,
      "state_reason": null
    },
    {
      "url": "https://api.github.com/repos/bosens-China/blog/issues/96",
      "repository_url": "https://api.github.com/repos/bosens-China/blog",
      "labels_url": "https://api.github.com/repos/bosens-China/blog/issues/96/labels{/name}",
      "comments_url": "https://api.github.com/repos/bosens-China/blog/issues/96/comments",
      "events_url": "https://api.github.com/repos/bosens-China/blog/issues/96/events",
      "html_url": "https://github.com/bosens-China/blog/issues/96",
      "id": 1672296843,
      "node_id": "I_kwDOCzPAy85jrTmL",
      "number": 96,
      "title": "hook下如何书写发布订阅",
      "user": {
        "login": "bosens-China",
        "id": 39508895,
        "node_id": "MDQ6VXNlcjM5NTA4ODk1",
        "avatar_url": "https://avatars.githubusercontent.com/u/39508895?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bosens-China",
        "html_url": "https://github.com/bosens-China",
        "followers_url": "https://api.github.com/users/bosens-China/followers",
        "following_url": "https://api.github.com/users/bosens-China/following{/other_user}",
        "gists_url": "https://api.github.com/users/bosens-China/gists{/gist_id}",
        "starred_url": "https://api.github.com/users/bosens-China/starred{/owner}{/repo}",
        "subscriptions_url": "https://api.github.com/users/bosens-China/subscriptions",
        "organizations_url": "https://api.github.com/users/bosens-China/orgs",
        "repos_url": "https://api.github.com/users/bosens-China/repos",
        "events_url": "https://api.github.com/users/bosens-China/events{/privacy}",
        "received_events_url": "https://api.github.com/users/bosens-China/received_events",
        "type": "User",
        "site_admin": false
      },
      "labels": [
        {
          "id": 1473940161,
          "node_id": "MDU6TGFiZWwxNDczOTQwMTYx",
          "url": "https://api.github.com/repos/bosens-China/blog/labels/%E6%A1%86%E6%9E%B6%E7%9B%B8%E5%85%B3",
          "name": "框架相关",
          "color": "42b883",
          "default": false,
          "description": "目前Vue和React为主"
        }
      ],
      "state": "open",
      "locked": false,
      "assignee": null,
      "assignees": [],
      "milestone": null,
      "comments": 1,
      "created_at": "2023-04-18T03:43:26Z",
      "updated_at": "2023-06-01T08:44:54Z",
      "closed_at": null,
      "author_association": "OWNER",
      "active_lock_reason": null,
      "body": "这篇文章的思路来源为 [ahooks](https://github.com/alibaba/hooks/blob/master/packages/hooks/src/useEventEmitter/index.ts)，因为 react 已经有相对应的实现了，所以这里主要介绍 vue 下如何实现一个 hook 的发布订阅。\r\n\r\n假设有一个需求，当价格发生改变的时候刷新列表，在 vue 中很自然而然想到调用 watch 观察，但是这样的调用还是有点繁琐。例如下面一段伪代码\r\n\r\n```js\r\nimport { ref, watch } from 'vue';\r\n\r\nconst isChange = ref(false);\r\nconst refreshList = () => {\r\n  // 省略\r\n  isChange.value = false;\r\n};\r\n\r\nconst onClick = () => {\r\n  isChange.value = true;\r\n};\r\n\r\nwatch(isChange, (val) => {\r\n  if (!val) {\r\n    return;\r\n  }\r\n  refreshList();\r\n});\r\n```\r\n\r\n但是仔细观察一下，其实我们只是想让变化的时候通知一下，然后调用 refreshList 即可。\r\n\r\n且我们也不希望每次都复制这样一段代码在其他组件中重复使用，基于上面的场景我们很容易想到可以写一个发布订阅的模块来实现我们需求。\r\n\r\n## EventEmitter\r\n\r\n```js\r\nclass EventEmitter {\r\n  subscriptions = new Set();\r\n\r\n  emit = (val) => {\r\n    for (const subscription of this.subscriptions) {\r\n      subscription(val);\r\n    }\r\n  };\r\n\r\n  useSubscription = (callback) => {\r\n    this.subscriptions.add(subscription);\r\n  };\r\n}\r\n```\r\n\r\n上面的发布订阅模块很简单，`useSubscription` 来订阅，`emit` 来进行通知。下面是使用形式\r\n\r\n```js\r\nconst event = new EventEmitter();\r\nconst refreshList = () => {};\r\nconst fn = (val) => {\r\n  if (val !== 'refresh') {\r\n    return;\r\n  }\r\n  refreshList();\r\n};\r\nevent.useSubscription('refresh', fn);\r\n\r\nconst onClick = () => {\r\n  event.emit('refresh');\r\n};\r\n\r\nonUnmounted(() => {\r\n  event.subscriptions.delete(fn);\r\n});\r\n```\r\n\r\n使用方式稍微简化了一下，不过也多出了 `onUnmounted`，这也谈不上方便，因为会有额外的心智负担，上面之所以单独写一个 `fn` 就是因为卸载的时候需要卸载对应的函数才行。\r\n\r\n基于简化和不想重复管理的需求，我们再重新写一版，这里我们采用 hook 的形式来书写\r\n\r\n## useEventEmitter\r\n\r\n```js\r\nclass EventEmitter {\r\n  subscriptions = new Set();\r\n\r\n  emit = (val) => {\r\n    for (const subscription of this.subscriptions) {\r\n      subscription(val);\r\n    }\r\n  };\r\n\r\n  useSubscription = (callback) => {\r\n    this.subscriptions.add(callback);\r\n    onUnmounted(() => {\r\n      this.subscriptions.delete(callback);\r\n    });\r\n  };\r\n}\r\nconst useEventEmitter = () => {\r\n  const event = new EventEmitter();\r\n\r\n  return event;\r\n};\r\n```\r\n\r\n上面的逻辑改变了一下，我们在 `useSubscription` 中调用 `onUnmounted` 来完成一个自动的卸载。\r\n\r\n之后使用方法\r\n\r\n```js\r\nconst event = useEventEmitter();\r\n\r\nconst refreshList = () => {};\r\n\r\nevent.useSubscription((val) => {\r\n  if (val !== 'refresh') {\r\n    return;\r\n  }\r\n  refreshList();\r\n});\r\n\r\nconst onClick = () => {\r\n  event.emit('refresh');\r\n};\r\n```\r\n\r\n这里就达到我们期待的一个效果了，不过还是有需要改进的地方：\r\n\r\n在使用发布订阅的场景基本上组件之间的层级会嵌套很多，例如上面每次调用 `useEventEmitter` 生成一个新的 `event` 所以通过单例简化为全局唯一的 event 即可，或者也可以借助 `provide` 和 `inject` 解决这一问题\r\n\r\n## 改进之后\r\n\r\n```js\r\nclass EventEmitter {\r\n  subscriptions = new Set();\r\n\r\n  emit = (val) => {\r\n    for (const subscription of this.subscriptions) {\r\n      subscription(val);\r\n    }\r\n  };\r\n\r\n  useSubscription = (callback) => {\r\n    this.subscriptions.add(callback);\r\n    onUnmounted(() => {\r\n      this.subscriptions.delete(callback);\r\n    });\r\n  };\r\n}\r\nconst event = new EventEmitter();\r\nconst useEventEmitter = () => {\r\n  return event;\r\n};\r\n```\r\n",
      "reactions": {
        "url": "https://api.github.com/repos/bosens-China/blog/issues/96/reactions",
        "total_count": 0,
        "+1": 0,
        "-1": 0,
        "laugh": 0,
        "hooray": 0,
        "confused": 0,
        "heart": 0,
        "rocket": 0,
        "eyes": 0
      },
      "timeline_url": "https://api.github.com/repos/bosens-China/blog/issues/96/timeline",
      "performed_via_github_app": null,
      "state_reason": null
    },
    {
      "url": "https://api.github.com/repos/bosens-China/blog/issues/95",
      "repository_url": "https://api.github.com/repos/bosens-China/blog",
      "labels_url": "https://api.github.com/repos/bosens-China/blog/issues/95/labels{/name}",
      "comments_url": "https://api.github.com/repos/bosens-China/blog/issues/95/comments",
      "events_url": "https://api.github.com/repos/bosens-China/blog/issues/95/events",
      "html_url": "https://github.com/bosens-China/blog/issues/95",
      "id": 1520334523,
      "node_id": "I_kwDOCzPAy85anna7",
      "number": 95,
      "title": "monorepo 如何解决别名问题",
      "user": {
        "login": "bosens-China",
        "id": 39508895,
        "node_id": "MDQ6VXNlcjM5NTA4ODk1",
        "avatar_url": "https://avatars.githubusercontent.com/u/39508895?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bosens-China",
        "html_url": "https://github.com/bosens-China",
        "followers_url": "https://api.github.com/users/bosens-China/followers",
        "following_url": "https://api.github.com/users/bosens-China/following{/other_user}",
        "gists_url": "https://api.github.com/users/bosens-China/gists{/gist_id}",
        "starred_url": "https://api.github.com/users/bosens-China/starred{/owner}{/repo}",
        "subscriptions_url": "https://api.github.com/users/bosens-China/subscriptions",
        "organizations_url": "https://api.github.com/users/bosens-China/orgs",
        "repos_url": "https://api.github.com/users/bosens-China/repos",
        "events_url": "https://api.github.com/users/bosens-China/events{/privacy}",
        "received_events_url": "https://api.github.com/users/bosens-China/received_events",
        "type": "User",
        "site_admin": false
      },
      "labels": [
        {
          "id": 1740577858,
          "node_id": "MDU6TGFiZWwxNzQwNTc3ODU4",
          "url": "https://api.github.com/repos/bosens-China/blog/labels/%E5%B7%A5%E5%85%B7%E7%9B%B8%E5%85%B3",
          "name": "工具相关",
          "color": "f73d62",
          "default": false,
          "description": "工程化相关的东西"
        }
      ],
      "state": "open",
      "locked": false,
      "assignee": null,
      "assignees": [],
      "milestone": null,
      "comments": 0,
      "created_at": "2023-01-05T08:43:30Z",
      "updated_at": "2023-01-05T08:43:30Z",
      "closed_at": null,
      "author_association": "OWNER",
      "active_lock_reason": null,
      "body": "得益于 pnpm 软链接实现现在 monorepo 项目已经十分成熟了，不过在写项目时候还是遇到很多痛点，例如：\r\n\r\n1. 如果我有多个 packages 项目并且使用 TypeScript，那么我肯定希望是写的都是 ts，在需要调用的时候通过工具来完成这一过程的转译，不过在实际开发中可能使用了 vite 这样的工具，导致遇到问题只能通过其它方式来绕过去；\r\n2. 如果写一个后端项目，那么数据库定义的模型描述肯定希望在 web 项目也可以复用，不过在多入口中可能还需要通过 `@new-house/src/xxxx.ts` 来引用，这个 `src/xxx` 也太不简洁了。\r\n\r\n所以这篇文章重点就是解决问题 2 ，问题 1 如果有机会再单独开一个篇幅来说，在正式讲解之前需要介绍一下 `exports` 这个属性\r\n\r\n## exports\r\n\r\n这个属性添加于 v12.7.0，最简单的使用方式如下\r\n\r\n```js\r\n{\r\n  // package.json\r\n  \"exports\": \"./index.js\"\r\n}\r\n```\r\n\r\n它的优先级高于 `main`，除此之外更多是作为不同环境导入文件来使用，例如开发了一个 utils 的包希望它可以在 node 的 cjs 和 ems 环境下工作，那么它就可以发挥作用了。\r\n\r\n```js\r\n{\r\n  \"exports\": {\r\n    \".\": {\r\n      \"import\": \"./feature-node.mjs\",\r\n      \"require\": \"./feature-node.cjs\"\r\n    },\r\n  }\r\n}\r\n```\r\n\r\n除此之外还可以解决目录别名问题，这也是为什么介绍它的原因\r\n\r\n```js\r\n{\r\n  \"name\": \"my-package\",\r\n  \"exports\": {\r\n    \".\": \"./lib/index.js\",\r\n    \"./lib\": \"./lib/index.js\",\r\n    \"./lib/*\": \"./lib/*.js\",\r\n    \"./lib/*.js\": \"./lib/*.js\",\r\n    \"./feature\": \"./feature/index.js\",\r\n    \"./feature/*\": \"./feature/*.js\",\r\n    \"./feature/*.js\": \"./feature/*.js\",\r\n    \"./package.json\": \"./package.json\"\r\n  }\r\n}\r\n```\r\n\r\n上面的 ` \"./feature/*\": \"./feature/*.js\",` 以及 `\"./feature/*.js\": \"./feature/*.js\",` 等都可以通过 `my-package/feature/xxx.js` 来完成调用\r\n\r\nexports 就介绍到这里，了解到它可以适配不同环境以及用于解决目录别名，下面就是项目实战。\r\n\r\n## TypeScript 下使用\r\n\r\n为了方便，这里我已经搭建好了一个 pnpm monorepo 项目，它的文件结构如下\r\n\r\n```sh\r\ntest\r\n├─ node_modules\r\n├─ package.json\r\n├─ packages\r\n│    ├─ utils\r\n│    │    ├─ package.json\r\n│    │    ├─ src\r\n│    │    │    ├─ addition.ts\r\n│    │    │    └─ subtraction.ts\r\n│    │    └─ tsconfig.json\r\n│    └─ web\r\n│           ├─ babel.config.js\r\n│           ├─ dist\r\n│           │    └─ index.js\r\n│           ├─ node_modules\r\n│           ├─ package.json\r\n│           ├─ src\r\n│           │    └─ index.ts\r\n│           ├─ tsconfig.json\r\n│           └─ webpack.config.js\r\n├─ pnpm-lock.yaml\r\n├─ pnpm-workspace.yaml\r\n└─ tsconfig.json\r\n```\r\n\r\nutils 这个项目用于给 web 项目使用，它的 package.json 内容如下\r\n\r\n```js\r\n{\r\n  \"name\": \"@test/utils\",\r\n  \"version\": \"1.0.0\",\r\n  \"exports\": {\r\n    \"./*\": \"./src/*.ts\"\r\n  }\r\n}\r\n```\r\n\r\n这里设置 `\"./*\"` 是提示这个为一个子目录别名，同理你也可以设置 `\"test/*\"` 表示以 test 为开头，因为 utils 这个项目都是 ts 我并不想花时间每次都 build 一遍成 js 所以只能写成 `./src/*.ts`\r\n\r\n> 这里提示一下，如果是 ts 项目必须这个结尾，否则会提示找不到类型文件\r\n\r\n第二步就是在 web 项目中引用\r\n\r\n```js\r\n// web/src/index.ts\r\nimport addition from '@test/utils/addition';\r\nimport subtraction from '@test/utils/subtraction';\r\n\r\nconsole.log(addition(1, 1));\r\nconsole.log(subtraction(1, 1));\r\n```\r\n\r\n> 如果 TypeScript 提示说不到模块之类的错误，那么你需要调整一下 tsconfig.json 的配置\r\n>\r\n> ```json\r\n> {\r\n>   \"compilerOptions\": {\r\n>     \"moduleResolution\": \"NodeNext\" // node 16也可以\r\n>   }\r\n> }\r\n> ```\r\n\r\n这样就消除了闹心的 src 目录\r\n\r\n## 其它问题\r\n\r\n### TypeScript 使用别名如何定义类型文件\r\n\r\n这个可以参考官方文档的实现\r\n\r\n```json\r\n// package.json\r\n{\r\n  \"name\": \"my-package\",\r\n  \"type\": \"module\",\r\n  \"exports\": {\r\n    \".\": {\r\n      // Entry-point for TypeScript resolution - must occur first!\r\n      \"types\": \"./types/index.d.ts\",\r\n      // Entry-point for `import \"my-package\"` in ESM\r\n      \"import\": \"./esm/index.js\",\r\n      // Entry-point for `require(\"my-package\") in CJS\r\n      \"require\": \"./commonjs/index.cjs\"\r\n    }\r\n  },\r\n  // CJS fall-back for older versions of Node.js\r\n  \"main\": \"./commonjs/index.cjs\",\r\n  // Fall-back for older versions of TypeScript\r\n  \"types\": \"./types/index.d.ts\"\r\n}\r\n```\r\n\r\n额外在 exports 中添加 types 属性，相关讨论链接 https://github.com/microsoft/TypeScript/issues/33079#issuecomment-598961442\r\n\r\n### 设置了 moduleResolution 导致导入其它模块必须以.js 结尾\r\n\r\n以.js 结尾是规范的规定，如果你使用 webpack5 来打包项目可以在配置文件中添加以下内容\r\n\r\n```js\r\n{\r\n  resolve: {\r\n    extensionAlias: {\r\n      \".js\": [\".ts\", \".js\"],\r\n      \".cjs\": [\".cts\", \".cjs\"],\r\n      \".mjs\": [\".mts\", \".mjs\"],\r\n    }\r\n    // ...\r\n  }\r\n  // ...\r\n}\r\n```\r\n\r\n相关问题链接 [Support TypeScript module resolution `node16` · Issue #12625 · facebook/create-react-app (github.com)](https://github.com/facebook/create-react-app/issues/12625)\r\n\r\n## 参考链接\r\n\r\n- [模块：包|节点.js v19.3.0 文档 (nodejs.org)](https://nodejs.org/api/packages.html#subpath-imports)\r\n- [TypeScript： Documentation - ECMAScript Modules in Node.js (typescriptlang.org)](https://www.typescriptlang.org/docs/handbook/esm-node.html)\r\n- [Module 的加载实现 - ECMAScript 6 入门 (ruanyifeng.com)](https://es6.ruanyifeng.com/#docs/module-loader)\r\n",
      "reactions": {
        "url": "https://api.github.com/repos/bosens-China/blog/issues/95/reactions",
        "total_count": 1,
        "+1": 1,
        "-1": 0,
        "laugh": 0,
        "hooray": 0,
        "confused": 0,
        "heart": 0,
        "rocket": 0,
        "eyes": 0
      },
      "timeline_url": "https://api.github.com/repos/bosens-China/blog/issues/95/timeline",
      "performed_via_github_app": null,
      "state_reason": null
    },
    {
      "url": "https://api.github.com/repos/bosens-China/blog/issues/94",
      "repository_url": "https://api.github.com/repos/bosens-China/blog",
      "labels_url": "https://api.github.com/repos/bosens-China/blog/issues/94/labels{/name}",
      "comments_url": "https://api.github.com/repos/bosens-China/blog/issues/94/comments",
      "events_url": "https://api.github.com/repos/bosens-China/blog/issues/94/events",
      "html_url": "https://github.com/bosens-China/blog/issues/94",
      "id": 1361066184,
      "node_id": "I_kwDOCzPAy85RIDjI",
      "number": 94,
      "title": "TypeScript 类型收窄",
      "user": {
        "login": "bosens-China",
        "id": 39508895,
        "node_id": "MDQ6VXNlcjM5NTA4ODk1",
        "avatar_url": "https://avatars.githubusercontent.com/u/39508895?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bosens-China",
        "html_url": "https://github.com/bosens-China",
        "followers_url": "https://api.github.com/users/bosens-China/followers",
        "following_url": "https://api.github.com/users/bosens-China/following{/other_user}",
        "gists_url": "https://api.github.com/users/bosens-China/gists{/gist_id}",
        "starred_url": "https://api.github.com/users/bosens-China/starred{/owner}{/repo}",
        "subscriptions_url": "https://api.github.com/users/bosens-China/subscriptions",
        "organizations_url": "https://api.github.com/users/bosens-China/orgs",
        "repos_url": "https://api.github.com/users/bosens-China/repos",
        "events_url": "https://api.github.com/users/bosens-China/events{/privacy}",
        "received_events_url": "https://api.github.com/users/bosens-China/received_events",
        "type": "User",
        "site_admin": false
      },
      "labels": [
        {
          "id": 1371686611,
          "node_id": "MDU6TGFiZWwxMzcxNjg2NjEx",
          "url": "https://api.github.com/repos/bosens-China/blog/labels/%E5%85%B6%E4%BB%96",
          "name": "其他",
          "color": "f6ecbf",
          "default": false,
          "description": "未找到分类，暂定的文章"
        }
      ],
      "state": "open",
      "locked": false,
      "assignee": null,
      "assignees": [],
      "milestone": null,
      "comments": 0,
      "created_at": "2022-09-04T07:17:35Z",
      "updated_at": "2022-09-04T07:17:35Z",
      "closed_at": null,
      "author_association": "OWNER",
      "active_lock_reason": null,
      "body": "![image-20220904141910530](https://user-images.githubusercontent.com/39508895/188302110-a54f0cf4-ec09-4b1b-bcf0-2caf181351da.png)\r\n\r\n\r\n写这篇文章是因为最近在写一个[管理异步队列的库](https://github.com/bosens-China/async-queue)，但是有一些类型推导不太好写，例如上面的期待是\r\n\r\n```js\r\nif (values.stauts === 'error') {\r\n  // values.data to Error\r\n}\r\n```\r\n\r\n后面查询了一些文档和资料就有了这篇文章。\r\n\r\n## 收窄方式\r\n\r\n在具体讲解上面如何实现之前，先介绍一下几种收窄对象的方式。\r\n\r\n### typeof 类型守卫\r\n\r\n```js\r\nfunction padLeft(padding: number | string, input: string): string {\r\n  throw new Error('Not implemented yet!');\r\n}\r\n```\r\n\r\n如果在 padLeft 函数内调用不是 stirng 和 number 相同的方法，例如 toString、valueOf 会提示方法不存在。\r\n\r\n之所以出现这样问题是因为 Typescript 并不知道 padding 到底是 number 还是 string，但是你可以通过 typeof 的显式告诉它的类型。\r\n\r\n```js\r\nfunction padLeft(padding: number | string, input: string): string {\r\n  if (typeof padding === 'string') {\r\n    return padding.charAt(0);\r\n  }\r\n  // 排除了string，剩下就是number\r\n  return padding.toFixed(2);\r\n}\r\n```\r\n\r\n### 条件语句\r\n\r\n在使用条件语句，例如 `if`、`&&`、`||` 、`!` 等条件语句的时候也会缩小类型。\r\n\r\n看一个例子\r\n\r\n```js\r\nfunction printAll(strs: string | string[] | null) {\r\n  //\r\n}\r\n```\r\n\r\n按照上面 typeof 语句很自然就想到判断是不是 object 来完成数组区分\r\n\r\n```js\r\nfunction printAll(strs: string | string[] | null) {\r\n  if (typeof strs === 'object') {\r\n    strs.forEach((item) => {});\r\n    // Object is possibly 'null'.\r\n    //'item' is declared but its value is never read.\r\n  }\r\n}\r\n```\r\n\r\n不过写到一半就会发现提示报错了，strs 在 object 的判断下依然可能为 null，回忆一下 typeof 的运算符可以得知这个是正常现象，null 的 typeof 返回值也是 object，这个是 JavaScript 语言设计的一个缺陷。\r\n\r\n不过要怎么消除这个影响呢？这就用到这条件语句，可以通过判断 strs 是否存在显式排除 null 的存在\r\n\r\n```js\r\nfunction printAll(strs: string | string[] | null) {\r\n  if (typeof strs === 'object' && strs) {\r\n    // object\r\n    return strs;\r\n    // 这里strs类型已经被排除object了\r\n  } else if (typeof strs === 'string') {\r\n    return strs;\r\n  }\r\n  // null\r\n  return strs;\r\n}\r\n```\r\n\r\n### 相等运算符和 switch 收窄\r\n\r\n还可以使用 `===`、`==`、`!=`、`!==` 运算符来完成收窄\r\n\r\n```js\r\ninterface Container {\r\n  value: number | null | undefined;\r\n}\r\n\r\nfunction multiplyValue(container: Container, factor: number) {}\r\n```\r\n\r\n例如上面，如果想让 container 排除 null 和 undefined 就可以使用 `===` 来完成，下面是示例\r\n\r\n```js\r\ninterface Container {\r\n  value: number | null | undefined;\r\n}\r\n\r\nfunction multiplyValue(container: Container, factor: number) {\r\n  if (container.value === undefined) {\r\n    return 0;\r\n  }\r\n  if (container.value === null) {\r\n    return 1;\r\n  }\r\n  return container.value === factor;\r\n}\r\n```\r\n\r\n通过 === 完成了 undefined 和 null 的收窄过程，这里顺便说下其实上面的写法可以简写成 `==` ，== 在判断 undefined 跟 null 之间时返回 true。\r\n\r\n```js\r\ninterface Container {\r\n  value: number | null | undefined;\r\n}\r\n\r\nfunction multiplyValue(container: Container, factor: number) {\r\n  if (container.value == undefined) {\r\n    return 0;\r\n  }\r\n\r\n  return container.value === factor;\r\n}\r\n```\r\n\r\n### in 运算符\r\n\r\nin 运算符用于判断一个属性是否存在对象上，在 TypeScript 同样可以使用 in 来完成收窄。\r\n\r\n```js\r\ntype Fish = { swim: () => void };\r\ntype Bird = { fly: () => void };\r\n\r\nfunction move(animal: Fish | Bird) {\r\n  if ('swim' in animal) {\r\n    return animal.swim();\r\n  }\r\n\r\n  return animal.fly();\r\n}\r\n```\r\n\r\n上面 move 通过指定 `swim in animal` 告诉 TypeScript，在 if 中类型就是 Fish，因为 Bird 中不存在这个属性。\r\n\r\n> 使用 in 运算符收窄时，使用其他联合类型不存在的属性来完成对某一类型的收窄\r\n\r\n### instanceof\r\n\r\n与 JavaScript 中一样，instanceof 也可以判断某个属性是否匹配对象。\r\n\r\n```js\r\nfunction logValue(x: Date | string) {\r\n  if (x instanceof Date) {\r\n    console.log(x.toUTCString());\r\n  } else {\r\n    console.log(x.toUpperCase());\r\n  }\r\n}\r\n```\r\n\r\n### 赋值\r\n\r\n这里直接看例子\r\n\r\n```js\r\nlet x = Math.random() < 0.5 ? 10 : 'hello world!';\r\n// let x: string | number\r\nx = 1;\r\n\r\nconsole.log(x);\r\n// let x: number\r\nx = 'goodbye!';\r\n\r\nconsole.log(x);\r\n// let x: string\r\n```\r\n\r\n不过注意，分配给上面的 x 一定要符合 x 最初的联合类型，也就是说给定 boolean 会报错。\r\n\r\n### 类型谓词\r\n\r\n在使用 lodash 类型的函数库，通常都会有 isObject，你可能很好奇怎么实现。\r\n\r\n其实它们就是使用了类型谓词，下面动手实现一个 isObject\r\n\r\n```js\r\nfunction isObject (value:any) : value is object {\r\n    return value && typeof value === 'object'\r\n}\r\n```\r\n\r\n之后在配合使用就可以完成类型收窄\r\n\r\n```js\r\nfunction test(pet: object | null) {\r\n  if (isObject(pet)) {\r\n    return pet;\r\n  } else {\r\n    return {};\r\n  }\r\n}\r\n```\r\n\r\n### interface 收窄\r\n\r\n上面将收窄的方式列举了一番，下面就看下在 interface 中如何实现收窄，最开始已经说了，我们期待使用 if 条件语句可以通过 status 的不同来完成 data 的变化。\r\n\r\n在 TypeScript 我们可以使用联合类型将两者通用部分区分\r\n\r\n```js\r\nexport interface ChangeError {\r\n  status: 'error';\r\n  data: Error;\r\n}\r\n\r\nexport interface ChangeData<T> {\r\n  status: 'success';\r\n  data: T;\r\n}\r\n```\r\n\r\n之后拼接一起\r\n\r\n```js\r\nexport type Change<T = any> = {\r\n  index: number,\r\n  progress: number,\r\n  total: number,\r\n} & (ChangeError | ChangeData<T>);\r\n```\r\n\r\n之后通过 TypeScript 的条件收窄就自动完成这一过程。\r\n\r\n### 收窄类型的实用示例\r\n\r\n收窄 + never 结合可以完成一个联合类型添加新对象不处理报错。\r\n\r\n```js\r\ninterface A {\r\n  name: 'a';\r\n}\r\ninterface B {\r\n  name: 'b';\r\n}\r\n\r\ntype Types = A | B;\r\n\r\nfunction check(values: Types) {\r\n  switch (values.name) {\r\n    case 'a':\r\n      return '';\r\n    case 'b':\r\n      return '';\r\n    default:\r\n      const _never: never = values;\r\n      return _never;\r\n  }\r\n}\r\n```\r\n\r\nnever 表示永远为空的类型，结合 switch 可以将对象类型收窄尽，这时对象的类型就是 never。\r\n\r\n现在如果给 Types 添加新的联合类型 default 就会抛出错误\r\n\r\n```js\r\ninterface A {\r\n  name: 'a';\r\n}\r\ninterface B {\r\n  name: 'b';\r\n}\r\n\r\ntype Types = A | B | { name: 'c' };\r\n\r\nfunction check(values: Types) {\r\n  switch (values.name) {\r\n    case 'a':\r\n      return '';\r\n    case 'b':\r\n      return '';\r\n    default:\r\n      const _never: never = values;\r\n      return _never;\r\n  }\r\n}\r\n```\r\n",
      "reactions": {
        "url": "https://api.github.com/repos/bosens-China/blog/issues/94/reactions",
        "total_count": 0,
        "+1": 0,
        "-1": 0,
        "laugh": 0,
        "hooray": 0,
        "confused": 0,
        "heart": 0,
        "rocket": 0,
        "eyes": 0
      },
      "timeline_url": "https://api.github.com/repos/bosens-China/blog/issues/94/timeline",
      "performed_via_github_app": null,
      "state_reason": null
    },
    {
      "url": "https://api.github.com/repos/bosens-China/blog/issues/93",
      "repository_url": "https://api.github.com/repos/bosens-China/blog",
      "labels_url": "https://api.github.com/repos/bosens-China/blog/issues/93/labels{/name}",
      "comments_url": "https://api.github.com/repos/bosens-China/blog/issues/93/comments",
      "events_url": "https://api.github.com/repos/bosens-China/blog/issues/93/events",
      "html_url": "https://github.com/bosens-China/blog/issues/93",
      "id": 1254826397,
      "node_id": "I_kwDOCzPAy85KyyGd",
      "number": 93,
      "title": "nginx 极简入门",
      "user": {
        "login": "bosens-China",
        "id": 39508895,
        "node_id": "MDQ6VXNlcjM5NTA4ODk1",
        "avatar_url": "https://avatars.githubusercontent.com/u/39508895?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bosens-China",
        "html_url": "https://github.com/bosens-China",
        "followers_url": "https://api.github.com/users/bosens-China/followers",
        "following_url": "https://api.github.com/users/bosens-China/following{/other_user}",
        "gists_url": "https://api.github.com/users/bosens-China/gists{/gist_id}",
        "starred_url": "https://api.github.com/users/bosens-China/starred{/owner}{/repo}",
        "subscriptions_url": "https://api.github.com/users/bosens-China/subscriptions",
        "organizations_url": "https://api.github.com/users/bosens-China/orgs",
        "repos_url": "https://api.github.com/users/bosens-China/repos",
        "events_url": "https://api.github.com/users/bosens-China/events{/privacy}",
        "received_events_url": "https://api.github.com/users/bosens-China/received_events",
        "type": "User",
        "site_admin": false
      },
      "labels": [
        {
          "id": 1740577858,
          "node_id": "MDU6TGFiZWwxNzQwNTc3ODU4",
          "url": "https://api.github.com/repos/bosens-China/blog/labels/%E5%B7%A5%E5%85%B7%E7%9B%B8%E5%85%B3",
          "name": "工具相关",
          "color": "f73d62",
          "default": false,
          "description": "工程化相关的东西"
        }
      ],
      "state": "open",
      "locked": false,
      "assignee": null,
      "assignees": [],
      "milestone": null,
      "comments": 0,
      "created_at": "2022-06-01T03:35:30Z",
      "updated_at": "2022-06-01T03:35:30Z",
      "closed_at": null,
      "author_association": "OWNER",
      "active_lock_reason": null,
      "body": "nginx（读音：engine-x，音标：[ˈendʒɪnks']）是 HTTP 和反向代理服务器、邮件代理服务器和通用 TCP/UDP 代理服务器。\r\n\r\n日常中最经常听到用到的就是反向代理以及负载均衡，那么什么是反向代理呢？\r\n\r\n## 什么是反向代理？\r\n\r\n![reverse-proxy](https://user-images.githubusercontent.com/39508895/171322376-dc12836e-435a-44c1-b3c8-cfdc3f8c4293.png)\r\n\r\n\r\n反向代理（Reverse Proxy）是指以代理服务器来接受 internet（ˈɪntəˌnɛt） 上的连接请求，然后将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给 internet 上请求连接的客户端，此时代理服务器对外就表现为一个反向代理服务器。\r\n\r\n简单概括就是有一个中转服务器来转发你的请求，那么使用反向代理有什么好处呢？\r\n\r\n- 隐藏真实的服务地址\r\n- 节省 ip 资源，公共的 ip 地址是有限的，反向代理可以解决此问题\r\n\r\n### nginx 中如何配置反向代理？\r\n\r\n在 nginx 中通过指定 proxy_pass（ˈprɒksi pɑːs） 即可完成请求转发到指定服务器\r\n\r\n```nginx\r\n# 省略其他配置\r\n\r\nserver {\r\n  listen       80;\r\n  server_name  www.helloworld.com;\r\n\r\n  location /app1/ {\r\n    proxy_pass http://api_server;\r\n    rewrite \"^/app1/(.*)$\" /$1 break;\r\n  }\r\n\r\n  location /app2/ {\r\n    proxy_pass http://api_server;\r\n  }\r\n}\r\n```\r\n\r\n上面的两种形式是最长使用的场景。\r\n\r\n假设访问 `www.helloworld.com/api1/user/1`，那么真实请求的是 `http://api_server/user/1`；\r\n\r\n而如果访问` www.helloworld.com/api2/user/2`，真实请求地址为 `http://api_server/app2/user/2`。\r\n\r\n上面的 `rewrite（ˈriːraɪt）` 是重写请求地址，而 `(.*)` 代表正则的组匹配，$1 是获取 `()` 的内容，同理如果存在多个 `()` 还可以通过$2,$3 的形式来简写。\r\n\r\n### 与 dev 开发对比\r\n\r\n而在真实的开发中（可能是通过 webpack 或者 vite 这样的工具），为了解决跨域问题，我们也会引入反向代理，例如如下配置：\r\n\r\n```js\r\nexport default defineConfig({\r\n  server: {\r\n    proxy: {\r\n      // 字符串简写写法\r\n      '/foo': 'http://localhost:4567',\r\n      // 选项写法\r\n      '/api': {\r\n        target: 'http://jsonplaceholder.typicode.com',\r\n        changeOrigin: true,\r\n        rewrite: (path) => path.replace(/^\\/api/, ''),\r\n      },\r\n    },\r\n  },\r\n});\r\n```\r\n\r\n所以综上所述，反向代理我们一直在使用可能你并没有觉察到。\r\n\r\n## 什么是负载均衡？\r\n\r\n负载均衡（Load Balance）这个词经常会听到，它的作用就是分摊到多个操作单元上进行执行。\r\n\r\n概念还是不太明显，举一个例子，如果有一个网站 `www.helloworld.com`，正常情况下它的 web 架构如下\r\n![demo1](https://pic3.zhimg.com/80/v2-6a7f624cd5e776a6b0b05a051e65666e_720w.jpg)\r\n这里如果服务器宕机了或者达到访问上限就会出现没办法访问情况。\r\n\r\n那么负载均衡如何解决如上问题呢？\r\n\r\n### 负载均衡如何解决\r\n\r\n\r\n\r\n在后端引入一个负载均衡器和一台额外的 web 服务器就可以缓解这种情况（注意，这里的 web 服务会提供一致的服务）。\r\n\r\n所以负载均衡的作用就是在于分流，而像上面部署两台或者以上的 web 服务，我们称为集群。\r\n\r\n下面看一个 nginx 的负载均衡例子，作为额外知识点补充\r\n\r\n### nginx 负载均衡示例\r\n\r\n```nginx\r\nhttp {\r\n     #设定mime类型,类型由mime.type文件定义\r\n    include       /etc/nginx/mime.types;\r\n    default_type  application/octet-stream;\r\n    #设定日志格式\r\n    access_log    /var/log/nginx/access.log;\r\n\r\n    #设定负载均衡的服务器列表\r\n    upstream load_balance_server {\r\n        #weigth参数表示权值，权值越高被分配到的几率越大\r\n        server 192.168.1.11:80   weight=5;\r\n        server 192.168.1.12:80   weight=1;\r\n        server 192.168.1.13:80   weight=6;\r\n    }\r\n\r\n   #HTTP服务器\r\n   server {\r\n        #侦听80端口\r\n        listen       80;\r\n\r\n        #定义使用www.xx.com访问\r\n        server_name  www.helloworld.com;\r\n\r\n        #对所有请求进行负载均衡请求\r\n        location / {\r\n            root        /root;                 #定义服务器的默认网站根目录位置\r\n            index       index.html index.htm;  #定义首页索引文件的名称\r\n            proxy_pass  http://load_balance_server ;#请求转向load_balance_server 定义的服务器列表\r\n\r\n            #以下是一些反向代理的配置(可选择性配置)\r\n            #proxy_redirect off;\r\n            proxy_set_header Host $host;\r\n            proxy_set_header X-Real-IP $remote_addr;\r\n            #后端的Web服务器可以通过X-Forwarded-For获取用户真实IP\r\n            proxy_set_header X-Forwarded-For $remote_addr;\r\n            proxy_connect_timeout 90;          #nginx跟后端服务器连接超时时间(代理连接超时)\r\n            proxy_send_timeout 90;             #后端服务器数据回传时间(代理发送超时)\r\n            proxy_read_timeout 90;             #连接成功后，后端服务器响应时间(代理接收超时)\r\n            proxy_buffer_size 4k;              #设置代理服务器（nginx）保存用户头信息的缓冲区大小\r\n            proxy_buffers 4 32k;               #proxy_buffers缓冲区，网页平均在32k以下的话，这样设置\r\n            proxy_busy_buffers_size 64k;       #高负荷下缓冲大小（proxy_buffers*2）\r\n            proxy_temp_file_write_size 64k;    #设定缓存文件夹大小，大于这个值，将从upstream服务器传\r\n\r\n            client_max_body_size 10m;          #允许客户端请求的最大单文件字节数\r\n            client_body_buffer_size 128k;      #缓冲区代理缓冲用户端请求的最大字节数\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n这里在访问 www.helloworld.com 会按照以下权重访问\r\n\r\n- 192.168.1.13:80\r\n- 192.168.1.11:80\r\n- 192.168.1.12:80\r\n\r\n## nginx 常见命令\r\n\r\n| 命令                         | 描述                                                                                               |\r\n| ---------------------------- | -------------------------------------------------------------------------------------------------- |\r\n| <kbd>nginx -s stop</kbd>     | 快速关闭 Nginx，可能不保存相关信息，并迅速终止 web 服务。                                          |\r\n| <kbd>nginx -s quit</kbd>     | 平稳关闭 Nginx，保存相关信息，有安排的结束 web 服务。                                              |\r\n| <kbd>nginx -s reload</kbd>   | 因改变了 Nginx 相关配置，需要重新加载配置而重载。                                                  |\r\n| <kbd>nginx -s reopen</kbd>   | 重新打开日志文件。                                                                                 |\r\n| <kbd>nginx -c filename</kbd> | 为 Nginx 指定一个配置文件，来代替缺省的。                                                          |\r\n| <kbd>nginx -t</kbd>          | 不运行，仅仅测试配置文件。nginx 将检查配置文件的语法的正确性，并尝试打开配置文件中所引用到的文件。 |\r\n| <kbd>nginx -v</kbd>          | 显示 nginx 的版本。                                                                                |\r\n| <kbd>nginx -V</kbd>          | 显示 nginx 的版本，编译器版本和配置参数。                                                          |\r\n\r\n这里的 nginx -t 还有一个额外作用，在不指定-c 的情况下会测试默认的配置文件，且会输出一句额外信息\r\n\r\n```sh\r\nginx: the configuration file /etc/nginx/nginx.conf syntax is ok\r\nnginx: configuration file /etc/nginx/nginx.conf test is successful\r\n```\r\n\r\n可以从上面信息获取到默认的配置文件路径\r\n\r\n## location 匹配规则\r\n\r\n| 名称           | 描述                                                               |\r\n| -------------- | ------------------------------------------------------------------ |\r\n| <kbd>=</kbd>   | 表示精确匹配                                                       |\r\n| <kbd>~</kbd>   | 表示该规则是使用正则定义的，区分大小写                             |\r\n| <kbd>~\\*</kbd> | 表示该规则是使用正则定义的，不区分大小写                           |\r\n| <kbd>^~</kbd>  | 表示如果该符号后面的字符是最佳匹配，采用该规则，不再进行后续的查找 |\r\n| <kbd>/</kbd>   | 通用匹配                                                           |\r\n\r\n它们之前优先级如下\r\n\r\n1. 如果匹配到 `=` 不再寻找；\r\n2. 如果匹配到 `^~` 不再寻找；\r\n3. 如果匹配到正则规则（存在多条取第一条匹配），不再查找；\r\n4. 匹配不带任何前缀的规则，例如 `location /user/`\r\n5. 如果都不存在，匹配 `/`;\r\n\r\n### location 实战\r\n\r\n下面看一个例子，假设 nginx 配置如下\r\n\r\n```nginx\r\nlocation = / {\r\n    [ configuration A ]\r\n}\r\n\r\nlocation / {\r\n    [ configuration B ]\r\n}\r\n\r\nlocation /user/ {\r\n    [ configuration C ]\r\n}\r\n\r\nlocation ^~ /images/ {\r\n    [ configuration D ]\r\n}\r\n\r\nlocation ~* \\.(gif|jpg|jpeg)$ {\r\n    [ configuration E ]\r\n}\r\n```\r\n\r\n分别请求以下内容会匹配到那条规则呢？\r\n\r\n- /\r\n- /index.html\r\n- /user/index.html\r\n- /images/1.jpg\r\n- /documents/about.html\r\n\r\n## alias 与 root 区别\r\n\r\nalias 与 root 有着细微的差异，以下面 nginx 配置为例\r\n\r\n```nginx\r\nserver {\r\n  # 省略其他\r\n  # 自定义一些变量\r\n  set $path /usr/share/nginx/html/icare/dist;\r\n\r\n  charset utf-8;\r\n\r\n  location / {\r\n    root $path;\r\n    index index.html;\r\n    try_files $uri $uri/ /index.html;\r\n  }\r\n\r\n  location /media/ {\r\n    expires 1h;\r\n    alias /usr/share/nginx/html/icare/static/download/;\r\n  }\r\n\r\n  location ^~ /app/center/assets {\r\n    alias $path/assets/;\r\n    gzip on;\r\n    gzip_http_version 1.1;\r\n    gzip_min_length 1k;\r\n    gzip_comp_level 5;\r\n    gzip_types *;\r\n    expires 30d;\r\n  }\r\n\r\n}\r\n\r\n```\r\n\r\n静态资源的存放路径为： `/usr/share/nginx/html/icare/dist`\r\n\r\n静态资源的公共前缀为/app/center/，此前缀是通过 vite 设置 base 来完成的\r\n\r\n```js\r\nbase: command === 'build' ? '/app/center/' : '/';\r\n```\r\n\r\n而假定我们请求一个资源 `http://10.0.40.33:8000/app/center/assets/index.d1eb2512.js`\r\n\r\n如果上面的 alias 为 `root` 就会请求 `/usr/share/nginx/html/icare/dist/app/center/assets/index.d1eb2512.js` 这条资源\r\n\r\n而实际上 app/center 这个目录是不存在，如果使用 root 指令就会导致资源无法正常加载。\r\n\r\n对此使用 aliasa 指令来指定目录，还是以上面资源为例，指定 alias 情况下，真正请求的资源地址为 `/usr/share/nginx/html/icare/dist/assets/index.d1eb2512.js`\r\n\r\n所以概括一下：\r\n\r\n- root 请求的资源路径为 root + location 匹配规则 + 资源后缀（index.d1eb2512.js）\r\n- alias 请求资源路径为 alias + 资源后缀（index.d1eb2512.js）\r\n\r\n## 实战\r\n\r\n上面简短的介绍了一下 nginx 的一些知识点，下面看几种常见的场景\r\n\r\n- 部署静态站点\r\n- 部署 spa 单页面\r\n\r\n### 部署静态站点\r\n\r\n不需要任何后端服务的项目，可能是一个纯展示信息，假设静态资源放置到了/app/dist 下\r\n\r\n```nginx\r\nworker_processes  1;\r\n\r\nevents {\r\n\tworker_connections  1024;\r\n}\r\n\r\nhttp {\r\n    include       mime.types;\r\n    default_type  application/octet-stream;\r\n    sendfile        on;\r\n    keepalive_timeout  65;\r\n\r\n    gzip on;\r\n    gzip_types text/plain application/x-javascript text/css application/xml text/javascript application/javascript image/jpeg image/gif image/png;\r\n    gzip_vary on;\r\n\r\n    server {\r\n\t\tlisten       80;\r\n\t\tserver_name  static.zp.cn;\r\n\r\n\t\tlocation / {\r\n\t\t\troot /app/dist;\r\n\t\t\tindex index.html;\r\n\t\t\t#转发任何请求到 index.html\r\n\t\t}\r\n\t}\r\n}\r\n```\r\n\r\n运行 nginx 就可以看到展示的信息了。\r\n\r\n### 部署 spa 单页面\r\n\r\nspa 单页面部署可以根据路由分为 history 和 hash 模式，即(/hello or #hello)区别。\r\n\r\n- hash 路由\r\n\r\n![hash](https://user-images.githubusercontent.com/39508895/171322500-143846c6-7d38-4909-99e0-c2d7c9dc0927.jpg)\r\n\r\n- history 路由\r\n\r\n![history](https://user-images.githubusercontent.com/39508895/171322578-5d9dc8a3-841b-417b-9995-b74d1e5e5286.jpg)\r\n\r\n\r\n对于 hash 只需要前端这边路由处理即可不涉及到服务端，所以只需要确保指向正确的 index.html 即可。\r\n\r\n而 history 模式需要则保证在刷新页面之后，用户请求的页面地址依然可以正确返回内容，后面会详细介绍，下面看一下 hash 模式 nginx 如何配置？\r\n\r\n#### hash nginx 配置\r\n\r\n```nginx\r\nworker_processes 1;\r\n\r\nevents {\r\n  worker_connections 1024;\r\n}\r\n\r\nhttp {\r\n  include mime.types;\r\n  default_type application/octet-stream;\r\n  sendfile on;\r\n  keepalive_timeout 65;\r\n\r\n  gzip on;\r\n  gzip_types text/plain application/x-javascript text/css application/xml text/javascript application/javascript image/jpeg image/gif image/png;\r\n  gzip_vary on;\r\n\r\n  root /app/dist;\r\n\r\n  server {\r\n    listen 80;\r\n    server_name static.zp.cn;\r\n\r\n    location / {\r\n      index index.html index.htm;\r\n    }\r\n    location ^~ /assets/ {\r\n      add_header Cache-Control \"public,max-age=31536000\";\r\n      # Allow cross origin access\r\n      add_header Access-Control-Expose-Headers \"Access-Control-Allow-Origin\";\r\n      add_header Access-Control-Allow-Origin \"*\";\r\n    }\r\n\r\n  }\r\n}\r\n```\r\n\r\n这里新增了 `^~ /assets/`它的意思是如果请求 url 包含/assets/内容就采用该匹配规则。\r\n\r\n#### history nginx 配置\r\n\r\n```nginx\r\nworker_processes 1;\r\n\r\nevents {\r\n  worker_connections 1024;\r\n}\r\n\r\nhttp {\r\n  include mime.types;\r\n  default_type application/octet-stream;\r\n  sendfile on;\r\n  keepalive_timeout 65;\r\n\r\n  gzip on;\r\n  gzip_types text/plain application/x-javascript text/css application/xml text/javascript application/javascript image/jpeg image/gif image/png;\r\n  gzip_vary on;\r\n\r\n  root /app/dist;\r\n\r\n  server {\r\n    listen 80;\r\n    server_name static.zp.cn;\r\n\r\n    location / {\r\n      try_files $uri /index.html;\r\n      index index.html index.htm;\r\n    }\r\n    location ^~ /assets/ {\r\n      add_header Cache-Control \"public,max-age=31536000\";\r\n      # Allow cross origin access\r\n      add_header Access-Control-Expose-Headers \"Access-Control-Allow-Origin\";\r\n      add_header Access-Control-Allow-Origin \"*\";\r\n    }\r\n\r\n  }\r\n}\r\n```\r\n\r\n对比之下 history 模式则多了一个 try_files。\r\n\r\ntry_files 的作用是检查文件是否存在，如果存在返回该文件，否则返回后置文件。\r\n\r\n举个例子 访问 static.zp.cn/a 的时候$uri 为/a，此时按照顺序会检查如下文件\r\n\r\n- 检查 /$root/a 文件是否存在\r\n- 检查 /$root/a/ 目录是否存在\r\n- 都不存在返回 index.html 内容\r\n\r\n> 为了演示方便没有包含接口请求，生产环境中一般会出现 proxy_pass 指定。\r\n\r\n# 最后\r\n\r\n到此分享就结束了，下面是一些工具链接，如果有需要可以收藏。\r\n\r\n如果文章有错误的地方也欢迎指出。\r\n\r\n- [NGINX 配置生成](https://www.digitalocean.com/community/tools/nginx?global.app.lang=zhCN)\r\n- [正则可视化工具](https://regexper.com/#)\r\n",
      "reactions": {
        "url": "https://api.github.com/repos/bosens-China/blog/issues/93/reactions",
        "total_count": 0,
        "+1": 0,
        "-1": 0,
        "laugh": 0,
        "hooray": 0,
        "confused": 0,
        "heart": 0,
        "rocket": 0,
        "eyes": 0
      },
      "timeline_url": "https://api.github.com/repos/bosens-China/blog/issues/93/timeline",
      "performed_via_github_app": null,
      "state_reason": null
    },
    {
      "url": "https://api.github.com/repos/bosens-China/blog/issues/92",
      "repository_url": "https://api.github.com/repos/bosens-China/blog",
      "labels_url": "https://api.github.com/repos/bosens-China/blog/issues/92/labels{/name}",
      "comments_url": "https://api.github.com/repos/bosens-China/blog/issues/92/comments",
      "events_url": "https://api.github.com/repos/bosens-China/blog/issues/92/events",
      "html_url": "https://github.com/bosens-China/blog/issues/92",
      "id": 1187971933,
      "node_id": "I_kwDOCzPAy85GzwNd",
      "number": 92,
      "title": ".gitattributes 正确使用姿势",
      "user": {
        "login": "bosens-China",
        "id": 39508895,
        "node_id": "MDQ6VXNlcjM5NTA4ODk1",
        "avatar_url": "https://avatars.githubusercontent.com/u/39508895?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bosens-China",
        "html_url": "https://github.com/bosens-China",
        "followers_url": "https://api.github.com/users/bosens-China/followers",
        "following_url": "https://api.github.com/users/bosens-China/following{/other_user}",
        "gists_url": "https://api.github.com/users/bosens-China/gists{/gist_id}",
        "starred_url": "https://api.github.com/users/bosens-China/starred{/owner}{/repo}",
        "subscriptions_url": "https://api.github.com/users/bosens-China/subscriptions",
        "organizations_url": "https://api.github.com/users/bosens-China/orgs",
        "repos_url": "https://api.github.com/users/bosens-China/repos",
        "events_url": "https://api.github.com/users/bosens-China/events{/privacy}",
        "received_events_url": "https://api.github.com/users/bosens-China/received_events",
        "type": "User",
        "site_admin": false
      },
      "labels": [
        {
          "id": 3661376441,
          "node_id": "LA_kwDOCzPAy87aPCu5",
          "url": "https://api.github.com/repos/bosens-China/blog/labels/%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83",
          "name": "代码规范",
          "color": "5319e7",
          "default": false,
          "description": "团队规范、代码规范、技术选型等相关内容"
        }
      ],
      "state": "open",
      "locked": false,
      "assignee": null,
      "assignees": [],
      "milestone": null,
      "comments": 0,
      "created_at": "2022-03-31T12:00:40Z",
      "updated_at": "2022-04-16T03:28:38Z",
      "closed_at": null,
      "author_association": "OWNER",
      "active_lock_reason": null,
      "body": "这篇文章的由来是因为项目上的一个神奇问题，之前觉得写重复的创建项目太繁琐就封装了一个[创建模板文件 CLI](https://github.com/bosens-China/template-create) ，当时心想自己真是一个上进的小伙子。\r\n\r\n后来某天 xx 领导对我说有一个新项目交给我做，当时心想终于可以大展拳脚试试新的工具了，一顿操作后项目完成了，不过在推送 GitLab 时发现图片竟然无法预览。why？后面根据 git log 记录一个个回滚和但是这也无法复现 entire，后面又对项目文件屏蔽检查终于发现原来是 .gitattributes 文件填写问题。\r\n\r\n> 之前.gitattributes 写法\r\n>\r\n> ```sh\r\n> * text eol=lf\r\n> ```\r\n\r\n那是不是直接删除 .gitattributes 文件就可以了呢？如果只考虑解决图片提交格式损坏当时是没问题。\r\n\r\n## .gitattributes 作用\r\n\r\n不过回到标题，当时之所以在模板文件中添加 .gitattributes 主要是有两个目的：\r\n\r\n- 确保文件行尾序列符合一致，在 windows 下行尾序列为 CRLF 而在 mac 和 linux 则是 LF。行尾序列不同在某些 Eslint 规则下会显示报错，这是为了规范你的代码。\r\n\r\n![Code File With Prettier Linting Errors - .gitattributes](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/2/11/17033a0f5ed87f6c~tplv-t2oaga2asx-zoom-in-crop-mark:1304:0:0:0.awebp)\r\n\r\n- 避免 git 提交记录莫名差异，例如从仓库下拉取了一个项目，更改了一个某一个文件的内容发现不对又撤销了，但是因为系统不同行尾序列已经发生了变更，git 会显示这个文件的差异。\r\n\r\n![image-20220410152753128.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4843f675b9cd448eaafa3e944cc5d7ec~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n> 以上操作是假设仓库的文件是 LF 格式，且你是 windows 电脑下操作\r\n\r\n## 如何编写.gitattributes 文件\r\n\r\n按照开头我最初的写法肯定是错误的\r\n\r\n```sh\r\n* text eol=lf\r\n```\r\n\r\n这里会把代码的所有文件都 LF 化，对于文本文件是没问题的，但是对于一些图片文件、pdf 等二进制文件就会导致额外的问题。\r\n\r\n这里参考两个库的写法 [v8 .gitattributes](https://github.com/v8/v8/blob/main/.gitattributes)\r\n\r\n```sh\r\n# Automatically normalize line endings (to LF) for all text-based files.\r\n* text=auto eol=lf\r\n# Do not modify line endings for binary files (which are sometimes auto\r\n# detected as text files by git).\r\n*.png binary\r\n# Don't include minified JS in git grep/diff output\r\ntest/mjsunit/asm/sqlite3/*.js -diff\r\n```\r\n\r\n上面会把所有的文件都 LF 化，不同的是单独为需要的资源添加了 binary，而翻阅 git 官方 [gitattributes 文档](https://git-scm.com/docs/gitattributes) 可以看到\r\n\r\n> 如果你不希望产生文本差异，以及行尾转换应用到任何二进制文件。可以使用系统内置的 binary，它会取消 text 和 diff 属性。\r\n\r\n而第三行 `test/mjsunit/asm/sqlite3/*.js -diff` 则是说不要跟踪 diff 差异。\r\n\r\n再来看一个 [pdf .gitattributes](https://github.com/mozilla/pdf.js/blob/master/.gitattributes)\r\n\r\n```sh\r\n# Force Unix line endings for most file formats (except binary files)\r\n*.js         text eol=lf\r\n*.jsm        text eol=lf\r\n*.css        text eol=lf\r\n*.html       text eol=lf\r\n*.md         text eol=lf\r\n*.properties text eol=lf\r\n*.yml        text eol=lf\r\n*.json       text eol=lf\r\n*.config     text eol=lf\r\n*.inc        text eol=lf\r\n*.manifest   text eol=lf\r\n*.rdf        text eol=lf\r\n*.jade       text eol=lf\r\n*.coffee     text eol=lf\r\n\r\n# PDF files shall not modify CRLF line endings\r\n*.pdf -crlf\r\n\r\n# Linguist language overrides\r\n*.js linguist-language=JavaScript\r\n*.jsm linguist-language=JavaScript\r\n*.inc linguist-language=XML\r\n```\r\n\r\n它将资源前置化处理，需要的文件全部 LF 处理，而 `*.pdf -crlf` 则是说强制 crlf 处理，下面的 `linguist-language` 是 [Linguist](https://github.com/github/linguist) 库的属性，它用于生成我们常见的语言分布\r\n\r\n![image-20220410155340149.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f64c46b840a84381bfcea21d0fe87235~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n综合上面两个库来看，有两种编写 .gitattributes 的方式\r\n\r\n### 前置后添加\r\n\r\n这就是 [pdf.js](https://github.com/mozilla/pdf.js) 所采用的，将需要用的序列化，例如如果你是 React 项目，只可能只需要这样指定\r\n\r\n```sh\r\n*.js        text eol=lf\r\n*.jsm       text eol=lf\r\n*.jsx     \ttext eol=lf\r\n*.ts        text eol=lf\r\n*.tsx   \ttext eol=lf\r\n*.json      text eol=lf\r\n*.css       text eol=lf\r\n*.html      text eol=lf\r\n```\r\n\r\n后面如果还有新的需要行尾序列的后缀可以继续添加\r\n\r\n### 全局后添加\r\n\r\n这是 [V8](https://github.com/v8/v8) 的做法，假定所有资源都是文本相关，如果后续有新的二进制文件再对 .gitattributes 文件进行编辑。\r\n\r\n```sh\r\n* text eol=lf\r\n# 如果有新的二进制文件\r\n* png eol=binary\r\n```\r\n\r\n## 迁移指南\r\n\r\n如果你的项目已经存在很久，但是也想添加 .gitattributes 文件来统一行尾序列，下面就介绍一下相关方法。\r\n\r\n1. 添加相关的 .gitattributes 文件到项目（详情见如何编写.gitattributes 文件\r\n2. 运行 `git add .` 添加所有文件\r\n3. 运行 `git commit -m \"Saving files before refreshing line endings\"` 来保存本次更改\r\n4. 删除所有文件，不包括 .git 目录，`git rm -rf --cached .`\r\n5. 运行 `git reset --hard HEAD`，恢复上一次的提交，这里会得到正确的行尾序列\r\n\r\n## 兼容指南\r\n\r\n如果你发现 monorepo 项目中还是没有得到正确的行尾序列，可以参考一下下面 [ .gitattributes 的写法](https://gist.github.com/dpalomar/ebc64d6f56cfc25a3e5c20fe7cdfbd4f)\r\n\r\n```sh\r\n* text=auto\r\n\r\n# Force the following filetypes to have unix eols, so Windows does not break them\r\n*.* text eol=lf\r\n\r\n# Windows forced line-endings\r\n/.idea/* text eol=crlf\r\n\r\n#\r\n## These files are binary and should be left untouched\r\n#\r\n\r\n# (binary is a macro for -text -diff)\r\n*.png binary\r\n```\r\n\r\n添加了兼容性的写法，强制在 window 下 lf 化\r\n\r\n## 最后\r\n\r\n如果文章有相关错误欢迎指出\r\n\r\n> 参考了\r\n>\r\n> - [配置 Git 处理行结束符](https://docs.github.com/cn/get-started/getting-started-with-git/configuring-git-to-handle-line-endings)\r\n",
      "reactions": {
        "url": "https://api.github.com/repos/bosens-China/blog/issues/92/reactions",
        "total_count": 0,
        "+1": 0,
        "-1": 0,
        "laugh": 0,
        "hooray": 0,
        "confused": 0,
        "heart": 0,
        "rocket": 0,
        "eyes": 0
      },
      "timeline_url": "https://api.github.com/repos/bosens-China/blog/issues/92/timeline",
      "performed_via_github_app": null,
      "state_reason": null
    },
    {
      "url": "https://api.github.com/repos/bosens-China/blog/issues/91",
      "repository_url": "https://api.github.com/repos/bosens-China/blog",
      "labels_url": "https://api.github.com/repos/bosens-China/blog/issues/91/labels{/name}",
      "comments_url": "https://api.github.com/repos/bosens-China/blog/issues/91/comments",
      "events_url": "https://api.github.com/repos/bosens-China/blog/issues/91/events",
      "html_url": "https://github.com/bosens-China/blog/issues/91",
      "id": 1187970892,
      "node_id": "I_kwDOCzPAy85Gzv9M",
      "number": 91,
      "title": "yarn.lock 引发的血案",
      "user": {
        "login": "bosens-China",
        "id": 39508895,
        "node_id": "MDQ6VXNlcjM5NTA4ODk1",
        "avatar_url": "https://avatars.githubusercontent.com/u/39508895?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bosens-China",
        "html_url": "https://github.com/bosens-China",
        "followers_url": "https://api.github.com/users/bosens-China/followers",
        "following_url": "https://api.github.com/users/bosens-China/following{/other_user}",
        "gists_url": "https://api.github.com/users/bosens-China/gists{/gist_id}",
        "starred_url": "https://api.github.com/users/bosens-China/starred{/owner}{/repo}",
        "subscriptions_url": "https://api.github.com/users/bosens-China/subscriptions",
        "organizations_url": "https://api.github.com/users/bosens-China/orgs",
        "repos_url": "https://api.github.com/users/bosens-China/repos",
        "events_url": "https://api.github.com/users/bosens-China/events{/privacy}",
        "received_events_url": "https://api.github.com/users/bosens-China/received_events",
        "type": "User",
        "site_admin": false
      },
      "labels": [
        {
          "id": 1371686609,
          "node_id": "MDU6TGFiZWwxMzcxNjg2NjA5",
          "url": "https://api.github.com/repos/bosens-China/blog/labels/JavaScript",
          "name": "JavaScript",
          "color": "F7DF1E",
          "default": false,
          "description": "JavaScript系列的文章"
        }
      ],
      "state": "open",
      "locked": false,
      "assignee": null,
      "assignees": [],
      "milestone": null,
      "comments": 0,
      "created_at": "2022-03-31T11:59:44Z",
      "updated_at": "2022-04-08T11:14:47Z",
      "closed_at": null,
      "author_association": "OWNER",
      "active_lock_reason": null,
      "body": "最近开发项目的时候遇到一个神奇的 bug，在回滚了无数次之后终于定位到了问题，就是 yarn.lock 引起的，当时升级相关依赖版本不小心把 yanr.lock 文件给干掉了，导致依赖引用的模块有问题。\r\n\r\n不过这也引起了我的思考为什么 yarn 要有一个 `yarn.lock` 文件呢？或者说为什么现代的包安装都需要有 lock 文件呢？例如 npm 的叫做 [package-lock.json](http://nodejs.cn/learn/the-package-lock-json-file)，pnpm 的叫做 `pnpm-lock.yaml`。\r\n\r\n后面调查了一下发现其实是为了确认依赖关系，这里以 npm 的发展历史进行讲解。\r\n\r\n## 扁平化依赖安装\r\n\r\n下面的例子都以这张依赖图为例\r\n\r\n![relyon.jpeg](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a70906a65fcb4dab971ee37e894c1e15~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n在 npm5 之前也就是还没有 package-lock.json 之前，会将所有的依赖都下载到 `node_modules` 目录下，如果依赖还依赖其他依赖就会继续下载到依赖本身下的 `node_modules`下，例如上图所示最终会生成如下依赖关系。\r\n\r\n```sh\r\nnode_modules\r\n  modules1\r\n    a:1.0\r\n    b:1.0\r\n  modules2\r\n    a:1.0\r\n    b:2.0\r\n```\r\n\r\n这样做虽然不会遇到依赖管理问题，但是很明显占用磁盘空间太大了。\r\n例如上面有一个共同模块是 `a:1.0`，如果能把相同的依赖提取出来不就是可以大大节省安装时长嘛？\r\n\r\n而且最关键的时因为包的文件体积很小，依赖一旦多起来反复读写反而成为性能的瓶颈。\r\n\r\nnpm5 之后就尝试了扁平化安装，它的思想很简单就是安装的时候如果有子依赖就安装到根目录下的 `node_modules` ，如果还有依赖跟根目录下的依赖冲突就和 npm5 之前的处理方式一样，在子依赖的目录下新建 `node_modules` 然后重复。\r\n以上面的例子演示\r\n\r\n```sh\r\nnpm i modules1 modules2\r\n```\r\n\r\n会得到这样一个依赖\r\n\r\n```sh\r\nnode_modules\r\n  modules1\r\n  a:1.0\r\n  b:1.0\r\n  modules2\r\n    b:2.0\r\n```\r\n\r\n这样做很明显改善了安装时长和节省了磁盘空间，但是带来了一个安装顺序的问题，就是上面是安装 module1 为开始，但是假设安装 module2 为开始呢？\r\n\r\n```sh\r\nnpm i modules2 modules1\r\n```\r\n\r\n会得到这样一个依赖\r\n\r\n```sh\r\nnode_modules\r\n  modules1\r\n  a:1.0\r\n  b:2.0\r\n  modules2\r\n    b:1.0\r\n```\r\n\r\n> 注意，上面不考虑网速等额外情况\r\n\r\n会发现结构已经发生了改变。\r\n\r\n温习一下查找模块的方式：如果在当前 `node_modules` 找不到时会怎么查找？会继续向上查找，直到最顶层为止。\r\n\r\n而 module1 import 的很明显是期待 `b:1.0` 这个依赖，最终却得到了 `b:2.0` 依赖。这就给代码新增了不确定性，我最开始遇到的问题就是这个原因得来的。\r\n\r\n## 解决方式\r\n\r\n上面演示了扁平化依赖可能遇到的依赖不确定问题，那能不能通过新增一个文件来记录模块之间的依赖关系呢，之后安装的时候复用？这就是 yanr.lock、package-lock.lock 和 pnpm-lock.yml 的由来。\r\n\r\n不过除了锁定 lock 文件的这种方式还有什么新的办法呢？pnpm 给出了答案，可以继续采用 npm5 之前的安装方式 + 软连接来解决。\r\n\r\n上面说到因为安装重复的模块导致安装效率很低，才被迫采用提取公共模块的扁平化安装，但是如果把当前项目的模块放到最顶的磁盘文件内，每次安装新的模块先搜寻有没有对应的，如果有给一个软链接而不生成真正文件，这样不就是大大节省了安装效率嘛？虽然 lock 文件还是存在但是已经改善重复磁盘的读写问题。\r\n\r\n## 新的展望\r\n\r\n最近在知乎看到了 [如何看待蚂蚁在 SEEConf 分享的 NPM 安装优化，提速 3 倍之多？](https://www.zhihu.com/question/511006062) 我觉得这可能是后面的网速不断提升但是包安装依然很慢的解决方案，但是目前还未开源所以暂未能体验。\r\n\r\n## 最后\r\n\r\n如果有什么错误欢迎指出。\r\n\r\n> 参考了一些文章：\r\n>\r\n> - [深入浅出 tnpm rapid 模式 - 如何比 pnpm 快 10 秒](https://zhuanlan.zhihu.com/p/455809528)\r\n> - [关于现代包管理器的深度思考——为什么现在我更推荐 pnpm 而不是 npm/yarn?](https://juejin.cn/post/6932046455733485575#heading-7)\r\n",
      "reactions": {
        "url": "https://api.github.com/repos/bosens-China/blog/issues/91/reactions",
        "total_count": 0,
        "+1": 0,
        "-1": 0,
        "laugh": 0,
        "hooray": 0,
        "confused": 0,
        "heart": 0,
        "rocket": 0,
        "eyes": 0
      },
      "timeline_url": "https://api.github.com/repos/bosens-China/blog/issues/91/timeline",
      "performed_via_github_app": null,
      "state_reason": null
    },
    {
      "url": "https://api.github.com/repos/bosens-China/blog/issues/90",
      "repository_url": "https://api.github.com/repos/bosens-China/blog",
      "labels_url": "https://api.github.com/repos/bosens-China/blog/issues/90/labels{/name}",
      "comments_url": "https://api.github.com/repos/bosens-China/blog/issues/90/comments",
      "events_url": "https://api.github.com/repos/bosens-China/blog/issues/90/events",
      "html_url": "https://github.com/bosens-China/blog/issues/90",
      "id": 1115786958,
      "node_id": "I_kwDOCzPAy85CgY7O",
      "number": 90,
      "title": "vite 源码解析之 create-vite ",
      "user": {
        "login": "bosens-China",
        "id": 39508895,
        "node_id": "MDQ6VXNlcjM5NTA4ODk1",
        "avatar_url": "https://avatars.githubusercontent.com/u/39508895?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bosens-China",
        "html_url": "https://github.com/bosens-China",
        "followers_url": "https://api.github.com/users/bosens-China/followers",
        "following_url": "https://api.github.com/users/bosens-China/following{/other_user}",
        "gists_url": "https://api.github.com/users/bosens-China/gists{/gist_id}",
        "starred_url": "https://api.github.com/users/bosens-China/starred{/owner}{/repo}",
        "subscriptions_url": "https://api.github.com/users/bosens-China/subscriptions",
        "organizations_url": "https://api.github.com/users/bosens-China/orgs",
        "repos_url": "https://api.github.com/users/bosens-China/repos",
        "events_url": "https://api.github.com/users/bosens-China/events{/privacy}",
        "received_events_url": "https://api.github.com/users/bosens-China/received_events",
        "type": "User",
        "site_admin": false
      },
      "labels": [
        {
          "id": 3661377607,
          "node_id": "LA_kwDOCzPAy87aPDBH",
          "url": "https://api.github.com/repos/bosens-China/blog/labels/Node%E7%B3%BB%E5%88%97",
          "name": "Node系列",
          "color": "9F9262",
          "default": false,
          "description": "和node.js相关内容"
        }
      ],
      "state": "open",
      "locked": false,
      "assignee": null,
      "assignees": [],
      "milestone": null,
      "comments": 0,
      "created_at": "2022-01-27T05:20:46Z",
      "updated_at": "2022-01-27T05:20:46Z",
      "closed_at": null,
      "author_association": "OWNER",
      "active_lock_reason": null,
      "body": "\r\n![home](https://user-images.githubusercontent.com/39508895/151296625-9fdcf1c2-7cfb-40b8-8c55-4ffe42540073.png)\r\n\r\n\r\n如题这是一个系列文章不过更新起来可能很缓慢，从 [vite](https://github.com/vitejs/vite) 出来之际我就开始关注，目前 [npm](https://www.npmjs.com/package/vite) 的包下载量为 `1,589,416+`，可以看到已经非常稳定了。而且开发十分香，完全就是开箱即用，下面就来探讨一下 vite 是如何将项目创建到目录中的。\r\n\r\n## 使用方式\r\n\r\n目前比较火的管理代码形式为 monorepo，Vue3 和 vite 都采取了这种方式，打开 [packages](https://github.com/vitejs/vite/tree/main/packages) 可以很明显看到分布在 packages 下的各个包，这篇文章重点聊一聊 `create-vite`。\r\n\r\n打开 create-vite 目录可以看到下面结构\r\n\r\n![界面](https://user-images.githubusercontent.com/39508895/151296636-12bc9f7f-8483-42d2-b75b-8a95463e9a7a.png)\r\n\r\n\r\n其中以 **template-** 开头的文件为模板文件，而 \\_\\_test\\_\\_ 开头的是测试文件，`updateVersions.ts` 是更新相关 template 文件夹下的 `package.json` 文件让其与 vite 的版本号保持一致。\r\n\r\n我们重点看 index.js 文件，这个文件负责具体的创建，不过在说源码之前先看下文档的使用形式\r\n\r\n- `npm init vite@latest`\r\n- `npm init vite@latest my-vue-app --template vue`\r\n\r\n这里 init 其实是一个快捷指令，它相当于把 `create-vite` 简化成只需要 `init create-后面部分即可`，yarn 下的 create 也跟 npm init 类似。\r\n\r\n如果直接使用第一种形式，vite 会询问一系列信息，例如包的名称、模板等，而使用第二种形式则可以省略询问信息。\r\n\r\n> [vite 镜像网站](https://vitejs.bootcss.com/guide/#using-unreleased-commits)\r\n\r\n## 源码\r\n\r\nvite-create 使用了三个模块，这里提前说下它们的作用是什么\r\n\r\n### minimist\r\n\r\n[minimist](https://www.npmjs.com/package/minimist) 的作用就是将命令行输入的信息解析出来，例如上面我们使用 `npm init vite@latest my-vue-app --template vue` 它会将其解析成下面内容\r\n\r\n```js\r\n{\r\n  _: ['my-vue-app'],\r\n  template: 'vue'\r\n}\r\n```\r\n\r\n### prompts\r\n\r\n[prompts](https://www.npmjs.com/package/prompts) 则是与用户交互的一个包，它提供了 `input`、`select` 等交互方式，更多内容可以查看文档了解。\r\n\r\n### kolorist\r\n\r\n[kolorist](https://www.npmjs.com/package/kolorist) 它是一个 color 包，主要作用就是让 node 展示的文字更有趣，不再是默认的颜色。\r\n\r\n### 流程\r\n\r\nvite-create 将任务放到了 init 函数中，为了保持阅读体验这里直接在代码中进行讲解\r\n\r\n```js\r\nasync function init() {\r\n  // 获取默认输入的文件夹名称，例如 npm init vite@latest my-vue-app --template vue 这个时候 targetDir 为 my-vue-app\r\n  let targetDir = argv._[0];\r\n  // 获取是否有指定的 template\r\n  let template = argv.template || argv.t;\r\n  // 默认创建项目名称\r\n  const defaultProjectName = !targetDir ? 'vite-project' : targetDir;\r\n  // prompts 返回的一系列结果\r\n  let result = {};\r\n\r\n  /*\r\n   * prompts 如果 type 为 null 不会执行下去，并且 prompts 的 tasks 是按照顺序执行下去的\r\n   */\r\n\r\n  try {\r\n    result = await prompts(\r\n      [\r\n        // 如果没有指定 targetDir 则需要用户手动输入\r\n        {\r\n          type: targetDir ? null : 'text',\r\n          name: 'projectName',\r\n          message: reset('Project name:'),\r\n          initial: defaultProjectName,\r\n          onState: (state) =>\r\n            (targetDir = state.value.trim() || defaultProjectName),\r\n        },\r\n        // 如果目标目录存在，要求用户指定处理方式，是删除还是退出\r\n        {\r\n          type: () =>\r\n            !fs.existsSync(targetDir) || isEmpty(targetDir) ? null : 'confirm',\r\n          name: 'overwrite',\r\n          message: () =>\r\n            (targetDir === '.'\r\n              ? 'Current directory'\r\n              : `Target directory \"${targetDir}\"`) +\r\n            ` is not empty. Remove existing files and continue?`,\r\n        },\r\n        //如果上一步选择删除为 false 退出\r\n        {\r\n          type: (_, { overwrite } = {}) => {\r\n            if (overwrite === false) {\r\n              throw new Error(red('✖') + ' Operation cancelled');\r\n            }\r\n            return null;\r\n          },\r\n          name: 'overwriteChecker',\r\n        },\r\n        // 校验输入项目名称是否符合 npm 名称，如果不符合规则则不能通过\r\n        {\r\n          type: () => (isValidPackageName(targetDir) ? null : 'text'),\r\n          name: 'packageName',\r\n          message: reset('Package name:'),\r\n          initial: () => toValidPackageName(targetDir),\r\n          validate: (dir) =>\r\n            isValidPackageName(dir) || 'Invalid package.json name',\r\n        },\r\n        // 用户如果直接传递的 template 不存在模板中让其重新选择\r\n        {\r\n          type: template && TEMPLATES.includes(template) ? null : 'select',\r\n          name: 'framework',\r\n          message:\r\n            typeof template === 'string' && !TEMPLATES.includes(template)\r\n              ? reset(\r\n                  `\"${template}\" isn't a valid template. Please choose from below: `\r\n                )\r\n              : reset('Select a framework:'),\r\n          initial: 0,\r\n          choices: FRAMEWORKS.map((framework) => {\r\n            const frameworkColor = framework.color;\r\n            return {\r\n              title: frameworkColor(framework.name),\r\n              value: framework,\r\n            };\r\n          }),\r\n        },\r\n        // 选择是 js 项目还是 ts 项目\r\n        {\r\n          type: (framework) =>\r\n            framework && framework.variants ? 'select' : null,\r\n          name: 'variant',\r\n          message: reset('Select a variant:'),\r\n          // @ts-ignore\r\n          choices: (framework) =>\r\n            framework.variants.map((variant) => {\r\n              const variantColor = variant.color;\r\n              return {\r\n                title: variantColor(variant.name),\r\n                value: variant.name,\r\n              };\r\n            }),\r\n        },\r\n      ],\r\n      // 如果没有选择 crrl + c 退出\r\n      {\r\n        onCancel: () => {\r\n          throw new Error(red('✖') + ' Operation cancelled');\r\n        },\r\n      }\r\n    );\r\n  } catch (cancelled) {\r\n    console.log(cancelled.message);\r\n    return;\r\n  }\r\n\r\n  // user choice associated with prompts\r\n  const { framework, overwrite, packageName, variant } = result;\r\n\r\n  const root = path.join(cwd, targetDir);\r\n  // 上面提到了如果目录存在，则要求进行删除\r\n  if (overwrite) {\r\n    emptyDir(root);\r\n  } else if (!fs.existsSync(root)) {\r\n    // 如果不存在目录创建\r\n    fs.mkdirSync(root);\r\n  }\r\n\r\n  // determine template\r\n  template = variant || framework || template;\r\n\r\n  console.log(`\\nScaffolding project in ${root}...`);\r\n\r\n  // 当前模板文件所在路径\r\n  const templateDir = path.join(__dirname, `template-${template}`);\r\n\r\n  const write = (file, content) => {\r\n    const targetPath = renameFiles[file]\r\n      ? path.join(root, renameFiles[file])\r\n      : path.join(root, file);\r\n    if (content) {\r\n      fs.writeFileSync(targetPath, content);\r\n    } else {\r\n      copy(path.join(templateDir, file), targetPath);\r\n    }\r\n  };\r\n\r\n  /*\r\n   * 写入文件，package.json 单独处理\r\n   */\r\n  const files = fs.readdirSync(templateDir);\r\n  for (const file of files.filter((f) => f !== 'package.json')) {\r\n    write(file);\r\n  }\r\n\r\n  const pkg = require(path.join(templateDir, `package.json`));\r\n\r\n  pkg.name = packageName || targetDir;\r\n\r\n  write('package.json', JSON.stringify(pkg, null, 2));\r\n\r\n  // 这里是查看调用程序的是 yarn 还是 npm 或者 pnpm\r\n  const pkgInfo = pkgFromUserAgent(process.env.npm_config_user_agent);\r\n  const pkgManager = pkgInfo ? pkgInfo.name : 'npm';\r\n\r\n  console.log(`\\nDone. Now run:\\n`);\r\n  if (root !== cwd) {\r\n    console.log(`  cd ${path.relative(cwd, root)}`);\r\n  }\r\n  switch (pkgManager) {\r\n    case 'yarn':\r\n      console.log('  yarn');\r\n      console.log('  yarn dev');\r\n      break;\r\n    default:\r\n      console.log(`  ${pkgManager} install`);\r\n      console.log(`  ${pkgManager} run dev`);\r\n      break;\r\n  }\r\n  console.log();\r\n}\r\n```\r\n\r\n上面的流程还是很清晰的概括下来就是\r\n\r\n- 要求用户输入创建所需要的项目名称（如果用户指定跳过\r\n- 如果项目存在，则询问是否删除\r\n- 校验输入的名称是否符合 `npm.name` 的要求\r\n- 如果用户指定 template 则进行校验，指定 template 如果不存在重新要求选择\r\n- 拉取指定模板仓库，将其 copy 到目标文件夹下\r\n- 修改 package.json 文件输入\r\n- 输出完成信息，结束\r\n\r\n之前讲解 `init` 函数为了阅读省略了一些前置定义的变量，这里放出来。\r\n\r\n```js\r\nconst cwd = process.cwd();\r\n\r\nconst FRAMEWORKS = [\r\n  {\r\n    name: 'vanilla',\r\n    color: yellow,\r\n    variants: [\r\n      {\r\n        name: 'vanilla',\r\n        display: 'JavaScript',\r\n        color: yellow,\r\n      },\r\n      {\r\n        name: 'vanilla-ts',\r\n        display: 'TypeScript',\r\n        color: blue,\r\n      },\r\n    ],\r\n  },\r\n  {\r\n    name: 'vue',\r\n    color: green,\r\n    variants: [\r\n      {\r\n        name: 'vue',\r\n        display: 'JavaScript',\r\n        color: yellow,\r\n      },\r\n      {\r\n        name: 'vue-ts',\r\n        display: 'TypeScript',\r\n        color: blue,\r\n      },\r\n    ],\r\n  },\r\n  {\r\n    name: 'react',\r\n    color: cyan,\r\n    variants: [\r\n      {\r\n        name: 'react',\r\n        display: 'JavaScript',\r\n        color: yellow,\r\n      },\r\n      {\r\n        name: 'react-ts',\r\n        display: 'TypeScript',\r\n        color: blue,\r\n      },\r\n    ],\r\n  },\r\n  {\r\n    name: 'preact',\r\n    color: magenta,\r\n    variants: [\r\n      {\r\n        name: 'preact',\r\n        display: 'JavaScript',\r\n        color: yellow,\r\n      },\r\n      {\r\n        name: 'preact-ts',\r\n        display: 'TypeScript',\r\n        color: blue,\r\n      },\r\n    ],\r\n  },\r\n  {\r\n    name: 'lit',\r\n    color: lightRed,\r\n    variants: [\r\n      {\r\n        name: 'lit',\r\n        display: 'JavaScript',\r\n        color: yellow,\r\n      },\r\n      {\r\n        name: 'lit-ts',\r\n        display: 'TypeScript',\r\n        color: blue,\r\n      },\r\n    ],\r\n  },\r\n  {\r\n    name: 'svelte',\r\n    color: red,\r\n    variants: [\r\n      {\r\n        name: 'svelte',\r\n        display: 'JavaScript',\r\n        color: yellow,\r\n      },\r\n      {\r\n        name: 'svelte-ts',\r\n        display: 'TypeScript',\r\n        color: blue,\r\n      },\r\n    ],\r\n  },\r\n];\r\n\r\nconst TEMPLATES = FRAMEWORKS.map(\r\n  (f) => (f.variants && f.variants.map((v) => v.name)) || [f.name]\r\n).reduce((a, b) => a.concat(b), []);\r\n\r\nconst renameFiles = {\r\n  _gitignore: '.gitignore',\r\n};\r\n```\r\n\r\n`FRAMEWORKS` 定义了模板的信息，而 `TEMPLATES` 简单来说就是将 `TEMPLATES.name` 下的信息返回，\r\n配合 prompts 做校验和重新选择使用，它的值如下\r\n\r\n```js\r\n[\r\n  'vanilla',\r\n  'vanilla-ts',\r\n  'vue',\r\n  'vue-ts',\r\n  'react',\r\n  'react-ts',\r\n  'preact',\r\n  'preact-ts',\r\n  'lit',\r\n  'lit-ts',\r\n  'svelte',\r\n  'svelte-ts',\r\n];\r\n```\r\n\r\n`renameFiles` 则是重命名文件，将一些特殊的文件重新命名输出。\r\n\r\n当然 vite-create 也用了 `fs` 的 `path` 的一些方法，这里选取重点的几个函数讲解，剩余的几个函数可以自行去源码查看 [create-vite/index.js](https://github.com/vitejs/vite/blob/main/packages/create-vite/index.js)\r\n\r\n**emptyDir**\r\n\r\n```js\r\nfunction emptyDir(dir) {\r\n  if (!fs.existsSync(dir)) {\r\n    return;\r\n  }\r\n  for (const file of fs.readdirSync(dir)) {\r\n    const abs = path.resolve(dir, file);\r\n    // baseline is Node 12 so can't use rmSync :(\r\n    if (fs.lstatSync(abs).isDirectory()) {\r\n      emptyDir(abs);\r\n      fs.rmdirSync(abs);\r\n    } else {\r\n      fs.unlinkSync(abs);\r\n    }\r\n  }\r\n}\r\n```\r\n\r\n这个方法是删除文件夹，node 的删除文件夹必须保证文件夹内没有文件，所以需要递归一层层的删除。\r\n\r\n**isEmpty**\r\n\r\n```js\r\nfunction isEmpty(path) {\r\n  return fs.readdirSync(path).length === 0;\r\n}\r\n```\r\n\r\n这个方法比较简单，判断目标文件夹的文件数量，如果不存在表示为空。\r\n\r\n**copy**\r\n\r\n```js\r\nfunction copy(src, dest) {\r\n  const stat = fs.statSync(src);\r\n  if (stat.isDirectory()) {\r\n    copyDir(src, dest);\r\n  } else {\r\n    fs.copyFileSync(src, dest);\r\n  }\r\n}\r\n```\r\n\r\n配合 `copyDir` 方法，来完成整体 `copy` 目录的操作\r\n\r\n**copyDir**\r\n\r\n```js\r\nfunction copyDir(srcDir, destDir) {\r\n  fs.mkdirSync(destDir, { recursive: true });\r\n  for (const file of fs.readdirSync(srcDir)) {\r\n    const srcFile = path.resolve(srcDir, file);\r\n    const destFile = path.resolve(destDir, file);\r\n    copy(srcFile, destFile);\r\n  }\r\n}\r\n```\r\n\r\n将 src 目录下的内容 copy 到 dest 下，这里首先创建 destDir 目录，之后调用 copy 方法，而 `copy` 方法只会拷贝文件如果是文件夹继续调用 `copyDir`。\r\n\r\n## \\_\\_test\\_\\_\r\n\r\n上面已经把 create-vite 创建的流程讲了一遍，不过在软件开发中单元测试也是一个大头，所以这里看下 vite-create 是怎么写的单元测试。\r\n\r\n在 `cli.spec.ts` 文件中，vite 引用了两个库\r\n\r\n- [execa](https://github.com/sindresorhus/execa)：封装 `child_process` 使用起来更加方便；\r\n- [fs-extra](https://github.com/jprichardson/node-fs-extra)：封装的 fs 库，提供了更高级的用法，例如 copy、remove 等；\r\n\r\n在 jest 运行之前 cli.spce.ts 定义了一些变量\r\n\r\n```js\r\n// ..返回到 index.js,package.json 存在的这个目录\r\nconst CLI_PATH = join(__dirname, '..');\r\n// 项目名称\r\nconst projectName = 'test-app';\r\n// 生成的目录路径\r\nconst genPath = join(__dirname, projectName);\r\n\r\n/*\r\n * 封装的 run 方法，node CLI_PATH 会默认执行 CLI_PATH 下 index.js 文件\r\n */\r\nconst run = (\r\n  args: string[],\r\n  options: SyncOptions<string> = {}\r\n): ExecaSyncReturnValue<string> => {\r\n  return commandSync(`node ${CLI_PATH} ${args.join(' ')}`, options);\r\n};\r\n\r\n/*\r\n * 写入 package.json 文件，为了方便测试后续的 package.json 信息\r\n */\r\n// Helper to create a non-empty directory\r\nconst createNonEmptyDir = () => {\r\n  // Create the temporary directory\r\n  mkdirpSync(genPath);\r\n\r\n  // Create a package.json file\r\n  const pkgJson = join(genPath, 'package.json');\r\n  writeFileSync(pkgJson, '{ \"foo\": \"bar\" }');\r\n};\r\n\r\n// Vue 3 starter template\r\nconst templateFiles = readdirSync(join(CLI_PATH, 'template-vue'))\r\n  // _gitignore is renamed to .gitignore\r\n  .map((filePath) => (filePath === '_gitignore' ? '.gitignore' : filePath))\r\n  .sort();\r\n\r\n// 运行之前执行步骤，只会执行一次\r\nbeforeAll(() => remove(genPath));\r\n// 每次运行之后执行步骤\r\nafterEach(() => remove(genPath));\r\n```\r\n\r\nok，上面就把一些关键的点说了，我们来逐条分析测试用例\r\n\r\n### prompts for the project name if none supplied\r\n\r\n```js\r\ntest('prompts for the project name if none supplied', () => {\r\n  const { stdout, exitCode } = run([]);\r\n  expect(stdout).toContain('Project name:');\r\n});\r\n```\r\n\r\n[toContain](https://jestjs.io/zh-Hans/docs/expect) 作用简单来说就是匹配数组有没有当前值信息，这条 test 是为了验证如果没有输入项目名称是否出现 prompts 交互信息\r\n\r\n> 这里可以出现交互得益于使用的 execa 库，这个是它的功能之一\r\n\r\n### prompts for the framework if none supplied\r\n\r\n```js\r\ntest('prompts for the framework if none supplied', () => {\r\n  const { stdout } = run([projectName]);\r\n  expect(stdout).toContain('Select a framework:');\r\n});\r\n```\r\n\r\n按照 init 函数的分析，输入名称并且项目没有重复的，且用户也没有指定 template 就需要选择框架了，这条 jest 就是为了测试 prompts 顺序。\r\n\r\n### prompts for the framework on not supplying a value for --template\r\n\r\n```js\r\ntest('prompts for the framework on not supplying a value for --template', () => {\r\n  const { stdout } = run([projectName, '--template']);\r\n  expect(stdout).toContain('Select a framework:');\r\n});\r\n```\r\n\r\n继续测试 framework 情况。如果指定 `--template` 但是没有指定 vue、react， minimist 会将其解析成 true，当然也不符合情况。\r\n\r\n### prompts for the framework on supplying an invalid template\r\n\r\n```js\r\ntest('prompts for the framework on supplying an invalid template', () => {\r\n  const { stdout } = run([projectName, '--template', 'unknown']);\r\n  expect(stdout).toContain(\r\n    `\"unknown\" isn't a valid template. Please choose from below:`\r\n  );\r\n});\r\n```\r\n\r\n指定错误的 template 会出现错误提示，校验 init 函数的验证。\r\n\r\n### asks to overwrite non-empty target directory\r\n\r\n```js\r\ntest('asks to overwrite non-empty target directory', () => {\r\n  createNonEmptyDir();\r\n  const { stdout } = run([projectName], { cwd: __dirname });\r\n  expect(stdout).toContain(`Target directory \"${projectName}\" is not empty.`);\r\n});\r\n```\r\n\r\n测试项目目录如果存在情况，createNonEmptyDir 这个方法前面有讲到，确保目录一定存在并且写入一些 package.json 信息。\r\n\r\n### asks to overwrite non-empty current directory\r\n\r\n```js\r\ntest('asks to overwrite non-empty current directory', () => {\r\n  createNonEmptyDir();\r\n  const { stdout } = run(['.'], { cwd: genPath, input: 'test-app\\n' });\r\n  expect(stdout).toContain(`Current directory is not empty.`);\r\n});\r\n```\r\n\r\n测试输入项目名称不能为 `.`，`.` 会返回当前 `process.cwd()` 目录，按照 init 函数的流程，如果目录存在会提示是否删除，如果执行了删除就是一个重大 bug 了。\r\n\r\n### successfully scaffolds a project based on vue starter template\r\n\r\n```js\r\ntest('successfully scaffolds a project based on vue starter template', () => {\r\n  const { stdout } = run([projectName, '--template', 'vue'], {\r\n    cwd: __dirname,\r\n  });\r\n  const generatedFiles = readdirSync(genPath).sort();\r\n\r\n  // Assertions\r\n  expect(stdout).toContain(`Scaffolding project in ${genPath}`);\r\n  expect(templateFiles).toEqual(generatedFiles);\r\n});\r\n```\r\n\r\n这里测试了两条\r\n\r\n- 走完了所有流程；\r\n- 确定输出的文件信息和 templateFiles 是一样的；\r\n\r\n### works with the -t alias\r\n\r\n```js\r\ntest('works with the -t alias', () => {\r\n  const { stdout } = run([projectName, '-t', 'vue'], {\r\n    cwd: __dirname,\r\n  });\r\n  const generatedFiles = readdirSync(genPath).sort();\r\n\r\n  // Assertions\r\n  expect(stdout).toContain(`Scaffolding project in ${genPath}`);\r\n  expect(templateFiles).toEqual(generatedFiles);\r\n});\r\n```\r\n\r\n这里主要是测试简写语法是否可以识别。\r\n\r\n## 最后\r\n\r\n如果文章有错别字或者不对的地方欢迎指出。\r\n",
      "reactions": {
        "url": "https://api.github.com/repos/bosens-China/blog/issues/90/reactions",
        "total_count": 0,
        "+1": 0,
        "-1": 0,
        "laugh": 0,
        "hooray": 0,
        "confused": 0,
        "heart": 0,
        "rocket": 0,
        "eyes": 0
      },
      "timeline_url": "https://api.github.com/repos/bosens-China/blog/issues/90/timeline",
      "performed_via_github_app": null,
      "state_reason": null
    },
    {
      "url": "https://api.github.com/repos/bosens-China/blog/issues/89",
      "repository_url": "https://api.github.com/repos/bosens-China/blog",
      "labels_url": "https://api.github.com/repos/bosens-China/blog/issues/89/labels{/name}",
      "comments_url": "https://api.github.com/repos/bosens-China/blog/issues/89/comments",
      "events_url": "https://api.github.com/repos/bosens-China/blog/issues/89/events",
      "html_url": "https://github.com/bosens-China/blog/issues/89",
      "id": 1103349199,
      "node_id": "I_kwDOCzPAy85Bw8XP",
      "number": 89,
      "title": "使用 TypeScript 来编写 cli 程序",
      "user": {
        "login": "bosens-China",
        "id": 39508895,
        "node_id": "MDQ6VXNlcjM5NTA4ODk1",
        "avatar_url": "https://avatars.githubusercontent.com/u/39508895?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bosens-China",
        "html_url": "https://github.com/bosens-China",
        "followers_url": "https://api.github.com/users/bosens-China/followers",
        "following_url": "https://api.github.com/users/bosens-China/following{/other_user}",
        "gists_url": "https://api.github.com/users/bosens-China/gists{/gist_id}",
        "starred_url": "https://api.github.com/users/bosens-China/starred{/owner}{/repo}",
        "subscriptions_url": "https://api.github.com/users/bosens-China/subscriptions",
        "organizations_url": "https://api.github.com/users/bosens-China/orgs",
        "repos_url": "https://api.github.com/users/bosens-China/repos",
        "events_url": "https://api.github.com/users/bosens-China/events{/privacy}",
        "received_events_url": "https://api.github.com/users/bosens-China/received_events",
        "type": "User",
        "site_admin": false
      },
      "labels": [
        {
          "id": 3661377607,
          "node_id": "LA_kwDOCzPAy87aPDBH",
          "url": "https://api.github.com/repos/bosens-China/blog/labels/Node%E7%B3%BB%E5%88%97",
          "name": "Node系列",
          "color": "9F9262",
          "default": false,
          "description": "和node.js相关内容"
        }
      ],
      "state": "open",
      "locked": false,
      "assignee": null,
      "assignees": [],
      "milestone": null,
      "comments": 0,
      "created_at": "2022-01-14T09:35:23Z",
      "updated_at": "2022-01-14T09:37:18Z",
      "closed_at": null,
      "author_association": "OWNER",
      "active_lock_reason": null,
      "body": "新的一年已经开始，之前在知乎刷到一篇新年展望贴 [2022 前端技术领域会有哪些新的变化？](https://www.zhihu.com/question/493891614/answer/2269197391)，里面的小伙伴回答了很多，这里稍微归纳一下回答：\r\n\r\n- Monorepo\r\n- TypeScript\r\n- ESBuild\r\n- ESM 化\r\n- pnpm\r\n- ...\r\n\r\n上面的回答中 `TypeScript` 提及的次数很多，原因很是随着项目复杂程度的日趋增加，需要对代码进行一个严格管理，且 TypeScript 对编辑器的智能提示太香了，用完之后根本没办法拒绝。且越多框架和生态都在往其迁徙，作为 er 的一份子，我们也应当进行拥抱。\r\n\r\n这里以 node cli 的开发场景进行举例，因为它的使用随处可见，例如 `vite`、`react` 或者内部自己使用的脚手架。\r\n\r\n## 如何开发命令行\r\n\r\n> 这里推荐一下阮一峰的 [Node.js 命令行程序开发教程](https://www.ruanyifeng.com/blog/2015/05/command-line-with-node.html) 文章，因为篇幅的问题，这里不过多讲解无关内容。\r\n\r\n在编写一个命令行程序之前通常会做两件事情：\r\n\r\n1. 在入口文件第一行添加 `#!/usr/bin/env node`，它的意思是告诉系统如何正确处理这个脚本；\r\n2. 在`package.json`的 bin 字段下添加脚本的名称跟路径，例如：\r\n\r\n```json\r\nbin: {\r\n    \"create\": \"xxx\"\r\n}\r\n```\r\n\r\n上面 bin 字段会在安装 package 的时候将 `bin 命令` 放置到 `node_modules` 下的 `bin 目录`。\r\n\r\n平时使用的 webpack 之所以在 `scripts` 执行的 `webpack xxx` 可以通过，就是因为查找 `bin 目录` 存在 webpack 的命令。\r\n\r\n回到主题，上面说了使用 TypeScript 的原因是因为程序的复杂程度在日趋增加，那如果我们想使用 TypeScript 来开发一个 cli 程序有正确的姿势是什么呢？\r\n\r\n直接在 TypeScript 的文件上添加 `#!/usr/bin/env node` ？\r\n\r\n```ts\r\n#!/usr/bin/env node\r\nconst obj: Obj = {};\r\n// xxx\r\n```\r\n\r\n上面的做法肯定不行，因为 node 并不认识这些语法，下面就来列举一下日常使用的方式。\r\n\r\n## tsc\r\n\r\ntsc 是安装 TypeScript 提供给我们的一个命令，它的作用就是编译 TypeScript 文件，例如\r\n\r\n```sh\r\ntsc index.ts\r\n```\r\n\r\n如果目录存在 `tsconfig.json` 文件，运行 tsc 会将所有符合的 TypeScript 文件输出到 `outDir` 目录下。\r\n\r\n不过使用 tsc 来完成构建有两点问题：\r\n\r\n- 不能清理死代码；\r\n- 输出的 `outDir`没有跟资源文件进行绑定；\r\n\r\n第一点很好理解，我们使用 rollup 等工具，在指定 input 文件的时候会进行一个依赖收集，如果没有执行到的代码就是一个死代码，不会被最终 build 出来，不过使用 tsc 很显然它是没有这个能力的。\r\n\r\n而第二点说的则是，如果 cli 工具需要完成拉取目录的操作，例如\r\n\r\n```sh\r\n- index.ts\r\n- template-modules\r\n- template-server\r\n- template-react\r\n```\r\n\r\n上面 `index.ts` 是程序入口文件，而其他的 `template 文件夹` 只是静态资源，平时使用 JavaScript 通过 `__dirname + 文件夹名称` 即可确定目录，而现在使用 tsc，它只会将 `index.ts` 输出到 `outDir` 下，假设 `outDir` 为 `'./dist'`\r\n\r\n```sh\r\n- dist\r\n-  index.ts\r\n- template-modules\r\n- template-server\r\n- template-react\r\n```\r\n\r\n如果还按照 `__dirname + 文件夹名称` 形式运行代码是获取不到 template 等文件夹的。\r\n\r\n综合来看，如果项目很简单可以使用 tsc 的形式，而如果包含 `__dirname` 语法或者静态资源的项目则需要注意路径问题。\r\n\r\n## rollup\r\n\r\nrollup 是下一代的打包器，vue 和 react 都使用此进行打包，因为它的使用很简单其次生成的代码比 webpack 更可读体积更小。\r\n\r\n使用 rollup 同样也可以完成 cli 打包，只需要在 `rollup.config.js` 进行相关的配置即可，下面以我最常用的配置为例\r\n\r\n```js\r\n/* eslint-disable @typescript-eslint/indent */\r\n\r\nimport fs from \"fs-extra\";\r\nimport { defineConfig } from \"rollup\";\r\nimport { babel } from \"@rollup/plugin-babel\";\r\nimport commonjs from \"@rollup/plugin-commonjs\";\r\nimport path from \"path\";\r\nimport json from \"@rollup/plugin-json\";\r\nimport { preserveShebangs } from \"rollup-plugin-preserve-shebangs\";\r\nimport { terser } from \"rollup-plugin-terser\";\r\nimport { nodeResolve } from \"@rollup/plugin-node-resolve\";\r\nimport { dependencies } from \"../package.json\";\r\nimport { cwd } from \"process\";\r\nimport copyPlugin from \"rollup-plugin-copy\";\r\nimport { string } from \"rollup-plugin-string\";\r\nimport config from \"./config\";\r\n\r\nimport { DEFAULT_EXTENSIONS } from \"@babel/core\";\r\n\r\nconst extensions = [...DEFAULT_EXTENSIONS, \".ts\"];\r\n\r\nconst dist = path.join(cwd(), \"dist\");\r\nfs.removeSync(dist);\r\n\r\nexport default defineConfig(\r\n  config.map((item) => {\r\n    const { name } = path.parse(item.src);\r\n    // copy文件\r\n    const copy = item.copy || [];\r\n\r\n    return defineConfig({\r\n      input: item.src,\r\n      // 禁止打包外部依赖\r\n      external: [...Object.keys(dependencies), \"@babel/runtime\"],\r\n      plugins: [\r\n        nodeResolve({ extensions, rootDir: __dirname }),\r\n        commonjs(),\r\n        json(),\r\n        babel({\r\n          babelHelpers: \"runtime\",\r\n          exclude: /exclude/,\r\n          extensions,\r\n          presets: [[\"@babel/preset-env\"], \"@babel/preset-typescript\"],\r\n          // 禁止打包重复模块\r\n          plugins: [\"@babel/plugin-transform-runtime\"],\r\n        }),\r\n        terser(),\r\n        copyPlugin({\r\n          targets: copy.map((item) => {\r\n            return { src: item, dest: dist };\r\n          }),\r\n        }),\r\n        preserveShebangs(),\r\n        // 导入非js资源\r\n        string({\r\n          include: \"**/*.{md,html}\",\r\n          exclude: [],\r\n        }),\r\n      ],\r\n      output: {\r\n        file: path.join(\r\n          dist,\r\n          item.format === \"cjs\" ? `${name}.js` : `${name}.${item.format}.js`\r\n        ),\r\n        format: item.format,\r\n        sourcemap: true,\r\n        exports: \"auto\",\r\n      },\r\n    });\r\n  })\r\n);\r\n```\r\n\r\n指定 inout 运行 rollup 即可完成打包，不过使用 rollup 打包同样也有优缺点\r\n\r\n### 优点\r\n\r\n- 可以清除无效代码；\r\n- 可以进行代码压缩；\r\n\r\n### 缺点\r\n\r\n- 书写代码需要配置，以及每次发布之前都需要 build（虽然可以 watch，但是也是占用资源；\r\n- 导入静态资源，例如上面 tsc 举例拉取静态资源的时候，需要配置插件将资源复制到 build 目录下，之后通过 `__dirname` 形式来使用\r\n\r\n## ts-node\r\n\r\n除了上面介绍的两种，还可以使用 ts-node 来完成，最开头的时候讲了开发 cli 不能直接使用 TypeScript 的原因就是 node 不识别语法，那如果可以做到运行时编译到 JavaScript 不久可以了吗？\r\n\r\n入口文件还是一个普通的 JavaScript 文件，后续的文件通过 ts-node 来解析语法运行。\r\n\r\n```js\r\n#!/usr/bin/env node\r\nrequire(\"ts-node\").register({\r\n  /* options */\r\n});\r\n// 后面可以直接加载ts文件\r\nrequire(\"./index.ts\");\r\n```\r\n\r\n> 更多选项可以参考 https://typestrong.org/ts-node/api/interfaces/RegisterOptions.html\r\n\r\n### 优点\r\n\r\n- 改动很小，跟原生 TypeScript 写法没区别；\r\n\r\n### 缺点\r\n\r\n- 不支持死代码去除；\r\n- 运行速度很慢；\r\n\r\n使用 ts-node 最致命的缺点还是加载很慢，因为是运行时解析，且还会校验 TypeScript 文件。\r\n\r\n## es-build\r\n\r\n这是基于 ts-node 思路来的变异方法，es-build 是基于 go 语言开发的打包器，它去除了运行时校验，支持并发。\r\n\r\n这里贴一张官方的对比图来进行展示，如果想了解更多内容请查看 [官方](https://esbuild.github.io/)。\r\n![image](https://user-images.githubusercontent.com/39508895/149493087-842eb40e-4a2e-4eac-9f48-a4f1cbc5a4b1.png)\r\n\r\n\r\nes-build 会将代码编译，不过这里我们需要的是直接运行，es-build 没有提供相关的方法。我们取巧一下在将入口文件 require 导入的 TypeScript 文件全部编译，之后写到TypeScript文件目录下运行，运行程序结束之后删除文件。\r\n\r\n幸运的是，不需要手动来完成这样一件事情，社区已经有相关的库 [esbuild-register](https://github.com/egoist/esbuild-register)，我们直接使用即可。\r\n\r\n```js\r\n#!/usr/bin/env node\r\nrequire(\"esbuild-register/dist/node\");\r\n// 后面可以直接加载ts文件\r\nrequire(\"./index.ts\");\r\n```\r\n\r\n当前优缺点跟 ts-node 基本相同，运行速度慢得到了改变。\r\n\r\n## 最后\r\n\r\n综合来看，如果你想享受 TypeScript 语法不想做太多的改动，es-build 的方案绝对是最佳实践，虽然不支持 rollup 等这样的生态，但是结合 eslint 的工具对代码进行检查，还是可以很大程度改善。\r\n\r\n如果文章有什么错别字或者讲解不对地方欢迎指出，如果对你有帮助可以 `star` 支持一下。\r\n",
      "reactions": {
        "url": "https://api.github.com/repos/bosens-China/blog/issues/89/reactions",
        "total_count": 0,
        "+1": 0,
        "-1": 0,
        "laugh": 0,
        "hooray": 0,
        "confused": 0,
        "heart": 0,
        "rocket": 0,
        "eyes": 0
      },
      "timeline_url": "https://api.github.com/repos/bosens-China/blog/issues/89/timeline",
      "performed_via_github_app": null,
      "state_reason": null
    },
    {
      "url": "https://api.github.com/repos/bosens-China/blog/issues/82",
      "repository_url": "https://api.github.com/repos/bosens-China/blog",
      "labels_url": "https://api.github.com/repos/bosens-China/blog/issues/82/labels{/name}",
      "comments_url": "https://api.github.com/repos/bosens-China/blog/issues/82/comments",
      "events_url": "https://api.github.com/repos/bosens-China/blog/issues/82/events",
      "html_url": "https://github.com/bosens-China/blog/issues/82",
      "id": 1085661350,
      "node_id": "I_kwDOCzPAy85AteCm",
      "number": 82,
      "title": "Babel to Class之私有属性（3）",
      "user": {
        "login": "bosens-China",
        "id": 39508895,
        "node_id": "MDQ6VXNlcjM5NTA4ODk1",
        "avatar_url": "https://avatars.githubusercontent.com/u/39508895?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bosens-China",
        "html_url": "https://github.com/bosens-China",
        "followers_url": "https://api.github.com/users/bosens-China/followers",
        "following_url": "https://api.github.com/users/bosens-China/following{/other_user}",
        "gists_url": "https://api.github.com/users/bosens-China/gists{/gist_id}",
        "starred_url": "https://api.github.com/users/bosens-China/starred{/owner}{/repo}",
        "subscriptions_url": "https://api.github.com/users/bosens-China/subscriptions",
        "organizations_url": "https://api.github.com/users/bosens-China/orgs",
        "repos_url": "https://api.github.com/users/bosens-China/repos",
        "events_url": "https://api.github.com/users/bosens-China/events{/privacy}",
        "received_events_url": "https://api.github.com/users/bosens-China/received_events",
        "type": "User",
        "site_admin": false
      },
      "labels": [
        {
          "id": 1908144759,
          "node_id": "MDU6TGFiZWwxOTA4MTQ0NzU5",
          "url": "https://api.github.com/repos/bosens-China/blog/labels/ES6%E7%B3%BB%E5%88%97",
          "name": "ES6系列",
          "color": "0366d6",
          "default": false,
          "description": "ES6的最新语法"
        }
      ],
      "state": "open",
      "locked": false,
      "assignee": null,
      "assignees": [],
      "milestone": null,
      "comments": 0,
      "created_at": "2021-12-21T10:13:22Z",
      "updated_at": "2021-12-28T09:51:19Z",
      "closed_at": null,
      "author_association": "OWNER",
      "active_lock_reason": null,
      "body": "## 前言\r\n\r\n这是《Babel to Class》系列的第三篇\r\n\r\n- [Babel to Class之编译（1）](https://github.com/bosens-China/blog/issues/80)\r\n- [Babel to Class 做了什么（2）](https://github.com/bosens-China/blog/issues/81)\r\n- [Babel to Class之原生构造函数继承（4）](https://github.com/bosens-China/blog/issues/88)\r\n\r\n这个系列主要讲 Class 的普通写法、继承、私有属性和原生构造函数继承 `babel` 是如何实现这一过程的。\r\n> 注：文章顺序存在关联，请按照顺序阅读。\r\n\r\n## 前置知识点\r\n\r\n### WeakMap\r\n\r\n`WeakMap` 是 ES6 新加入的数据结构，它与 `map` 类似，但是键为弱引用。\r\n\r\n> 弱引用就是指不计入垃圾回收次数，当引用被垃圾回收 `WeakMap` 对应键值自动消失。\r\n\r\n> 更多内容请参考[文档](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/WeakMap)\r\n\r\n### WeakSet\r\n\r\n与 `WeakMap` 类似，不同在于 `WeakSet` 只有键名，没有键值。\r\n\r\n> 更多内容请参考[文档](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/WeakSet)\r\n\r\n### Class 私有属性\r\n\r\n之前 `Class` 要实现私有属性只能通过，`Symbol` 或者外部变量来实现，不过都各有缺点，现在新的提案 [proposal-private-methods](https://github.com/tc39/proposal-private-methods) 添加了私有属性和私有方法，使用方式很简单，直接`#<name>`即可。\r\n\r\n```js\r\nclass Test {\r\n  #age = 12;\r\n  #getage() {}\r\n}\r\n```\r\n\r\n私有属性只能在构造函数内部调用，如果在非内部调用则抛出异常（在 static 上调用也是可以的）。\r\n\r\n## 示例文件\r\n\r\n```js\r\nclass Test {\r\n  #age = 17;\r\n  static #name = 'zhangsan';\r\n\r\n  #getAge() {\r\n    console.log(this.#age);\r\n  }\r\n  static #getName() {\r\n    console.log(this.#name);\r\n  }\r\n\r\n  all() {\r\n    this.#getAge();\r\n    Test.#getName();\r\n  }\r\n}\r\nconst test = new Test();\r\ntest.all();\r\n```\r\n\r\n以下内容根据此文件进行讲解。\r\n\r\n## babel\r\n\r\n```js\r\n'use strict';\r\n\r\nfunction _classCallCheck(instance, Constructor) {\r\n  if (!(instance instanceof Constructor)) {\r\n    throw new TypeError('Cannot call a class as a function');\r\n  }\r\n}\r\n\r\nfunction _defineProperties(target, props) {\r\n  for (var i = 0; i < props.length; i++) {\r\n    var descriptor = props[i];\r\n    descriptor.enumerable = descriptor.enumerable || false;\r\n    descriptor.configurable = true;\r\n    if ('value' in descriptor) descriptor.writable = true;\r\n    Object.defineProperty(target, descriptor.key, descriptor);\r\n  }\r\n}\r\n\r\nfunction _createClass(Constructor, protoProps, staticProps) {\r\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\r\n  if (staticProps) _defineProperties(Constructor, staticProps);\r\n  Object.defineProperty(Constructor, 'prototype', { writable: false });\r\n  return Constructor;\r\n}\r\n\r\nfunction _classPrivateMethodInitSpec(obj, privateSet) {\r\n  _checkPrivateRedeclaration(obj, privateSet);\r\n  privateSet.add(obj);\r\n}\r\n\r\nfunction _classPrivateFieldInitSpec(obj, privateMap, value) {\r\n  _checkPrivateRedeclaration(obj, privateMap);\r\n  privateMap.set(obj, value);\r\n}\r\n\r\nfunction _checkPrivateRedeclaration(obj, privateCollection) {\r\n  if (privateCollection.has(obj)) {\r\n    throw new TypeError(\r\n      'Cannot initialize the same private elements twice on an object'\r\n    );\r\n  }\r\n}\r\n\r\nfunction _classStaticPrivateMethodGet(receiver, classConstructor, method) {\r\n  _classCheckPrivateStaticAccess(receiver, classConstructor);\r\n  return method;\r\n}\r\n\r\nfunction _classPrivateMethodGet(receiver, privateSet, fn) {\r\n  if (!privateSet.has(receiver)) {\r\n    throw new TypeError('attempted to get private field on non-instance');\r\n  }\r\n  return fn;\r\n}\r\n\r\nfunction _classStaticPrivateFieldSpecGet(\r\n  receiver,\r\n  classConstructor,\r\n  descriptor\r\n) {\r\n  _classCheckPrivateStaticAccess(receiver, classConstructor);\r\n  _classCheckPrivateStaticFieldDescriptor(descriptor, 'get');\r\n  return _classApplyDescriptorGet(receiver, descriptor);\r\n}\r\n\r\nfunction _classCheckPrivateStaticFieldDescriptor(descriptor, action) {\r\n  if (descriptor === undefined) {\r\n    throw new TypeError(\r\n      'attempted to ' + action + ' private static field before its declaration'\r\n    );\r\n  }\r\n}\r\n\r\nfunction _classCheckPrivateStaticAccess(receiver, classConstructor) {\r\n  if (receiver !== classConstructor) {\r\n    throw new TypeError('Private static access of wrong provenance');\r\n  }\r\n}\r\n\r\nfunction _classPrivateFieldGet(receiver, privateMap) {\r\n  var descriptor = _classExtractFieldDescriptor(receiver, privateMap, 'get');\r\n  return _classApplyDescriptorGet(receiver, descriptor);\r\n}\r\n\r\nfunction _classExtractFieldDescriptor(receiver, privateMap, action) {\r\n  if (!privateMap.has(receiver)) {\r\n    throw new TypeError(\r\n      'attempted to ' + action + ' private field on non-instance'\r\n    );\r\n  }\r\n  return privateMap.get(receiver);\r\n}\r\n\r\nfunction _classApplyDescriptorGet(receiver, descriptor) {\r\n  if (descriptor.get) {\r\n    return descriptor.get.call(receiver);\r\n  }\r\n  return descriptor.value;\r\n}\r\n\r\nvar _age = /*#__PURE__*/ new WeakMap();\r\n\r\nvar _getAge = /*#__PURE__*/ new WeakSet();\r\n\r\nvar Test = /*#__PURE__*/ (function () {\r\n  debugger;\r\n  function Test() {\r\n    _classCallCheck(this, Test);\r\n\r\n    _classPrivateMethodInitSpec(this, _getAge);\r\n\r\n    _classPrivateFieldInitSpec(this, _age, {\r\n      writable: true,\r\n      value: 17,\r\n    });\r\n  }\r\n\r\n  _createClass(Test, [\r\n    {\r\n      key: 'all',\r\n      value: function all() {\r\n        _classPrivateMethodGet(this, _getAge, _getAge2).call(this);\r\n\r\n        _classStaticPrivateMethodGet(Test, Test, _getName).call(Test);\r\n      },\r\n    },\r\n  ]);\r\n\r\n  return Test;\r\n})();\r\n\r\nfunction _getAge2() {\r\n  console.log(_classPrivateFieldGet(this, _age));\r\n}\r\n\r\nfunction _getName() {\r\n  console.log(_classStaticPrivateFieldSpecGet(this, Test, _name));\r\n}\r\n\r\nvar _name = {\r\n  writable: true,\r\n  value: 'zhangsan',\r\n};\r\nvar test = new Test();\r\ntest.all();\r\n```\r\n\r\n以下方法出现在之前讲解过的篇幅中就不再赘述\r\n\r\n- `_classCallCheck`\r\n- `_defineProperties`\r\n- `_createClass`\r\n\r\n### \\_checkPrivateRedeclaration\r\n\r\n```js\r\nfunction _checkPrivateRedeclaration(obj, privateCollection) {\r\n  if (privateCollection.has(obj)) {\r\n    throw new TypeError(\r\n      'Cannot initialize the same private elements twice on an object'\r\n    );\r\n  }\r\n}\r\n```\r\n\r\n验证 `WeakSet` 上是否存在构造函数，如果存在直接抛出错误。\r\n\r\n### \\_classPrivateMethodInitSpec\r\n\r\n```js\r\nfunction _classPrivateMethodInitSpec(obj, privateSet) {\r\n  _checkPrivateRedeclaration(obj, privateSet);\r\n  privateSet.add(obj);\r\n}\r\n```\r\n\r\n在 `WeakSet` 上添加构造函数。\r\n\r\n### \\_classPrivateFieldInitSpec\r\n\r\n```js\r\nfunction _classPrivateFieldInitSpec(obj, privateMap, value) {\r\n  _checkPrivateRedeclaration(obj, privateMap);\r\n  privateMap.set(obj, value);\r\n}\r\n```\r\n\r\n在 `WeakMap` 上添加私有属性（属性描述符形式）。\r\n\r\n### \\_classPrivateMethodGet\r\n\r\n```js\r\nfunction _classPrivateMethodGet(receiver, privateSet, fn) {\r\n  if (!privateSet.has(receiver)) {\r\n    throw new TypeError('attempted to get private field on non-instance');\r\n  }\r\n  return fn;\r\n}\r\n```\r\n\r\n验证是否在构造函数内部调用，如果外部则抛出错误 `试图在非实例上获取私有字段`。\r\n\r\n### \\_classCheckPrivateStaticAccess\r\n\r\n```js\r\nfunction _classCheckPrivateStaticAccess(receiver, classConstructor) {\r\n  if (receiver !== classConstructor) {\r\n    throw new TypeError('Private static access of wrong provenance');\r\n  }\r\n}\r\n```\r\n\r\n判断静态属性的来源是否合法，例如\r\n\r\n```js\r\nclass A {\r\n  static #name() {}\r\n}\r\n\r\nclass Test {\r\n  static #name() {\r\n    A.#name();\r\n  }\r\n\r\n  all() {\r\n    Test.#name();\r\n  }\r\n}\r\n\r\nconst test = new Test();\r\ntest.all();\r\n```\r\n\r\n我们在 `Test` 获取` A.#name` 这种情况下就要抛出异常。\r\n\r\n### \\_classStaticPrivateMethodGet\r\n\r\n```js\r\nfunction _classStaticPrivateMethodGet(receiver, classConstructor, method) {\r\n  _classCheckPrivateStaticAccess(receiver, classConstructor);\r\n  return method;\r\n}\r\n```\r\n\r\n验证通过返回 `method`。\r\n\r\n### \\_classExtractFieldDescriptor\r\n\r\n```js\r\nfunction _classExtractFieldDescriptor(receiver, privateMap, action) {\r\n  if (!privateMap.has(receiver)) {\r\n    throw new TypeError(\r\n      'attempted to ' + action + ' private field on non-instance'\r\n    );\r\n  }\r\n  return privateMap.get(receiver);\r\n}\r\n```\r\n\r\n验证 `WeakMap` 是否有构造函数，如果没有则抛出非法获取实例错误，否则返回对应的 key。\r\n\r\n### \\_classApplyDescriptorGet\r\n\r\n```js\r\nfunction _classApplyDescriptorGet(receiver, descriptor) {\r\n  if (descriptor.get) {\r\n    return descriptor.get.call(receiver);\r\n  }\r\n  return descriptor.value;\r\n}\r\n```\r\n\r\n返回私有属性，根据属性描述符，如果是 `get、set` 这种形式储存，直接调用 `get 函数` 返回，否则返回 `value`。\r\n\r\n### \\_classCheckPrivateStaticFieldDescriptor\r\n\r\n```js\r\nfunction _classCheckPrivateStaticFieldDescriptor(descriptor, action) {\r\n  if (descriptor === undefined) {\r\n    throw new TypeError(\r\n      'attempted to ' + action + ' private static field before its declaration'\r\n    );\r\n  }\r\n}\r\n```\r\n\r\n判断属性描述符是否存在，不存在抛出异常。\r\n\r\n### \\_classStaticPrivateFieldSpecGet\r\n\r\n```js\r\nfunction _classStaticPrivateFieldSpecGet(\r\n  receiver,\r\n  classConstructor,\r\n  descriptor\r\n) {\r\n  _classCheckPrivateStaticAccess(receiver, classConstructor);\r\n  _classCheckPrivateStaticFieldDescriptor(descriptor, 'get');\r\n  return _classApplyDescriptorGet(receiver, descriptor);\r\n}\r\n```\r\n\r\n返回静态私有方法\r\n\r\n- 调用 `_classCheckPrivateStaticAccess` 确保构造函数和调用函数一致；\r\n- 调用 `_classCheckPrivateStaticFieldDescriptor` 确保静态私有属性一致；\r\n- 调用 `_classApplyDescriptorGet` 返回私有属性;\r\n\r\n### \\_classPrivateFieldGet\r\n\r\n```js\r\nfunction _classPrivateFieldGet(receiver, privateMap) {\r\n  var descriptor = _classExtractFieldDescriptor(receiver, privateMap, 'get');\r\n  return _classApplyDescriptorGet(receiver, descriptor);\r\n}\r\n```\r\n\r\n返回静态私有属性。\r\n\r\n## 执行过程\r\n\r\n上面已经放过 babel 过的代码，这里就不重复了，重点看下执行的过程，从`var _age = /*#__PURE__*/ new WeakMap();`这段代码开始。\r\n\r\n- 创建 `_age` 和 `_getAge` 的 `Weak` 对象；\r\n- 调用 `_createClass` 给 Test 完成 prototype 赋值；\r\n- `new Test`，进入 Test 构造函数内部；\r\n- 调用 `_classCallCheck` 确保为 `new` 调用；\r\n- 调用 `_classPrivateMethodInitSpec`，让 `_getAge` 添加当前 `this`；\r\n- 调用 `_classPrivateFieldInitSpec`，给 `_age` 添加属性，key 为 this，value 为属性描述符；\r\n- 调用 `all` 方法；\r\n- 执行 `_classPrivateMethodGet(this, _getAge, _getAge2).call(this);`，它的作用验证通过后调用 `_getAge2`；\r\n- `_getAge2` 内部执行 `_classPrivateFieldGet`，返回 `_age` 设置的属性描述符;\r\n- 返回 `all` 内部执行 `_classStaticPrivateMethodGet(Test, Test, _getName).call(Test);`这一行，它的作用是验证后执行 `_getName`；\r\n- `_getName` 内部执行 `_classStaticPrivateFieldSpecGet` 它返回属性描述符；\r\n- 输出结果，结束；\r\n\r\n## 实现私有属性方法\r\n\r\n从上面过程中可以看到，实现私有方法的主要步骤是通过 `WeakMap` 来完成，如果不考虑验证过程，可以很简单实现。\r\n\r\n```js\r\nconst privateName = new WeakMap();\r\n\r\nclass Test {\r\n  constructor() {\r\n    privateName.set(this, 'zhangsan');\r\n  }\r\n  getName() {\r\n    return privateName.get(this);\r\n  }\r\n}\r\n```\r\n\r\n## 最后\r\n\r\n如果有什么不正确或者书写错误欢迎指出。\r\n",
      "reactions": {
        "url": "https://api.github.com/repos/bosens-China/blog/issues/82/reactions",
        "total_count": 0,
        "+1": 0,
        "-1": 0,
        "laugh": 0,
        "hooray": 0,
        "confused": 0,
        "heart": 0,
        "rocket": 0,
        "eyes": 0
      },
      "timeline_url": "https://api.github.com/repos/bosens-China/blog/issues/82/timeline",
      "performed_via_github_app": null,
      "state_reason": null
    },
    {
      "url": "https://api.github.com/repos/bosens-China/blog/issues/81",
      "repository_url": "https://api.github.com/repos/bosens-China/blog",
      "labels_url": "https://api.github.com/repos/bosens-China/blog/issues/81/labels{/name}",
      "comments_url": "https://api.github.com/repos/bosens-China/blog/issues/81/comments",
      "events_url": "https://api.github.com/repos/bosens-China/blog/issues/81/events",
      "html_url": "https://github.com/bosens-China/blog/issues/81",
      "id": 1085660852,
      "node_id": "I_kwDOCzPAy85Atd60",
      "number": 81,
      "title": "Babel to Class之继承（2）",
      "user": {
        "login": "bosens-China",
        "id": 39508895,
        "node_id": "MDQ6VXNlcjM5NTA4ODk1",
        "avatar_url": "https://avatars.githubusercontent.com/u/39508895?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bosens-China",
        "html_url": "https://github.com/bosens-China",
        "followers_url": "https://api.github.com/users/bosens-China/followers",
        "following_url": "https://api.github.com/users/bosens-China/following{/other_user}",
        "gists_url": "https://api.github.com/users/bosens-China/gists{/gist_id}",
        "starred_url": "https://api.github.com/users/bosens-China/starred{/owner}{/repo}",
        "subscriptions_url": "https://api.github.com/users/bosens-China/subscriptions",
        "organizations_url": "https://api.github.com/users/bosens-China/orgs",
        "repos_url": "https://api.github.com/users/bosens-China/repos",
        "events_url": "https://api.github.com/users/bosens-China/events{/privacy}",
        "received_events_url": "https://api.github.com/users/bosens-China/received_events",
        "type": "User",
        "site_admin": false
      },
      "labels": [
        {
          "id": 1908144759,
          "node_id": "MDU6TGFiZWwxOTA4MTQ0NzU5",
          "url": "https://api.github.com/repos/bosens-China/blog/labels/ES6%E7%B3%BB%E5%88%97",
          "name": "ES6系列",
          "color": "0366d6",
          "default": false,
          "description": "ES6的最新语法"
        }
      ],
      "state": "open",
      "locked": false,
      "assignee": null,
      "assignees": [],
      "milestone": null,
      "comments": 0,
      "created_at": "2021-12-21T10:12:50Z",
      "updated_at": "2021-12-28T09:51:06Z",
      "closed_at": null,
      "author_association": "OWNER",
      "active_lock_reason": null,
      "body": "## 前言\r\n\r\n这是《Babel to Class》系列的第二篇\r\n\r\n- [Babel to Class之编译（1）](https://github.com/bosens-China/blog/issues/80)\r\n- [Babel to Class之私有属性（3）](https://github.com/bosens-China/blog/issues/82)\r\n- [Babel to Class之原生构造函数继承（4）](https://github.com/bosens-China/blog/issues/88)\r\n\r\n这个系列主要讲 Class 的普通写法、继承、私有属性和原生构造函数继承 `babel` 是如何实现这一过程的。\r\n> 注：文章顺序存在关联，请按照顺序阅读。\r\n\r\n## 前置知识点\r\n\r\n### super\r\n\r\n`super` 通常用于 Class 继承中调用父类构造函数，以及在方法中调用父类方法。\r\n\r\n```js\r\nclass Rectangle {\r\n  logNbSides() {\r\n    return 'I have 4 sides';\r\n  }\r\n}\r\n\r\nclass Square extends Rectangle {\r\n  logDescription() {\r\n    return super.logNbSides() + ' which are all equal';\r\n  }\r\n}\r\n```\r\n\r\n> 更多的内容请参考 [super](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/super)\r\n\r\n### Object.create\r\n\r\n`Object.create(proto，[propertiesObject])`\r\n\r\n`Object.create` 用于创建一个新的对象，并将新的对象原型设置在 `proto` 上，它还支持第二个参数，第二个参数为对象每个对象的值为属性描述符。\r\n\r\n```js\r\nvar o = Object.create(Object.prototype, {\r\n  // foo会成为所创建对象的数据属性\r\n  foo: {\r\n    writable: true,\r\n    configurable: true,\r\n    value: 'hello',\r\n  },\r\n  // bar会成为所创建对象的访问器属性\r\n  bar: {\r\n    configurable: false,\r\n    get: function () {\r\n      return 10;\r\n    },\r\n    set: function (value) {\r\n      console.log('Setting `o.bar` to', value);\r\n    },\r\n  },\r\n});\r\n```\r\n\r\n> 更多内容请参考 [Object.create](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/create)\r\n\r\n### Reflect.construct\r\n\r\n```js\r\nReflect.construct(target, argumentsList[, newTarget])\r\n```\r\n\r\n- target：被运行的目标构造函数\r\n- argumentsList：类数组，目标构造函数调用时的参数。\r\n- newTarget：作为新创建对象的原型对象的 constructor 属性， 参考 new.target 操作符，默认值为 target。\r\n\r\n`Reflect.construct` 的作用相当于不用 `new` 操作符调用构造函数，创建对象。\r\n\r\n```js\r\nclass Foo {}\r\nvar obj = new Foo(...args);\r\nvar obj = Reflect.construct(Foo, args);\r\n```\r\n\r\n注意点：\r\n\r\n1. 使用 `Reflect.construct` 创建对象，`new.target` 会自动指向 newTarget，\r\n2. 如果指定 newTarget，`new.target` 会指向 newTarget 且构造函数内部的 this 为 newTarget\r\n\r\n> 更多内容请参考 [Reflect.construct](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Reflect/construct)\r\n\r\n### Class\r\n\r\n- Class extends 继承的必须是 `null` 或者 `function`（class 也是 function），否则抛出错误；\r\n- Class 子类 extends 父类的时候必须在 `constructor` 显式调用 `super()`，否则抛出错误；\r\n\r\n## 示例代码\r\n\r\n```js\r\nclass Parent {\r\n  constructor() {\r\n    this.age = 17;\r\n  }\r\n\r\n  getAge() {\r\n    return this.age;\r\n  }\r\n\r\n  static getName() {\r\n    return this.name;\r\n  }\r\n}\r\n\r\nclass Child extends Parent {\r\n  constructor() {\r\n    super();\r\n    this.name = 'child';\r\n  }\r\n\r\n  static name = 'child';\r\n\r\n  getAll() {\r\n    return {\r\n      name: this.name,\r\n      age: this.age,\r\n    };\r\n  }\r\n}\r\n\r\nconst child = new Child();\r\nconsole.log(child.getAll());\r\nconsole.log(Child.getName());\r\n```\r\n\r\n以下讲解基于上面的内容而来。\r\n\r\n## babel\r\n\r\n```js\r\n'use strict';\r\n\r\nfunction _typeof(obj) {\r\n  // ...省略实现\r\n}\r\n\r\nfunction _inherits(subClass, superClass) {\r\n  // ...省略实现\r\n}\r\n\r\nfunction _setPrototypeOf(o, p) {\r\n  // ...省略实现\r\n}\r\n\r\nfunction _createSuper(Derived) {\r\n  // ...省略实现\r\n}\r\n\r\nfunction _possibleConstructorReturn(self, call) {\r\n  // ...省略实现\r\n}\r\n\r\nfunction _assertThisInitialized(self) {\r\n  // ...省略实现\r\n}\r\n\r\nfunction _isNativeReflectConstruct() {\r\n  // ...省略实现\r\n}\r\n\r\nfunction _getPrototypeOf(o) {\r\n  // ...省略实现\r\n}\r\n\r\nfunction _defineProperty(obj, key, value) {\r\n  // ...省略实现\r\n}\r\n\r\nfunction _classCallCheck(instance, Constructor) {\r\n  // ...省略实现\r\n}\r\n\r\nfunction _defineProperties(target, props) {\r\n  // ...省略实现\r\n}\r\n\r\nfunction _createClass(Constructor, protoProps, staticProps) {\r\n  // ...省略实现\r\n}\r\n\r\nvar Parent = /*#__PURE__*/ (function () {\r\n  function Parent() {\r\n    _classCallCheck(this, Parent);\r\n\r\n    this.age = 17;\r\n  }\r\n\r\n  _createClass(\r\n    Parent,\r\n    [\r\n      {\r\n        key: 'getAge',\r\n        value: function getAge() {\r\n          return this.age;\r\n        },\r\n      },\r\n    ],\r\n    [\r\n      {\r\n        key: 'getName',\r\n        value: function getName() {\r\n          return this.name;\r\n        },\r\n      },\r\n    ],\r\n  );\r\n\r\n  return Parent;\r\n})();\r\n\r\nvar Child = /*#__PURE__*/ (function (_Parent) {\r\n  _inherits(Child, _Parent);\r\n\r\n  var _super = _createSuper(Child);\r\n\r\n  function Child() {\r\n    var _this;\r\n\r\n    _classCallCheck(this, Child);\r\n\r\n    _this = _super.call(this);\r\n    _this.name = 'child';\r\n    return _this;\r\n  }\r\n\r\n  _createClass(Child, [\r\n    {\r\n      key: 'getAll',\r\n      value: function getAll() {\r\n        return {\r\n          name: this.name,\r\n          age: this.age,\r\n        };\r\n      },\r\n    },\r\n  ]);\r\n\r\n  return Child;\r\n})(Parent);\r\n\r\n_defineProperty(Child, 'name', 'child');\r\n\r\nvar child = new Child();\r\nconsole.log(child.getAll());\r\nconsole.log(Child.getName());\r\n```\r\n\r\n下面函数在 [Babel to Class 做了什么（1）](https://github.com/bosens-China/blog/issues/80) 讲解过了\r\n\r\n- `_defineProperty`\r\n- `_classCallCheck`\r\n- `_defineProperties`\r\n- `_createClass`\r\n\r\n所以不再赘述，重点先看新出现的函数。\r\n\r\n### \\_typeof\r\n\r\n```js\r\nfunction _typeof(obj) {\r\n  '@babel/helpers - typeof';\r\n  return (\r\n    (_typeof =\r\n      'function' == typeof Symbol && 'symbol' == typeof Symbol.iterator\r\n        ? function (obj) {\r\n            return typeof obj;\r\n          }\r\n        : function (obj) {\r\n            return obj && 'function' == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype\r\n              ? 'symbol'\r\n              : typeof obj;\r\n          }),\r\n    _typeof(obj)\r\n  );\r\n}\r\n```\r\n\r\n这个函数的作用为类型判断。\r\n\r\n- `'function' == typeof Symbol && 'symbol' == typeof Symbol.iterator`\r\n  这段化意思是如果支持原生的 `Symbol` 就直接执行 `typeof` 即可\r\n\r\n- `obj && 'function' == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype`\r\n  这段代码主要是用于判断低版本不兼容 `Symbol` 的浏览器是不是使用了 `polyfill` 库，如果是的化就返回 `symbol`\r\n\r\n- 其他情况返回 `typeof` 结果\r\n\r\n### \\_inherits\r\n\r\n```js\r\nfunction _inherits(subClass, superClass) {\r\n  if (typeof superClass !== 'function' && superClass !== null) {\r\n    throw new TypeError('Super expression must either be null or a function');\r\n  }\r\n  Object.defineProperty(subClass, 'prototype', {\r\n    value: Object.create(superClass && superClass.prototype, {\r\n      constructor: { value: subClass, writable: true, configurable: true },\r\n    }),\r\n    writable: false,\r\n  });\r\n  if (superClass) _setPrototypeOf(subClass, superClass);\r\n}\r\n```\r\n\r\n- 这段代码首先判断继承的 `superClass` 是否符合要求\r\n- 其次对 `subClass.prototype` 进行设置确保 `prototype` 属性非遍历\r\n- 设置原型，将 `subClass` 的原型设置为 `superClass`\r\n\r\n### \\_setPrototypeOf\r\n\r\n```js\r\nfunction _setPrototypeOf(o, p) {\r\n  _setPrototypeOf =\r\n    Object.setPrototypeOf ||\r\n    function _setPrototypeOf(o, p) {\r\n      o.__proto__ = p;\r\n      return o;\r\n    };\r\n  return _setPrototypeOf(o, p);\r\n}\r\n```\r\n\r\n设置原型链的方法，首先调用原生的 `Object.setPrototypeOf` 方法，如果不支持尝试使用 `__proto__`，`__proto__`是浏览器实现的一个私有属性，在其他环境下不是必须实现。\r\n\r\n不过仔细观察，你会发现它还使用了一个函数懒加载，确保判断只执行一次，后续直接不会改变了。\r\n\r\n### \\_createSuper\r\n\r\n```js\r\nfunction _createSuper(Derived) {\r\n  var hasNativeReflectConstruct = _isNativeReflectConstruct();\r\n  return function _createSuperInternal() {\r\n    var Super = _getPrototypeOf(Derived),\r\n      result;\r\n    if (hasNativeReflectConstruct) {\r\n      var NewTarget = _getPrototypeOf(this).constructor;\r\n      result = Reflect.construct(Super, arguments, NewTarget);\r\n    } else {\r\n      result = Super.apply(this, arguments);\r\n    }\r\n    return _possibleConstructorReturn(this, result);\r\n  };\r\n}\r\n```\r\n\r\n这段代码的作用是返回 `super`\r\n\r\n- `_isNativeReflectConstruct` 这个函数我们后面讲解，它的作用就是判断当前环境支不支持 `Reflect.construct`\r\n- `_possibleConstructorReturn` 这个函数后面讲解，作用为判断 Class 符不符合要求\r\n\r\n### \\_possibleConstructorReturn\r\n\r\n```js\r\nfunction _possibleConstructorReturn(self, call) {\r\n  debugger;\r\n  if (call && (_typeof(call) === 'object' || typeof call === 'function')) {\r\n    return call;\r\n  } else if (call !== void 0) {\r\n    throw new TypeError('Derived constructors may only return object or undefined');\r\n  }\r\n  return _assertThisInitialized(self);\r\n}\r\n```\r\n\r\n这个函数用于判断 Class 和 extends 的 Class 符不符合要求\r\n\r\n- `call && (_typeof(call) === 'object' || typeof call === 'function')`\r\n\r\n这个相当于判断 isObject，构造函数被调用是可以返回一个对象的\r\n\r\n```js\r\nfunction Foo() {\r\n  return { name: 1 };\r\n}\r\nnew Foo();\r\n// {name: 1}\r\n```\r\n\r\n如果不是对象也没有默认返回 `undefined`，则直接抛出错误\r\n\r\n- `_assertThisInitialized`，这个函数用于判断子类有没有调用 `super`，如果没有调用抛出错误\r\n\r\n### \\_isNativeReflectConstruct\r\n\r\n```js\r\nfunction _isNativeReflectConstruct() {\r\n  if (typeof Reflect === 'undefined' || !Reflect.construct) return false;\r\n  if (Reflect.construct.sham) return false;\r\n  if (typeof Proxy === 'function') return true;\r\n  try {\r\n    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));\r\n    return true;\r\n  } catch (e) {\r\n    return false;\r\n  }\r\n}\r\n```\r\n\r\n判断当前环境支不支持 `Reflect.construct`，它的判断思路为前置判断，如果不符合早早返回\r\n\r\n- `if (typeof Reflect === 'undefined' || !Reflect.construct) return false;`，不支持原生返回 `false`\r\n- `if (Reflect.construct.sham) return false;`，`polyfill` 的则也返回 `false`\r\n- `if (typeof Proxy === 'function') return true;`，返回 `true` 的原因是因为，`Proxy` 的兼容性比 `Reflect` 差，如果 `Proxy` 支持 `Reflect` 一定也支持\r\n  - [proxy 兼容性总览](https://caniuse.com/?search=proxy)\r\n  - [Reflect 兼容性总览](https://caniuse.com/?search=Reflect)\r\n- `Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));`，如果都符合直接运行，前面说过 `Reflect.construct` 支持第三个参数，如果运行没报错返回 `true`\r\n\r\n### \\_getPrototypeOf\r\n\r\n```js\r\nfunction _getPrototypeOf(o) {\r\n  _getPrototypeOf = Object.setPrototypeOf\r\n    ? Object.getPrototypeOf\r\n    : function _getPrototypeOf(o) {\r\n        return o.__proto__ || Object.getPrototypeOf(o);\r\n      };\r\n  return _getPrototypeOf(o);\r\n}\r\n```\r\n\r\n这段代码为获取原型，跟 `_setPrototypeOf` 函数类似，如果当前环境支持优先使用 `Object.getPrototypeOf` 上的，否则回滚。\r\n\r\n## 运行流程\r\n\r\n讲解到这里，继承基本讲完了，现在把完整代码贴以下，之后讲一下运行的流程\r\n\r\n```js\r\n'use strict';\r\n\r\nfunction _typeof(obj) {\r\n  '@babel/helpers - typeof';\r\n  return (\r\n    (_typeof =\r\n      'function' == typeof Symbol && 'symbol' == typeof Symbol.iterator\r\n        ? function (obj) {\r\n            return typeof obj;\r\n          }\r\n        : function (obj) {\r\n            return obj && 'function' == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype\r\n              ? 'symbol'\r\n              : typeof obj;\r\n          }),\r\n    _typeof(obj)\r\n  );\r\n}\r\n\r\nfunction _inherits(subClass, superClass) {\r\n  if (typeof superClass !== 'function' && superClass !== null) {\r\n    throw new TypeError('Super expression must either be null or a function');\r\n  }\r\n  Object.defineProperty(subClass, 'prototype', {\r\n    value: Object.create(superClass && superClass.prototype, {\r\n      constructor: { value: subClass, writable: true, configurable: true },\r\n    }),\r\n    writable: false,\r\n  });\r\n  if (superClass) _setPrototypeOf(subClass, superClass);\r\n}\r\n\r\nfunction _setPrototypeOf(o, p) {\r\n  _setPrototypeOf =\r\n    Object.setPrototypeOf ||\r\n    function _setPrototypeOf(o, p) {\r\n      o.__proto__ = p;\r\n      return o;\r\n    };\r\n  return _setPrototypeOf(o, p);\r\n}\r\n\r\nfunction _createSuper(Derived) {\r\n  var hasNativeReflectConstruct = _isNativeReflectConstruct();\r\n  return function _createSuperInternal() {\r\n    var Super = _getPrototypeOf(Derived),\r\n      result;\r\n    if (hasNativeReflectConstruct) {\r\n      var NewTarget = _getPrototypeOf(this).constructor;\r\n      result = Reflect.construct(Super, arguments, NewTarget);\r\n    } else {\r\n      result = Super.apply(this, arguments);\r\n    }\r\n    return _possibleConstructorReturn(this, result);\r\n  };\r\n}\r\n\r\nfunction _possibleConstructorReturn(self, call) {\r\n  if (call && (_typeof(call) === 'object' || typeof call === 'function')) {\r\n    return call;\r\n  } else if (call !== void 0) {\r\n    throw new TypeError('Derived constructors may only return object or undefined');\r\n  }\r\n  return _assertThisInitialized(self);\r\n}\r\n\r\nfunction _assertThisInitialized(self) {\r\n  if (self === void 0) {\r\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\r\n  }\r\n  return self;\r\n}\r\n\r\nfunction _isNativeReflectConstruct() {\r\n  if (typeof Reflect === 'undefined' || !Reflect.construct) return false;\r\n  if (Reflect.construct.sham) return false;\r\n  if (typeof Proxy === 'function') return true;\r\n  try {\r\n    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));\r\n    return true;\r\n  } catch (e) {\r\n    return false;\r\n  }\r\n}\r\n\r\nfunction _getPrototypeOf(o) {\r\n  _getPrototypeOf = Object.setPrototypeOf\r\n    ? Object.getPrototypeOf\r\n    : function _getPrototypeOf(o) {\r\n        return o.__proto__ || Object.getPrototypeOf(o);\r\n      };\r\n  return _getPrototypeOf(o);\r\n}\r\n\r\nfunction _defineProperty(obj, key, value) {\r\n  if (key in obj) {\r\n    Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true });\r\n  } else {\r\n    obj[key] = value;\r\n  }\r\n  return obj;\r\n}\r\n\r\nfunction _classCallCheck(instance, Constructor) {\r\n  if (!(instance instanceof Constructor)) {\r\n    throw new TypeError('Cannot call a class as a function');\r\n  }\r\n}\r\n\r\nfunction _defineProperties(target, props) {\r\n  for (var i = 0; i < props.length; i++) {\r\n    var descriptor = props[i];\r\n    descriptor.enumerable = descriptor.enumerable || false;\r\n    descriptor.configurable = true;\r\n    if ('value' in descriptor) descriptor.writable = true;\r\n    Object.defineProperty(target, descriptor.key, descriptor);\r\n  }\r\n}\r\n\r\nfunction _createClass(Constructor, protoProps, staticProps) {\r\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\r\n  if (staticProps) _defineProperties(Constructor, staticProps);\r\n  Object.defineProperty(Constructor, 'prototype', { writable: false });\r\n  return Constructor;\r\n}\r\n\r\nvar Parent = /*#__PURE__*/ (function () {\r\n  function Parent() {\r\n    _classCallCheck(this, Parent);\r\n\r\n    this.age = 17;\r\n  }\r\n\r\n  _createClass(\r\n    Parent,\r\n    [\r\n      {\r\n        key: 'getAge',\r\n        value: function getAge() {\r\n          return this.age;\r\n        },\r\n      },\r\n    ],\r\n    [\r\n      {\r\n        key: 'getName',\r\n        value: function getName() {\r\n          return this.name;\r\n        },\r\n      },\r\n    ],\r\n  );\r\n\r\n  return Parent;\r\n})();\r\n\r\nvar Child = /*#__PURE__*/ (function (_Parent) {\r\n  _inherits(Child, _Parent);\r\n\r\n  var _super = _createSuper(Child);\r\n\r\n  function Child() {\r\n    var _this;\r\n\r\n    _classCallCheck(this, Child);\r\n\r\n    _this = _super.call(this);\r\n    _this.name = 'child';\r\n    return _this;\r\n  }\r\n\r\n  _createClass(Child, [\r\n    {\r\n      key: 'getAll',\r\n      value: function getAll() {\r\n        return {\r\n          name: this.name,\r\n          age: this.age,\r\n        };\r\n      },\r\n    },\r\n  ]);\r\n\r\n  return Child;\r\n})(Parent);\r\n\r\n_defineProperty(Child, 'name', 'child');\r\n\r\nvar child = new Child();\r\nconsole.log(child.getAll());\r\nconsole.log(Child.getName());\r\n```\r\n\r\n代码从 `var Parent = /*#__PURE__*/ (function () {` 这段开始\r\n\r\n- 调用 `_createClass`，将 `prototype 属性` 和 `static 属性` 设置到 Parent 函数上\r\n- 之后代码往下执行，到`var Child = /*#__PURE__*/ (function (_Parent) {`\r\n- 调用 `_inherits`，判断 Parent 符合要求，设置 `Child.prototype` 属性，设置 Child 原型\r\n- 调用 `_createSuper`，获取 `super`\r\n- 调用 `_createClass`，设置 `prototype 属性` 和 `static 属性` 设置到 Child 函数上\r\n- 调用 `_defineProperty`，覆盖 Child 上的属性，确保是可以遍历修改的\r\n- new Child\r\n- Child 函数内部执行 `_classCallCheck`，确保一定为 `new` 调用\r\n- 在 Child 函数内部执行 `_super.call(this)` 操作，调用父类构造函数\r\n- Parent 内部，调用 `_classCallCheck`，确保 `new` 调用\r\n- 返回 Parent 的 this 值\r\n- Child 内部修改 Parent 返回的 this 值，进行重写\r\n- 执行后续代码...\r\n\r\n## 跟 es5 继承的差异\r\n\r\n从上面代码不难看到跟 es5 写的继承有很大差异\r\n\r\n1. `prototype` 不可以遍历；\r\n2. 不通过 `new` 调用显式报错；\r\n3. Class 的继承不仅是将子类的 `prototype` 指向父类的 `prototype`，同时也将子类的原型指向了父类；\r\n4. 得益于子类原型指向父类，静态方法和属性也可以调用；\r\n\r\n## 最后\r\n\r\n如果有什么不正确或者书写错误欢迎指出。\r\n",
      "reactions": {
        "url": "https://api.github.com/repos/bosens-China/blog/issues/81/reactions",
        "total_count": 0,
        "+1": 0,
        "-1": 0,
        "laugh": 0,
        "hooray": 0,
        "confused": 0,
        "heart": 0,
        "rocket": 0,
        "eyes": 0
      },
      "timeline_url": "https://api.github.com/repos/bosens-China/blog/issues/81/timeline",
      "performed_via_github_app": null,
      "state_reason": null
    },
    {
      "url": "https://api.github.com/repos/bosens-China/blog/issues/80",
      "repository_url": "https://api.github.com/repos/bosens-China/blog",
      "labels_url": "https://api.github.com/repos/bosens-China/blog/issues/80/labels{/name}",
      "comments_url": "https://api.github.com/repos/bosens-China/blog/issues/80/comments",
      "events_url": "https://api.github.com/repos/bosens-China/blog/issues/80/events",
      "html_url": "https://github.com/bosens-China/blog/issues/80",
      "id": 1085660079,
      "node_id": "I_kwDOCzPAy85Atduv",
      "number": 80,
      "title": "Babel to Class之编译（1）",
      "user": {
        "login": "bosens-China",
        "id": 39508895,
        "node_id": "MDQ6VXNlcjM5NTA4ODk1",
        "avatar_url": "https://avatars.githubusercontent.com/u/39508895?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bosens-China",
        "html_url": "https://github.com/bosens-China",
        "followers_url": "https://api.github.com/users/bosens-China/followers",
        "following_url": "https://api.github.com/users/bosens-China/following{/other_user}",
        "gists_url": "https://api.github.com/users/bosens-China/gists{/gist_id}",
        "starred_url": "https://api.github.com/users/bosens-China/starred{/owner}{/repo}",
        "subscriptions_url": "https://api.github.com/users/bosens-China/subscriptions",
        "organizations_url": "https://api.github.com/users/bosens-China/orgs",
        "repos_url": "https://api.github.com/users/bosens-China/repos",
        "events_url": "https://api.github.com/users/bosens-China/events{/privacy}",
        "received_events_url": "https://api.github.com/users/bosens-China/received_events",
        "type": "User",
        "site_admin": false
      },
      "labels": [
        {
          "id": 1908144759,
          "node_id": "MDU6TGFiZWwxOTA4MTQ0NzU5",
          "url": "https://api.github.com/repos/bosens-China/blog/labels/ES6%E7%B3%BB%E5%88%97",
          "name": "ES6系列",
          "color": "0366d6",
          "default": false,
          "description": "ES6的最新语法"
        }
      ],
      "state": "open",
      "locked": false,
      "assignee": null,
      "assignees": [],
      "milestone": null,
      "comments": 0,
      "created_at": "2021-12-21T10:12:08Z",
      "updated_at": "2021-12-28T09:48:18Z",
      "closed_at": null,
      "author_association": "OWNER",
      "active_lock_reason": null,
      "body": "## 前言\r\n\r\n这是《Babel to Class》系列的第一篇\r\n\r\n- [Babel to Class之继承（2）](https://github.com/bosens-China/blog/issues/81)\r\n- [Babel to Class之私有属性（3）](https://github.com/bosens-China/blog/issues/82)\r\n- [Babel to Class之原生构造函数继承（4）](https://github.com/bosens-China/blog/issues/88)\r\n\r\n这个系列主要讲 Class 的普通写法、继承、私有属性和原生构造函数继承 `babel` 是如何实现这一过程的。\r\n> 注：文章顺序存在关联，请按照顺序阅读。\r\n\r\n## 前置知识点\r\n\r\n### Object.defineProperty\r\n\r\n`Object.defineProperty(obj, prop, descriptor)` 用于定义对象属性，它有三个参数分为别：对象，对象 key，以及属性描述符。\r\n\r\n属性描述符默认不传递具体的值则为 `false`\r\n\r\n```js\r\nconst a = {};\r\nObject.defineProperty(a, 'd', {});\r\nObject.getOwnPropertyDescriptor(a, 'd');\r\n// {value: undefined, writable: false, enumerable: false, configurable: false}\r\n```\r\n\r\n有两种调用形式\r\n\r\n```js\r\nvar o = {};\r\n\r\n// 1.\r\nObject.defineProperty(o, 'a', {\r\n  value: 37,\r\n  writable: true,\r\n  enumerable: true,\r\n  configurable: true,\r\n});\r\n\r\n// 2.\r\nvar bValue = 38;\r\nObject.defineProperty(o, 'b', {\r\n  get() {\r\n    return bValue;\r\n  },\r\n  set(newValue) {\r\n    bValue = newValue;\r\n  },\r\n  enumerable: true,\r\n  configurable: true,\r\n});\r\n```\r\n\r\n> 更多内容，以及属性描述符包含那些，请[参考文档](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty)\r\n\r\n### Class\r\n\r\n- `Class`必须通过 `new` 调用，否则抛出 `Uncaught TypeError: Class constructor A cannot be invoked without 'new'`\r\n- `Class`的 `prototype` 属性默认不可遍历\r\n\r\n## 示例文件\r\n\r\n```js\r\nclass Test {\r\n  constructor() {\r\n    this.name = '张三';\r\n  }\r\n\r\n  _age = 18;\r\n\r\n  get age() {\r\n    return this._age;\r\n  }\r\n\r\n  set age(value) {\r\n    this._age = value;\r\n  }\r\n\r\n  getName() {\r\n    return this.name;\r\n  }\r\n\r\n  static getClassName() {\r\n    return this.name;\r\n  }\r\n\r\n  static name = 'TestClass';\r\n}\r\n```\r\n\r\n上面就是准备好的示例文件，结构很简单，我们看下 `babel` 会将代码转码成什么样\r\n\r\n## babel\r\n\r\n为了方便讲解，下面通过注释的形式来解读，阅读部分请从 `const Test = /* #__PURE__ */ (function () {` 这段开始。\r\n\r\n```js\r\n'use strict';\r\n\r\nfunction _classCallCheck(instance, Constructor) {\r\n  /*\r\n   * Class必须通过new调用，这是判断调用的this跟Test进行instanceof对比，如果不符合抛出错误\r\n   */\r\n  if (!(instance instanceof Constructor)) {\r\n    throw new TypeError('Cannot call a class as a function');\r\n  }\r\n}\r\n\r\n/**\r\n * 用于给对象定义属性\r\n * 注意它判断了value属性是否存在，这是因为存在两种写法\r\n * 一种是传递value的普通\r\n * 另外一种是传递get和set的形式\r\n */\r\nfunction _defineProperties(target, props) {\r\n  for (let i = 0; i < props.length; i++) {\r\n    const descriptor = props[i];\r\n    descriptor.enumerable = descriptor.enumerable || false;\r\n    descriptor.configurable = true;\r\n    if ('value' in descriptor) descriptor.writable = true;\r\n    Object.defineProperty(target, descriptor.key, descriptor);\r\n  }\r\n}\r\n\r\n/**\r\n * 初始化Class属性\r\n * 先从函数的prototype属性来进行定义\r\n * 后面定义Constructor本身的属性\r\n */\r\nfunction _createClass(Constructor, protoProps, staticProps) {\r\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\r\n  if (staticProps) _defineProperties(Constructor, staticProps);\r\n  Object.defineProperty(Constructor, 'prototype', { writable: false });\r\n  return Constructor;\r\n}\r\n\r\n/**\r\n * 用于给Test实例和本身定义属性\r\n * 之所以进行一个 in 判定是为了覆盖本身已经有的属性\r\n * 例如class.name属性，这个本身已经存在 {value: 'A', writable: false, enumerable: false, configurable: true}\r\n * 但是我们从新定义就要属性描述符全部为true\r\n */\r\nfunction _defineProperty(obj, key, value) {\r\n  if (key in obj) {\r\n    Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true });\r\n  } else {\r\n    obj[key] = value;\r\n  }\r\n  return obj;\r\n}\r\n\r\nconst Test = /* #__PURE__ */ (function () {\r\n  function Test() {\r\n    // 初始进行new调用判断\r\n    _classCallCheck(this, Test);\r\n    // 实例属性写法\r\n    _defineProperty(this, '_age', 18);\r\n\r\n    this.name = '张三';\r\n  }\r\n\r\n  // 初始化，后面分为为prototype属性以及静态属性\r\n  _createClass(\r\n    Test,\r\n    [\r\n      {\r\n        key: 'age',\r\n        get: function get() {\r\n          return this._age;\r\n        },\r\n        set: function set(value) {\r\n          this._age = value;\r\n        },\r\n      },\r\n      {\r\n        key: 'getName',\r\n        value: function getName() {\r\n          return this.name;\r\n        },\r\n      },\r\n    ],\r\n    [\r\n      {\r\n        key: 'getClassName',\r\n        value: function getClassName() {\r\n          return this.name;\r\n        },\r\n      },\r\n    ],\r\n  );\r\n\r\n  return Test;\r\n})();\r\n\r\n_defineProperty(Test, 'name', 'TestClass');\r\n```\r\n\r\n概况一下上面流程：\r\n\r\n1. 初始化 `Class` 上的 `prototype 属性`以及 `static 属性`\r\n2. `new Class` 的时候，对 Class 的调用形式进行判断\r\n3. `new` 过程中赋值实例属性\r\n4. 执行...\r\n\r\n## 最后\r\n\r\n如果有什么不正确或者书写错误欢迎指出。\r\n",
      "reactions": {
        "url": "https://api.github.com/repos/bosens-China/blog/issues/80/reactions",
        "total_count": 0,
        "+1": 0,
        "-1": 0,
        "laugh": 0,
        "hooray": 0,
        "confused": 0,
        "heart": 0,
        "rocket": 0,
        "eyes": 0
      },
      "timeline_url": "https://api.github.com/repos/bosens-China/blog/issues/80/timeline",
      "performed_via_github_app": null,
      "state_reason": null
    },
    {
      "url": "https://api.github.com/repos/bosens-China/blog/issues/88",
      "repository_url": "https://api.github.com/repos/bosens-China/blog",
      "labels_url": "https://api.github.com/repos/bosens-China/blog/issues/88/labels{/name}",
      "comments_url": "https://api.github.com/repos/bosens-China/blog/issues/88/comments",
      "events_url": "https://api.github.com/repos/bosens-China/blog/issues/88/events",
      "html_url": "https://github.com/bosens-China/blog/issues/88",
      "id": 1089747064,
      "node_id": "I_kwDOCzPAy85A9Dh4",
      "number": 88,
      "title": "Babel to Class之原生构造函数继承（4）",
      "user": {
        "login": "bosens-China",
        "id": 39508895,
        "node_id": "MDQ6VXNlcjM5NTA4ODk1",
        "avatar_url": "https://avatars.githubusercontent.com/u/39508895?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bosens-China",
        "html_url": "https://github.com/bosens-China",
        "followers_url": "https://api.github.com/users/bosens-China/followers",
        "following_url": "https://api.github.com/users/bosens-China/following{/other_user}",
        "gists_url": "https://api.github.com/users/bosens-China/gists{/gist_id}",
        "starred_url": "https://api.github.com/users/bosens-China/starred{/owner}{/repo}",
        "subscriptions_url": "https://api.github.com/users/bosens-China/subscriptions",
        "organizations_url": "https://api.github.com/users/bosens-China/orgs",
        "repos_url": "https://api.github.com/users/bosens-China/repos",
        "events_url": "https://api.github.com/users/bosens-China/events{/privacy}",
        "received_events_url": "https://api.github.com/users/bosens-China/received_events",
        "type": "User",
        "site_admin": false
      },
      "labels": [
        {
          "id": 1935755992,
          "node_id": "MDU6TGFiZWwxOTM1NzU1OTky",
          "url": "https://api.github.com/repos/bosens-China/blog/labels/%E5%BE%85%E5%AE%8C%E6%88%90%E7%B3%BB%E5%88%97",
          "name": "待完成系列",
          "color": "cc6e43",
          "default": false,
          "description": "等待完成的文章..."
        }
      ],
      "state": "open",
      "locked": false,
      "assignee": null,
      "assignees": [],
      "milestone": null,
      "comments": 0,
      "created_at": "2021-12-28T09:44:09Z",
      "updated_at": "2021-12-28T09:44:09Z",
      "closed_at": null,
      "author_association": "OWNER",
      "active_lock_reason": null,
      "body": null,
      "reactions": {
        "url": "https://api.github.com/repos/bosens-China/blog/issues/88/reactions",
        "total_count": 0,
        "+1": 0,
        "-1": 0,
        "laugh": 0,
        "hooray": 0,
        "confused": 0,
        "heart": 0,
        "rocket": 0,
        "eyes": 0
      },
      "timeline_url": "https://api.github.com/repos/bosens-China/blog/issues/88/timeline",
      "performed_via_github_app": null,
      "state_reason": null
    },
    {
      "url": "https://api.github.com/repos/bosens-China/blog/issues/83",
      "repository_url": "https://api.github.com/repos/bosens-China/blog",
      "labels_url": "https://api.github.com/repos/bosens-China/blog/issues/83/labels{/name}",
      "comments_url": "https://api.github.com/repos/bosens-China/blog/issues/83/comments",
      "events_url": "https://api.github.com/repos/bosens-China/blog/issues/83/events",
      "html_url": "https://github.com/bosens-China/blog/issues/83",
      "id": 1085661652,
      "node_id": "I_kwDOCzPAy85AteHU",
      "number": 83,
      "title": "漫谈程序初始化",
      "user": {
        "login": "bosens-China",
        "id": 39508895,
        "node_id": "MDQ6VXNlcjM5NTA4ODk1",
        "avatar_url": "https://avatars.githubusercontent.com/u/39508895?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bosens-China",
        "html_url": "https://github.com/bosens-China",
        "followers_url": "https://api.github.com/users/bosens-China/followers",
        "following_url": "https://api.github.com/users/bosens-China/following{/other_user}",
        "gists_url": "https://api.github.com/users/bosens-China/gists{/gist_id}",
        "starred_url": "https://api.github.com/users/bosens-China/starred{/owner}{/repo}",
        "subscriptions_url": "https://api.github.com/users/bosens-China/subscriptions",
        "organizations_url": "https://api.github.com/users/bosens-China/orgs",
        "repos_url": "https://api.github.com/users/bosens-China/repos",
        "events_url": "https://api.github.com/users/bosens-China/events{/privacy}",
        "received_events_url": "https://api.github.com/users/bosens-China/received_events",
        "type": "User",
        "site_admin": false
      },
      "labels": [
        {
          "id": 1371686608,
          "node_id": "MDU6TGFiZWwxMzcxNjg2NjA4",
          "url": "https://api.github.com/repos/bosens-China/blog/labels/%E6%BC%AB%E8%B0%88%E7%B3%BB%E5%88%97",
          "name": "漫谈系列",
          "color": "e7f3ee",
          "default": false,
          "description": "浅谈类文章"
        }
      ],
      "state": "open",
      "locked": false,
      "assignee": null,
      "assignees": [],
      "milestone": null,
      "comments": 0,
      "created_at": "2021-12-21T10:13:42Z",
      "updated_at": "2021-12-24T05:45:59Z",
      "closed_at": null,
      "author_association": "OWNER",
      "active_lock_reason": null,
      "body": "## 前言\r\n\r\n在软件工程的开发中有生命周期这个概念，它的作用就是定义各个阶段需要处理的事情跟 `tcp/ip` 协议分层一个意思，今天重点聊一聊初始化这个阶段。\r\n\r\n- 在日常使用的 `webpack`、`vite` 等工具会有一个配置收集的过程，这个过程就是初始化；\r\n- 在使用 `react`、`vue` 等框架时也会有 `created` 等生命周期函数暴露，在此阶段执行一些请求 api 等操作，这也是初始化；\r\n- 在使用 `koa` 等 `node` 框架启动服务之前进行 `use` 装载也是初始化；\r\n- 甚至，一段代码在执行之前通常会经历以下三个阶段，也可以概括为初始化\r\n  - 分词/词法分析\r\n  - 解析/语法分析\r\n  - 生成代码\r\n\r\n下面，我把任务分为两部分：\r\n\r\n- 可以前置化处理\r\n- 不能前置化处理\r\n\r\n## 前置初始化\r\n\r\n上面举例的一大堆，你会发现很多任务我们可以很自然完成，例如：\r\n\r\n- `webpack`、`vite` 读取配置，如果让你写大概就是根据 `npm script` 填写 config 的路径进行解析，然后通过 node 的 `fs` 模块进行读取\r\n- `koa` 在装载插件之前可能还需要自动导入所有符合要求的文件，这里可以通过 `glob` 模块来查找所有符合规则的文件进行批量导入\r\n\r\n上面的任务都可以通过 node 提供的同步 api 进行完成，且他们只会运行一次并不会影响到主体的功能。\r\n\r\n但是有一些操作，例如请求网络，异步加载模块后续的操作都需要等待加载完成之后才能执行，这种情况下没有同步的语法供使用，没办法完成前置依赖的处理。\r\n\r\n下面就抛砖引玉聊聊这种情况如何处理\r\n\r\n## 非前置化处理\r\n\r\n下面的例子都以 db 模块为例，它负责连接数据库之后进行读取数据，可能有一个 connect 的方法和 queue 的查询方法。\r\n\r\n```js\r\nclass Db {\r\n  constructor() {\r\n    this.signIn = false;\r\n  }\r\n  connect() {\r\n    if (this.signIn) {\r\n      return Promise.resolve(true);\r\n    }\r\n    return new Promise((resolve) => {\r\n      setTimeout(() => {\r\n        this.signIn = true;\r\n        resolve(true);\r\n      }, 3000);\r\n    });\r\n  }\r\n  async queue(str) {\r\n    if (!this.signIn) {\r\n      throw new Error(`必须连接数据库才能使用queue！`);\r\n    }\r\n    console.log(str);\r\n  }\r\n}\r\nconst db = new Db();\r\n\r\nconst app = async () => {\r\n  await db.connect();\r\n  await db.queue(`xx`);\r\n};\r\napp();\r\n```\r\n\r\n> 为了演示，后面代码全部为简化版本，不执行具体操作\r\n\r\n我们在程序中调用这个 db 模块，你会发现发现 `await db.connect()` 这段代码省略不了，我们的程序依赖 connect 这一步。\r\n\r\n且因为只是演示没有传递具体的密码和账号，但想象一下每次调用 db 都需要手动传递一次账号和密码也太糟心了。\r\n\r\n有什么办法可以简化这个过程呢？可以对 connect 进行一次封装，最后暴露 db 模块出去。\r\n\r\n### 封装 connect\r\n\r\n```js\r\nclass Db {\r\n  constructor() {\r\n    this.signIn = false;\r\n  }\r\n  connect() {\r\n    if (this.signIn) {\r\n      return Promise.resolve(true);\r\n    }\r\n    return new Promise((resolve) => {\r\n      setTimeout(() => {\r\n        this.signIn = true;\r\n        resolve(true);\r\n      }, 3000);\r\n    });\r\n  }\r\n  async queue(str) {\r\n    if (!this.signIn) {\r\n      throw new Error(`必须连接数据库才能使用queue！`);\r\n    }\r\n    console.log(str);\r\n  }\r\n}\r\nconst proxyDb = (() => {\r\n  const db = new Db();\r\n  let sign = false;\r\n  return async () => {\r\n    if (!sign) {\r\n      sign = await db.connect();\r\n    }\r\n    return db;\r\n  };\r\n})();\r\nconst app = async () => {\r\n  const db = await proxyDb();\r\n  await db.queue('xxx');\r\n};\r\napp();\r\n```\r\n\r\n使用一个代理将 `connect` 进行缓存起来，确保执行一次，后续使用直接 await 调用。\r\n\r\n不过这种方法虽然实现简单，但是体验只能说一般，有没有更加优雅的方法呢？\r\n\r\n### 预先队列\r\n\r\n观察上面 db 的操作，可以看到两部分\r\n\r\n- 登录操作\r\n- 依赖登录操作的后续\r\n\r\n我们可以把需要依赖登录的操作进行一个封装，如果没有登录就 push 到队列中，等到登录的时候进行一个整体的执行。\r\n\r\n```js\r\nclass Db {\r\n  constructor() {\r\n    this.signIn = false;\r\n    this.list = [];\r\n  }\r\n  connect() {\r\n    if (this.signIn) {\r\n      return Promise.resolve(true);\r\n    }\r\n    return new Promise((resolve) => {\r\n      setTimeout(() => {\r\n        this.signIn = true;\r\n        this.list.forEach((fn) => fn());\r\n        this.list = [];\r\n        resolve(true);\r\n      }, 3000);\r\n    });\r\n  }\r\n  queue(str) {\r\n    return new Promise((resolve) => {\r\n      const fn = () => {\r\n        console.log(str);\r\n        resolve(undefined);\r\n      };\r\n      if (this.signIn) {\r\n        return fn();\r\n      }\r\n      this.list.push(fn);\r\n    });\r\n  }\r\n}\r\nconst db = new Db();\r\ndb.connect();\r\nconst app = async () => {\r\n  await db.queue('xxx');\r\n};\r\napp();\r\n```\r\n\r\n- 在直接执行 `queue` 的时候状态还没有登录，添加到 `list` 中；\r\n- `connect` 执行成功，释放队列的值\r\n\r\n### 预先队列状态分离\r\n\r\n上述的要求我们实现了，但是后面如果还有其他的方法，例如 `toArray`、`findOne` 等方法，一个个写重复的步骤太繁琐了。\r\n\r\n按照设计模式单一原则，我们尝试进行分离一下\r\n\r\n- 执行 db 相关的操作只执行这部分\r\n- 对未登录状态的操作进行一个统一拦截\r\n\r\n这部分拦截可以基于 ES6 的 `proxy`，也可以是 class 的 `extends`，这里采用 extends 的方式来进行。\r\n\r\n```js\r\nclass Db {\r\n  constructor() {\r\n    this.signIn = false;\r\n  }\r\n  connect() {\r\n    if (this.signIn) {\r\n      return Promise.resolve(true);\r\n    }\r\n    return new Promise((resolve) => {\r\n      setTimeout(() => {\r\n        this.signIn = true;\r\n        resolve(true);\r\n      }, 3000);\r\n    });\r\n  }\r\n  async queue(str) {\r\n    console.log(str);\r\n  }\r\n}\r\nclass ProxyDb extends Db {\r\n  constructor() {\r\n    super();\r\n    this.list = [];\r\n    ['queue'].forEach((item) => {\r\n      this[item] = (...rest) => {\r\n        return new Promise((resolve) => {\r\n          const fn = () => {\r\n            const result = super[item].apply(this, rest);\r\n            return resolve(result);\r\n          };\r\n          if (!super.signIn) {\r\n            this.list.push(fn);\r\n            return;\r\n          }\r\n          fn();\r\n        });\r\n      };\r\n    });\r\n  }\r\n  async connect() {\r\n    await super.connect();\r\n    this.list.forEach((fn) => fn());\r\n  }\r\n}\r\nconst db = new ProxyDb();\r\ndb.connect();\r\ndb.queue('xxx');\r\n```\r\n\r\n通过继承重写 `connect` 操作，在 `constructor` 阶段把需要代理的方法手写到子类中，最后利用 Promise 的特性，等待 `connect `完成之后 `resolve`。\r\n\r\n### 顶层 await\r\n\r\n除了上述的两种方法，ES6 的最新 `顶层 await` 也可以帮助实现效果，顶层 await 是为了解决模块异步加载问题，对于本文刚好可以用到。\r\n\r\n我们之所以要对 `db` 模块 进行缓存和队列等一系列操作，就是因为初始化这部分我们没办法完成前置，不能像读取配置文件一样通过同步 api 语法完成。\r\n\r\n但是顶层 await 的出现，让其有一种同步的语法完成这部分工作。\r\n\r\n```js\r\nclass Db {\r\n  constructor() {\r\n    this.signIn = false;\r\n  }\r\n  connect() {\r\n    if (this.signIn) {\r\n      return Promise.resolve(true);\r\n    }\r\n    return new Promise((resolve) => {\r\n      setTimeout(() => {\r\n        this.signIn = true;\r\n        resolve(true);\r\n      }, 3000);\r\n    });\r\n  }\r\n  async queue(str) {\r\n    if (!this.signIn) {\r\n      throw new Error(`必须连接数据库才能使用queue！`);\r\n    }\r\n    console.log(str);\r\n  }\r\n}\r\n```\r\n\r\n这是最初我们的 db 模块，使用顶层 await 只需要，直接 `import` 后\r\n\r\n```js\r\nconst db = new Db();\r\nawait db.connect();\r\nawait db.queue('xxx');\r\n```\r\n\r\n## 最后\r\n\r\n抛砖引玉聊了初始化加载可能遇到的情况，受限于聊天的方向，很多异常情况没有给予考虑，例如数据库如果连接操作，需要手动对队列的操作进行 `reject` 的错误抛出。\r\n\r\n最后如果文章有什么错误或者错别字欢迎指出。\r\n\r\n> 参考：\r\n>\r\n> - [顶层 await](https://es6.ruanyifeng.com/#docs/async#%E9%A1%B6%E5%B1%82-await)\r\n> - [ECMAScript proposal: Top-level `await`](https://github.com/tc39/proposal-top-level-await)\r\n",
      "reactions": {
        "url": "https://api.github.com/repos/bosens-China/blog/issues/83/reactions",
        "total_count": 0,
        "+1": 0,
        "-1": 0,
        "laugh": 0,
        "hooray": 0,
        "confused": 0,
        "heart": 0,
        "rocket": 0,
        "eyes": 0
      },
      "timeline_url": "https://api.github.com/repos/bosens-China/blog/issues/83/timeline",
      "performed_via_github_app": null,
      "state_reason": null
    },
    {
      "url": "https://api.github.com/repos/bosens-China/blog/issues/86",
      "repository_url": "https://api.github.com/repos/bosens-China/blog",
      "labels_url": "https://api.github.com/repos/bosens-China/blog/issues/86/labels{/name}",
      "comments_url": "https://api.github.com/repos/bosens-China/blog/issues/86/comments",
      "events_url": "https://api.github.com/repos/bosens-China/blog/issues/86/events",
      "html_url": "https://github.com/bosens-China/blog/issues/86",
      "id": 1085665053,
      "node_id": "I_kwDOCzPAy85Ate8d",
      "number": 86,
      "title": "漫谈异步函数执行的前世今生",
      "user": {
        "login": "bosens-China",
        "id": 39508895,
        "node_id": "MDQ6VXNlcjM5NTA4ODk1",
        "avatar_url": "https://avatars.githubusercontent.com/u/39508895?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bosens-China",
        "html_url": "https://github.com/bosens-China",
        "followers_url": "https://api.github.com/users/bosens-China/followers",
        "following_url": "https://api.github.com/users/bosens-China/following{/other_user}",
        "gists_url": "https://api.github.com/users/bosens-China/gists{/gist_id}",
        "starred_url": "https://api.github.com/users/bosens-China/starred{/owner}{/repo}",
        "subscriptions_url": "https://api.github.com/users/bosens-China/subscriptions",
        "organizations_url": "https://api.github.com/users/bosens-China/orgs",
        "repos_url": "https://api.github.com/users/bosens-China/repos",
        "events_url": "https://api.github.com/users/bosens-China/events{/privacy}",
        "received_events_url": "https://api.github.com/users/bosens-China/received_events",
        "type": "User",
        "site_admin": false
      },
      "labels": [
        {
          "id": 1371686608,
          "node_id": "MDU6TGFiZWwxMzcxNjg2NjA4",
          "url": "https://api.github.com/repos/bosens-China/blog/labels/%E6%BC%AB%E8%B0%88%E7%B3%BB%E5%88%97",
          "name": "漫谈系列",
          "color": "e7f3ee",
          "default": false,
          "description": "浅谈类文章"
        }
      ],
      "state": "open",
      "locked": false,
      "assignee": null,
      "assignees": [],
      "milestone": null,
      "comments": 0,
      "created_at": "2021-12-21T10:17:10Z",
      "updated_at": "2021-12-23T05:42:51Z",
      "closed_at": null,
      "author_association": "OWNER",
      "active_lock_reason": null,
      "body": "今天简单聊聊异步函数的演变史，不着重讲解语法本身，而是借此窥探一下演变过程，以及是基于什么原因一步步推进。\r\n\r\n## 回调函数\r\n\r\n回调函数是最简单处理异步的方式，之所以会有回调函数原因在于 `JavaScript` 是单线程的语言，如果遇到 io 输入就会阻塞在这里，体验感受较差，为了不影响性能刻意设计。\r\n\r\n当然回调函数本身不是问题，例如我们点击提交按钮，在 `jQuery` 可能会这样写\r\n\r\n```js\r\n$(\".btn\").on(\"click\", () => {\r\n  // 验证通过，执行发送\r\n  $.ajax({\r\n    url: url,\r\n    data: data,\r\n    success: success,\r\n    dataType: dataType,\r\n  });\r\n});\r\n```\r\n\r\n可以看到，在功能简单的情况下使用回调函数是最简洁的写法。\r\n\r\n回调函数的问题在于需求的不断扩充，使得我们在回调函数不停的嵌套，且还要在每层考虑抛出异常的情况，想想就让人头大。\r\n\r\n```js\r\nfn1(fn2(fn3(fn4())));\r\n```\r\n\r\n下面通过一个爬虫例子举例，我们需要获取某网站列表字段还有每个列表对应的详情字段。\r\n\r\n```js\r\nconst request = require(\"request\");\r\n\r\nconst reptile = (fn) => {\r\n  request(\"xxx/list\", function (error, response, body) {\r\n    if (error) {\r\n      return fn(error);\r\n    }\r\n    request(\"xxx/details\", function (err, res, data) {\r\n      if (error) {\r\n        return fn(error);\r\n      }\r\n      fn(body, data);\r\n    });\r\n  });\r\n};\r\n```\r\n\r\n首先我们看上面这段代码，因为是只请求两次所以看起来不算混乱，不过也可以发现两处问题：\r\n\r\n- 回调函数内的命名，按照好的做法不应当存在遮蔽现象，内部的代码覆盖外层的变量，这样会导致引用和歧义\r\n- 代码在朝这 `>>>` 的形式拓展\r\n\r\n当然也可以通过职责分离来进行一定程度的缓解，例如上面代码我们把爬取列表和爬取详情分离开，通过一个主函数来进行组装，不过这样的作法也只是缓解，当程序越来越庞大维护和调试的成本也会越来越高。\r\n\r\n## Promise\r\n\r\n`Promise` 是社区为了解决回调问题而出现的提案，`ES6` 的时候将其吸收到规范内，变成了语言内置的特性。\r\n为了保持跟之前代码兼容，现在 Promise 的检测都是基于`.then`方法。\r\n\r\n在说 Promise 之前，我们来回忆一下它的特性\r\n\r\n- Promise 创建之后不可取消\r\n- Promise 只有三种状态：进行、完成和失败，状态变更后不会改变\r\n- Promise 可以随时 `.then`，每次 then 都返回一个新的 Promise 实例\r\n\r\n上面的特性总结下来就是给我们一个统一的处理机制，可以随时调用不用担心错过，这个在回调函数是可能发生的，例如一个事件没有初始监听，在发生之后监听是不会监听到的。\r\n\r\n还是拿上面的爬虫例子，看基于 Promise 写是不是更优雅一些\r\n\r\n```js\r\nconst rp = require(\"request-promise\");\r\n// 这里Promise原本的库不支持，所以改用一下Promise版本\r\nconst reptile = () => {\r\n  return rp(\"xxx/list\").then((listData) => {\r\n    return rp(\"xxx/details\").then((detailsData) => {\r\n      return {\r\n        listData,\r\n        detailsData,\r\n      };\r\n    });\r\n  });\r\n};\r\nreptile()\r\n  .then((res) => {\r\n    console.log(res);\r\n  })\r\n  .catch((err) => {\r\n    console.log(err);\r\n  });\r\n```\r\n\r\n观察上面代码，可以明显看到\r\n\r\n- 改善了`>>>`之前横向代码的发展，结构更加清晰\r\n- 拥有了统一的错误处理，在请求列表如果失败，后续的.then 也不会执行\r\n\r\n而且 Promise 包装起来也十分简单，下面以 wait 函数为例\r\n\r\n```js\r\nconst wait = (time) => new Promise((resolve) => setTimeout(resolve, time));\r\n```\r\n\r\n不过 Promise 也不完全都是优点，例如它只是把代码的书写结构从`>>>`变成往下的延伸，代码结构多起来也是挺糟心。\r\n\r\n## Generator\r\n\r\n`Generator` 是 ES6 新出现的 API，它的出现解决了两个问题：\r\n\r\n- 给 Symbol.iterator 提供了简单的实现\r\n- 给异步变成提供了新的思路\r\n\r\n我们重点聊一聊第二点，还是上面的爬虫例子，看下用 Generator 应当如何书写，为了省去一些写执行器的过程，这里直接结合`co`模块进行书写。\r\n\r\n> 如果对这部分感兴趣，可以点击了解[Generator 函数的异步应用](https://es6.ruanyifeng.com/#docs/generator-async)，里面会一步步包含如何实现一个简单执行器。\r\n\r\n```js\r\nconst rp = require(\"request-promise\");\r\n// 这里Promise原本的库不支持，所以改用一下Promise版本\r\nconst co = require(\"co\");\r\nfunction* getList() {\r\n  return rp(\"xxx/list\");\r\n}\r\nfunction* getDetails() {\r\n  return rp(\"xxx/details\");\r\n}\r\nfunction* peptile() {\r\n  const listData = yield getList();\r\n  const detailsData = yield getDetails();\r\n  return {\r\n    listData,\r\n    detailsData,\r\n  };\r\n}\r\nco(peptile);\r\n```\r\n\r\n再来观察一下上面代码，是不是感觉已经接近同步函数的写法了，这就是 Generator 带来的影响。\r\n\r\n不过它的缺点也很明显，没有内置执行器，需要额外自己编写。\r\n\r\n## async\r\n\r\n`ES2017` 引用了 `async` 函数，它本身是 Generator 的语法糖，我们上面说 Generator 最大缺点就是没有自带执行器，async 函数出现弥补了这一缺陷。\r\n\r\n- 它本身自带执行器，await 执行的可以是任何表达式，不需要一定基于 Promise\r\n- 语法更加简洁，返回值是基于 Promise\r\n\r\n还是爬虫的例子，这次我们改用 async 函数书写\r\n\r\n```js\r\nconst rp = require(\"request-promise\");\r\n// 这里Promise原本的库不支持，所以改用一下Promise版本\r\nfunction getList() {\r\n  return rp(\"xxx/list\");\r\n}\r\nfunction getDetails() {\r\n  return rp(\"xxx/details\");\r\n}\r\nconst peptile = async () => {\r\n  const listData = await getList();\r\n  const detailsData = await getDetails();\r\n  return {\r\n    listData,\r\n    detailsData,\r\n  };\r\n};\r\n```\r\n\r\n从上面的代码不难看出 async 函数的出现，标志异步编程解决方案的最终成熟，结合 `babel` 现在就可以在低版本浏览器运行起来。\r\n\r\n不过 async 虽然很好，但是也有一些实现不了的点，例如讲 Promise 的时候 wait 函数，用 async 函数就是实现不了，在解决问题一定要零和组合。\r\n\r\n## 最后\r\n\r\n简单回顾了一下 js 的异步史：`回调 > Promise > Generator > async`。受限于篇幅并没有讲解太多，但是从异步的解决可以看到 JavaScript 正在走向成熟。\r\n\r\n最后如果这篇文章有什么错误欢迎指点，如果对你有帮助也可以`start`下。\r\n",
      "reactions": {
        "url": "https://api.github.com/repos/bosens-China/blog/issues/86/reactions",
        "total_count": 0,
        "+1": 0,
        "-1": 0,
        "laugh": 0,
        "hooray": 0,
        "confused": 0,
        "heart": 0,
        "rocket": 0,
        "eyes": 0
      },
      "timeline_url": "https://api.github.com/repos/bosens-China/blog/issues/86/timeline",
      "performed_via_github_app": null,
      "state_reason": null
    },
    {
      "url": "https://api.github.com/repos/bosens-China/blog/issues/87",
      "repository_url": "https://api.github.com/repos/bosens-China/blog",
      "labels_url": "https://api.github.com/repos/bosens-China/blog/issues/87/labels{/name}",
      "comments_url": "https://api.github.com/repos/bosens-China/blog/issues/87/comments",
      "events_url": "https://api.github.com/repos/bosens-China/blog/issues/87/events",
      "html_url": "https://github.com/bosens-China/blog/issues/87",
      "id": 1085665660,
      "node_id": "I_kwDOCzPAy85AtfF8",
      "number": 87,
      "title": "函数组合",
      "user": {
        "login": "bosens-China",
        "id": 39508895,
        "node_id": "MDQ6VXNlcjM5NTA4ODk1",
        "avatar_url": "https://avatars.githubusercontent.com/u/39508895?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bosens-China",
        "html_url": "https://github.com/bosens-China",
        "followers_url": "https://api.github.com/users/bosens-China/followers",
        "following_url": "https://api.github.com/users/bosens-China/following{/other_user}",
        "gists_url": "https://api.github.com/users/bosens-China/gists{/gist_id}",
        "starred_url": "https://api.github.com/users/bosens-China/starred{/owner}{/repo}",
        "subscriptions_url": "https://api.github.com/users/bosens-China/subscriptions",
        "organizations_url": "https://api.github.com/users/bosens-China/orgs",
        "repos_url": "https://api.github.com/users/bosens-China/repos",
        "events_url": "https://api.github.com/users/bosens-China/events{/privacy}",
        "received_events_url": "https://api.github.com/users/bosens-China/received_events",
        "type": "User",
        "site_admin": false
      },
      "labels": [
        {
          "id": 1935755992,
          "node_id": "MDU6TGFiZWwxOTM1NzU1OTky",
          "url": "https://api.github.com/repos/bosens-China/blog/labels/%E5%BE%85%E5%AE%8C%E6%88%90%E7%B3%BB%E5%88%97",
          "name": "待完成系列",
          "color": "cc6e43",
          "default": false,
          "description": "等待完成的文章..."
        }
      ],
      "state": "open",
      "locked": false,
      "assignee": null,
      "assignees": [],
      "milestone": null,
      "comments": 0,
      "created_at": "2021-12-21T10:17:50Z",
      "updated_at": "2021-12-21T10:17:50Z",
      "closed_at": null,
      "author_association": "OWNER",
      "active_lock_reason": null,
      "body": null,
      "reactions": {
        "url": "https://api.github.com/repos/bosens-China/blog/issues/87/reactions",
        "total_count": 0,
        "+1": 0,
        "-1": 0,
        "laugh": 0,
        "hooray": 0,
        "confused": 0,
        "heart": 0,
        "rocket": 0,
        "eyes": 0
      },
      "timeline_url": "https://api.github.com/repos/bosens-China/blog/issues/87/timeline",
      "performed_via_github_app": null,
      "state_reason": null
    },
    {
      "url": "https://api.github.com/repos/bosens-China/blog/issues/85",
      "repository_url": "https://api.github.com/repos/bosens-China/blog",
      "labels_url": "https://api.github.com/repos/bosens-China/blog/issues/85/labels{/name}",
      "comments_url": "https://api.github.com/repos/bosens-China/blog/issues/85/comments",
      "events_url": "https://api.github.com/repos/bosens-China/blog/issues/85/events",
      "html_url": "https://github.com/bosens-China/blog/issues/85",
      "id": 1085663742,
      "node_id": "I_kwDOCzPAy85Aten-",
      "number": 85,
      "title": "手写PromiseA+规范",
      "user": {
        "login": "bosens-China",
        "id": 39508895,
        "node_id": "MDQ6VXNlcjM5NTA4ODk1",
        "avatar_url": "https://avatars.githubusercontent.com/u/39508895?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bosens-China",
        "html_url": "https://github.com/bosens-China",
        "followers_url": "https://api.github.com/users/bosens-China/followers",
        "following_url": "https://api.github.com/users/bosens-China/following{/other_user}",
        "gists_url": "https://api.github.com/users/bosens-China/gists{/gist_id}",
        "starred_url": "https://api.github.com/users/bosens-China/starred{/owner}{/repo}",
        "subscriptions_url": "https://api.github.com/users/bosens-China/subscriptions",
        "organizations_url": "https://api.github.com/users/bosens-China/orgs",
        "repos_url": "https://api.github.com/users/bosens-China/repos",
        "events_url": "https://api.github.com/users/bosens-China/events{/privacy}",
        "received_events_url": "https://api.github.com/users/bosens-China/received_events",
        "type": "User",
        "site_admin": false
      },
      "labels": [
        {
          "id": 1935755992,
          "node_id": "MDU6TGFiZWwxOTM1NzU1OTky",
          "url": "https://api.github.com/repos/bosens-China/blog/labels/%E5%BE%85%E5%AE%8C%E6%88%90%E7%B3%BB%E5%88%97",
          "name": "待完成系列",
          "color": "cc6e43",
          "default": false,
          "description": "等待完成的文章..."
        }
      ],
      "state": "open",
      "locked": false,
      "assignee": null,
      "assignees": [],
      "milestone": null,
      "comments": 0,
      "created_at": "2021-12-21T10:15:52Z",
      "updated_at": "2021-12-21T10:15:52Z",
      "closed_at": null,
      "author_association": "OWNER",
      "active_lock_reason": null,
      "body": null,
      "reactions": {
        "url": "https://api.github.com/repos/bosens-China/blog/issues/85/reactions",
        "total_count": 0,
        "+1": 0,
        "-1": 0,
        "laugh": 0,
        "hooray": 0,
        "confused": 0,
        "heart": 0,
        "rocket": 0,
        "eyes": 0
      },
      "timeline_url": "https://api.github.com/repos/bosens-China/blog/issues/85/timeline",
      "performed_via_github_app": null,
      "state_reason": null
    },
    {
      "url": "https://api.github.com/repos/bosens-China/blog/issues/69",
      "repository_url": "https://api.github.com/repos/bosens-China/blog",
      "labels_url": "https://api.github.com/repos/bosens-China/blog/issues/69/labels{/name}",
      "comments_url": "https://api.github.com/repos/bosens-China/blog/issues/69/comments",
      "events_url": "https://api.github.com/repos/bosens-China/blog/issues/69/events",
      "html_url": "https://github.com/bosens-China/blog/issues/69",
      "id": 911281718,
      "node_id": "MDU6SXNzdWU5MTEyODE3MTg=",
      "number": 69,
      "title": "Webpack 插件入门",
      "user": {
        "login": "bosens-China",
        "id": 39508895,
        "node_id": "MDQ6VXNlcjM5NTA4ODk1",
        "avatar_url": "https://avatars.githubusercontent.com/u/39508895?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bosens-China",
        "html_url": "https://github.com/bosens-China",
        "followers_url": "https://api.github.com/users/bosens-China/followers",
        "following_url": "https://api.github.com/users/bosens-China/following{/other_user}",
        "gists_url": "https://api.github.com/users/bosens-China/gists{/gist_id}",
        "starred_url": "https://api.github.com/users/bosens-China/starred{/owner}{/repo}",
        "subscriptions_url": "https://api.github.com/users/bosens-China/subscriptions",
        "organizations_url": "https://api.github.com/users/bosens-China/orgs",
        "repos_url": "https://api.github.com/users/bosens-China/repos",
        "events_url": "https://api.github.com/users/bosens-China/events{/privacy}",
        "received_events_url": "https://api.github.com/users/bosens-China/received_events",
        "type": "User",
        "site_admin": false
      },
      "labels": [
        {
          "id": 1740577858,
          "node_id": "MDU6TGFiZWwxNzQwNTc3ODU4",
          "url": "https://api.github.com/repos/bosens-China/blog/labels/%E5%B7%A5%E5%85%B7%E7%9B%B8%E5%85%B3",
          "name": "工具相关",
          "color": "f73d62",
          "default": false,
          "description": "工程化相关的东西"
        }
      ],
      "state": "open",
      "locked": false,
      "assignee": null,
      "assignees": [],
      "milestone": null,
      "comments": 0,
      "created_at": "2021-06-04T08:53:06Z",
      "updated_at": "2021-12-21T10:04:02Z",
      "closed_at": null,
      "author_association": "OWNER",
      "active_lock_reason": null,
      "body": "# webpack 插件入门\r\n\r\n![bg](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/69547c8c2fe9429faf29c425de792cb3~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n最近写了一个移动端项目，不过每次 build 的时候还需要手动上传服务器感觉很不方便，毕竟每次删除文件夹然后拖拽上传的过程太重复了，本着不重复造轮子的原则去 Github 翻了一下，发现 `Upload`上传插件还是蛮多的，不过距离自己的要求还是有些差异，很多插件只是只是单一职责，只负责上传这件事情。\r\n\r\n而如果只负责上传文件不做删除会导致服务器文件越来越多，占用额外的储存成本，WebPack 在 build 过程中会检测相关依赖是否变更，如果变更相关文件的 `hash` 也是发生变更，这样就会导致新的文件上传到服务器，而旧资源却不会被覆盖替换掉。\r\n\r\n## 基本概念\r\n\r\nWebPack 的插件是基于 `Tapable` 实现的，它是一种发布订阅的实现，作用就是将插件的各个生命周期钩子广播出去，然后在合适的时机执行。同时只让插件关注自身的订阅，保证插件组合起来有序进行。\r\n\r\n`Tapable`暴露了三个方法：\r\n\r\n- tap： 可以注册同步钩子和异步钩子\r\n- tapAsync： 回调形式注册异步钩子\r\n- tapPromise： Promise 形式注册异步钩子\r\n\r\n在编写插件时 WebPack 显示要求我们有 `apply` 方法，这样做的原因是 WebPack 执行期间会执行 apply 方法，并且注入`compiler`，之后在`compiler`上订阅钩子事件，在合适时间触发已订阅的 apply 方法\r\n\r\n再看一下官方给出的示例代码\r\n\r\n```js\r\n// A JavaScript class.\r\nclass MyExampleWebpackPlugin {\r\n  // Define `apply` as its prototype method which is supplied with compiler as its argument\r\n  apply(compiler) {\r\n    // Specify the event hook to attach to\r\n    compiler.hooks.emit.tapAsync('MyExampleWebpackPlugin', (compilation, callback) => {\r\n      console.log('This is an example plugin!');\r\n      console.log(\r\n        'Here’s the `compilation` object which represents a single build of assets:',\r\n        compilation\r\n      );\r\n\r\n      // Manipulate the build using the plugin API provided by webpack\r\n      compilation.addModule(/* ... */);\r\n\r\n      callback();\r\n    });\r\n  }\r\n}\r\n```\r\n\r\n上面插件在`compiler`中订阅了 `emit` 的异步钩子，然后做了一些操作之后，执行 `callback()` 回调\r\n\r\n> 这里稍微说下，对于 `tapAsync` 的钩子，`callback` 必须执行，否则程序会一致在等待，而 callback 左侧的 `compilation` 是用来访问这一次的资源构建信息，例如一些输出的资源，相互依赖的关系等。\r\n\r\n了解了上面的信息，我们找一下 [compiler 钩子 ](https://webpack.docschina.org/api/compiler-hooks/)有没有我们需要的，文档中列举的钩子很多：\r\n\r\n- environment\r\n- afterEnvironment\r\n- entryOption\r\n- ...\r\n\r\n翻到最后会看到一个 `done` 的钩子，它在 `compilation` 完成时执行。\r\n\r\n这里我们需要的前置基本准备齐全了，下面要做的就是在 `done` 触发时\r\n\r\n- 连接 ssh 服务器，执行`rm-rf xx`的操作\r\n- 上传 build 后的资源到 xx 目录下\r\n\r\n## 插件开发准备\r\n\r\n> 之后的内容采用 `TypeScript` 作为开发，如果你没有相关经验直接跳过类型注释即可\r\n\r\n为了方便解耦和复用文件，我们创建了一个 utils.ts 文件\r\n\r\n```ts\r\n// utils.ts\r\nimport { NodeSSH } from 'node-ssh';\r\n\r\nimport { Option } from './typings';\r\n\r\nexport const isObject = (obj: any): obj is Object => typeof obj === 'object' && obj;\r\n\r\n// 删除文件夹\r\nexport const removeDir = async (option: Option) => {\r\n  const ssh = new NodeSSH();\r\n  await ssh.connect(option);\r\n  await ssh.execCommand(`rm -rf ${option.to}`);\r\n  await ssh.dispose();\r\n};\r\n\r\n// 上传文件夹\r\nexport const uploadDir = async (option: Option) => {\r\n  const ssh = new NodeSSH();\r\n  await ssh.connect(option);\r\n  await ssh.putDirectory(option.src!, option.to, {\r\n    recursive: true,\r\n  });\r\n  await ssh.dispose();\r\n};\r\n```\r\n\r\n它暴露三个方法，删除文件夹和上传文件夹还有一个判断 object 的方法，上面的删除和上传文件夹基于 [node-ssh](https://github.com/steelbrain/node-ssh) 封装而来，如果你有兴趣了解可以去阅读一下文档\r\n\r\n## 插件开发\r\n\r\n剩下的插件开发，就是获取用户填写一些必要字段，例如密码、上传的服务器路径、host 等信息，结合上面的 `utils` 和钩子，完成这个上传过程\r\n\r\n```ts\r\n// upload-plugin.ts\r\nimport { Compiler, Stats } from 'webpack';\r\nimport { isObject, uploadDir, removeDir } from './utils';\r\nimport { Option } from './typings';\r\n\r\nclass UploadPlugin {\r\n  public stats: Stats;\r\n\r\n  public option: Option & Record<string, any>;\r\n\r\n  public removeDir: boolean;\r\n\r\n  constructor(option: Option, remove = true) {\r\n    this.stats = null as unknown as Stats;\r\n    this.option = option;\r\n    this.removeDir = remove;\r\n    this.init();\r\n  }\r\n\r\n  init() {\r\n    this.checkOption();\r\n    this.setOption();\r\n  }\r\n\r\n  // 检验参数\r\n  checkOption(option = this.option) {\r\n    if (!isObject(option)) {\r\n      throw new Error('option Must be an object!');\r\n    }\r\n    const result = ['to', 'host'].filter((f) => !option[f]);\r\n    if (result.length) {\r\n      throw new Error(`The ${result.join(',')} parameter is required!`);\r\n    }\r\n    if (!option.password && !option.privateKey) {\r\n      throw new Error('password and privateKey must have one entry!');\r\n    }\r\n  }\r\n\r\n  // 初始化默认值\r\n  setOption() {\r\n    const option = {\r\n      port: 22,\r\n      username: 'root',\r\n    };\r\n    this.option = {\r\n      ...option,\r\n      ...this.option,\r\n    };\r\n  }\r\n\r\n  apply(compiler: Compiler) {\r\n    compiler.hooks.done.tap('upload-plugin', async (stats) => {\r\n      console.time('time');\r\n      // 获取默认的信息，如果src不存在直接使用webpack的配置\r\n      const src = stats.compilation.outputOptions.path;\r\n      this.option.src = this.option.src ?? src;\r\n      if (this.removeDir) {\r\n        await removeDir(this.option);\r\n      }\r\n      await uploadDir(this.option);\r\n      console.timeEnd('time');\r\n    });\r\n  }\r\n}\r\n\r\nexport default UploadPlugin;\r\n```\r\n\r\n整体代码还是很简洁的，去除参数校验部分还有赋值默认值参数，剩下的就是根据参数来是否删除远程文件夹，之后执行上传方法。\r\n\r\n你可能很好奇 `Option` 的定义是啥，这个是结合 `node-ssh` 的连接信息加上自定义扩展的一些字段而来的\r\n\r\n```ts\r\n// typings.d.ts\r\nexport interface Option {\r\n  src?: string;\r\n  to: string;\r\n  port?: number;\r\n  host: string;\r\n  username?: string;\r\n  password?: string;\r\n  privateKey?: string;\r\n}\r\n```\r\n\r\n## 最后\r\n\r\n完整代码已经上传了[Github 仓库](https://github.com/bosens-China/upload-plugin)，如果你有兴趣可以具体看下更具体的一些信息，如果对你有帮助也欢迎 `star`。\r\n",
      "reactions": {
        "url": "https://api.github.com/repos/bosens-China/blog/issues/69/reactions",
        "total_count": 0,
        "+1": 0,
        "-1": 0,
        "laugh": 0,
        "hooray": 0,
        "confused": 0,
        "heart": 0,
        "rocket": 0,
        "eyes": 0
      },
      "timeline_url": "https://api.github.com/repos/bosens-China/blog/issues/69/timeline",
      "performed_via_github_app": null,
      "state_reason": null
    },
    {
      "url": "https://api.github.com/repos/bosens-China/blog/issues/70",
      "repository_url": "https://api.github.com/repos/bosens-China/blog",
      "labels_url": "https://api.github.com/repos/bosens-China/blog/issues/70/labels{/name}",
      "comments_url": "https://api.github.com/repos/bosens-China/blog/issues/70/comments",
      "events_url": "https://api.github.com/repos/bosens-China/blog/issues/70/events",
      "html_url": "https://github.com/bosens-China/blog/issues/70",
      "id": 913346542,
      "node_id": "MDU6SXNzdWU5MTMzNDY1NDI=",
      "number": 70,
      "title": "团队规范系列之 git 规范",
      "user": {
        "login": "bosens-China",
        "id": 39508895,
        "node_id": "MDQ6VXNlcjM5NTA4ODk1",
        "avatar_url": "https://avatars.githubusercontent.com/u/39508895?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bosens-China",
        "html_url": "https://github.com/bosens-China",
        "followers_url": "https://api.github.com/users/bosens-China/followers",
        "following_url": "https://api.github.com/users/bosens-China/following{/other_user}",
        "gists_url": "https://api.github.com/users/bosens-China/gists{/gist_id}",
        "starred_url": "https://api.github.com/users/bosens-China/starred{/owner}{/repo}",
        "subscriptions_url": "https://api.github.com/users/bosens-China/subscriptions",
        "organizations_url": "https://api.github.com/users/bosens-China/orgs",
        "repos_url": "https://api.github.com/users/bosens-China/repos",
        "events_url": "https://api.github.com/users/bosens-China/events{/privacy}",
        "received_events_url": "https://api.github.com/users/bosens-China/received_events",
        "type": "User",
        "site_admin": false
      },
      "labels": [
        {
          "id": 3661376441,
          "node_id": "LA_kwDOCzPAy87aPCu5",
          "url": "https://api.github.com/repos/bosens-China/blog/labels/%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83",
          "name": "代码规范",
          "color": "5319e7",
          "default": false,
          "description": "团队规范、代码规范、技术选型等相关内容"
        }
      ],
      "state": "open",
      "locked": false,
      "assignee": null,
      "assignees": [],
      "milestone": null,
      "comments": 0,
      "created_at": "2021-06-07T09:37:17Z",
      "updated_at": "2021-12-21T10:03:46Z",
      "closed_at": null,
      "author_association": "OWNER",
      "active_lock_reason": null,
      "body": "最近一周的工作重心就是在梳理团队规范，在写的过程也查缺补漏了不少知识，剔除掉关于公司场景的部分就有了这一系列的文章，预计写四部分：\r\n1. git规范\r\n2. [工程规范](https://github.com/bosens-China/blog/issues/71)\r\n3. [用户体验规范](https://github.com/bosens-China/blog/issues/72)\r\n4. [命名规范](https://github.com/bosens-China/blog/issues/73)\r\n\r\n\r\n# Git 规范\r\n\r\nGit 作为现在最流行的分布式管理工具，基本上是每个团队的必备，下面就从分支和提交这两部分展开\r\n\r\n## 什么是分支\r\n\r\n分支就是把你的工作从开发主线上分离开来，以免影响开发主线，假设你准备开发一个新功能，但是需要两周才能完成，第一周你写了 50%的代码，如果立刻提交，由于代码还没写完，不完整的代码库会导致别人不能干活了。如果等代码全部写完再一次提交，又存在丢失每天进度的巨大风险。\r\n\r\n现在有了分支，就不用怕了。你创建了一个属于你自己的分支，别人看不到，还继续在原来的分支上正常工作，而你在自己的分支上干活，想提交就提交，直到开发完毕后，再一次性合并到原来的分支上，这样，既安全，又不影响别人工作。\r\n\r\n![1.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/305ee83c688b49ae859b493fbf7d7218~tplv-k3u1fbpfcp-watermark.image)\r\n\r\n## 分支如何命名\r\n\r\n分支按照类型可以分为以下几种\r\n\r\n| 分支名称         |       命名        |                                                       说明 |\r\n| ---------------- | :---------------: | ---------------------------------------------------------: |\r\n| 主分支           |      master       | 主分支，所有提供给用户使用的正式版本，都在这个主分支上发布 |\r\n| 开发主分支       |      develop      |                         开发分支，永远是功能最新最全的分支 |\r\n| 功能分支         |    feature-\\*     |                         新功能分支，某个功能点正在开发阶段 |\r\n| 发布版本         |    release-\\*     |                                       发布定期要上线的功能 |\r\n| 修复发布版本分支 | bugfix-release-\\* |                                               修复测试 bug |\r\n| 紧急修复分支     | bugfix-master-\\*  |                                     紧急修复线上代码的 bug |\r\n\r\n## 开发流程示例\r\n\r\n下面就以一个产品从最初到发布上线为例子，讲解 git 流程\r\n\r\n### 初始化\r\n\r\n第一步，初始仓库的信息，同时创建`develop`分支\r\n\r\n![2.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cf641e319fd14f93a08b9ee748b0706b~tplv-k3u1fbpfcp-watermark.image)\r\n\r\n### 开发新功能\r\n\r\n开发人员在`develop`分支开发新的功能，包括:新特性与 Bug 修复\r\n\r\n![3.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2656d065a3714906a8a503b318698841~tplv-k3u1fbpfcp-watermark.image)\r\n\r\n如果并行开发多个需求，可以创建 `feature 分支`，命名规则为`feature-分支创建日期-新特性关键字`，例如:`feature-20190919-i18n`\r\n\r\n![4.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/dba19d9f51714f7caa6f8e45ebd1e120~tplv-k3u1fbpfcp-watermark.image)\r\n\r\n开发完成之后将 feature 分支合并到 develop 分支，最后删除 feature 分支\r\n\r\n> 什么时候使用 feature\r\n>\r\n> - 开发一个独立的新特性(完成时，需合并到 develop 分支)\r\n> - 技术研究与尝试(若失败，可随时删除 feature 分支)\r\n> - 提前实现下一个版本需要开发的特性(可不在本次迭代中发布)\r\n\r\n### 准备发布版本\r\n\r\n如果 develop 分支上的功开发完毕\r\n\r\n1. 建 release 分支(发布分支)命名规则:release-分支创建日期-待发布版本号，例如：`release-20190919-v1.0.0`\r\n2. 对 release 分支的版本号进行修改（之后提交一次）\r\n3. 通知测试人员测试\r\n\r\n![5.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f639127d864f404b9cd12d85cc8e5547~tplv-k3u1fbpfcp-watermark.image)\r\n\r\n### 修复问题\r\n\r\n开发人员在 release 修复问题，此时禁止开发新功能，只对 bug 进行修复\r\n\r\n![6.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5566fa0226ee43b78f8daf7d4ed14950~tplv-k3u1fbpfcp-watermark.image)\r\n\r\n### 最终发布\r\n\r\n经过测试没有发现问题，或者问题已经全部修复，这个时候\r\n\r\n1. 将 release 分支同时合并到 master 分支与 develop 分支\r\n\r\n   - 通知测试，进行主分支测试\r\n   - 如果没问题，进行下一步，如果有问题回到 release\r\n\r\n1. 删除 release 分支\r\n1. 构建应用到服务器\r\n\r\n![7.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ad87a01a2eb845a99dfc4ff489e6b4e9~tplv-k3u1fbpfcp-watermark.image)\r\n\r\n## commit 规范\r\n\r\n目前开源社区主要应用是规范是[Angular Git Commit Guidelines](https://github.com/angular/angular.js/blob/master/DEVELOPERS.md#-git-commit-guidelines)\r\n\r\n它由下面几部分组成:\r\n\r\n```sh\r\n<type>: <subject>\r\n<BLANK LINE>\r\n<body>\r\n<BLANK LINE>\r\n<footer>\r\n```\r\n\r\n### type\r\n\r\n本次 commit 的类型，诸如 bugfix、docs、style 等\r\n\r\n完整的类型如下：\r\n\r\n| 名称     |                        描述                        |\r\n| -------- | :------------------------------------------------: |\r\n| feat     |                     添加新特性                     |\r\n| fix      |                      修复 bug                      |\r\n| docs     |                   仅仅修改了文档                   |\r\n| style    | 仅仅修改了空格、格式缩进、都好等等，不改变代码逻辑 |\r\n| refactor |         代码重构，没有加新功能或者修复 bug         |\r\n| perf     |                增加代码进行性能测试                |\r\n| test     |                    增加测试用例                    |\r\n| chore    |        改变构建流程、或者增加依赖库、工具等        |\r\n\r\n### scope\r\n\r\n本次 commit 波及的范围\r\n\r\n### subject\r\n\r\n简明扼要的阐述下本次 commit 的主旨\r\n\r\n有几点需要注意：\r\n\r\n1. 首字母不要大写\r\n2. 结尾无需添加标点\r\n\r\n### body\r\n\r\n主体内容，我们需要把本次 commit 详细的描述一下，比如此次变更的动机等，不能超出 72 个字符\r\n\r\n> 为什么需要\r\n>\r\n> - 它可能是用来修复一个 bug，增加一个 feature，提升性能、可靠性、稳定性等等\r\n> - 它如何解决这个问题? 具体描述解决问题的步骤\r\n> - 是否存在副作用、风险?\r\n\r\n### footer\r\n\r\n描述下与之关联的 issue 或 break change，在公司项目中基本忽略即可\r\n\r\n## 参考文章\r\n\r\n- [Git 分支管理规范](https://juejin.cn/post/6844903945245048846#heading-1)\r\n",
      "reactions": {
        "url": "https://api.github.com/repos/bosens-China/blog/issues/70/reactions",
        "total_count": 0,
        "+1": 0,
        "-1": 0,
        "laugh": 0,
        "hooray": 0,
        "confused": 0,
        "heart": 0,
        "rocket": 0,
        "eyes": 0
      },
      "timeline_url": "https://api.github.com/repos/bosens-China/blog/issues/70/timeline",
      "performed_via_github_app": null,
      "state_reason": null
    },
    {
      "url": "https://api.github.com/repos/bosens-China/blog/issues/74",
      "repository_url": "https://api.github.com/repos/bosens-China/blog",
      "labels_url": "https://api.github.com/repos/bosens-China/blog/issues/74/labels{/name}",
      "comments_url": "https://api.github.com/repos/bosens-China/blog/issues/74/comments",
      "events_url": "https://api.github.com/repos/bosens-China/blog/issues/74/events",
      "html_url": "https://github.com/bosens-China/blog/issues/74",
      "id": 931481508,
      "node_id": "MDU6SXNzdWU5MzE0ODE1MDg=",
      "number": 74,
      "title": "为 React 添加双向绑定 hooks",
      "user": {
        "login": "bosens-China",
        "id": 39508895,
        "node_id": "MDQ6VXNlcjM5NTA4ODk1",
        "avatar_url": "https://avatars.githubusercontent.com/u/39508895?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bosens-China",
        "html_url": "https://github.com/bosens-China",
        "followers_url": "https://api.github.com/users/bosens-China/followers",
        "following_url": "https://api.github.com/users/bosens-China/following{/other_user}",
        "gists_url": "https://api.github.com/users/bosens-China/gists{/gist_id}",
        "starred_url": "https://api.github.com/users/bosens-China/starred{/owner}{/repo}",
        "subscriptions_url": "https://api.github.com/users/bosens-China/subscriptions",
        "organizations_url": "https://api.github.com/users/bosens-China/orgs",
        "repos_url": "https://api.github.com/users/bosens-China/repos",
        "events_url": "https://api.github.com/users/bosens-China/events{/privacy}",
        "received_events_url": "https://api.github.com/users/bosens-China/received_events",
        "type": "User",
        "site_admin": false
      },
      "labels": [
        {
          "id": 1473940161,
          "node_id": "MDU6TGFiZWwxNDczOTQwMTYx",
          "url": "https://api.github.com/repos/bosens-China/blog/labels/%E6%A1%86%E6%9E%B6%E7%9B%B8%E5%85%B3",
          "name": "框架相关",
          "color": "42b883",
          "default": false,
          "description": "目前Vue和React为主"
        }
      ],
      "state": "open",
      "locked": false,
      "assignee": null,
      "assignees": [],
      "milestone": null,
      "comments": 0,
      "created_at": "2021-06-28T11:43:52Z",
      "updated_at": "2021-12-21T10:03:06Z",
      "closed_at": null,
      "author_association": "OWNER",
      "active_lock_reason": null,
      "body": "最近换了一家新公司，用的技术栈`react`为主，所以上周紧急的看了一下`react`相关的文档，也对照文档写了几个 demo，不过在开发阶段我的体验还是蛮差的。\r\n\r\n- 生态很繁荣，但是不知道那种方案是最佳\r\n- 开发效率很繁琐（这一点待商榷）\r\n\r\n刚刚简单写了一个 todolist 的功能，不过在对 list 进行保存、修改、删除的时候，感觉很酸爽\r\n\r\n```js\r\n// ...\r\nconst list = myContent.list[props.index]!;\r\nlist.title = inp;\r\nlist.show = false;\r\nmyContent.setlist([...myContent.list]);\r\n```\r\n\r\n大量这样的代码，所以就想通过 hook + 数据劫持 来实现下面这样的功能\r\n\r\n```js\r\nimport { useModel } from './utils';\r\nconst app = () => {\r\n  // ... 省略其他代码\r\n  const [arr] = useModel([]);\r\n  arr.push(1);\r\n};\r\n```\r\n\r\n在 push 之类的操作时，自动帮我们完成`setArr([...arr])`这样的操作\r\n\r\n## 实现思路\r\n\r\n之前想借鉴`useEffect, useCallback`之类自带的 hook 来实现，不过很遗憾这个必须要显示调用`setxxx`才会触发，所以现在摆在面前的如何通过变化之后通过回调来触发 set 的操作。\r\n\r\n因为之前使用的是 vue 所以脑海中最先蹦出的就是通过`Object.defineProperty`来劫持数据\r\n\r\n> 这里补充一点，proxy 的效果更好，不过这里会有一些兼容性问题，后面我会将这些功能封装成一个库，优先使用`proxy`之后降级到`Object.defineProperty`\r\n\r\n## Object.defineProperty\r\n\r\n刷过面试题的应该对这个 api 应该不陌生，它是 vue2.x 实现数据劫持的关键，通过拦截对象的 get 和 set 属性，之后分发事件来通知视图进行更新。\r\n\r\n不过这个 api 是有一些缺点的，尤其是对数组而言\r\n\r\n- 不支持拦截`length`属性，这点很关键，会导致我们直接修改`arr.length = 0`无效，原因是内部引擎的规定不允许监听\r\n\r\n- 不支持方法监听，例如使用 push 等\r\n\r\n明确上面两点之后，我们就来动手设计这个`useModel`应该怎么写，思路借鉴 vue2.x 的写法，\r\n\r\n- 约定不能直接修改`length`，例如：`arr[100] = {}`；\r\n- 使用变异方法`push、pop、shift、unshift、splice、sort、reverse`来完成对数组的删除和其他修改；\r\n- 允许修改存在的数组下标，可以直接修改 arr[0]这样的数据；\r\n\r\n> 这里稍微提一下 vue 官方不允许修改已存在数组下标是因为存在性能考虑\r\n\r\n## 实现思路\r\n\r\n实现思路很简单，主要就是递归遍历对象的所有属性，之后将属性改用`get`和`set`的形式进行定义，在对象属性值更改的时候来调用`useState`返回的 set 方法进行数据的更新。\r\n\r\n而数组的变异方法监听，则是通过改写数组的原型链实现，例如\r\n\r\n```js\r\nconst arr = [];\r\nconst myProto = Object.create(Array.prototype);\r\nconst arrFn = arr.push;\r\nmyProto.push = (...rest) => {\r\n  consoole.log(1);\r\n  arrFn.push.apply(arr, rest);\r\n};\r\nObject.setPrototypeOf(arr, myProto);\r\n// 1\r\narr.push(1);\r\n```\r\n\r\n将这个数组的 `__propo__`指向我们自定义的原型对象上，这个原型对象上有 push、pop 等变异方法，通过调用变异方法完成对原数组的的操作和对 set 的更新\r\n\r\n![实现思路](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/db03f6a89974472f9bd617577d3b6365~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n## 具体实现\r\n\r\n代码量并不是很大，所以直接放代码了，一些关键的地方已经进行了注释\r\n\r\n```js\r\nimport { useState } from 'react';\r\nconst isObject = (obj) => {\r\n  return (typeof obj === 'object' && obj) || typeof obj === 'function';\r\n};\r\n// 直接改写成一个通用遍历，这里进行类型判断，后续的useModel则不需要进行判断了\r\nconst each = (obj, change) => {\r\n  if (!isObject(obj)) {\r\n    return;\r\n  }\r\n  const isArr = Array.isArray(obj);\r\n  const keys = isArr ? obj : Object.keys(obj);\r\n  for (let i = 0, len = keys.length; i < len; i++) {\r\n    const key = isArr ? i : keys[i];\r\n    const value = obj[key];\r\n    change(key, value);\r\n  }\r\n};\r\nexport const useModel = (obj) => {\r\n  const [model, setModel] = useState(obj);\r\n  // 更新的时候直接更新顶层对象即可，因为这是hook写法不存在class的局部替换\r\n  const setRootValue = () => {\r\n    if (Array.isArray(model)) {\r\n      setModel([...model]);\r\n      return;\r\n    }\r\n    setModel(Object.assign({...model});\r\n  };\r\n  // 定义对象的key\r\n  const defineProperty = (key, value, o) => {\r\n    Object.defineProperty(o, key, {\r\n      enumerable: true,\r\n      get() {\r\n        return value;\r\n      },\r\n      set(v) {\r\n        if (v === value || (Number.isNaN(v) && Number.isNaN(value))) {\r\n          return;\r\n        }\r\n        value = v;\r\n        setRootValue();\r\n      },\r\n    });\r\n  };\r\n  const definePropertyArray = (all) => {\r\n    const myProto = Object.create(Array.prototype);\r\n    each(['push', 'pop', 'shift', 'unshift', 'splice', 'sort', 'reverse'], (_, value) => {\r\n      const fn = all[value];\r\n      myProto[value] = (...rest) => {\r\n        fn.apply(all, rest);\r\n        setRootValue();\r\n      };\r\n    });\r\n    Object.setPrototypeOf(all, myProto);\r\n  };\r\n  const observer = (all) => {\r\n    each(all, (key, value) => {\r\n      defineProperty(key, value, all);\r\n      observer(value);\r\n    });\r\n    if (Array.isArray(all)) {\r\n      definePropertyArray(all);\r\n    }\r\n  };\r\n  observer(model);\r\n  return [model, setRootValue];\r\n};\r\n```\r\n\r\n> 注意，上面并没有在`Object.defineProperty`set 的时候继续执行深度监听，是因为 hook 在改变的时候就会重新执行这个方法，所以并不需要深度监听\r\n\r\n## 最后\r\n\r\n如果写的有什么不对的地方欢迎指出，如果对你有帮助可以点一下`start`\r\n\r\n为了方便验证效果，放一个[示例代码（可能需要翻墙）](https://codesandbox.io/s/eloquent-kilby-1cdj7?from-embed=&file=/src/App.js)\r\n",
      "reactions": {
        "url": "https://api.github.com/repos/bosens-China/blog/issues/74/reactions",
        "total_count": 0,
        "+1": 0,
        "-1": 0,
        "laugh": 0,
        "hooray": 0,
        "confused": 0,
        "heart": 0,
        "rocket": 0,
        "eyes": 0
      },
      "timeline_url": "https://api.github.com/repos/bosens-China/blog/issues/74/timeline",
      "performed_via_github_app": null,
      "state_reason": null
    },
    {
      "url": "https://api.github.com/repos/bosens-China/blog/issues/68",
      "repository_url": "https://api.github.com/repos/bosens-China/blog",
      "labels_url": "https://api.github.com/repos/bosens-China/blog/issues/68/labels{/name}",
      "comments_url": "https://api.github.com/repos/bosens-China/blog/issues/68/comments",
      "events_url": "https://api.github.com/repos/bosens-China/blog/issues/68/events",
      "html_url": "https://github.com/bosens-China/blog/issues/68",
      "id": 906504178,
      "node_id": "MDU6SXNzdWU5MDY1MDQxNzg=",
      "number": 68,
      "title": "如何选择合适的公司？",
      "user": {
        "login": "bosens-China",
        "id": 39508895,
        "node_id": "MDQ6VXNlcjM5NTA4ODk1",
        "avatar_url": "https://avatars.githubusercontent.com/u/39508895?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bosens-China",
        "html_url": "https://github.com/bosens-China",
        "followers_url": "https://api.github.com/users/bosens-China/followers",
        "following_url": "https://api.github.com/users/bosens-China/following{/other_user}",
        "gists_url": "https://api.github.com/users/bosens-China/gists{/gist_id}",
        "starred_url": "https://api.github.com/users/bosens-China/starred{/owner}{/repo}",
        "subscriptions_url": "https://api.github.com/users/bosens-China/subscriptions",
        "organizations_url": "https://api.github.com/users/bosens-China/orgs",
        "repos_url": "https://api.github.com/users/bosens-China/repos",
        "events_url": "https://api.github.com/users/bosens-China/events{/privacy}",
        "received_events_url": "https://api.github.com/users/bosens-China/received_events",
        "type": "User",
        "site_admin": false
      },
      "labels": [
        {
          "id": 3041947800,
          "node_id": "MDU6TGFiZWwzMDQxOTQ3ODAw",
          "url": "https://api.github.com/repos/bosens-China/blog/labels/%E4%BB%A3%E7%A0%81%E4%BA%BA%E7%94%9F",
          "name": "代码人生",
          "color": "7B17E3",
          "default": false,
          "description": "和技术无关，人生的感悟"
        }
      ],
      "state": "open",
      "locked": false,
      "assignee": null,
      "assignees": [],
      "milestone": null,
      "comments": 0,
      "created_at": "2021-05-29T16:03:33Z",
      "updated_at": "2021-12-21T10:00:56Z",
      "closed_at": null,
      "author_association": "OWNER",
      "active_lock_reason": null,
      "body": "![背景图片](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7fc336f293cb45d3a308a9ccc0a1aa17~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n虽然金三银四早也过去，不过坦率的说好多公司招聘的需求量依然很大，再加上自己这段时间也在关注，这块所以就简单聊聊从选择公司到入职的一系列问题\r\n\r\n> 这里不涉及如何写简历以及如何回答面试的问题，后面如果有时间会考虑新开一个篇幅来说\r\n\r\n## 求职渠道\r\n\r\n首先如果自己早已有心仪的目标那可以跳过这一步，直接从脉脉或者知乎等各种社交 app 上找到内推信息，然后投递简历等待面试。\r\n\r\n但是如果没有找到满意的目标，那不妨从 `boss 直聘`着手，之前也用了很多其他的招聘 app 比如拉钩，不过坦率的说沟通模式或者说回复消息这块始终没有 boss 直聘来的简洁和清爽。\r\n\r\n## 筛选公司\r\n\r\n之前在知乎看到一个问题就是说`“年轻人到底选择大公司还有小公司”`，当然各种答案各不相同，但是站在自己踩过坑的情况来说还是建议大家选择一个大公司，因为可以节省你很多额外的采坑成本\r\n\r\n- 有着完整加薪结构，不再是口头上的一年两调或者一调；\r\n- 各种福利比较齐全，公积金和社保缴纳等；\r\n- 开发规范和团队协作流程比较成熟，可以接触到完整的开发流程；\r\n\r\n其次要想好自己做什么样的产品，目前按照产品划分可以分为两种\r\n\r\n- to B：提供给企业的产品\r\n- to C：提供给个人的产品\r\n\r\n所以根据上面两条，在加上自己的一些心理底线：\r\n\r\n1. 确定好自己想去什么规模的公司\r\n2. 做的产品业务是什么样子的\r\n3. 期待的薪资结构 + 上下班时间 + 基础性的福利等\r\n\r\n根据上面条件初步筛选出一些公司，下面的话就是看公司的介绍跟自己的符合度怎么样，这里建议大家不要广撒网而是专门精选这样会更有效的针对公司进行准备，其实不仅仅是公司在选择个人，个人也要选择公司，不然其实你会待的很压抑或者说跟你不匹配就是浪费双方的时间。\r\n\r\n这里额外补充一点，在面试之前可以事先沟通好你自己的一些底线信息。避免更多的时间成本浪费，比如我就是要过滤掉公积金社保不足额缴纳的公司，那你就可以直接说，你好方便问一下你们公积金缴纳比例和基数吗？\r\n\r\n最后，如果对方已读不回那就默认凉了，作为不要怀疑自己，找工作从来不是一个简单的事情。\r\n\r\n## 面试准备\r\n\r\n确定好目标跟 hr 沟通的时候我个人觉得稍微突出主题可以提高不少面试几率，我一般喜欢说：“你好看到贵公司的招聘情况觉得蛮符合的，可以发一份简历给你看看吗？”\r\n\r\n不过这个也不是绝对的，毕竟求职还是看符不符合岗位要求，如果你的简历足够丰富，估计每天沟通你的 hr 自己都要排队处理。\r\n\r\n说完打招呼还有一个需要确认就是面试时间和方式，一般而言如果是在职的话优先远程或者电话面试，不然遇到坑的面试官让你感觉时间被浪费，而如果你在外地求职的地点跟你不在同一个地方那如果对方不支持远程我建议你就不要去了，因为很多公司的 hr 对指标有要求，可能你只是一个他们的 kpi。\r\n\r\n当然如果能实地面试更好，可以通过观察公司附近的环境，公司的环境以及人员初步判断一下。\r\n\r\n## 面试结束\r\n\r\n如果你已经把一面、二面之类的全部都过了，只剩下 hr 这一关了那你就可以聊一下关乎切身的福利之类了。\r\n\r\n### 工资\r\n\r\n劳动合同会签订多少，绩效会占比多少，以及绩效是按照每个月发放还是一个季度发放，试用期工资都需要详细了解清楚，而且关于合同上的工资，也是后面如果需要维权情况的的一个重要依据。\r\n\r\n### 五险一金缴纳的基数和比例\r\n\r\n五险一金不缴纳是违法的，但是有的企业为了降低成本选择只缴纳最低的基数。\r\n\r\n公积金会跟你买房的公积金贷款还有还款挂钩，是一个真正的福利；\r\n\r\n而五险虽然目前可能用不到，但是少交肯定是个人的一个损失\r\n\r\n### 加班\r\n\r\n是否有加班工资或者调休，其实我个人是不怎么喜欢加班多的公司，尤其是因为业务很赶的原因或者团队公司氛围造成的，因为这个会影响到你的后续学习，而且每天使你很疲倦，从长远来看逃离加班多的公司对你的职业生涯更友好。\r\n\r\n### 作息时间是怎么样的\r\n\r\n确定好作息时间，看看自己每天需要通勤多久，如果条件允许就搬到公司附近来吧，每天通勤十几分钟真的很有幸福感。\r\n\r\n还有确定好是否可以弹性打卡，如果你像我一样每天喜欢卡着点上班还有扣钱啥的，就需要仔细想下了，不过对于这种公司建议跑路之。\r\n\r\n### 每年会有调薪的机会吗，一个流程是怎么样的\r\n\r\n这里可以简单了解下，对于互联网来说跳槽永远是涨薪的最好机会，不过如果团队氛围不错，再加上涨薪幅度也 ok 我觉得留下来也没有什么不好的\r\n\r\n### 其他各种福利\r\n\r\n比如餐补、房补、交通补、节假日福利、另外的保险等，不过注意不要跟你谈的薪资混合在了一起，比如你税前 20K，结果是各种福利加在一起的，那我觉得就没有什么必要了，还不如不写。\r\n\r\n### 年终奖\r\n\r\n年终奖也可以问下，一般来说最少一个月，多的话三四个月的也是有。\r\n\r\n对于期权之类的，我个人建议先暂时无视之，因为这个东西需要有时间前置条件，到时候你能不能待满这么久都不好说，如果真的待这么久再了解也不迟。\r\n\r\n## 最后\r\n\r\n如果确定好准备去，记得让对方公司发一份`offer`过来，辞职的话正式员工需要一个月，试用期三天，所以你需要跟新公司的 hr 确定好具体的入职时间，以及确定好社保的缴纳时间，避免断交社保造成的影响。\r\n\r\n最后，如果对你有帮助可以点一下`statr`\r\n",
      "reactions": {
        "url": "https://api.github.com/repos/bosens-China/blog/issues/68/reactions",
        "total_count": 0,
        "+1": 0,
        "-1": 0,
        "laugh": 0,
        "hooray": 0,
        "confused": 0,
        "heart": 0,
        "rocket": 0,
        "eyes": 0
      },
      "timeline_url": "https://api.github.com/repos/bosens-China/blog/issues/68/timeline",
      "performed_via_github_app": null,
      "state_reason": null
    },
    {
      "url": "https://api.github.com/repos/bosens-China/blog/issues/71",
      "repository_url": "https://api.github.com/repos/bosens-China/blog",
      "labels_url": "https://api.github.com/repos/bosens-China/blog/issues/71/labels{/name}",
      "comments_url": "https://api.github.com/repos/bosens-China/blog/issues/71/comments",
      "events_url": "https://api.github.com/repos/bosens-China/blog/issues/71/events",
      "html_url": "https://github.com/bosens-China/blog/issues/71",
      "id": 914142576,
      "node_id": "MDU6SXNzdWU5MTQxNDI1NzY=",
      "number": 71,
      "title": "团队规范系列之工程规范",
      "user": {
        "login": "bosens-China",
        "id": 39508895,
        "node_id": "MDQ6VXNlcjM5NTA4ODk1",
        "avatar_url": "https://avatars.githubusercontent.com/u/39508895?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bosens-China",
        "html_url": "https://github.com/bosens-China",
        "followers_url": "https://api.github.com/users/bosens-China/followers",
        "following_url": "https://api.github.com/users/bosens-China/following{/other_user}",
        "gists_url": "https://api.github.com/users/bosens-China/gists{/gist_id}",
        "starred_url": "https://api.github.com/users/bosens-China/starred{/owner}{/repo}",
        "subscriptions_url": "https://api.github.com/users/bosens-China/subscriptions",
        "organizations_url": "https://api.github.com/users/bosens-China/orgs",
        "repos_url": "https://api.github.com/users/bosens-China/repos",
        "events_url": "https://api.github.com/users/bosens-China/events{/privacy}",
        "received_events_url": "https://api.github.com/users/bosens-China/received_events",
        "type": "User",
        "site_admin": false
      },
      "labels": [
        {
          "id": 3661376441,
          "node_id": "LA_kwDOCzPAy87aPCu5",
          "url": "https://api.github.com/repos/bosens-China/blog/labels/%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83",
          "name": "代码规范",
          "color": "5319e7",
          "default": false,
          "description": "团队规范、代码规范、技术选型等相关内容"
        }
      ],
      "state": "open",
      "locked": false,
      "assignee": null,
      "assignees": [],
      "milestone": null,
      "comments": 0,
      "created_at": "2021-06-08T01:42:17Z",
      "updated_at": "2021-12-21T10:00:23Z",
      "closed_at": null,
      "author_association": "OWNER",
      "active_lock_reason": null,
      "body": "![bg](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7235b285206d49f5bb8f0cc2e43771c9~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n最近一周的工作重心就是在梳理团队规范，在写的过程也查缺补漏了不少知识，剔除掉关于公司场景的部分就有了这一系列的文章，预计写四部分：\r\n\r\n1. [git 规范](https://github.com/bosens-China/blog/issues/70)\r\n2. 工程规范\r\n3. [用户体验规范](https://github.com/bosens-China/blog/issues/72)\r\n4. [命名规范](https://github.com/bosens-China/blog/issues/73)\r\n\r\n# 工程规范\r\n\r\n## 项目目录\r\n\r\n项目目录定义的名称应当做到清晰易读，对于每个文件夹可以放置一个`README.md`的文件，对重要部分和职责进行描述，下面给一份常用的示例：\r\n\r\n```sh\r\n├── public                          // 静态页面\r\n├── scripts                         // 相关脚本配置\r\n├── src                             // 主目录\r\n    ├── assets                      // 静态资源\r\n    ├── components                  // 全局组件\r\n    ├── lib                         // 全局插件\r\n    ├── router                      // 路由配置\r\n    ├── store                       // vuex 配置\r\n    ├── styles                      // 样式\r\n    ├── utils                       // 工具方法(axios封装，全局方法等)\r\n    ├── views                       // 页面\r\n    ├── App.vue                     // 页面主入口\r\n    ├── main.js                     // 脚本主入口\r\n```\r\n\r\n下面再说几条建议：\r\n\r\n- 如果存在嵌套路由的页面，可以在 src 定义一个 `layout` 当做基础的视图组件使用\r\n- `components` 文件内的组件请保持通用性\r\n- 如果 views 存在业务组件，可以在当前目录下新建 components 使用，或者基于全局 components 进行二次封装\r\n- views 下的页面使用文件夹的形式来定义，例如有一个统计页面，如果只写一个`.vue`文件会导致文件内容过多，而如果直接在 views 下进行抽离多个`.vue`会导致结构不统一\r\n\r\n## utils\r\n\r\n对于 utils 下的文件，请保持按照文件类型进行划分，下面截取[ant-design-pro](https://github.com/ant-design/ant-design-pro/tree/master/src/utils)的 utils 文件为例\r\n\r\n| 名称          |                            提交信息                             |\r\n| ------------- | :-------------------------------------------------------------: |\r\n| Authorized.ts |                     use @umijs/fabric@2.5.0                     |\r\n| authority.ts  |       🌎 localization: docs translated to english (#7938)       |\r\n| request.ts    |       🌎 localization: docs translated to english (#7938)       |\r\n| utils.less    |                clean: remove unuse less (#6214)                 |\r\n| utils.test.ts | feat: @umijs/route-utils replace getAuthorityFromRouter (#7319) |\r\n| utils.ts      |       🌎 localization: docs translated to english (#7938)       |\r\n\r\n> 在开发项目中，请优先使用 [lodash](https://www.lodashjs.com/) 这样的工具库，并在此基础上封装自己的方法，如果真的不存再在考虑手动实现从 0 到 1 实现\r\n\r\n## VueX\r\n\r\n在大型项目中，对 VueX 的拆分通常根据业务，请不要直接使用 VueX 下的`State`、`Getter`、`Mutation`等，而是改用`Module`将相关依赖聚合在一起，最后通过`import`整合在一起，下面以 home 文件夹为例：\r\n\r\n```sh\r\n├── home                            // 主目录\r\n    ├── index.js                    // VueX state getters mutations action 管理\r\n    ├── ...                         // 可能存在的其它文件\r\n└── index.js                        // VueX 主入口\r\n```\r\n\r\nhome/index.js\r\n\r\n```js\r\nexport default {\r\n  namespaced: true,\r\n  state: () => ({ ... }),\r\n  mutations: { ... },\r\n  actions: { ... },\r\n  getters: { ... }\r\n}\r\n```\r\n\r\nindex.js\r\n\r\n```js\r\nimport { createStore } from 'vuex';\r\nimport home from './home';\r\n\r\nconst store = createStore({\r\n  modules: {\r\n    home,\r\n  },\r\n});\r\n\r\nexport default store;\r\n```\r\n\r\n## Router\r\n\r\n### 路由层级\r\n\r\n路由层级十分重要，在 Router4 之前，会根据路由定义的顺序来决定路由的先后顺序，如果层级很不清晰会导致两个问题：\r\n\r\n- 维护或者定义新路由需要查找半天\r\n- 遍历 routes 信息十分困难，做权限之类的的很麻烦\r\n\r\n![1.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8312de118fe34964afb919655f2f7292~tplv-k3u1fbpfcp-watermark.image)\r\n\r\n举个例子，对于上面的一个设计图，包含：`head、content、footer`三个部分，观察他们剩余设计图顶部和底部基本相同，只是 content 区域的内容有所不同。\r\n\r\n而对这样一个设计图进行开发，可以定义一个`layout`组件当做基础公共结构，之后书写`routers`的具体信息\r\n\r\n```sh\r\n├── routes                            // routes的定义目录\r\n    ├── home.js                       // 首页\r\n    ├── type.js                       // 分类\r\n    ├── food.js                       // 东家菜\r\n    ├── brand.js                       // 大牌\r\n└── index.js                          // vue router 主入口\r\n└── routes.js                         // 将routers目录下的文件分发成最终vue router使用结构\r\n```\r\n\r\nroutes.js\r\n\r\n```js\r\nimport layout from '@/layout';\r\nimport home from './routes/home';\r\nimport type from './routes/type';\r\nimport food from './routes/food';\r\nimport brand from './routes/brand';\r\n\r\nconst routes = [\r\n  {\r\n    path: '/',\r\n    component: layout,\r\n    children: home,\r\n  },\r\n  {\r\n    path: '/',\r\n    component: layout,\r\n    children: type,\r\n  },\r\n  {\r\n    path: '/',\r\n    component: layout,\r\n    children: food,\r\n  },\r\n  {\r\n    path: '/',\r\n    component: layout,\r\n    children: brand,\r\n  },\r\n];\r\n\r\nexport default routes;\r\n```\r\n\r\nindex.js\r\n\r\n```js\r\nimport { createRouter, createWebHistory, createWebHashHistory } from 'vue-router';\r\n\r\nimport routes from './routes';\r\n\r\nconst router = createRouter({\r\n  routes,\r\n});\r\n\r\n// 全局导航守卫\r\nrouter.beforeEach(async (to) => {\r\n  // ...\r\n});\r\n\r\nexport default router;\r\n```\r\n\r\n### 捕获未知路由\r\n\r\n无论在做中台还是移动端的产品，都需要正确处理未知的路由，一般而言有二种处理方式，具体参考项目的类型进行选择：\r\n\r\n1. 直接给出 404 之类的提示，提示页面不存在等信息；\r\n2. 帮助其重定向到首页或者其它页面；\r\n\r\n```js\r\n// vue router4\r\n{ path: '/:pathMatch(._)_', name: 'NotFound', redirect: { name: 'home' } };\r\n\r\n// vue router3\r\n{ path: '*', name: 'NotFound', redirect: { name: 'home' } };\r\n```\r\n\r\n### 路由懒加载\r\n\r\n使用懒加载可以节省白屏时间，懒加载的机制利用了 webpack 代码分割 + import()，只在进入当前路由的时候加载所依赖的 js 文件。\r\n\r\n```js\r\n  { path: '/', name: 'home', component: () => import(/* webpackChunkName: \"home\" */ 'views/home/index.vue') }\r\n```\r\n\r\n> 除了需要`children`的父级页面，所有其它页面统一使用懒加载\r\n>\r\n> `/* webpackChunkName: \"home\" */`这样的注释语法，是 webpack 独有的，它负责 build 打包之后的文件名称\r\n\r\n## 组件拆分建议\r\n\r\n![2.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/620871b1cb374af4a5995db475119ba6~tplv-k3u1fbpfcp-watermark.image)\r\n\r\n一个大型项目由无数子组件组合而成，有点像乐高积木一样，直接开发一个大型项目肯定很难，但是如果给无数子组件让你拼接则相对简单。\r\n\r\n组件的拆分，应该遵循两个原则：\r\n\r\n### 颗粒度细分\r\n\r\n在学习设计模式中有很重要的一句话就是**单一职责**，在组件开发也是同理，原则上让一个组件只负责一件事情，可以最大程度的复用组件，方便测试和定位问题。\r\n\r\n但是过度的单一职责组件也会导致一个问题就是颗粒度太细造成组件的碎片化，举一个例子来说，自动完成组件，它是搜索框 + select 组合而成，因此我们可以直接复用，因为前两个组件的颗粒度刚刚好。\r\n\r\n![3.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0e6da1bee9e44e9a9059520b8555a99b~tplv-k3u1fbpfcp-watermark.image)\r\n\r\n还有一个例子就是徽章数组件(Badge)，它的右上角会有红点提示，可能是数字也可能是 icon，它的职责当然也很单一，这个红点提示也理所当然也可以被单独抽象为一个独立组件，但是我们通常不会将它作为独立组件，因为在其它场景中这个组件是无法被复用的，因为没有类似的场景再需要小红点这个小组件了\r\n\r\n![4.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/517274f4b3744cd9acd35e15c091425f~tplv-k3u1fbpfcp-watermark.image)\r\n\r\n### 通用性考虑\r\n\r\n组件分为基础组件和业务组件，当存在业务常见重复使用的时候通常会对通用组件进行二次封装，例如有一个搜索部门的组件，这个组件在很多 view 都有复用而且也对这个组件集成了自动搜索 + 初始 loading + 自动加载下一页，最后使用效果用起来也很方便。\r\n\r\n但是现在突然来一个需求，说对搜索的组件进行底部提示，那难道直接更改源码吗？但是如果直接更改组件，这样也违背了`开放、关闭原则`\r\n\r\n其实说这个例子就是希望思考组件广的适配性，在使用第三方的组件，会看到它们暴露了很多插槽、jsx 的渲染函数，最终的目的也就是应对各种各样的场景\r\n\r\n> 组件的形态(DOM 结构)永远是千变万化的，但是其行为(逻辑)是固定的，因此通用组件的秘诀之一就是将 DOM 结构的控制权交给开发者,组件只负责行为和最基本的 DOM 结构\r\n\r\n## 工程优化\r\n\r\n优化是一个很庞大的命题，根据项目的不同所采取的方式也不尽相同，下面只总结一些常用的方式\r\n\r\n### 项目优化\r\n\r\n- CND\r\n- gzip，让后端支持 gzip 压缩，前端也生成 gzip 文件\r\n- 使用 webp 格式，生产环境下压缩图片\r\n- 路由懒加载\r\n- 第三方组件按需加载\r\n- 抽离第三方库，避免和业务组件耦合一起打包\r\n- ...\r\n\r\n### code 优化\r\n\r\n- 减少对 dom 操作，如果操作将所有 dom 聚合在一起修改\r\n- 不直接修改 style 改用 class 修改；\r\n- 尽量不适用 table，绑定事件采用事件委托形式\r\n- 对动画元素，让其脱离文档流，减少重绘和重排\r\n- ...\r\n\r\n### 构建过程优化\r\n\r\n- 删除 eslint-loader，改用编辑器自带的 eslint\r\n- 使用 catch-loader，对资源进行加速\r\n- 生产环境下删除`.map`文件，缩短`import`查找后缀\r\n- ...\r\n",
      "reactions": {
        "url": "https://api.github.com/repos/bosens-China/blog/issues/71/reactions",
        "total_count": 0,
        "+1": 0,
        "-1": 0,
        "laugh": 0,
        "hooray": 0,
        "confused": 0,
        "heart": 0,
        "rocket": 0,
        "eyes": 0
      },
      "timeline_url": "https://api.github.com/repos/bosens-China/blog/issues/71/timeline",
      "performed_via_github_app": null,
      "state_reason": null
    },
    {
      "url": "https://api.github.com/repos/bosens-China/blog/issues/72",
      "repository_url": "https://api.github.com/repos/bosens-China/blog",
      "labels_url": "https://api.github.com/repos/bosens-China/blog/issues/72/labels{/name}",
      "comments_url": "https://api.github.com/repos/bosens-China/blog/issues/72/comments",
      "events_url": "https://api.github.com/repos/bosens-China/blog/issues/72/events",
      "html_url": "https://github.com/bosens-China/blog/issues/72",
      "id": 914175625,
      "node_id": "MDU6SXNzdWU5MTQxNzU2MjU=",
      "number": 72,
      "title": "团队规范系列之用户体验规范",
      "user": {
        "login": "bosens-China",
        "id": 39508895,
        "node_id": "MDQ6VXNlcjM5NTA4ODk1",
        "avatar_url": "https://avatars.githubusercontent.com/u/39508895?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bosens-China",
        "html_url": "https://github.com/bosens-China",
        "followers_url": "https://api.github.com/users/bosens-China/followers",
        "following_url": "https://api.github.com/users/bosens-China/following{/other_user}",
        "gists_url": "https://api.github.com/users/bosens-China/gists{/gist_id}",
        "starred_url": "https://api.github.com/users/bosens-China/starred{/owner}{/repo}",
        "subscriptions_url": "https://api.github.com/users/bosens-China/subscriptions",
        "organizations_url": "https://api.github.com/users/bosens-China/orgs",
        "repos_url": "https://api.github.com/users/bosens-China/repos",
        "events_url": "https://api.github.com/users/bosens-China/events{/privacy}",
        "received_events_url": "https://api.github.com/users/bosens-China/received_events",
        "type": "User",
        "site_admin": false
      },
      "labels": [
        {
          "id": 3661376441,
          "node_id": "LA_kwDOCzPAy87aPCu5",
          "url": "https://api.github.com/repos/bosens-China/blog/labels/%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83",
          "name": "代码规范",
          "color": "5319e7",
          "default": false,
          "description": "团队规范、代码规范、技术选型等相关内容"
        }
      ],
      "state": "open",
      "locked": false,
      "assignee": null,
      "assignees": [],
      "milestone": null,
      "comments": 0,
      "created_at": "2021-06-08T02:22:11Z",
      "updated_at": "2021-12-21T10:00:18Z",
      "closed_at": null,
      "author_association": "OWNER",
      "active_lock_reason": null,
      "body": "![bg](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b9625a50c497462ab14fb45ab08d21d6~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n最近一周的工作重心就是在梳理团队规范，在写的过程也查缺补漏了不少知识，剔除掉关于公司场景的部分就有了这一系列的文章，预计写四部分：\r\n\r\n1. [git 规范](https://github.com/bosens-China/blog/issues/70)\r\n2. [工程规范](https://github.com/bosens-China/blog/issues/71)\r\n3. 用户体验规范\r\n4. [命名规范](https://github.com/bosens-China/blog/issues/73)\r\n\r\n# 用户体验规范\r\n\r\n关于用户体验是一个很庞大的命题并且每个人对于体验的理解也各不相同，同时伴随着时效性，随着新技术的出现可能之前的体验就很快落伍了，所以下面内容只能简短概括下。\r\n\r\n## 通用准则\r\n\r\n### 增加可点击区域大小\r\n\r\n![1.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a2fb47391323406d90d3cc8a350bdf0b~tplv-k3u1fbpfcp-watermark.image)\r\n\r\n以上图为例，如果必须点击到`checkbox`区域才能点击生效，必然会导致体验不佳\r\n\r\n组件的考虑一致性同时也包含了页面结构，对于上图所示 label 和 checkbox 就是一个整体，这里抛砖引玉说一些常见适用该准则的元素：\r\n\r\n- header 区域右上角头像和姓名部分；\r\n- Label、li 等整体一行元素；\r\n- 自定义图标\r\n- ...\r\n\r\n在对上面元素进行交互的时候，尽量避免用户的点击成本，下面说两个常见的做法\r\n\r\n#### 增大整体区域点击，例如有下面一个头像区域\r\n\r\n```html\r\n<p class=\"portrait\">\r\n  <img class=\"portrait-img\" src=\"xxx\" />\r\n  <span class=\"portrait-name\">xxxx</span>\r\n</p>\r\n```\r\n\r\n如果原本是点击事件绑定在`.portrait-img`，那么请考虑增加到`.portrait`\r\n\r\n#### 增大元素本身的点击区域\r\n\r\n```html\r\n<i class=\"i-con\"></i>\r\n```\r\n\r\n对于上面的 i 元素，通常用来设置自定义图标，但是在实际操作中，用户的鼠标或者手势可能存在偏差所以需要增加这个元素的本身范围。\r\n\r\n回归`css box`的概念，我们可以增加`border`来完成增加区域的效果\r\n\r\n```css\r\n.i-con {\r\n  /* 省略其它代码 */\r\n  border: 5px solid transparent;\r\n}\r\n```\r\n\r\n> 注意：pc 上还需要考虑光标的一致性，以及 hover 等一系列整体的效果\r\n\r\n### 图片相关优化\r\n\r\n对于很多项目而言，图片是常见的优化点，毕竟多方面的优化远没有压缩一张图片来的直观，而对于用户体验来说也同样是\r\n\r\n#### 预加载\r\n\r\n不同于懒加载，预加载的目的就是提前输出图片，避免用户等待。\r\n\r\n举一个常见的例子：轮播图就很适合使用预加载，否则用户看到下一张图片的时候还继续等待加载就会感觉很突兀。\r\n\r\n预加载的原理就是提前请求，之后重复请求相同资源时会返回缓存文件，我们可以封装一个方法，利用`Image`对 src 赋值即可\r\n\r\n```js\r\nconst preloading = (src) => {\r\n  return new Promise((resolve, reject) => {\r\n    const img = new Image();\r\n    img.src = src;\r\n    img.onload = resolve;\r\n    img.onerror = reject;\r\n  });\r\n};\r\n```\r\n\r\n#### 错误图片\r\n\r\n各个浏览器对错误图片的处理方式各不相同，虽然存在`alt`提示信息，但是不够统一和美观\r\n\r\n![2.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/eb2385e0dcf34915b0ada7050405f3a5~tplv-k3u1fbpfcp-watermark.image)\r\n\r\n例如上面这种错误信息看起来就不够美观，更好的做法给出默认的错误图片，监听图片的`onerror`事件来重新赋值，如果不想一个个写，可以监听`window.addEventListener error`来完成全局监听\r\n\r\n```js\r\nwindow.addEventListener(\r\n  'error',\r\n  function (event) {\r\n    var dom = event.target;\r\n    if (/img/i.test(dom.nodeName)) {\r\n      dom.src = 'xxxx.png';\r\n    }\r\n  },\r\n  true\r\n);\r\n```\r\n\r\n> 如果想增加对错误图片进行重试，或者对 JSP 动态渲染内容进行拦截，可以参考这篇文章[如何优雅处理图片异常](https://juejin.cn/post/6844904046705246216#heading-2)\r\n\r\n### 空数据默认处理\r\n\r\n对空数据放任不管，可能会导致用户认为系统出现了问题，通常情况下我们要尽量避免空数据的出现，一般而言有两种处理方式\r\n\r\n#### 使用 empty（空状态）进行填充\r\n\r\n![3.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1a378691e6c94997ad9cbf2578f3d310~tplv-k3u1fbpfcp-watermark.image)\r\n\r\n一般 UI 框架现在都内置 empty 组件，可以跟产品和设计沟通无误后，对于常见的 table 或者 list 无数据的进行默认的提示\r\n\r\n```vue\r\n<template>\r\n  <template v-if=\"list.length\"> /* ... */ </template>\r\n  <template v-else>\r\n    <empty />\r\n  </template>\r\n</template>\r\n```\r\n\r\n#### 隐藏整体区域\r\n\r\n![1.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2945ac9ba5ed4a8d83341bf1815157fe~tplv-k3u1fbpfcp-watermark.image)\r\n\r\n对于上面的作者帮当，如果当前子项不存在数据，只展示一个标题和完整榜单的信息可能会很奇怪那不妨考虑删除整体区域\r\n\r\n### 优先使用语义化标签\r\n\r\n尽量避免无语义的`div、span`滥用，因为搜索引擎抓录不友好，维护起来不够直观，而且使用语义化标签可以节省很多代码性工作，下面举一个例子\r\n\r\n![5.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/942b4d168d254463801b2938ee7c8cbe~tplv-k3u1fbpfcp-watermark.image)\r\n\r\n例如上面的按钮，假设它的功能是跳转到一个新的页面，如果在 spa 页面中，我们可以直接使用`vue-router`自带的`router-link`跳转即可完成，而在传统开发中可以在`button`外部嵌套一个`a`标签完成跳转\r\n\r\n```html\r\n<a href=\"xxx\">\r\n  <button>xxx</button>\r\n</a>\r\n<!-- 或者 -->\r\n<router-link to=\"xxx\">\r\n  <button>xxx</button>\r\n</router-link>\r\n```\r\n\r\n而且这样做很容易配合浏览器的一些其它行为，比如右击打开在新标签页\r\n\r\n### 操作反馈\r\n\r\n操作反馈是提升用户体验的一个重要指标，具体可以展开为三部分来说\r\n\r\n#### Require 反馈\r\n\r\n在与后端进行通信的过程中，如果成功或者失败，都请告知用户，而且提示的消息必须友好。\r\n\r\n这里有一个准则\r\n\r\n- 成功消息可以由前端来定义，可以结合各种操作场景做到更细致的提示\r\n- 对于错误消息，则返回后端返回的 message 等信息\r\n- 对于 500 等错误，请在拦截器统一改成`网络连接错误，请稍后重试`，而不是提示一串超时等英文信息\r\n\r\n#### 元素反馈\r\n\r\n在衡量一个 ui 框架的时候就有两点很重要：\r\n\r\n1. 组件本身的交互是否友好，比如动画是否流畅，有没有 hover、active 等效果\r\n2. 对于无障碍阅读是否友好\r\n\r\n可见交互的重要性，要让用户感觉自己在点击一个真实存在的元素，而不是像图片一样的静止\r\n\r\n![6.gif](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f7548ccd492147eb989ca42b2057e0d6~tplv-k3u1fbpfcp-watermark.image)\r\n\r\n例如上图中，最少要存在`hover`、`active`等效果\r\n\r\n#### 等待反馈\r\n\r\n![7.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6af4503f4f9c425583118b98b1f3b57e~tplv-k3u1fbpfcp-watermark.image)\r\n\r\n因为与后端的通信是异步的，而且用户的网络好坏也不是固定不变的，所以给元素添加`loading`就很有必要，这里说两个常见的场景\r\n\r\n#### 表单提交\r\n\r\n![7.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6af4503f4f9c425583118b98b1f3b57e~tplv-k3u1fbpfcp-watermark.image)\r\n\r\n需要操作交互的常见都可以考虑使用`loading`，这样可以防止用户重复点击和避免用户不知道有没有点击成功\r\n\r\n#### 重新获取数据\r\n\r\n![8.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/17d967b2947344f5815e114084df2ad8~tplv-k3u1fbpfcp-watermark.image)\r\n\r\n#### 获取前置信息\r\n\r\n在 pc 上，整体进入页面的时候为了掩盖获取一些前置的信息的场景，可以选择使用 loading 元素减少用户等待的焦虑感\r\n\r\n### 缓存\r\n\r\n缓存本质上就是拿空间换时间，对于客户端而言，更多的瓶颈是在时间上，下面就说两种常见的缓存场景\r\n\r\n#### 组件信息缓存\r\n\r\n![9.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2dbabc0b5fb8449297b174ca267ef2f2~tplv-k3u1fbpfcp-watermark.image)\r\n\r\n例如上面表单，如果用户误操作关闭网页，从头开始填写体验就不是特别好，可以在未提交成功的状态下结合本地做持久化缓存\r\n\r\n下面给一个简单示例（没有给出完成清除本地储存）\r\n\r\n```vue\r\n<script>\r\nimport { reactive, watchEffect } from 'vue';\r\n\r\nexport default {\r\n  setUp() {\r\n    const key = 'form';\r\n    const form = reactive({\r\n      name: '',\r\n      password: '',\r\n    });\r\n    const set = (key, value) => {\r\n      localStorage.setItem(key, JSON.stringify(value));\r\n    };\r\n    const get = () => {\r\n      const value = localStorage.getItem(key);\r\n      try {\r\n        return JSON.parse(value);\r\n      } catch {\r\n        return undefined;\r\n      }\r\n    };\r\n    watchEffect(() => {\r\n      set(key, form);\r\n    });\r\n    Object.assign(form, get('form'));\r\n  },\r\n};\r\n</script>\r\n```\r\n\r\n#### 接口缓存\r\n\r\n如果存在频繁请求且很耗时，接口本身基本不会变更的情况，可以考虑接口缓存，下面给出一段简单的代码示例\r\n\r\n生产环境可以考虑使用一些库 [axios-request-cache](https://github.com/ZhengXiaowei/axios-request-cache)\r\n\r\n```js\r\nimport axios from 'axios';\r\nconst { toString } = Object.prototype;\r\n\r\n// 数据存储\r\nexport const cache = {\r\n  data: {},\r\n  set(key, data) {\r\n    this.data[key] = data;\r\n  },\r\n  get(key) {\r\n    return this.data[key];\r\n  },\r\n  clear(key) {\r\n    delete this.data[key];\r\n  },\r\n};\r\n\r\n// 建立唯一的key值\r\nexport const buildUniqueUrl = (url, method, params = {}, data = {}) => {\r\n  const paramStr = (obj) => {\r\n    if (toString.call(obj) === '[object Object]') {\r\n      return JSON.stringify(\r\n        Object.keys(obj)\r\n          .sort()\r\n          .reduce((result, key) => {\r\n            result[key] = obj[key];\r\n            return result;\r\n          }, {})\r\n      );\r\n    } else {\r\n      return JSON.stringify(obj);\r\n    }\r\n  };\r\n  url += `?${paramStr(params)}&${paramStr(data)}&${method}`;\r\n  return url;\r\n};\r\n\r\n// 防止重复请求\r\nexport default (options = {}) =>\r\n  async (config) => {\r\n    const defaultOptions = {\r\n      // 设置为0，不清除缓存\r\n      time: 0,\r\n      ...options,\r\n    };\r\n    const index = buildUniqueUrl(config.url, config.method, config.params, config.data);\r\n    let responsePromise = cache.get(index);\r\n    if (!responsePromise) {\r\n      responsePromise = (async () => {\r\n        try {\r\n          const response = await axios.defaults.adapter(config);\r\n          return Promise.resolve(response);\r\n        } catch (reason) {\r\n          cache.clear(index);\r\n          return Promise.reject(reason);\r\n        }\r\n      })();\r\n      cache.set(index, responsePromise);\r\n      if (defaultOptions.time !== 0) {\r\n        setTimeout(() => {\r\n          cache.clear(index);\r\n        }, defaultOptions.time);\r\n      }\r\n    }\r\n    // 为防止数据源污染\r\n    return responsePromise.then((data) => JSON.parse(JSON.stringify(data)));\r\n  };\r\n```\r\n\r\n### 风格一致性\r\n\r\n风格一致性包含很多部分，这里不太好全部列举，就说两个常见的\r\n\r\n#### 视觉颜色一致\r\n\r\n每个页面都有一个主色号，对于设计图或者原型图没有给到的部分，自己动手或者引用组件时需要考虑是否跟主色号存在冲突，这里推荐阅读一下`视觉规范`，下面给出一个示例\r\n\r\n![2.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2efab79f3bf4429c852e5f7e4182a8ae~tplv-k3u1fbpfcp-watermark.image)\r\n\r\n![3.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4f0aabbe895d42f0b18b0bdd5b9a7698~tplv-k3u1fbpfcp-watermark.image)\r\n\r\n在默认的 vant 组件中，tab 默认的颜色是`#ee0a24`，如果直接放上去就会导致页面风格不统一，因为页面整体风格是蓝色\r\n\r\n#### 组件交互一致性\r\n\r\n这里在自定义扩展或者二次封装比较常见，还是以表单为例\r\n\r\n![9.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/56f9f210d65e4ae9b23516548a1056e1~tplv-k3u1fbpfcp-watermark.image)\r\n\r\n如果我们想自定义根据业务进行一个文件上传的组件，除了考虑功能本身的实现，还要考虑一致性的问题，例如校验的问题\r\n\r\n这里`Ant Design `在不符合条件的`form-item`下面出现一个红字提示，而如果我们使用`message`或者其他提示就会造成提示信息的不一致性，那更好的做法就是根据官方文档提供的自定义插件做法进行组件开发。\r\n\r\n## pc\r\n\r\n### 考虑最小布局\r\n\r\n请设置`min-width`，防止因为宽度不够导致元素挤在一起\r\n\r\n```css\r\nbody {\r\n  /* 省略其它 */\r\n  min-width: 1200px;\r\n  overflow: auto;\r\n}\r\n```\r\n\r\n### 表格宽度\r\n\r\n对于表格，根据字段的权值不同分配的宽度也应该不同，尽量不要使用`auto`避免二次表格宽度计算造成视觉上的浮动\r\n\r\n![13.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d295a4f0c4544388b1190c62b862bd3c~tplv-k3u1fbpfcp-watermark.image)\r\n\r\n对于不可省略的信息可以让其换行展示，否则请考虑`ellipsis`\r\n\r\n```css\r\n.ellipsis {\r\n  overflow: hidden;\r\n  white-space: nowrap;\r\n  text-overflow: ellipsis;\r\n}\r\n```\r\n\r\n### 指标卡片添加 tip\r\n\r\n在一些中台产品中，很容易遇到一些专业名词，比如`pv`和`uv`等，对于这种专业名词，建议添加一个问号的提示图标，鼠标移动上去给与提示\r\n\r\n![14.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fc35ab89bc294f45b7c0c070d527ec9e~tplv-k3u1fbpfcp-watermark.image)\r\n\r\n上面效果仅供参考\r\n\r\n### 支持键盘快捷键\r\n\r\n![9.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6a0349131f50469e85f9efbeb0934b2f~tplv-k3u1fbpfcp-watermark.image)\r\n\r\n如上图所示，在我们使用`form`或者`input`时，如果按下`enter`时请确保可以进行正常的搜索或者提交操作，不仅局限于表单提交，对于一些常见的搜索场景都需要考虑\r\n\r\n一个好的建议，对于需要 submit 的子元素，都绑定`.enter`修饰符\r\n\r\n```vue\r\n<input @keyup.enter=\"submit\" />\r\n```\r\n\r\n### SPA 路由导航\r\n\r\n对于单页面导航请考虑使用[nprogress](https://github.com/rstacruz/nprogress)这样的进度条，为你的页面添加进度通知\r\n\r\n![15.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7b2a1bf70cab4c279339f2e11ef5e5e0~tplv-k3u1fbpfcp-watermark.image)\r\n\r\n## 移动端\r\n\r\n### 左右滑动监听\r\n\r\n浏览了许多 H5 的页面，对于手势左右滑动基本上都没做支持，而在很多 App 上，例如知乎，从首页进去问题左滑就可以返回\r\n\r\n![微信图片_20210608100923.jpg](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5e1ef02488054521999304fe663d9867~tplv-k3u1fbpfcp-watermark.image)\r\n\r\n这里稍微建议一下，对于下面两种情况可以考虑引入左滑返回\r\n\r\n- 跟上面图片一致的 tab 页比较多，可以考虑做成 tab 下的元素滑动监听\r\n- 对于一些列表和详情页\r\n\r\n推荐一个库源码也很简洁可以基于这个库进行二次封装，提高用户的体验 [swipy](https://github.com/whitecube/swipy)\r\n\r\n### 尽量使用 SVG\r\n\r\nSVG 是一种图像文件格式，它的英文全称为 Scalable Vector Graphics，意思为可缩放的矢量图形。基于 XML 的标记语言\r\n\r\nSVG 是矢量图，它有很多优点\r\n\r\n- SVG 是可伸缩的，在任何的分辨率下被高质量地打印\r\n- SVG 可在图像质量不下降的情况下被放大\r\n- 修改方便，可以在记事本之类的软件中被打开\r\n\r\n而在开发移动端，面对的用户手机的屏幕也各不相同，之前的做法是对不同 ratio 的手机选择不同的图片，但是根据上面 SVG 的优点，我们可以直接选用 SVG 当做图片\r\n\r\n而在 SVG 不适用的场景，我们可以利用媒体查询，选择合适的高倍图\r\n\r\n```js\r\nexport const getMultipleImg = (img1, img2) => {\r\n  const mql = window.matchMedia('@media only screen and (-webkit-min-device-pixel-ratio:3)');\r\n  if (mql.matches) {\r\n    return img2;\r\n  }\r\n  return img1;\r\n};\r\n```\r\n",
      "reactions": {
        "url": "https://api.github.com/repos/bosens-China/blog/issues/72/reactions",
        "total_count": 0,
        "+1": 0,
        "-1": 0,
        "laugh": 0,
        "hooray": 0,
        "confused": 0,
        "heart": 0,
        "rocket": 0,
        "eyes": 0
      },
      "timeline_url": "https://api.github.com/repos/bosens-China/blog/issues/72/timeline",
      "performed_via_github_app": null,
      "state_reason": null
    },
    {
      "url": "https://api.github.com/repos/bosens-China/blog/issues/73",
      "repository_url": "https://api.github.com/repos/bosens-China/blog",
      "labels_url": "https://api.github.com/repos/bosens-China/blog/issues/73/labels{/name}",
      "comments_url": "https://api.github.com/repos/bosens-China/blog/issues/73/comments",
      "events_url": "https://api.github.com/repos/bosens-China/blog/issues/73/events",
      "html_url": "https://github.com/bosens-China/blog/issues/73",
      "id": 914211223,
      "node_id": "MDU6SXNzdWU5MTQyMTEyMjM=",
      "number": 73,
      "title": "团队规范系列之命名规范",
      "user": {
        "login": "bosens-China",
        "id": 39508895,
        "node_id": "MDQ6VXNlcjM5NTA4ODk1",
        "avatar_url": "https://avatars.githubusercontent.com/u/39508895?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bosens-China",
        "html_url": "https://github.com/bosens-China",
        "followers_url": "https://api.github.com/users/bosens-China/followers",
        "following_url": "https://api.github.com/users/bosens-China/following{/other_user}",
        "gists_url": "https://api.github.com/users/bosens-China/gists{/gist_id}",
        "starred_url": "https://api.github.com/users/bosens-China/starred{/owner}{/repo}",
        "subscriptions_url": "https://api.github.com/users/bosens-China/subscriptions",
        "organizations_url": "https://api.github.com/users/bosens-China/orgs",
        "repos_url": "https://api.github.com/users/bosens-China/repos",
        "events_url": "https://api.github.com/users/bosens-China/events{/privacy}",
        "received_events_url": "https://api.github.com/users/bosens-China/received_events",
        "type": "User",
        "site_admin": false
      },
      "labels": [
        {
          "id": 3661376441,
          "node_id": "LA_kwDOCzPAy87aPCu5",
          "url": "https://api.github.com/repos/bosens-China/blog/labels/%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83",
          "name": "代码规范",
          "color": "5319e7",
          "default": false,
          "description": "团队规范、代码规范、技术选型等相关内容"
        }
      ],
      "state": "open",
      "locked": false,
      "assignee": null,
      "assignees": [],
      "milestone": null,
      "comments": 0,
      "created_at": "2021-06-08T02:53:40Z",
      "updated_at": "2021-12-21T10:00:13Z",
      "closed_at": null,
      "author_association": "OWNER",
      "active_lock_reason": null,
      "body": "![bg](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4b7b48b9a67c44eab564bf46e99f1ee0~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n最近一周的工作重心就是在梳理团队规范，在写的过程也查缺补漏了不少知识，剔除掉关于公司场景的部分就有了这一系列的文章，预计写四部分：\r\n\r\n1. [git 规范](https://github.com/bosens-China/blog/issues/70)\r\n2. [工程规范](https://github.com/bosens-China/blog/issues/71)\r\n3. [用户体验规范](https://github.com/bosens-China/blog/issues/72)\r\n4. 命名规范\r\n\r\n# 命名规范\r\n\r\n命名规范请结合团队情况来进行制定，如果想更进阶一些可以配合 git 钩子写校验工具，配合规范食用\r\n\r\n## 代码命名规范\r\n\r\n### 避免用一个字母命名\r\n\r\n```js\r\n// bad\r\nfunction q() {\r\n  // ...\r\n}\r\n\r\n// good\r\nfunction query() {\r\n  // ...\r\n}\r\n```\r\n\r\n### 用小驼峰命名法来命名你的对象、函数、实例\r\n\r\n```js\r\n// bad\r\nconst OBJEcttsssss = {};\r\nconst this_is_my_object = {};\r\nfunction c() {}\r\n\r\n// good\r\nconst thisIsMyObject = {};\r\nfunction thisIsMyFunction() {}\r\n```\r\n\r\n### 用大驼峰命名法来命名类\r\n\r\n```js\r\n// bad\r\nfunction user(options) {\r\n  this.name = options.name;\r\n}\r\n\r\nconst bad = new user({\r\n  name: 'nope',\r\n});\r\n\r\n// good\r\nclass User {\r\n  constructor(options) {\r\n    this.name = options.name;\r\n  }\r\n}\r\n\r\nconst good = new User({\r\n  name: 'yup',\r\n});\r\n```\r\n\r\n### 不要用前置或后置下划线\r\n\r\nJavaScript 没有私有属性或私有方法的概念。尽管前置下划线通常的概念上意味着私有，事实上，这些属性是完全公有的，因此这部分也是你的 API 的内容。这一概念可能会导致开发者误以为更改这个不会导致崩溃或者不需要测试。如果你想要什么东西变成私有，那就不要让它在这里出现。\r\n\r\n```js\r\n// bad\r\nthis.__firstName__ = 'Panda';\r\nthis.firstName_ = 'Panda';\r\nthis._firstName = 'Panda';\r\n\r\n// good\r\nthis.firstName = 'Panda';\r\n```\r\n\r\n### export\r\n\r\n#### export-default 导出名称与 import 引用名称保持一致\r\n\r\n例如：`export-default 模块 A`，则这个文件名也叫 `A`， import 时候的参数也叫 `A`。 大小写完全一致。\r\n\r\n```js\r\n// file 1 contents\r\nclass CheckBox {\r\n  // ...\r\n}\r\nexport default CheckBox;\r\n\r\n// file 2 contents\r\nexport default function fortyTwo() { return 42; }\r\n\r\n// file 3 contents\r\nexport default function insideDirectory() {}\r\n\r\n// in some other file\r\n// bad\r\nimport CheckBox from './checkBox'; // PascalCase import/export, camelCase filename\r\nimport FortyTwo from './FortyTwo'; // PascalCase import/filename, camelCase export\r\nimport InsideDirectory from './InsideDirectory'; // PascalCase import/filename, camelCase export\r\n\r\n// bad\r\nimport CheckBox from './check_box'; // PascalCase import/export, snake_case filename\r\nimport forty_two from './forty_two'; // snake_case import/filename, camelCase export\r\nimport inside_directory from './inside_directory'; // snake_case import, camelCase export\r\nimport index from './inside_directory/index'; // requiring the index file explicitly\r\nimport insideDirectory from './insideDirectory/index'; // requiring the index file explicitly\r\n\r\n// good\r\nimport CheckBox from './CheckBox'; // PascalCase export/import/filename\r\nimport fortyTwo from './fortyTwo'; // camelCase export/import/filename\r\nimport insideDirectory from './insideDirectory'; // camelCase export/import/directory name/implicit \"index\"\r\n// ^ supports both insideDirectory.js and insideDirectory/index.js\r\n```\r\n\r\n#### export-default 一个函数时，函数名用小驼峰，文件名需要和函数名一致\r\n\r\n```js\r\nfunction makeStyleGuide() {\r\n  // ...\r\n}\r\n\r\nexport default makeStyleGuide;\r\n```\r\n\r\n#### export 一个结构体/类/单例/函数库/对象 时用大驼峰\r\n\r\n```js\r\nconst AirbnbStyleGuide = {\r\n  es6: {},\r\n};\r\n\r\nexport default AirbnbStyleGuide;\r\n```\r\n\r\n### 简称和缩写应该全部大写或全部小写\r\n\r\n```js\r\n// bad\r\nimport SmsContainer from './containers/SmsContainer';\r\n\r\n// bad\r\nconst HttpRequests = [\r\n  // ...\r\n];\r\n\r\n// good\r\nimport SMSContainer from './containers/SMSContainer';\r\n\r\n// good\r\nconst HTTPRequests = [\r\n  // ...\r\n];\r\n\r\n// also good\r\nconst httpRequests = [\r\n  // ...\r\n];\r\n\r\n// best\r\nimport TextMessageContainer from './containers/TextMessageContainer';\r\n\r\n// best\r\nconst requests = [\r\n  // ...\r\n];\r\n```\r\n\r\n### 导出静态变量\r\n\r\n如果导出静态变量，它需要以下条件：\r\n\r\n- 确保被导出\r\n- 尽量全部大写\r\n- const 定义的，保证不能被改变\r\n- 如果导出对象，这个变量是可信的，他的子属性都是不能被改变的\r\n\r\n```js\r\n// bad\r\nconst PRIVATE_VARIABLE = 'should not be unnecessarily uppercased within a file';\r\n// bad\r\nexport const THING_TO_BE_CHANGED = 'should obviously not be uppercased';\r\n// bad\r\nexport let REASSIGNABLE_VARIABLE = 'do not use let with uppercase variables';\r\n// 允许但不够语义化\r\nexport const apiKey = 'SOMEKEY';\r\n// 更好的\r\nexport const API_KEY = 'SOMEKEY';\r\n\r\n// bad 不必要的大写键，没有增加任何语义\r\nexport const MAPPING = {\r\n  KEY: 'value',\r\n};\r\n// good\r\nexport const MAPPING = {\r\n  key: 'value',\r\n};\r\n```\r\n\r\n## CSS 命名规范\r\n\r\ncss 命名规范有很多方案，这里采用`BEM`作为规范，之所以采用 `BEM` 是因为它让你的前端代码更容易阅读和理解，更容易协作，更容易控制，更加健壮和明确，而且更加严密。\r\n\r\n下面介绍一些相关的概念，以及如何书写\r\n\r\n### 什么是 BEM 命名规范\r\n\r\nBem 是块（block）、元素（element）、修饰符（modifier）的简写，由 Yandex 团队提出的一种前端 CSS 命名方法论。\r\n\r\n- 中划线 ：仅作为连字符使用，表示某个块或者某个子元素的多单词之间的连接记号。\r\n\r\n- 双下划线：双下划线用来连接块和块的子元素\r\n\r\n- 单下划线：单下划线用来描述一个块或者块的子元素的一种状态\r\n\r\n### BEM 命名模式\r\n\r\n根据上面条件，下面写一个示例\r\n\r\n```css\r\n.block {\r\n}\r\n\r\n.block__element {\r\n}\r\n\r\n.block--modifier {\r\n}\r\n```\r\n\r\n仔细观察上面结构可以得到三个信息：\r\n\r\n- 每一个块(block)名应该有一个命名空间（前缀）\r\n- `block__element` 代表 `.block` 的后代，用于形成一个完整的 `.block` 的整体\r\n- `block--modifier` 代表 `.block` 的不同状态或不同版本\r\n\r\n使用两个连字符和下划线而不是一个，是为了让你自己的块可以用单个连字符来界定。如：\r\n\r\n```css\r\n.sub-block__element {\r\n}\r\n\r\n.sub-block--modifier {\r\n}\r\n```\r\n\r\n### 什么时候使用 BEM 命名\r\n\r\n- 你要知道什么时候哪些东西是应该写成 BEM 格式的\r\n\r\n或者说你要事先知道效果图或者 dom 结构应当是一个什么样子的\r\n\r\n- 只有模块或者组件有关联的时候才使用 BEM 格式\r\n\r\n- 单独的样式，没有必要使用 BEM 命名\r\n\r\n```css\r\n.hide {\r\n  display: none !important;\r\n}\r\n```\r\n\r\n### 与预处理器结合\r\n\r\nBEM 写起来可能会存在命名很长，但是如果有 less 之类的预处理器就能节省我们很多时间，下面以 less 为例\r\n\r\n```less\r\n.article {\r\n  max-width: 1200px;\r\n  &__body {\r\n    padding: 20px;\r\n  }\r\n  &__button {\r\n    padding: 5px 8px;\r\n    &--primary {\r\n      background: blue;\r\n    }\r\n    &--success {\r\n      background: green;\r\n    }\r\n  }\r\n}\r\n```\r\n\r\n### 在 Vue 中使用\r\n\r\nVue 为了简便开发提供了 `scope` 的 css 语法糖，但是在 BEM 中并不推荐，因为使用`scope`的目的就是避免样式冲突，而 BEM 本身就已经可以做到了。\r\n\r\n```vue\r\n<template>\r\n  <form class=\"form form--theme-xmas form--simple\">\r\n    <input class=\"form__input\" type=\"text\" />\r\n    <input class=\"form__submit form__submit--disabled\" type=\"submit\" />\r\n  </form>\r\n</template>\r\n\r\n<script lang=\"css\">\r\n.form { }\r\n.form--theme-xmas { }\r\n.form--simple { }\r\n.form__input { }\r\n.form__submit { }\r\n.form__submit--disabled { }\r\n</script>\r\n```\r\n\r\n## 组件命名规范\r\n\r\n### 文件名应始终单词大写开头或横线连接\r\n\r\n单词大写开头对于代码编辑器的自动补全最为友好，因为这使得我们在 `JS(X)` 和模板中引用组件的方式尽可能的一致。然而，混用文件命名方式有的时候会导致大小写不敏感的文件系统的问题，这也是横线连接命名同样完全可取的原因。\r\n\r\n```sh\r\n# bad\r\ncomponents/\r\n|- mycomponent.vue\r\n```\r\n\r\n```sh\r\ncomponents/\r\n|- myComponent.vue\r\n```\r\n\r\n```sh\r\n# good\r\ncomponents/\r\n|- TodoList.js\r\n|- TodoItem.js\r\n```\r\n\r\n```sh\r\n# good\r\ncomponents/\r\n|- TodoList.vue\r\n|- TodoItem.vue\r\n```\r\n\r\n### 基础组件以一个特定的前缀开头\r\n\r\n应用特定样式和约定的基础组件 (也就是展示类的、无逻辑的或无状态的组件) 应该全部以一个特定的前缀开头，比如 `Base`、`App` 或 `V`。\r\n\r\n```sh\r\n# bad\r\ncomponents/\r\n|- MyButton.vue\r\n|- VueTable.vue\r\n|- Icon.vue\r\n```\r\n\r\n```sh\r\n# good\r\ncomponents/\r\n|- BaseButton.vue\r\n|- BaseTable.vue\r\n|- BaseIcon.vue\r\n# or\r\ncomponents/\r\n|- AppButton.vue\r\n|- AppTable.vue\r\n|- AppIcon.vue\r\n# or\r\ncomponents/\r\n|- VButton.vue\r\n|- VTable.vue\r\n|- VIcon.vue\r\n```\r\n\r\n### 一次性组件命名\r\n\r\n单个活跃实例的组件应该以 `The` 前缀命名，以示其唯一性。\r\n\r\n这不意味着组件只可用于一个单页面，而是每个页面只使用一次。这些组件永远不接受任何 `prop`，因为它们是为你的应用定制的，而不是它们在你的应用中的上下文。如果你发现有必要添加 `prop`，那就表明这实际上是一个可复用的组件，只是目前在每个页面里只使用一次。\r\n\r\n```sh\r\n# bad\r\ncomponents/\r\n|- Heading.vue\r\n|- MySidebar.vue\r\n```\r\n\r\n```sh\r\n# good\r\ncomponents/\r\n|- TheHeading.vue\r\n|- TheSidebar.vue\r\n```\r\n\r\n### 组件命名请保持关联\r\n\r\n和父组件紧密耦合的子组件应该以父组件名作为前缀命名。\r\n\r\n如果一个组件只在某个父组件的场景下有意义，这层关系应该体现在其名字上。因为编辑器通常会按字母顺序组织文件，所以这样做可以把相关联的文件排在一起。\r\n\r\n```sh\r\n# bad\r\ncomponents/\r\n|- TodoList.vue\r\n|- TodoItem.vue\r\n|- TodoButton.vue\r\n```\r\n\r\n```sh\r\n# good\r\ncomponents/\r\n|- TodoList.vue\r\n|- TodoListItem.vue\r\n|- TodoListItemButton.vue\r\n```\r\n",
      "reactions": {
        "url": "https://api.github.com/repos/bosens-China/blog/issues/73/reactions",
        "total_count": 0,
        "+1": 0,
        "-1": 0,
        "laugh": 0,
        "hooray": 0,
        "confused": 0,
        "heart": 0,
        "rocket": 0,
        "eyes": 0
      },
      "timeline_url": "https://api.github.com/repos/bosens-China/blog/issues/73/timeline",
      "performed_via_github_app": null,
      "state_reason": null
    },
    {
      "url": "https://api.github.com/repos/bosens-China/blog/issues/77",
      "repository_url": "https://api.github.com/repos/bosens-China/blog",
      "labels_url": "https://api.github.com/repos/bosens-China/blog/issues/77/labels{/name}",
      "comments_url": "https://api.github.com/repos/bosens-China/blog/issues/77/comments",
      "events_url": "https://api.github.com/repos/bosens-China/blog/issues/77/events",
      "html_url": "https://github.com/bosens-China/blog/issues/77",
      "id": 1041025871,
      "node_id": "I_kwDOCzPAy84-DMtP",
      "number": 77,
      "title": "判断对象全等",
      "user": {
        "login": "bosens-China",
        "id": 39508895,
        "node_id": "MDQ6VXNlcjM5NTA4ODk1",
        "avatar_url": "https://avatars.githubusercontent.com/u/39508895?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bosens-China",
        "html_url": "https://github.com/bosens-China",
        "followers_url": "https://api.github.com/users/bosens-China/followers",
        "following_url": "https://api.github.com/users/bosens-China/following{/other_user}",
        "gists_url": "https://api.github.com/users/bosens-China/gists{/gist_id}",
        "starred_url": "https://api.github.com/users/bosens-China/starred{/owner}{/repo}",
        "subscriptions_url": "https://api.github.com/users/bosens-China/subscriptions",
        "organizations_url": "https://api.github.com/users/bosens-China/orgs",
        "repos_url": "https://api.github.com/users/bosens-China/repos",
        "events_url": "https://api.github.com/users/bosens-China/events{/privacy}",
        "received_events_url": "https://api.github.com/users/bosens-China/received_events",
        "type": "User",
        "site_admin": false
      },
      "labels": [
        {
          "id": 1602397157,
          "node_id": "MDU6TGFiZWwxNjAyMzk3MTU3",
          "url": "https://api.github.com/repos/bosens-China/blog/labels/%E6%B7%B1%E5%85%A5%E7%B3%BB%E5%88%97",
          "name": "深入系列",
          "color": "719192",
          "default": false,
          "description": "主要介绍实现的思路"
        }
      ],
      "state": "open",
      "locked": false,
      "assignee": null,
      "assignees": [],
      "milestone": null,
      "comments": 0,
      "created_at": "2021-11-01T10:38:09Z",
      "updated_at": "2021-12-21T09:58:45Z",
      "closed_at": null,
      "author_association": "OWNER",
      "active_lock_reason": null,
      "body": "JavaScript 自带了`==`和`===`两种判断方式，前者会隐式转换类型导致代码出现问题，而后者则是根据指针地址进行判断。\r\n\r\n在绝大多数情况这两种已经足够使用了，不过延伸下想判断两个对象或数组元素是否相同，则会显得不太友好，而且在 JavaScript 中有一些特殊的规则：`NaN`和`NaN`不相同、`+0`和`-0`相同，这就导致有的场景使用起来不便，下面动手实现一个`equal`函数，它具备以下功能：\r\n\r\n- `+0`和`-0`不相同\r\n- `NaN`和`NaN`相同\r\n- `{}`和`{}`相同\r\n- `[]`和`[]`相同\r\n- `new Set()`和`new Set()`相同\r\n- `new Map()`和`new Map()`相同\r\n- `new Date(111)`和`new Date(111)`相同\r\n- `new String(1)`和`new String(1)`之类的包装对象相同\r\n- `/a/`和`/a/`相同 -`() => {}`和`() => {}`不相同\r\n- 其他情况一律`===`判断\r\n\r\n## 第一版\r\n\r\n在这一版中，我们先实现`+0`和`-0`、`NaN`的判断\r\n\r\n```js\r\nfunction equal(a, b) {\r\n  // 判断NaN\r\n  if (a === b) {\r\n    return 1 / a === 1 / b;\r\n  }\r\n  // 判断对象\r\n  if (a && b && typeof a === 'object' && typeof b === 'object') {\r\n    //... 留空\r\n  }\r\n  // 判断NaN\r\n  return a !== a && b !== b;\r\n}\r\n```\r\n\r\n上面判断`NaN`的思路为`1 / 0`为`Infinity`，而`1/-0`为`-Infinity`\r\n\r\n## 第二版\r\n\r\n第一版中我们已经实现了基础的功能，下面就来实现一下怎么深层次判断对象和数组是否相同\r\n\r\n```js\r\nfunction equal(a, b) {\r\n  // 判断NaN\r\n  if (a === b) {\r\n    return 1 / a === 1 / b;\r\n  }\r\n  // 判断对象\r\n  if (a && b && typeof a === 'object' && typeof b === 'object') {\r\n    if (a.constructor !== b.constructor) {\r\n      return false;\r\n    }\r\n    // 判断array\r\n    if (Array.isArray(a) && Array.isArray(b)) {\r\n      const len = a.length;\r\n      if (len !== b.length) {\r\n        return false;\r\n      }\r\n      for (let i = 0; i < len; i++) {\r\n        if (!equal(a[i], b[i])) {\r\n          return false;\r\n        }\r\n      }\r\n      return true;\r\n    }\r\n    // 默认为对象，进行key和长度对比\r\n    const keys = Object.keys(a);\r\n    const len = keys.length;\r\n    if (Object.keys(b).length !== len) {\r\n      return false;\r\n    }\r\n    for (let i = 0; i < len; i++) {\r\n      const key = keys[i];\r\n      if (!Object.prototype.hasOwnProperty.call(b, key)) {\r\n        return false;\r\n      }\r\n      if (!equal(a[key], b[key])) {\r\n        return false;\r\n      }\r\n    }\r\n    return true;\r\n  }\r\n}\r\n```\r\n\r\n上面代码中首先判断`constructor`是否相同，`constructor`可以从实例指向原型的构造函数，上面代码首先的意思是首先判断构造函数是否相同，如果不相同直接返回。\r\n\r\n后面的话判断数组的成员数量、每个子属性是否相同，而判断对象也是判断`length`之后判断`b`下是否存在`name`，之后统一对比值是否相同。\r\n\r\n至于执行`Object.prototype.hasOwnProperty`的原因则是`hasOwnProperty`有可能被改写，例如：\r\n\r\n```js\r\nvar foo = {\r\n  hasOwnProperty: function () {\r\n    return false;\r\n  },\r\n  bar: 'Here be dragons',\r\n};\r\n\r\nfoo.hasOwnProperty('bar'); // 始终返回 false\r\n```\r\n\r\n## 第三版\r\n\r\n上面的代码基本实现了一个雏形，下面加入`Set`、`Map`的对比，`Set`和`Map`是 es6 是引入的新的数据结构，`Set`是一组不重复的成员，`Map`则是`object`的升级版：重点解决了键名循环不稳定以及只能插入 string 键名的问题。\r\n\r\n它们两者都是有序的，且都遵循`Symbol.iterator`，所以我们不仅要对比`name`、`value`也要对比所在的位置是否相同，这里为了简化后面的工作提前写了一个函数\r\n\r\n```js\r\nconst iteration = (value, j) => {\r\n  let i = 0;\r\n  for (const iterator of value) {\r\n    if (j === i++) {\r\n      return iterator;\r\n    }\r\n  }\r\n  return undefined;\r\n};\r\n```\r\n\r\n它的作用就是根据`j`指定下标来运行迭代器的`next`方法，例如：\r\n\r\n```js\r\niteration(new Set([1, 2, 3]), 1); // 2\r\n```\r\n\r\n```js\r\n// 判断set\r\nif (a instanceof Set && b instanceof Set) {\r\n  const len = a.size;\r\n  if (len !== b.size) {\r\n    return false;\r\n  }\r\n  for (let i = 0; i < len; i++) {\r\n    if (!equal(iteration(a, i), iteration(b, i))) {\r\n      return false;\r\n    }\r\n  }\r\n  return true;\r\n}\r\n// 判断Map\r\nif (a instanceof Map && b instanceof Map) {\r\n  const len = a.size;\r\n  if (len !== b.size) {\r\n    return false;\r\n  }\r\n  for (let i = 0; i < len; i++) {\r\n    const [nameA, valueA] = iteration(a.entries(), i);\r\n    const [nameB, valueB] = iteration(b.entries(), i);\r\n    if (!equal(nameA, nameB) || !equal(valueA, valueB)) {\r\n      return false;\r\n    }\r\n  }\r\n  return true;\r\n}\r\n```\r\n\r\n可以发现`Set`和`Map`判断是否相似，首先对比成员数量，其次对比每一次当前位置的键名和键值。\r\n\r\n## 第四版\r\n\r\n写到这里我们已经实现了 80%的功能，剩下的一些判断还有\r\n\r\n- `new Date(111)`和`new Date(111)`相同\r\n- `new String(1)`和`new String(1)`之类的包装对象相同\r\n- `/a/`和`/a/`相同\r\n\r\n```js\r\n// 判断regexp\r\nif (a.constructor === RegExp) {\r\n  return a.source === b.source && a.flags === b.flags;\r\n}\r\nif (a.toString !== Object.prototype.toString) {\r\n  return a.toString() === b.toString();\r\n}\r\nif (a.valueOf !== Object.prototype.valueOf) {\r\n  return a.valueOf() === b.valueOf();\r\n}\r\n```\r\n\r\n判断包装类型和`Date`可以`valueOf`和`toString`方法实现，每个对象都会从`Object.prototype`继承`vlaueOf`和`toString`方法。\r\n\r\n通常情况下`valueOf`返回包装对象传递的参数，而有的对象会更改`valueOf`方法，例如`Date`返回`number`类型，所以上面判断`valueOf`一则是为了`Date`另外一方则是初始过滤传递的参数。\r\n\r\n至于为什么也判断`toString`则是为了考虑边界情况，例如：\r\n\r\n```js\r\nvar a = new Boolean(true);\r\nvar b = new Boolean(1);\r\na === b ?\r\n```\r\n\r\n如果没有`toString`这个就相同了\r\n\r\n## 最后\r\n\r\n完整的把代码贴一下，如果对你有帮助也可以`star`支持一下，有什么错误也欢迎指出。\r\n\r\n```js\r\nconst iteration = (value, j) => {\r\n  let i = 0;\r\n  for (const iterator of value) {\r\n    if (j === i++) {\r\n      return iterator;\r\n    }\r\n  }\r\n  return undefined;\r\n};\r\nfunction equal(a, b) {\r\n  // 判断NaN\r\n  if (a === b) {\r\n    return 1 / a === 1 / b;\r\n  }\r\n  // 判断对象\r\n  if (a && b && typeof a === 'object' && typeof b === 'object') {\r\n    // 判断对象\r\n    if (a && b && typeof a === 'object' && typeof b === 'object') {\r\n      if (a.constructor !== b.constructor) {\r\n        return false;\r\n      }\r\n      // 判断array\r\n      if (Array.isArray(a) && Array.isArray(b)) {\r\n        const len = a.length;\r\n        if (len !== b.length) {\r\n          return false;\r\n        }\r\n        for (let i = 0; i < len; i++) {\r\n          if (!equal(a[i], b[i])) {\r\n            return false;\r\n          }\r\n        }\r\n        return true;\r\n      }\r\n      // 判断set\r\n      if (a instanceof Set && b instanceof Set) {\r\n        const len = a.size;\r\n        if (len !== b.size) {\r\n          return false;\r\n        }\r\n        for (let i = 0; i < len; i++) {\r\n          if (!equal(iteration(a, i), iteration(b, i))) {\r\n            return false;\r\n          }\r\n        }\r\n        return true;\r\n      }\r\n      // 判断Map\r\n      if (a instanceof Map && b instanceof Map) {\r\n        const len = a.size;\r\n        if (len !== b.size) {\r\n          return false;\r\n        }\r\n        for (let i = 0; i < len; i++) {\r\n          const [nameA, valueA] = iteration(a.entries(), i);\r\n          const [nameB, valueB] = iteration(b.entries(), i);\r\n          if (!equal(nameA, nameB) || !equal(valueA, valueB)) {\r\n            return false;\r\n          }\r\n        }\r\n        return true;\r\n      }\r\n      // 判断regexp\r\n      if (a.constructor === RegExp) {\r\n        return a.source === b.source && a.flags === b.flags;\r\n      }\r\n      if (a.toString !== Object.prototype.toString) {\r\n        return a.toString() === b.toString();\r\n      }\r\n      if (a.valueOf !== Object.prototype.valueOf) {\r\n        return a.valueOf() === b.valueOf();\r\n      }\r\n      // 默认为对象，进行key和长度对比\r\n      const keys = Object.keys(a);\r\n      const len = keys.length;\r\n      if (Object.keys(b).length !== len) {\r\n        return false;\r\n      }\r\n      for (let i = 0; i < len; i++) {\r\n        const key = keys[i];\r\n        if (!Object.prototype.hasOwnProperty.call(b, key)) {\r\n          return false;\r\n        }\r\n        if (!equal(a[key], b[key])) {\r\n          return false;\r\n        }\r\n      }\r\n      return true;\r\n    }\r\n  }\r\n  // 判断NaN\r\n  return a !== a && b !== b;\r\n}\r\n```\r\n\r\n## 参考\r\n\r\n- [fast-deep-equal](https://github.com/epoberezkin/fast-deep-equal)\r\n",
      "reactions": {
        "url": "https://api.github.com/repos/bosens-China/blog/issues/77/reactions",
        "total_count": 0,
        "+1": 0,
        "-1": 0,
        "laugh": 0,
        "hooray": 0,
        "confused": 0,
        "heart": 0,
        "rocket": 0,
        "eyes": 0
      },
      "timeline_url": "https://api.github.com/repos/bosens-China/blog/issues/77/timeline",
      "performed_via_github_app": null,
      "state_reason": null
    },
    {
      "url": "https://api.github.com/repos/bosens-China/blog/issues/76",
      "repository_url": "https://api.github.com/repos/bosens-China/blog",
      "labels_url": "https://api.github.com/repos/bosens-China/blog/issues/76/labels{/name}",
      "comments_url": "https://api.github.com/repos/bosens-China/blog/issues/76/comments",
      "events_url": "https://api.github.com/repos/bosens-China/blog/issues/76/events",
      "html_url": "https://github.com/bosens-China/blog/issues/76",
      "id": 1029841361,
      "node_id": "I_kwDOCzPAy849YiHR",
      "number": 76,
      "title": "函数记忆",
      "user": {
        "login": "bosens-China",
        "id": 39508895,
        "node_id": "MDQ6VXNlcjM5NTA4ODk1",
        "avatar_url": "https://avatars.githubusercontent.com/u/39508895?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bosens-China",
        "html_url": "https://github.com/bosens-China",
        "followers_url": "https://api.github.com/users/bosens-China/followers",
        "following_url": "https://api.github.com/users/bosens-China/following{/other_user}",
        "gists_url": "https://api.github.com/users/bosens-China/gists{/gist_id}",
        "starred_url": "https://api.github.com/users/bosens-China/starred{/owner}{/repo}",
        "subscriptions_url": "https://api.github.com/users/bosens-China/subscriptions",
        "organizations_url": "https://api.github.com/users/bosens-China/orgs",
        "repos_url": "https://api.github.com/users/bosens-China/repos",
        "events_url": "https://api.github.com/users/bosens-China/events{/privacy}",
        "received_events_url": "https://api.github.com/users/bosens-China/received_events",
        "type": "User",
        "site_admin": false
      },
      "labels": [
        {
          "id": 1602397157,
          "node_id": "MDU6TGFiZWwxNjAyMzk3MTU3",
          "url": "https://api.github.com/repos/bosens-China/blog/labels/%E6%B7%B1%E5%85%A5%E7%B3%BB%E5%88%97",
          "name": "深入系列",
          "color": "719192",
          "default": false,
          "description": "主要介绍实现的思路"
        }
      ],
      "state": "open",
      "locked": false,
      "assignee": null,
      "assignees": [],
      "milestone": null,
      "comments": 0,
      "created_at": "2021-10-19T04:16:45Z",
      "updated_at": "2021-12-21T09:58:43Z",
      "closed_at": null,
      "author_association": "OWNER",
      "active_lock_reason": null,
      "body": "> **记忆化**（英语：memoization）是一种提高[计算机程序](https://zh.wikipedia.org/wiki/计算机程序)执行速度的优化技术。通过储存大计算量[函数](https://zh.wikipedia.org/wiki/子程序)的返回值，当这个结果再次被需要时将其从[缓存](https://zh.wikipedia.org/wiki/缓存)提取，而不用再次计算来节省计算时间。\r\n>\r\n> 记忆化是一种典型的在计算时间与[电脑存储器](https://zh.wikipedia.org/wiki/電腦記憶體)空间之中获取平衡的方案。\r\n>\r\n> 来源：[维基百科](https://zh.wikipedia.org/wiki/%E8%AE%B0%E5%BF%86%E5%8C%96)\r\n\r\n从上面的定义可以看出缓存是一种非常有用的技巧，它可以把一些函数结果储存起来在下次调用的时候返回。\r\n这里不讨论什么样场景使用缓存而是抛砖引玉如何编写一个可复用的 Memoization 函数\r\n\r\n## MemoizationSync\r\n\r\nMemoizationSync 从字面就可以看出它是一个同步版本的 Memoization，下面的以 `add` 函数为例介绍如何编写一个通用的 memoization 来对结果进行缓存\r\n\r\n```js\r\nconst memo = {};\r\n\r\nconst add = (...args) => {\r\n  const key = args.join();\r\n  if (Object.prototype.hasOwnProperty.call(memo, key)) {\r\n    return memo[key];\r\n  }\r\n  const result = args.reduce((a, b) => a + b, 0);\r\n  memo[key] = result;\r\n  return result;\r\n};\r\n\r\nadd(1, 2, 3);\r\nadd(1, 2, 3);\r\n```\r\n\r\n如果要给 `add` 函数显示的添加一个缓存功能可能会按照上面的情况来编写，但是它存在问题。\r\n\r\n这个函数同时做了两件事情\r\n\r\n- 计算 args\r\n- 读取 memo 的缓存\r\n  但是这样显示违背了设计模式的单一原则，而且会给后续的维护带来麻烦，以及如果我们需要新的函数缓存是不是还要重新复制一份过去，显然不符合我们的要求，我们尝试将它进行一次抽离\r\n\r\n```js\r\nconst add = (...args) => {\r\n  return args.reduce((a, b) => a + b, 0);\r\n};\r\n\r\nconst memoizationSync = (fn, key) => {\r\n  const memo = {};\r\n  return function callback(...args) {\r\n    if (memo.hasOwnProperty(key)) {\r\n      return memo[key];\r\n    }\r\n    const result = fn.apply(this, args);\r\n    memo[key] = result;\r\n    return result;\r\n  };\r\n};\r\n\r\nconst argumentsArr = [1, 2, 3];\r\nconst memoizationAdd = memoizationSync(add, argumentsArr);\r\nmemoizationAdd(...argumentsArr);\r\nmemoizationAdd(...argumentsArr);\r\n```\r\n\r\n这样就得到了一个通用的 memoizationSync 函数，它接受一个 `key` ，通过 `key` 来进行区分缓存。\r\n\r\n不过为了它的灵活性和符合更多的场景的要求我们还是需要对它进行一次改造，来改造前我们看下这个函数做了啥\r\n\r\n- 根据 key 来读取缓存\r\n- 无缓存来执行函数设置缓存\r\n  显然这两步是不会改变的，但是我们可以对 `key` 下手提高 `key` 的唯一性，我们希望它可以是一个函数并且存在默认值，这样在复杂场景下可以由用户根据参数来指定缓存什么字段\r\n\r\n```js\r\nconst memoizationSync = (fn, getKey = (...args) => args.join('')) => {\r\n  const memo = {};\r\n  return function callback(...args) {\r\n    const key = typeof getKey === 'function' ? getKey.apply(this, args) : getKey;\r\n    if (memo.hasOwnProperty(key)) {\r\n      return memo[key];\r\n    }\r\n    const result = fn.apply(this, args);\r\n    memo[key] = result;\r\n    return result;\r\n  };\r\n};\r\n```\r\n\r\n## MemoizationAsync\r\n\r\n在 JavaScript 中异步场景粗略可以分为两部分\r\n\r\n- 回调函数\r\n- Promise（async 、Generator 都是基于 Promise）\r\n\r\n下面就来讨论这两部分我们如何实现缓存\r\n\r\n### Callback\r\n\r\n我现在有一个 getImgSize 的函数，它会根据 `img` 的 `src` 来返回图片的真实宽度和高度，如果成功就会调用 `callback` 来传递参数（node 回调风格），但是我希望如果 url 相同的时候就直接返回而不是继续调用一次 getImgSize\r\n\r\n```js\r\nconst getImgSize = (src, callback) => {\r\n  const img = new Image();\r\n  img.src = src;\r\n  img.addEventListener('load', () => {\r\n    callback(null, {\r\n      width: img.naturalWidth,\r\n      height: img.naturalHeight,\r\n    });\r\n  });\r\n\r\n  img.addEventListener('error', (e) => {\r\n    callback(new Error(e), null);\r\n  });\r\n};\r\n\r\nconst url = 'https://www.google.com/images/branding/googlelogo/1x/googlelogo_color_272x92dp.png';\r\n\r\ngetImgSize(url, (error, size) => {\r\n  if (error) {\r\n    return;\r\n  }\r\n  console.log(size);\r\n});\r\n```\r\n\r\n在编写 memoizationAsync 函数之前我们先想一下以什么样的方式来编写这个函数，按照惯例我们希望不要对用户的使用方式有太多影响，所以期待的调用方式如下\r\n\r\n```js\r\nconst getImgSizeMemoization = memoizationAsync(getImgSize);\r\ngetImgSizeMemoization(url, (error, size) => {\r\n  if (error) {\r\n    return;\r\n  }\r\n  console.log(size);\r\n});\r\n// 相同参数使用缓存\r\ngetImgSizeMemoization(url, (error, size) => {\r\n  if (error) {\r\n    return;\r\n  }\r\n  console.log(size);\r\n});\r\n```\r\n\r\n后面就是来编写这个函数\r\n\r\n```js\r\nconst memoizationAsync = (fn, getKey = (...args) => args.join()) => {\r\n  const memo = {};\r\n  const queue = {};\r\n  return function (...rest) {\r\n    const callback = Array.prototype.pop.call(rest);\r\n    const key = getKey.apply(this, rest);\r\n    const cb = (...args) => {\r\n      memo[key] = args;\r\n      queue[key].forEach((item) => {\r\n        item.apply(this, args);\r\n      });\r\n      delete queue[key];\r\n    };\r\n    if (memo.hasOwnProperty(key)) {\r\n      return memo[key];\r\n    }\r\n    if (!queue.hasOwnProperty(key)) {\r\n      queue[key] = [callback];\r\n    } else {\r\n      queue[key].push(callback);\r\n      // 后续加入等待第一个执行结束\r\n      return;\r\n    }\r\n    fn.apply(this, [...rest, cb]);\r\n  };\r\n};\r\n```\r\n\r\n说一下这个函数编写的思路，通过自定义创建 cb 回调函数来完成记录缓存和调用用户传递的回调，其他的读取和设置缓存与上面一致。\r\n\r\n而存在 `queue` 变量的原因是因为异步任务添加进来的时候可能正在请求，但是 `memo` 还没有被写入结果，所以通过队列来管理这个请求，等待第一个请求结束之后批量来执行队列的任务，最后删除。\r\n\r\n### Promise\r\n\r\n回忆一下[Promise 函数的特性](https://es6.ruanyifeng.com/#docs/promise#Promise-%E7%9A%84%E5%90%AB%E4%B9%89)\r\n\r\n- 对象的状态不受外界影响\r\n- 一旦状态改变，就不会再变，任何时候都可以得到这个结果\r\n\r\n重点是第二点，它不同于回调函数，只要结果出来了任何时候都可以调用，我们在 click 监听一个事件如果错过了这个监听想要回溯是不可能的，但是 promise 你重复无数次的`.then` 调用，基于这个特性我们来编写 MemoizationAsync\r\n\r\n```js\r\nconst getImgSize = (src) => {\r\n  return new Promise((resolve, reject) => {\r\n    const img = new Image();\r\n    img.src = src;\r\n    img.addEventListener('load', () => {\r\n      return resolve({\r\n        width: img.naturalWidth,\r\n        height: img.naturalHeight,\r\n      });\r\n    });\r\n\r\n    img.addEventListener('error', (e) => {\r\n      return reject(e);\r\n    });\r\n  });\r\n};\r\n\r\nconst url = 'https://www.google.com/images/branding/googlelogo/1x/googlelogo_color_272x92dp.png';\r\n\r\nconst memoizationAsync = (fn, getKey = (...args) => args.join()) => {\r\n  const memo = {};\r\n  return async function (...args) {\r\n    const key = getKey.apply(this, args);\r\n    if (memo.hasOwnProperty(key)) {\r\n      return memo[key];\r\n    }\r\n    const result = fn.apply(this, args);\r\n    memo[key] = result;\r\n    return result;\r\n  };\r\n};\r\n\r\nconst getImgSizeMemoization = memoizationAsync(getImgSize);\r\n\r\n(async () => {\r\n  const result = await Promise.all([getImgSizeMemoization(url), getImgSizeMemoization(url)]);\r\n  console.log(result);\r\n})();\r\n```\r\n\r\nmemoizationAsync 函数编写的十分精简跟同步版本基本没区别，不同点在于我们只是返回了 **Promise 的状态**，而得益于 Promise 的特性在任何时候这个函数都会返回正确的结果\r\n\r\n## 最后\r\n\r\n如果对你有帮助可以`关注`、 `star` 一下，有什么错误欢迎指出\r\n",
      "reactions": {
        "url": "https://api.github.com/repos/bosens-China/blog/issues/76/reactions",
        "total_count": 0,
        "+1": 0,
        "-1": 0,
        "laugh": 0,
        "hooray": 0,
        "confused": 0,
        "heart": 0,
        "rocket": 0,
        "eyes": 0
      },
      "timeline_url": "https://api.github.com/repos/bosens-China/blog/issues/76/timeline",
      "performed_via_github_app": null,
      "state_reason": null
    },
    {
      "url": "https://api.github.com/repos/bosens-China/blog/issues/49",
      "repository_url": "https://api.github.com/repos/bosens-China/blog",
      "labels_url": "https://api.github.com/repos/bosens-China/blog/issues/49/labels{/name}",
      "comments_url": "https://api.github.com/repos/bosens-China/blog/issues/49/comments",
      "events_url": "https://api.github.com/repos/bosens-China/blog/issues/49/events",
      "html_url": "https://github.com/bosens-China/blog/issues/49",
      "id": 548743305,
      "node_id": "MDU6SXNzdWU1NDg3NDMzMDU=",
      "number": 49,
      "title": "GitHubActions构建定时任务",
      "user": {
        "login": "bosens-China",
        "id": 39508895,
        "node_id": "MDQ6VXNlcjM5NTA4ODk1",
        "avatar_url": "https://avatars.githubusercontent.com/u/39508895?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bosens-China",
        "html_url": "https://github.com/bosens-China",
        "followers_url": "https://api.github.com/users/bosens-China/followers",
        "following_url": "https://api.github.com/users/bosens-China/following{/other_user}",
        "gists_url": "https://api.github.com/users/bosens-China/gists{/gist_id}",
        "starred_url": "https://api.github.com/users/bosens-China/starred{/owner}{/repo}",
        "subscriptions_url": "https://api.github.com/users/bosens-China/subscriptions",
        "organizations_url": "https://api.github.com/users/bosens-China/orgs",
        "repos_url": "https://api.github.com/users/bosens-China/repos",
        "events_url": "https://api.github.com/users/bosens-China/events{/privacy}",
        "received_events_url": "https://api.github.com/users/bosens-China/received_events",
        "type": "User",
        "site_admin": false
      },
      "labels": [
        {
          "id": 1740577858,
          "node_id": "MDU6TGFiZWwxNzQwNTc3ODU4",
          "url": "https://api.github.com/repos/bosens-China/blog/labels/%E5%B7%A5%E5%85%B7%E7%9B%B8%E5%85%B3",
          "name": "工具相关",
          "color": "f73d62",
          "default": false,
          "description": "工程化相关的东西"
        }
      ],
      "state": "open",
      "locked": false,
      "assignee": null,
      "assignees": [],
      "milestone": null,
      "comments": 0,
      "created_at": "2020-01-13T07:07:52Z",
      "updated_at": "2021-12-21T09:53:13Z",
      "closed_at": null,
      "author_association": "OWNER",
      "active_lock_reason": null,
      "body": "写这篇文章是无意之间看到阮一峰老师发布的[GitHub Actions 入门教程](http://www.ruanyifeng.com/blog/2019/09/getting-started-with-github-actions.html)里面介绍了 GitHub Actions 的一些概念，碰巧我之前用爬虫 + vuePress 构件了一个[typescript 的中文手册](https://bosens-china.github.io/Typescript-manual/)，下面就以每天定时构建这个应用为背景介绍如何使用 GitHub Actions 完成下面工作。\r\n\r\n下面内容主要以实践为主。\r\n\r\n## 思路\r\n\r\n1. 编写 bash 上传脚本\r\n2. 执行爬虫命令构建应用；\r\n3. 定时执行脚本，完成上传\r\n4. 出现错误发送邮件通知我；\r\n\r\n### deploy.sh\r\n\r\n```sh\r\n#!/usr/bin/env sh\r\n\r\n# 确保脚本抛出遇到的错误\r\nset -e\r\n# 下面是脚本命令，根据你的需求来选取。\r\nnpm run xxxx\r\n# 进入生成的文件夹\r\ncd docs/.vuepress/dist\r\ngit init\r\ngit add -A\r\ngit commit -m 'deploy'\r\n# 强制推送到指定分支\r\ngit push -f git@github.com:bosens-China/Typescript-manual.git master:gh-pages\r\ncd -\r\n```\r\n\r\n脚本执行的功能很简单，执行构建命令，之后进入构建的文件夹创建 git 仓库之后推送，这里需要注意一点的就是我们会将任务放置在`GitHub Actions`上，**而 git 推送是需要权限的**，下面就来解决和这个问题。\r\n\r\n###  ssh-keygen\r\n\r\n运行\r\n\r\n```sh\r\nssh-keygen\r\n```\r\n\r\n创建`id_rsa`和`id_rsa.pub`两个文件，分别对应私钥文件和公钥文件。\r\n\r\n之后将`id_rsa.pub`中的公钥添加到 Github 对应仓库的 Deploye keys 中\r\n![xx](https://user-gold-cdn.xitu.io/2020/1/13/16f9deb5aa175f0f?w=800&h=439&f=png&s=121430)\r\n再将`id_rsa`的私钥文件添加到 Github 对应仓库的 Secrets 中，这里将名称定义为`ACTION_DEPLOY_KEY`，你可以自行定义，目的就是为了让虚拟机拥有 git 仓库的权限\r\n![xx](https://user-gold-cdn.xitu.io/2020/1/13/16f9deb52f7e5467?w=800&h=389&f=png&s=121131)\r\n\r\nOK，到这一步我们得准备工作就基本上完成了，下面就是对 yml 配置文件的编写了。\r\n\r\n### deploy.yml\r\n\r\n我们在根目录新建一个`.github`的文件夹在文件夹内新建一个文件`deploy.yml`\r\n\r\n```sh\r\n# 触发的事件\r\non:\r\n  push:\r\n    branches:\r\n      - master\r\n# 定时任务在utc的9点执行，换算北京时间需要 + 8也就是凌晨五点\r\n  schedule:\r\n    - cron: \"0 21 * * *\"\r\n\r\njobs:\r\n  build:\r\n    runs-on: ubuntu-18.04\r\n\r\n    strategy:\r\n      matrix:\r\n        node-version: [12.x]\r\n\r\n    steps:\r\n      - uses: actions/checkout@v1\r\n      - name: Use Node.js ${{ matrix.node-version }}\r\n        uses: actions/setup-node@v1\r\n        with:\r\n          node-version: ${{ matrix.node-version }}\r\n      - name: git Actions\r\n        uses: srt32/git-actions@v0.0.3\r\n      - name: Setup\r\n        env:\r\n          ACTION_DEPLOY_KEY: ${{ secrets.ACTION_DEPLOY_KEY }}\r\n        run: |\r\n          mkdir -p ~/.ssh/\r\n          echo \"$ACTION_DEPLOY_KEY\" > ~/.ssh/id_rsa\r\n          chmod 600 ~/.ssh/id_rsa\r\n          ssh-keyscan github.com >> ~/.ssh/known_hosts\r\n          git config --global user.email \"你的邮箱\"\r\n          git config --global user.name \"你的名字\"\r\n          npm install\r\n          npm run updata\r\n```\r\n\r\n简单说下上面脚本干了什么事情。\r\n\r\n1. 拉取源码（actions/checkout@v1）\r\n2. 安装 node 和 git（actions/setup-node@v1 和 srt32/git-actions@v0.0.3）\r\n3. 将我们的私匙放置在.ssh 目录下（Setup）\r\n4. 执行`deploy.sh`脚本，上述的最后指定的 npm run updata 值就是`bash deploy.sh`\r\n\r\n在上面我指定了 on 它是触发的事件，我在这里指定了每天定时和`master`分支提交的时候执行这段脚本；\r\n\r\n`jobs`则是动作，动作可以有很多 build 就是一个动作，需要特别注意一点**runs-on: ubuntu-18.04**的值是指定虚拟机这个字段是必填的，不建议使用`windows`虚拟机。\r\n\r\n至于上面的`uses`字段，这个是官方提供的模块，你可以这样理解，它可以方便我们的操作，你也可以自己编写脚本之后上传到 github 的市场上，更多的内容我推荐到[官方文档上查阅](https://github.com/features/actions)\r\n\r\n### 执行错误邮件通知\r\n\r\n因为上面说这个是爬虫的应用，为了知道错误我需要邮件及时通知我，这里就使用第三方`nodemailer`的模块为例。\r\n\r\n```js\r\nfunction sendMail(e) {\r\n  const mailTransport = nodemailer.createTransport({\r\n    host: \"smtp.qq.com\",\r\n    secureConnection: true,\r\n    auth: {\r\n      user: \"xxx@qq.com\",\r\n      pass: \"vbwjzecplhehibed\"\r\n    }\r\n  });\r\n  const options = {\r\n    from: \"xxxx@qq.com\",\r\n    to: \"xxx@qq.com\",\r\n    subject: \"typescript-book出现错误\",\r\n    text: e instanceof Error ? e.message : e\r\n  };\r\n  mailTransport.sendMail(options);\r\n}\r\n```\r\n\r\n稍微注意一下`auth`字段，有一个 pass 这个本来是密码不过如果直接把密码暴露出来可能会造成不安全，所以也支持授权码，如果你想了解更多可以[什么是授权码，它又是如何设置？](https://link.jianshu.com/?t=http%3A%2F%2Fservice.mail.qq.com%2Fcgi-bin%2Fhelp%3Fsubtype%3D1%26%26no%3D1001256%26%26id%3D28)点击了解。\r\n\r\n最后你需要为邮箱开通`SMTP服务`，qq 邮箱直接点开设置查找就行了，其他邮箱也类似。\r\n之后再调用这个函数就 OK 了。\r\n\r\n### 查看效果\r\n\r\n上面写完后我们的定时发布脚本就完成了，剩下的就是提交代码触发钩子来执行我们的任务，这里我 push`master`分支代码，打开 actions\r\n![xx](https://user-gold-cdn.xitu.io/2020/1/13/16f9ded560ff8454?w=1920&h=937&f=png&s=62950)\r\n\r\n右侧就是我们脚本的执行次数和状态了，√ 表示成功，你可以详细点开查看更多的细节，例如下面的错误，你可以展开查看报错的原因是什么，方便对错误定位和调试，这里不做展开了。\r\n\r\n## 最后\r\n\r\n这篇文章写完发现更多是分享我怎么完成的，希望对你有所帮助，如果喜欢请给一下 Star\r\n",
      "reactions": {
        "url": "https://api.github.com/repos/bosens-China/blog/issues/49/reactions",
        "total_count": 0,
        "+1": 0,
        "-1": 0,
        "laugh": 0,
        "hooray": 0,
        "confused": 0,
        "heart": 0,
        "rocket": 0,
        "eyes": 0
      },
      "timeline_url": "https://api.github.com/repos/bosens-China/blog/issues/49/timeline",
      "performed_via_github_app": null,
      "state_reason": null
    },
    {
      "url": "https://api.github.com/repos/bosens-China/blog/issues/64",
      "repository_url": "https://api.github.com/repos/bosens-China/blog",
      "labels_url": "https://api.github.com/repos/bosens-China/blog/issues/64/labels{/name}",
      "comments_url": "https://api.github.com/repos/bosens-China/blog/issues/64/comments",
      "events_url": "https://api.github.com/repos/bosens-China/blog/issues/64/events",
      "html_url": "https://github.com/bosens-China/blog/issues/64",
      "id": 767600367,
      "node_id": "MDU6SXNzdWU3Njc2MDAzNjc=",
      "number": 64,
      "title": "ios屏幕适配",
      "user": {
        "login": "bosens-China",
        "id": 39508895,
        "node_id": "MDQ6VXNlcjM5NTA4ODk1",
        "avatar_url": "https://avatars.githubusercontent.com/u/39508895?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bosens-China",
        "html_url": "https://github.com/bosens-China",
        "followers_url": "https://api.github.com/users/bosens-China/followers",
        "following_url": "https://api.github.com/users/bosens-China/following{/other_user}",
        "gists_url": "https://api.github.com/users/bosens-China/gists{/gist_id}",
        "starred_url": "https://api.github.com/users/bosens-China/starred{/owner}{/repo}",
        "subscriptions_url": "https://api.github.com/users/bosens-China/subscriptions",
        "organizations_url": "https://api.github.com/users/bosens-China/orgs",
        "repos_url": "https://api.github.com/users/bosens-China/repos",
        "events_url": "https://api.github.com/users/bosens-China/events{/privacy}",
        "received_events_url": "https://api.github.com/users/bosens-China/received_events",
        "type": "User",
        "site_admin": false
      },
      "labels": [
        {
          "id": 1371686610,
          "node_id": "MDU6TGFiZWwxMzcxNjg2NjEw",
          "url": "https://api.github.com/repos/bosens-China/blog/labels/css%20%E7%9B%B8%E5%85%B3",
          "name": "css 相关",
          "color": "42b883",
          "default": false,
          "description": "css 技巧和基础为主"
        }
      ],
      "state": "open",
      "locked": false,
      "assignee": null,
      "assignees": [],
      "milestone": null,
      "comments": 0,
      "created_at": "2020-12-15T13:34:49Z",
      "updated_at": "2021-12-21T09:51:42Z",
      "closed_at": null,
      "author_association": "OWNER",
      "active_lock_reason": null,
      "body": "这篇文章算是迟来的总结，最近做了一个 h5 项目内嵌到 app 页面内联，默认情况下 app 那边不会做任何处理，也就是顶部和底部需要额外处理一下\r\n![bg](https://user-images.githubusercontent.com/39508895/102221576-4211db00-3f1d-11eb-981c-885c51309964.png)\r\n\r\n\r\n## 做法\r\n\r\n默认情况下 ios 的顶部状态栏是`20px`，如果存在刘海则是`44px`，当然实际开发中也不需要使用 js 来进行判断，因为 ios11 之后新增了一个安全区域，用来定义可视窗口的范围，它一共有四个属性\r\n\r\n- safe-area-inset-left：安全区域距离左边边界距离\r\n- safe-area-inset-right：安全区域距离右边边界距离\r\n- safe-area-inset-top：安全区域距离顶部边界距离\r\n- safe-area-inset-bottom：安全区域距离底部边界距离\r\n\r\n使用方法也很简单：\r\n\r\n```css\r\npadding-bottom: env(safe-area-inset-bottom);\r\n```\r\n\r\n在`html`文件的`meta`中添加\r\n\r\n```html\r\n   <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0,user-scalable=no, viewport-fit=cover\">\r\n```\r\n\r\n> 只有设置了viewport-fit=cover，才能使用`env`，注意上面说的都是竖屏情况\r\n\r\n\r\n\r\n#### env 第二个参数\r\n\r\n上面写法的`env`和`constant`其实都支持第二个参数，作为不支持环境的后退，可以作为了解\r\n例如：\r\n``` css\r\n/* 不支持就回退到第二个参数 */\r\npadding-bottom: env(safe-area-inset-bottom, 20px);\r\n```\r\n\r\n#### @supports 额外判断\r\n\r\n为了防止部分安卓也使用`safe-area-inset-top`之类的属性，可以添加`-webkit-overflow-scrolling: touch`来进行双重判断\r\n\r\n> [-webkit-overflow-scrolling](https://caniuse.com/?search=-webkit-overflow-scrolling) 只有 iOS Safari 支持\r\n\r\n```css\r\n@supports (\r\n    (height: constant(safe-area-inset-top)) or\r\n      (height: env(safe-area-inset-top))\r\n  )\r\n  and (-webkit-overflow-scrolling: touch) {\r\n  /* 代码 */\r\n}\r\n```\r\n\r\n## fixed 写法\r\n\r\n- calc，直接把原来写的值加上安全区域范围\r\n\r\n```css\r\nbottom: calc(50px (假设值) + env(safe-area-inset-bottom));\r\n```\r\n\r\n- padding: 添加 padding 的内边距进行填充\r\n\r\n```css\r\npadding-bottom: env(safe-area-inset-bottom);\r\n```\r\n\r\n## 额外注意点\r\n\r\n是不是因为上面就说完了，其实还有还有一点兼容的地方需要额外关注\r\n\r\n> The env() function shipped in iOS 11 with the name constant(). Beginning with Safari Technology Preview 41 and the iOS 11.2 beta, constant() has been removed and replaced with env(). You can use the CSS fallback mechanism to support both versions, if necessary, but should prefer env() going forward.\r\n\r\n翻译过来就是`ios`11.2 之后不再支持`constant`而是使用`env`，所以生产过程中可以使用下面写法做兼容\r\n\r\n```css\r\npadding-bottom: constant(safe-area-inset-bottom);\r\n/* 兼容 iOS < 11.2 */\r\npadding-bottom: env(safe-area-inset-bottom);\r\n/* 兼容 iOS >= 11.2 */\r\n```\r\n\r\n## 最后\r\n\r\n如果对你有帮助可以点一下`star`\r\n\r\n参考文章\r\n\r\n- [网页适配 iPhoneX，就是这么简单](https://aotu.io/notes/2017/11/27/iphonex/index.html)\r\n\r\n- [IOS刘海屏H5 CSS适配](https://juejin.cn/post/6844903974491930637#heading-4)\r\n",
      "reactions": {
        "url": "https://api.github.com/repos/bosens-China/blog/issues/64/reactions",
        "total_count": 0,
        "+1": 0,
        "-1": 0,
        "laugh": 0,
        "hooray": 0,
        "confused": 0,
        "heart": 0,
        "rocket": 0,
        "eyes": 0
      },
      "timeline_url": "https://api.github.com/repos/bosens-China/blog/issues/64/timeline",
      "performed_via_github_app": null,
      "state_reason": null
    },
    {
      "url": "https://api.github.com/repos/bosens-China/blog/issues/36",
      "repository_url": "https://api.github.com/repos/bosens-China/blog",
      "labels_url": "https://api.github.com/repos/bosens-China/blog/issues/36/labels{/name}",
      "comments_url": "https://api.github.com/repos/bosens-China/blog/issues/36/comments",
      "events_url": "https://api.github.com/repos/bosens-China/blog/issues/36/events",
      "html_url": "https://github.com/bosens-China/blog/issues/36",
      "id": 522570348,
      "node_id": "MDU6SXNzdWU1MjI1NzAzNDg=",
      "number": 36,
      "title": "漫谈系统权限设计",
      "user": {
        "login": "bosens-China",
        "id": 39508895,
        "node_id": "MDQ6VXNlcjM5NTA4ODk1",
        "avatar_url": "https://avatars.githubusercontent.com/u/39508895?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bosens-China",
        "html_url": "https://github.com/bosens-China",
        "followers_url": "https://api.github.com/users/bosens-China/followers",
        "following_url": "https://api.github.com/users/bosens-China/following{/other_user}",
        "gists_url": "https://api.github.com/users/bosens-China/gists{/gist_id}",
        "starred_url": "https://api.github.com/users/bosens-China/starred{/owner}{/repo}",
        "subscriptions_url": "https://api.github.com/users/bosens-China/subscriptions",
        "organizations_url": "https://api.github.com/users/bosens-China/orgs",
        "repos_url": "https://api.github.com/users/bosens-China/repos",
        "events_url": "https://api.github.com/users/bosens-China/events{/privacy}",
        "received_events_url": "https://api.github.com/users/bosens-China/received_events",
        "type": "User",
        "site_admin": false
      },
      "labels": [
        {
          "id": 1371686608,
          "node_id": "MDU6TGFiZWwxMzcxNjg2NjA4",
          "url": "https://api.github.com/repos/bosens-China/blog/labels/%E6%BC%AB%E8%B0%88%E7%B3%BB%E5%88%97",
          "name": "漫谈系列",
          "color": "e7f3ee",
          "default": false,
          "description": "浅谈类文章"
        }
      ],
      "state": "open",
      "locked": false,
      "assignee": null,
      "assignees": [],
      "milestone": null,
      "comments": 0,
      "created_at": "2019-11-14T01:35:53Z",
      "updated_at": "2021-12-21T09:48:35Z",
      "closed_at": null,
      "author_association": "OWNER",
      "active_lock_reason": null,
      "body": "> 这里不会介绍具体实现的方式，要根据公司的业务来进行调整，下面就聊一聊基本设计的思路。\r\n\r\n权限的设计对于一个后台来说至关重要，不过也要根据情况来选择，比如我们不会在一个博客或者个人网站的后台中写上权限控制，因为这是没有必要的，但是对于面向不同用户的产品来说就很有必要了，举个例子来说，滴滴打车的乘客和车主肯定是两个不同的用户产品，如何管理里面的数据就需要引用权限设计的功能了。\r\n\r\n权限设计可以帮助我们增加信息安全、保证页面的简洁不至于出现误操作的事情，下面就来说下基本的组成\r\n\r\n## 组成\r\n\r\n- 权限\r\n  ![](https://user-gold-cdn.xitu.io/2019/11/14/16e6786c0af135b6?w=1080&h=638&f=webp&s=9744)\r\n  权限这块可以分为页面权限、功能权限和数据权限，页面权限就是指是否能访问当前页面，功能权限对应的则是（增加、删除、修改等），而数据权限则是可以访问的数据范围。\r\n\r\n- 角色\r\n\r\n  在一个成熟的后台设计中必然要出现角色，这是为了避免每新增一个用户就还要重新为他勾选一遍权限，由角色赋值给用户权限，角色这层就相当于一个中间层，同时也方便维护。\r\n\r\n- 用户\r\n\r\n  每个用户对应一个账号，在默认状态下会给予用户一个最小的操作权限，权限的赋值由角色给予，多个角色的权限是可以叠加的。\r\n\r\n## 延伸\r\n\r\n上面介绍的其实就是`RBAC`模型的简单概念，在实际开发中觉得至少有以下几点需要注意：\r\n\r\n- admin\r\n\r\n在开发完成后需要在角色预留一个 admin 或者超级管理员，方便开发人员的维护\r\n\r\n- 权限的优先级\r\n\r\n上面介绍了权限的组成，但是页面的权限应当是大于操作的权限，只有页面的权限可见，功能的权限才是有意义的\r\n\r\n- tips\r\n\r\n无权限访问页面、页面不存在、服务器发生错误等方面的提示\r\n\r\n## 最后\r\n\r\n最后说一下前端对`tips`这块的处理\r\n403、404、500 的处理思路\r\n\r\n##### 500\r\n\r\n500 的处理可以通过`axions`的拦截器来实现，现在后端默认返回的基本格式都是\r\n\r\n```js\r\n{\r\n  // 状态码\r\n  status: 200,\r\n  data: {},\r\n  // ...\r\n  }\r\n```\r\n\r\n所以判断服务器发生错误，我们可以直接通过\r\n\r\n```js\r\n// 添加请求拦截器\r\naxios.interceptors.request.use(\r\n  function(config) {\r\n    // 在发送请求之前做些什么\r\n    return config;\r\n  },\r\n  function(error) {\r\n    // 对请求错误做些什么，这一步可以直接返回服务器发生错误，方便提示信息的定制\r\n    return Promise.reject(`服务器发生错误`);\r\n  }\r\n);\r\n```\r\n\r\n##### 404\r\n\r\n404 的实现可以通过`router`来实现，这里我用的是`vue router`就以这个举例，假设有一组路由为\r\n\r\n```js\r\nconst router = new VueRouter({\r\n  routes: [\r\n    {\r\n      path: \"/user\",\r\n      component: User,\r\n      children: [\r\n        {\r\n          path: \"profile\",\r\n          component: UserProfile\r\n        },\r\n        {\r\n          path: \"posts\",\r\n          component: UserPosts\r\n        }\r\n      ]\r\n    },\r\n    {\r\n      path: \"/sign\",\r\n      component: sign\r\n    }\r\n  ]\r\n});\r\n```\r\n\r\n那我们就通过递归将所有路由拼成一维数组（注意对比的条件，这里我对比的是 path 所以在递归过程中要将父 path 相加），具体的递归实现取决于你的常见，这里不做演示，之后对比访问的路径存不存在路由信息中，不存在则说明页面不存在返回`404`\r\n\r\n##### 403\r\n\r\n403 的实现需要配合后端来实现，一般情况下会请求用户的操作权限会返回当前用户权限所能操作的菜单，之后将能访问的菜单和路由信息对比，如果访问的路径在路由信息中但是不在用户返回的菜单说明没有页面访问的权限。\r\n\r\n最后说下为什么没有用`*`的原因，因为不太好定制，在默认状态下以`'/'`的形式访问我们要给予一个用户菜单的第一项，但是如果`'/'`不存在路由中我们还要写额外的判断，不如全部自己来自行处理了。\r\n\r\n## 参考\r\n\r\n1. [角色权限设计的 100 种解法](<https://mp.weixin.qq.com/s?__biz=MzI1ODY0NTg0MA==&mid=2247484799&idx=1&sn=5467e1452356e36607d938752805eb7d&chksm=ea044f40dd73c6563e72b1f34d0c27a23d06d5bcd80255568a9caa359ef2d03cd89713f0449b&scene=0&key=7fa4b6bcf3a05ff6a03f1d892329a3a1fcb4a9dd572857d0b82f72ec1386dfb5bd66a733158b657f4524063e1b5b4ade5442b1f23c89adbc9cfa818a68f64fbb4e725cc4baa55d048efe25d963e9e391&ascene=0&uin=MTAyMzI5NDA0Mw%3D%3D&devicetype=iMac+MacBookPro11%2C4+OSX+OSX+10.11.6+build(15G22010)&version=12020010&nettype=WIFI&lang=en&fontScale=100&pass_ticket=GR%2BJaO%2FEpgB4z%2BZuVHJsrM8QYhyiZAEBCQll6nnnN5CpbcQ%2FhZ5WoCr%2Fxr5QWiOL>)\r\n",
      "reactions": {
        "url": "https://api.github.com/repos/bosens-China/blog/issues/36/reactions",
        "total_count": 0,
        "+1": 0,
        "-1": 0,
        "laugh": 0,
        "hooray": 0,
        "confused": 0,
        "heart": 0,
        "rocket": 0,
        "eyes": 0
      },
      "timeline_url": "https://api.github.com/repos/bosens-China/blog/issues/36/timeline",
      "performed_via_github_app": null,
      "state_reason": null
    },
    {
      "url": "https://api.github.com/repos/bosens-China/blog/issues/42",
      "repository_url": "https://api.github.com/repos/bosens-China/blog",
      "labels_url": "https://api.github.com/repos/bosens-China/blog/issues/42/labels{/name}",
      "comments_url": "https://api.github.com/repos/bosens-China/blog/issues/42/comments",
      "events_url": "https://api.github.com/repos/bosens-China/blog/issues/42/events",
      "html_url": "https://github.com/bosens-China/blog/issues/42",
      "id": 542405907,
      "node_id": "MDU6SXNzdWU1NDI0MDU5MDc=",
      "number": 42,
      "title": "IntersectionObserver实现图片懒加载",
      "user": {
        "login": "bosens-China",
        "id": 39508895,
        "node_id": "MDQ6VXNlcjM5NTA4ODk1",
        "avatar_url": "https://avatars.githubusercontent.com/u/39508895?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bosens-China",
        "html_url": "https://github.com/bosens-China",
        "followers_url": "https://api.github.com/users/bosens-China/followers",
        "following_url": "https://api.github.com/users/bosens-China/following{/other_user}",
        "gists_url": "https://api.github.com/users/bosens-China/gists{/gist_id}",
        "starred_url": "https://api.github.com/users/bosens-China/starred{/owner}{/repo}",
        "subscriptions_url": "https://api.github.com/users/bosens-China/subscriptions",
        "organizations_url": "https://api.github.com/users/bosens-China/orgs",
        "repos_url": "https://api.github.com/users/bosens-China/repos",
        "events_url": "https://api.github.com/users/bosens-China/events{/privacy}",
        "received_events_url": "https://api.github.com/users/bosens-China/received_events",
        "type": "User",
        "site_admin": false
      },
      "labels": [
        {
          "id": 1580833992,
          "node_id": "MDU6TGFiZWwxNTgwODMzOTky",
          "url": "https://api.github.com/repos/bosens-China/blog/labels/%E5%AE%9E%E9%AA%8C%E6%80%A7%20API",
          "name": "实验性 API",
          "color": "7aa9d6",
          "default": false,
          "description": "还未定稿的API"
        }
      ],
      "state": "open",
      "locked": false,
      "assignee": null,
      "assignees": [],
      "milestone": null,
      "comments": 0,
      "created_at": "2019-12-26T01:53:33Z",
      "updated_at": "2021-12-21T09:48:12Z",
      "closed_at": null,
      "author_association": "OWNER",
      "active_lock_reason": null,
      "body": "> 传统的图片懒加载实现思路是判断图片的 top 区域是否小于父级区域，且自身高度加上 top 大于 0，\r\n> 例如\r\n\r\n```js\r\n// 元素是否可视\r\nconst viewVisible = el => {\r\n  const { top, width, height, left } = el.getBoundingClientRect();\r\n  const w = window.innerWidth || document.documentElement.clientWidth;\r\n  const h = window.innerHeight || document.documentElement.clientHeight;\r\n  return top < h && top + height >= 0 && left < w && left + width >= 0;\r\n};\r\n```\r\n\r\n> 不过这样写的话有一个问题就是我们监听的事件会重复多次触发，所以我们还需要写一个节流或者防抖函数，不过使用`IntersectionObserver`我们可以轻松实现，首先看下兼容性\r\n\r\n>![IntersectionObserver兼容性](https://user-images.githubusercontent.com/39508895/146864557-35c7c4d6-600c-4379-a433-1d38225500f5.png)可以看到差强人意，不过好在可以[polyfill](https://github.com/w3c/IntersectionObserver/tree/master/polyfill)，下面就介绍使用\r\n\r\n## 使用方法\r\n\r\n`IntersectionObserver`使用方法很简单\r\n\r\n```js\r\nvar observer = new IntersectionObserver(callback[, options]);\r\n```\r\n\r\n`callback`接收两个参数，一个 IntersectionObserverEntry 对象列表(list)，以及触发 IntersectionObserverEntry 的实例\r\n\r\n| 方法         | 说明                                           |\r\n| ------------ | ---------------------------------------------- |\r\n| disconnect() | 使 IntersectionObserver 对象停止监听工作。     |\r\n| observe()    | 使 IntersectionObserver 开始监听一个目标元素。 |\r\n| unobserve()  | 使 IntersectionObserver 停止监听特定目标元素。 |\r\n\r\n**注意**\r\n`callback`的回调函数会触发两次，第一次是元素开始可见，第二次是元素不可见的时候。\r\n\r\n## 选项(options)\r\n\r\n注意可选属性\r\n\r\n| 属性       | 说明                                                                                                                                                                                           |\r\n| ---------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\r\n| root       | 监听元素的祖先元素 Element 对象                                                                                                                                                                |\r\n| rootMargin | 一个在计算交叉值时添加至根的边界盒(bounding_box)中的一组偏移量，类型为字符串，可以有效的缩小或扩大根的判定范围从而满足计算需要。语法大致和 CSS 中的 margin 属性等同，默认值是\"0px 0px 0px 0px\" |\r\n| threshold  | 规定了一个监听目标与边界盒交叉区域的比例值，可以是一个具体的数值或是一组 0.0 到 1.0 之间的数组。若指定值为 0.0，则意味着监听元素即使与根有 1 像素交叉，此元素也会被视为可见.                   |\r\n\r\n## 实例\r\n\r\n```js\r\nconst dom = new IntersectionObserver(a => {\r\n  console.log(a);\r\n});\r\nArray.from(document.querySelectorAll(\"img\")).forEach(f => {\r\n  dom.observe(f);\r\n});\r\n```\r\n\r\n返回的 a 是一个数组，里面存放着一些元素信息，下面所有属性都是只读\r\n\r\n| 属性               | 说明                                                                                                                                                                                                                                |\r\n| ------------------ | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\r\n| boundingClientRect | 返回包含目标元素的边界信息的 DOMRectReadOnly. 边界的计算方式与 Element.getBoundingClientRect() 相同.                                                                                                                                |\r\n| intersectionRatio  | 返回 intersectionRect 与 boundingClientRect 的比例值,**如果大于 0 则表示可见，完全可见为 1**.                                                                                                                                       |\r\n| intersectionRect   | 返回一个 DOMRectReadOnly 用来描述根和目标元素的相交区域.                                                                                                                                                                            |\r\n| isIntersecting     | 返回一个布尔值, 如果目标元素与交叉区域观察者对象(intersection observer) 的根相交，则返回 true .如果返回 true, 则 IntersectionObserverEntry 描述了变换到交叉时的状态; 如果返回 false, 那么可以由此判断,变换是从交叉状态到非交叉状态. |\r\n| rootBounds         | 返回一个 DOMRectReadOnly 用来描述交叉区域观察者(intersection observer)中的根.                                                                                                                                                       |\r\n| target             | 与根出现相交区域改变的元素 (Element).                                                                                                                                                                                               |\r\n| time               | 返回一个记录从 IntersectionObserver 的时间原点(time origin)到交叉被触发的时间的时间戳(DOMHighResTimeStamp).                                                                                                                         |\r\n\r\n## 实现\r\n\r\n上面已经实现判断元素是否可见，下面我们只需要根据上面思路完善一下即可开发一个图片懒加载的类，首先先说明一下图片懒加载一般情况下为了防止图片`src`为空样式不统一和加载图片突然拉伸空间，会给默认的图片设置一个占位图片，或者给定一个样式\r\n\r\n```css\r\nimg {\r\n  width: 400px;\r\n  height: 400px;\r\n  display: inline-block;\r\n}\r\n```\r\n\r\n```html\r\n<img />\r\n```\r\n\r\n上面给了一个简单的演示，注意 `src` 属性不要写，因为即使为空也还会加载。 顺便说下火狐浏览器如果 img 标签没有其他属性的话会理解成内联元素，就是 span 标签一样的内联元素，所以如果不放置占位图片的话推荐重置 img 为 `inline-block` 然后设置固定宽高。\r\n\r\n之后就是给图片动态添加 src 属性，比较推荐的是`data-`的自定义属性，许多库用的也是这个方法，替换完成之后将图片元素从`IntersectionObserver`移除。\r\n\r\n## 最后\r\n\r\n`IntersectionObserver`使用的是异步的方式，可以不用担心性能问题\r\n\r\n- 参考\r\n  [IntersectionObserver MDN](https://developer.mozilla.org/zh-CN/docs/Web/API/IntersectionObserver/IntersectionObserver)\r\n",
      "reactions": {
        "url": "https://api.github.com/repos/bosens-China/blog/issues/42/reactions",
        "total_count": 0,
        "+1": 0,
        "-1": 0,
        "laugh": 0,
        "hooray": 0,
        "confused": 0,
        "heart": 0,
        "rocket": 0,
        "eyes": 0
      },
      "timeline_url": "https://api.github.com/repos/bosens-China/blog/issues/42/timeline",
      "performed_via_github_app": null,
      "state_reason": null
    },
    {
      "url": "https://api.github.com/repos/bosens-China/blog/issues/43",
      "repository_url": "https://api.github.com/repos/bosens-China/blog",
      "labels_url": "https://api.github.com/repos/bosens-China/blog/issues/43/labels{/name}",
      "comments_url": "https://api.github.com/repos/bosens-China/blog/issues/43/comments",
      "events_url": "https://api.github.com/repos/bosens-China/blog/issues/43/events",
      "html_url": "https://github.com/bosens-China/blog/issues/43",
      "id": 544505720,
      "node_id": "MDU6SXNzdWU1NDQ1MDU3MjA=",
      "number": 43,
      "title": "从form表单来看策略模式",
      "user": {
        "login": "bosens-China",
        "id": 39508895,
        "node_id": "MDQ6VXNlcjM5NTA4ODk1",
        "avatar_url": "https://avatars.githubusercontent.com/u/39508895?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bosens-China",
        "html_url": "https://github.com/bosens-China",
        "followers_url": "https://api.github.com/users/bosens-China/followers",
        "following_url": "https://api.github.com/users/bosens-China/following{/other_user}",
        "gists_url": "https://api.github.com/users/bosens-China/gists{/gist_id}",
        "starred_url": "https://api.github.com/users/bosens-China/starred{/owner}{/repo}",
        "subscriptions_url": "https://api.github.com/users/bosens-China/subscriptions",
        "organizations_url": "https://api.github.com/users/bosens-China/orgs",
        "repos_url": "https://api.github.com/users/bosens-China/repos",
        "events_url": "https://api.github.com/users/bosens-China/events{/privacy}",
        "received_events_url": "https://api.github.com/users/bosens-China/received_events",
        "type": "User",
        "site_admin": false
      },
      "labels": [
        {
          "id": 1740561541,
          "node_id": "MDU6TGFiZWwxNzQwNTYxNTQx",
          "url": "https://api.github.com/repos/bosens-China/blog/labels/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F",
          "name": "设计模式",
          "color": "d1a540",
          "default": false,
          "description": "设计模式在JavaScript的实现"
        }
      ],
      "state": "open",
      "locked": false,
      "assignee": null,
      "assignees": [],
      "milestone": null,
      "comments": 0,
      "created_at": "2020-01-02T09:36:08Z",
      "updated_at": "2021-12-21T09:47:57Z",
      "closed_at": null,
      "author_association": "OWNER",
      "active_lock_reason": null,
      "body": "### 前言\r\n\r\n之前写程序的时候为了快速开发写了许多`if`、`else if`的语句，当时开发倒是挺爽的，事后维护的时候想骂人，为了不坑自己和其他小伙伴，下面从零开始用一个基础表单 + 策略模式清除`if`分支语句\r\n\r\n```html\r\n<form class=\"cs-form\">\r\n  <label>\r\n    <span>账号：</span>\r\n    <input name=\"account\" type=\"text\" />\r\n  </label>\r\n  <label>\r\n    <span>密码：</span>\r\n    <input name=\"password\" type=\"password\" />\r\n  </label>\r\n  <label>\r\n    <span>手机号：</span>\r\n    <input name=\"mobile\" type=\"number\" />\r\n  </label>\r\n  <button class=\"submit\" type=\"submit\">登录</button>\r\n</form>\r\n```\r\n\r\n上面是一个很常见的表单元素，里面有账号和密码以及手机号，我们需要在提交之前对他进行一些校验，这里默认的规则是账号和密码不能为空，手机号的长度必须是 11 的纯数字。\r\n\r\n### 第一版\r\n\r\n```ts\r\ninterface Iform {\r\n  [k: string]: any;\r\n  account: HTMLInputElement;\r\n  password: HTMLInputElement;\r\n  mobile: HTMLInputElement;\r\n}\r\nconst form = document.querySelector(\".cs-form\") as HTMLFormElement;\r\n\r\nform.addEventListener(\"submit\", function(e) {\r\n  e.preventDefault();\r\n  const { account, password, mobile } = (form as unknown) as Iform;\r\n  if (!account.value) {\r\n    // 提示\r\n    alert(\"请输入账号\");\r\n    return false;\r\n  }\r\n  if (!password.value) {\r\n    // 提示\r\n    alert(\"请输入密码\");\r\n    return false;\r\n  }\r\n  if (!/\\d{11}/.test(mobile.value)) {\r\n    // 提示\r\n    alert(\"请输入正确的手机号\");\r\n    return false;\r\n  }\r\n  return false;\r\n});\r\n```\r\n\r\n根据上面的要求，我们实现了第一版代码，从代码的实现看毫无疑问是正确的，为了对比下面再用策略模式实现以下上述的功能\r\n\r\n### 第二版\r\n\r\n```ts\r\ninterface Iform {\r\n  [k: string]: any;\r\n  account: HTMLInputElement;\r\n  password: HTMLInputElement;\r\n  mobile: HTMLInputElement;\r\n}\r\n\r\ninterface Ilist {\r\n  value: string;\r\n  type: name;\r\n  msg: string;\r\n}\r\n\r\ntype name = keyof typeof rule;\r\nconst rule = {\r\n  account(value: string, msg: string) {\r\n    if (!value) {\r\n      return msg;\r\n    }\r\n  },\r\n  password(value: string, msg: string) {\r\n    if (!value) {\r\n      return msg;\r\n    }\r\n  },\r\n  mobile(value: string, msg: string) {\r\n    if (!/\\d{11}/.test(value)) {\r\n      return msg;\r\n    }\r\n  }\r\n};\r\nclass Verification {\r\n  private list: Ilist[] = [];\r\n  public message: string;\r\n  add<T extends { value: string }>(dom: T, type: name, msg: string) {\r\n    this.list.push({\r\n      value: dom.value,\r\n      type: type,\r\n      msg: msg\r\n    });\r\n  }\r\n  start(): boolean {\r\n    for (let i = 0; i < this.list.length; i++) {\r\n      const { value, type, msg } = this.list[i];\r\n      const fn = rule[type](value, msg);\r\n      if (fn) {\r\n        this.message = msg;\r\n        return false;\r\n      }\r\n    }\r\n    this.message = \"\";\r\n    return true;\r\n  }\r\n}\r\n\r\nconst form = document.querySelector(\".cs-form\") as HTMLFormElement;\r\n\r\nform.addEventListener(\"submit\", function(e) {\r\n  e.preventDefault();\r\n  const { account, password, mobile } = (form as unknown) as Iform;\r\n\r\n  const ruleSet = new Verification();\r\n  ruleSet.add(account, \"account\", \"请输入账号\");\r\n  ruleSet.add(password, \"password\", \"请输入密码\");\r\n  ruleSet.add(mobile, \"mobile\", \"请输入正确的手机号\");\r\n\r\n  if (!ruleSet.start()) {\r\n    // 提示\r\n    alert(ruleSet.message);\r\n    return false;\r\n  }\r\n  return false;\r\n});\r\n```\r\n\r\n从代码量看比第一版多出了很多语句，这里做法是把代码的规则放置在 rule 对象中，因为 javascript 本身就是这么灵活不需要在使用传统语言的 class 来实现了，剩下的就是新建一个校验类，新增校验规则最后校验，当然现在验证规则还是比较少，看不出策略模式的优点。\r\n\r\n下面再来新增一个要求，密码长度不能小于 6 位，在第一版中我们要紧接在密码不能为空的校验之后写，再来看下策略模式新增这个验证会新增哪些代码。\r\n\r\n```ts\r\ninterface Iform {\r\n  [k: string]: any;\r\n  account: HTMLInputElement;\r\n  password: HTMLInputElement;\r\n  mobile: HTMLInputElement;\r\n}\r\n\r\ninterface Ilist {\r\n  value: string;\r\n  type: name;\r\n  msg: string;\r\n}\r\n\r\ntype name = keyof typeof rule;\r\nconst rule = {\r\n  account(value: string, msg: string) {\r\n    if (!value) {\r\n      return msg;\r\n    }\r\n  },\r\n  password(value: string, msg: string) {\r\n    if (!value) {\r\n      return msg;\r\n    }\r\n  },\r\n  // 密码长度小于6的时候提示\r\n  passwordMinLength(value: string, msg: string) {\r\n    if (value.length < 6) {\r\n      return msg;\r\n    }\r\n  },\r\n  mobile(value: string, msg: string) {\r\n    if (!/\\d{11}/.test(value)) {\r\n      return msg;\r\n    }\r\n  }\r\n};\r\nclass Verification {\r\n  private list: Ilist[] = [];\r\n  public message: string;\r\n  add<T extends { value: string }>(dom: T, type: name, msg: string) {\r\n    this.list.push({\r\n      value: dom.value,\r\n      type: type,\r\n      msg: msg\r\n    });\r\n  }\r\n  start(): boolean {\r\n    for (let i = 0; i < this.list.length; i++) {\r\n      const { value, type, msg } = this.list[i];\r\n      const fn = rule[type](value, msg);\r\n      if (fn) {\r\n        this.message = msg;\r\n        return false;\r\n      }\r\n    }\r\n    this.message = \"\";\r\n    return true;\r\n  }\r\n}\r\n\r\nconst form = document.querySelector(\".cs-form\") as HTMLFormElement;\r\n\r\nform.addEventListener(\"submit\", function(e) {\r\n  e.preventDefault();\r\n  const { account, password, mobile } = (form as unknown) as Iform;\r\n\r\n  const ruleSet = new Verification();\r\n  ruleSet.add(account, \"account\", \"请输入账号\");\r\n  ruleSet.add(password, \"password\", \"请输入密码\");\r\n  ruleSet.add(password, \"passwordMinLength\", \"密码长度不符合要求\");\r\n  ruleSet.add(mobile, \"mobile\", \"请输入正确的手机号\");\r\n\r\n  if (!ruleSet.start()) {\r\n    // 提示\r\n    alert(ruleSet.message);\r\n    return false;\r\n  }\r\n  return false;\r\n});\r\n```\r\n\r\n把密码不能小于六位的规则添加到`rule`中，之后 add 的时候添加它，这里基本的校验其实就完成了，不过从上面看，我们的校验肯定不是一个 input 就对应一条，实际上会存在多种校验，比如最小长度最大长度，不能包含敏感词等，添加多条规则也是很合理的要求，下面就是最终版的实现。\r\n\r\n### 最终版\r\n\r\n```ts\r\ninterface Iform {\r\n  [k: string]: any;\r\n  account: HTMLInputElement;\r\n  password: HTMLInputElement;\r\n  mobile: HTMLInputElement;\r\n}\r\n\r\ninterface Ilist {\r\n  value: string;\r\n  type: name;\r\n  msg: string;\r\n}\r\ninterface Iadd {\r\n  type: name;\r\n  msg: string;\r\n}\r\n\r\ntype name = keyof typeof rule;\r\nconst rule = {\r\n  require(value: string, msg: string) {\r\n    if (!value) {\r\n      return msg;\r\n    }\r\n  },\r\n  minLength(value: string, msg: string) {\r\n    if (value.length < 6) {\r\n      return msg;\r\n    }\r\n  },\r\n  mobile(value: string, msg: string) {\r\n    if (!/\\d{11}/.test(value)) {\r\n      return msg;\r\n    }\r\n  }\r\n};\r\nclass Verification {\r\n  private list: Ilist[] = [];\r\n  public message: string;\r\n  // 用函数重载的形式实现\r\n  add<T extends { value: string }>(dom: T, type: name, msg: string): void;\r\n  add<T extends { value: string }>(dom: T, ruleArr: Array<Iadd>): void;\r\n  add<T extends { value: string }>(\r\n    dom: T,\r\n    ruleArr: Array<Iadd> | name,\r\n    msg?: string\r\n  ): void {\r\n    if (Array.isArray(ruleArr)) {\r\n      this.list.push(\r\n        ...ruleArr.map(f => {\r\n          return {\r\n            value: dom.value,\r\n            type: f.type,\r\n            msg: f.msg\r\n          };\r\n        })\r\n      );\r\n    } else {\r\n      this.list.push({\r\n        value: dom.value,\r\n        type: ruleArr,\r\n        msg: msg\r\n      });\r\n    }\r\n  }\r\n  start(): boolean {\r\n    for (let i = 0; i < this.list.length; i++) {\r\n      const { value, type, msg } = this.list[i];\r\n      const fn = rule[type](value, msg);\r\n      if (fn) {\r\n        this.message = msg;\r\n        return false;\r\n      }\r\n    }\r\n    this.message = \"\";\r\n    return true;\r\n  }\r\n}\r\n\r\nconst form = document.querySelector(\".cs-form\") as HTMLFormElement;\r\n\r\nform.addEventListener(\"submit\", function(e) {\r\n  e.preventDefault();\r\n  const { account, password, mobile } = (form as unknown) as Iform;\r\n\r\n  const ruleSet = new Verification();\r\n  ruleSet.add(account, \"require\", \"请输入账号\");\r\n  ruleSet.add(password, [\r\n    {\r\n      type: \"require\",\r\n      msg: \"请输入密码\"\r\n    },\r\n    {\r\n      type: \"minLength\",\r\n      msg: \"密码长度不符合要求\"\r\n    }\r\n  ]);\r\n  ruleSet.add(mobile, [\r\n    {\r\n      type: \"require\",\r\n      msg: \"请输入手机号\"\r\n    },\r\n    {\r\n      type: \"mobile\",\r\n      msg: \"请输入正确的手机号\"\r\n    }\r\n  ]);\r\n\r\n  if (!ruleSet.start()) {\r\n    // 提示\r\n    alert(ruleSet.message);\r\n    return false;\r\n  }\r\n  return false;\r\n});\r\n```\r\n\r\n撒花，这里就已经写完了，整体来看代码量还是蛮多的，主要是用 ts 写需要定义各种接口和类型，最终版本的时候我将上述的手机和账号的验证抽离成 require 函数，后续如果有用到只需要在 `rule` 规则中新增即可。\r\n\r\n当然因为只是讲解策略模式的使用所以这里并没有对这个校验更完整的定义，如果有进一步需要可以将 min 和 max 属性以及 regexp 属性新增上，进一步提高校验的规则\r\n",
      "reactions": {
        "url": "https://api.github.com/repos/bosens-China/blog/issues/43/reactions",
        "total_count": 0,
        "+1": 0,
        "-1": 0,
        "laugh": 0,
        "hooray": 0,
        "confused": 0,
        "heart": 0,
        "rocket": 0,
        "eyes": 0
      },
      "timeline_url": "https://api.github.com/repos/bosens-China/blog/issues/43/timeline",
      "performed_via_github_app": null,
      "state_reason": null
    },
    {
      "url": "https://api.github.com/repos/bosens-China/blog/issues/48",
      "repository_url": "https://api.github.com/repos/bosens-China/blog",
      "labels_url": "https://api.github.com/repos/bosens-China/blog/issues/48/labels{/name}",
      "comments_url": "https://api.github.com/repos/bosens-China/blog/issues/48/comments",
      "events_url": "https://api.github.com/repos/bosens-China/blog/issues/48/events",
      "html_url": "https://github.com/bosens-China/blog/issues/48",
      "id": 548738832,
      "node_id": "MDU6SXNzdWU1NDg3Mzg4MzI=",
      "number": 48,
      "title": "优雅处理图片异常",
      "user": {
        "login": "bosens-China",
        "id": 39508895,
        "node_id": "MDQ6VXNlcjM5NTA4ODk1",
        "avatar_url": "https://avatars.githubusercontent.com/u/39508895?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bosens-China",
        "html_url": "https://github.com/bosens-China",
        "followers_url": "https://api.github.com/users/bosens-China/followers",
        "following_url": "https://api.github.com/users/bosens-China/following{/other_user}",
        "gists_url": "https://api.github.com/users/bosens-China/gists{/gist_id}",
        "starred_url": "https://api.github.com/users/bosens-China/starred{/owner}{/repo}",
        "subscriptions_url": "https://api.github.com/users/bosens-China/subscriptions",
        "organizations_url": "https://api.github.com/users/bosens-China/orgs",
        "repos_url": "https://api.github.com/users/bosens-China/repos",
        "events_url": "https://api.github.com/users/bosens-China/events{/privacy}",
        "received_events_url": "https://api.github.com/users/bosens-China/received_events",
        "type": "User",
        "site_admin": false
      },
      "labels": [
        {
          "id": 1371686609,
          "node_id": "MDU6TGFiZWwxMzcxNjg2NjA5",
          "url": "https://api.github.com/repos/bosens-China/blog/labels/JavaScript",
          "name": "JavaScript",
          "color": "F7DF1E",
          "default": false,
          "description": "JavaScript系列的文章"
        }
      ],
      "state": "open",
      "locked": false,
      "assignee": null,
      "assignees": [],
      "milestone": null,
      "comments": 0,
      "created_at": "2020-01-13T06:54:18Z",
      "updated_at": "2021-12-21T09:47:37Z",
      "closed_at": null,
      "author_association": "OWNER",
      "active_lock_reason": null,
      "body": "## 前言\r\n\r\n不同浏览器对加载失败图片的图标展示不统一，所以给定一个默认的失败图片就尤为重要。\r\n\r\n正好前几天处理了一下公司首页图片 error 默认图片的问题，就趁着记忆没有消失分享一下这篇文章。\r\n\r\n## error\r\n\r\nimg 标签有一个 error 事件，通过它我们可以捕捉到异常，使用起来也很简单\r\n\r\n```html\r\n<img src=\"abc.xxx\" alt=\"xxx\" class=\"cs-img\" />\r\n```\r\n\r\n```js\r\n<img src=\"abc.xxx\" alt=\"xxx\" class=\"cs-img\" onerror=\"this.src = 'xxxx.png'\" />;\r\n// 或者\r\nvar img = document.querySelector(\".cs-img\");\r\nimg.addEventListener(\"error\", function(e) {\r\n  e.target.src = \"xxxx.png\";\r\n});\r\n```\r\n\r\n## 全局\r\n\r\n上面的方法没有问题，不过需要我们手动管理图片这样写的话维护成本可能很高，有可能你只是想为图片失败统一处理。\r\n\r\n我们希望可以统一监听到`error`的事件来完成，不过图片的`error`处于事件模型的第二阶段也就是目标阶段，是不会向上冒泡的，但是也是可以通过`window.addEventListener.error`来完成监听。\r\n\r\n> 顺便说下`window.addEventListener.error`不仅可以监听到图片的失败也可以监听到 `css,js` 之类加载错误，注意区分`window.onerror`和`window.addEventListener.error`之间的区别，前者是 js 运行错误，后者是资源错误，对于事件模型网上的例子很多，这里不做展开来说了。\r\n\r\n来看下如何用\r\n\r\n```js\r\nwindow.addEventListener(\r\n  \"error\",\r\n  function(event) {\r\n    var dom = event.target;\r\n    if (/img/i.test(dom.nodeName)) {\r\n      dom.src = \"xxxx.png\";\r\n    }\r\n  },\r\n  true\r\n);\r\n```\r\n\r\n注意 `addEventListener` 第二个参数必须是 `true`，默认为 `false`，表示只在冒泡阶段出发，但是上面我们说过图片的 error 事件并不会向上冒泡所以是不会捕捉到的。\r\n\r\n## 重试次数\r\n\r\n上面的代码没有考虑到备选`src`也会失效的问题，如果备选`src`失效就会导致图片无限重试，下面就抛砖引玉写一种方法。\r\n\r\n```js\r\nwindow.addEventListener(\r\n  \"error\",\r\n  function(event) {\r\n    var dom = event.target;\r\n    if (!/img/i.test(dom.nodeName)) {\r\n      return;\r\n    }\r\n    // 不存在返回null\r\n    var retry = +dom.getAttribute(\"data-retry\");\r\n    if (retry >= 3) {\r\n      // 绝对安全的图片\r\n      dom.src =\r\n        \"data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7\";\r\n    } else {\r\n      dom.src = \"xxxx.png\";\r\n      dom.setAttribute(\"data-retry\", (retry += 1));\r\n    }\r\n  },\r\n  true\r\n);\r\n```\r\n\r\n## 动态填充\r\n\r\n最后分享一个动态模板渲染出来的网页(例如，网页的内容是从后台的编辑器 html 直接插入的)如何监听`error`，如果不考虑兼容问题可以在`head`使用`window.addEventListener.error`方法，但是如果需要兼容性很高不妨试试下面这种。\r\n\r\n```js\r\nconst img = Array.prototype.slice.call(document.images);\r\nfor (let i = 0; i < img.length; i++) {\r\n  var dom = img[i];\r\n  const image = document.createElement(\"img\");\r\n  image.src = dom.src;\r\n  image.style.display = \"none\";\r\n  document.body.appendChild(image);\r\n  image.onerror = function(event) {\r\n    dom.src = \"xxxx.png\";\r\n    document.body.removeChild(image);\r\n  };\r\n  image.onload = function() {\r\n    document.body.removeChild(image);\r\n  };\r\n}\r\n```\r\n\r\n上面我们说了假设内容是直接通过 html 代码插入的，我们可能监听不到图片的默认错误事件，那么我们可以在网页加载完成之后重试一遍所有的 img，在为 img 指定一次错误事件就 OK 了。\r\n\r\n## 最后\r\n\r\n为了方便演示，上面的代码我都没有做兼容性的补充，但是在实际生产中上面代码需要`polyfill`尤其是 dom 的一些语法，推荐简单一些的做法可以把上面的例子转化为 jquery 的语法。\r\n",
      "reactions": {
        "url": "https://api.github.com/repos/bosens-China/blog/issues/48/reactions",
        "total_count": 0,
        "+1": 0,
        "-1": 0,
        "laugh": 0,
        "hooray": 0,
        "confused": 0,
        "heart": 0,
        "rocket": 0,
        "eyes": 0
      },
      "timeline_url": "https://api.github.com/repos/bosens-China/blog/issues/48/timeline",
      "performed_via_github_app": null,
      "state_reason": null
    },
    {
      "url": "https://api.github.com/repos/bosens-China/blog/issues/41",
      "repository_url": "https://api.github.com/repos/bosens-China/blog",
      "labels_url": "https://api.github.com/repos/bosens-China/blog/issues/41/labels{/name}",
      "comments_url": "https://api.github.com/repos/bosens-China/blog/issues/41/comments",
      "events_url": "https://api.github.com/repos/bosens-China/blog/issues/41/events",
      "html_url": "https://github.com/bosens-China/blog/issues/41",
      "id": 539716296,
      "node_id": "MDU6SXNzdWU1Mzk3MTYyOTY=",
      "number": 41,
      "title": "VuePress插件开发不完全指南",
      "user": {
        "login": "bosens-China",
        "id": 39508895,
        "node_id": "MDQ6VXNlcjM5NTA4ODk1",
        "avatar_url": "https://avatars.githubusercontent.com/u/39508895?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bosens-China",
        "html_url": "https://github.com/bosens-China",
        "followers_url": "https://api.github.com/users/bosens-China/followers",
        "following_url": "https://api.github.com/users/bosens-China/following{/other_user}",
        "gists_url": "https://api.github.com/users/bosens-China/gists{/gist_id}",
        "starred_url": "https://api.github.com/users/bosens-China/starred{/owner}{/repo}",
        "subscriptions_url": "https://api.github.com/users/bosens-China/subscriptions",
        "organizations_url": "https://api.github.com/users/bosens-China/orgs",
        "repos_url": "https://api.github.com/users/bosens-China/repos",
        "events_url": "https://api.github.com/users/bosens-China/events{/privacy}",
        "received_events_url": "https://api.github.com/users/bosens-China/received_events",
        "type": "User",
        "site_admin": false
      },
      "labels": [
        {
          "id": 1473940161,
          "node_id": "MDU6TGFiZWwxNDczOTQwMTYx",
          "url": "https://api.github.com/repos/bosens-China/blog/labels/%E6%A1%86%E6%9E%B6%E7%9B%B8%E5%85%B3",
          "name": "框架相关",
          "color": "42b883",
          "default": false,
          "description": "目前Vue和React为主"
        }
      ],
      "state": "open",
      "locked": false,
      "assignee": null,
      "assignees": [],
      "milestone": null,
      "comments": 0,
      "created_at": "2019-12-18T14:30:58Z",
      "updated_at": "2021-12-21T09:47:25Z",
      "closed_at": null,
      "author_association": "OWNER",
      "active_lock_reason": null,
      "body": "最近用 `vuepress` 把社区的 typeScript 翻译文章打包成了一个[在线文档](https://bosens-china.github.io/Typescript-manual/dist/)，不过有一些插件社区没有或者实现的不符合自己定制需求，所以决定自定义实现一个，这篇文化以掘金`复制代码`功能为例子。\r\n先看一下开发完成的界面\r\n\r\n![1](https://user-images.githubusercontent.com/39508895/71094442-f3384500-21e5-11ea-91b5-a0de07c72903.png)\r\n\r\n\r\n先看一下官方给出的架构图\r\n![](https://user-gold-cdn.xitu.io/2019/12/18/16f195bad0aeb2f4?w=1774&h=2334&f=png&s=65238)\r\n是不是感觉有点头疼，这里记不住没有关系，我们只需要知道**插件是在 node 环境下运行**，所以我们插件的返回形式必须是`CommonJS`形式。\r\n\r\n与 vue 类似，`vuepress`也有生命周期\r\n\r\n- ready\r\n\r\n可以简单理解为初始化完成调用\r\n\r\n- updated\r\n\r\n页面更新调用\r\n\r\n- generated\r\n\r\n生产环境构建完成调用\r\n\r\n### 实现思路\r\n\r\n因为`vuepress`会将 md 文件打包成多份 html 文件，所以在每次文件地址变更的时候我们都需要知道这个变更之后更新我们的组件，根据上面的生命周期可以在`updated`实现我们的需求\r\n\r\n至于如何将复制粘贴的组件插入到指定的`code`中，我们可以在页面加载完成后，搜索所有的指定节点，之后通过`appendChild`将组件插入\r\n\r\n### 项目结构\r\n\r\n```sh\r\ncopy\r\n├─ clientRootMixin.js\r\n├─ clipboard.js\r\n├─ copy.vue\r\n└─ index.js\r\n```\r\n\r\n- index.js\r\n\r\n暴露的出口文件\r\n\r\n- copy.vue\r\n\r\n具体实现复制代码组件\r\n\r\n- clipboard.js\r\n\r\n负责实现置剪切板文本\r\n\r\n- clientRootMixin.js\r\n\r\n负责实现将组件插入到不同的页面之中\r\n\r\n### index.js\r\n\r\n上面说了我们要开发一个复制代码的插件，我们就先按照简单的做法定义三个参数\r\n\r\n- 第一个是选择器的范围\r\n- 第二个是复制代码显示的文本\r\n- 第三个则是回调函数，负责接收变更消息，实现自定义的动画效果\r\n\r\n在官方给出的例子，有两种方式使用插件\r\n\r\n```js\r\n// 例1\r\nmodule.exports = {\r\n  plugins: [\r\n    [\r\n      \"vuepress-plugin-xxx\",\r\n      {\r\n        /* options */\r\n      }\r\n    ]\r\n  ]\r\n};\r\n// 例2\r\nmodule.exports = {\r\n  plugins: {\r\n    xxx: {\r\n      /* options */\r\n    }\r\n  }\r\n};\r\n```\r\n\r\n可以看到，如果有参数的话可以这样传递，那么我们定义的插件第一步就是要处理这个参数，当然也可以不接受，如果不接受直接返回一个对象就可以了\r\n\r\n```js\r\nmodule.exports = {\r\n  // ...\r\n};\r\n```\r\n\r\n下面来定义一个简单接受`options`的函数\r\n\r\n```js\r\n// 对象式\r\n\r\nmodule.exports = {\r\n  define: {\r\n    selector: options.selector || 'div[class*=\"language-\"] pre',\r\n    copyText: options.copyText || \"复制代码\",\r\n    change: options.change\r\n  }\r\n};\r\n// 函数式:\r\nmodule.exports = (options, context) => ({\r\n  define() {\r\n    return {\r\n      selector: options.selector || 'div[class*=\"language-\"] pre',\r\n      copyText: options.copyText || \"复制代码\",\r\n      change: options.change\r\n    };\r\n  }\r\n});\r\n```\r\n\r\n注意必须返回是`CommonJS`形式，上面我们通过`define`属性来定义供我们插件内部使用的全局变量，他支持函数和对象两种形式，可以理解为 vue 的 data 属性\r\n\r\n这一步比较简单，就不做其他过多说明了，上面我们提到了需要将组件注入到所有页面中，这一步是`clientRootMixin.js`所需要负责的事情，下面就是实现它，我们需要在`index.js`引入它，一个完整的`index.js`看起来应该是这样\r\n\r\n```js\r\nconst path = require(\"path\");\r\n\r\nmodule.exports = (options = {}, ctx) => ({\r\n  define: {\r\n    // ...\r\n  },\r\n  clientRootMixin: path.resolve(__dirname, \"clientRootMixin.js\")\r\n});\r\n```\r\n\r\n### clientRootMixin.js\r\n\r\n`clientRootMixin` 可以让我们控制根文组件的生命周期，这里我们只需要监听`updated`事件，之后把`copy.vue`插入到当前页面内即可\r\n\r\n```js\r\nimport CodeCopy from \"./copy.vue\";\r\nimport Vue from \"vue\";\r\n\r\nexport default {\r\n  updated() {\r\n    // 等待dom加载完成之后执行\r\n    this.$nextTick(() => {\r\n      this.update();\r\n    });\r\n  },\r\n  methods: {\r\n    update() {\r\n      // 获取所有的dom，之后在所有的代码块上插入vue的组件\r\n      const dom = Array.from(document.querySelectorAll(selector));\r\n      dom.forEach(el => {\r\n        // 判断一下，当前节点是不是已经插入了\r\n        if (/v-copy/.test(el.className)) {\r\n          return;\r\n        }\r\n        // 创建copy组件\r\n        const C = Vue.extend(CodeCopy);\r\n        const copy = new C();\r\n        // 下面这些是组件的props以及一些私有属性\r\n        copy.copyText = copyText;\r\n        copy.code = el.textContent;\r\n        copy._parent = el;\r\n        copy.$mount();\r\n        el.className += ` v- copy`;\r\n        el.appendChild(copy.$el);\r\n      });\r\n    }\r\n  }\r\n};\r\n```\r\n\r\nOK，到这一步也完成了，下面就是怎么把代码置入剪切板了\r\n\r\n### clipboard.js\r\n\r\n- navigator.clipboard\r\n  支持异步剪贴板\r\n- document.execCommand()\r\n  兼容性比较好一些，但是只能同步剪贴板\r\n\r\n上面是两种原生的方式，不过这里因为是作为库使用，需要考虑兼容性问题，所以我选择了已经封装好的`clipboard.js`作为实现复制粘贴，下面是具体的封装方法，这一步可以跳过\r\n\r\n```js\r\nimport ClipboardJS from \"clipboard\";\r\n// 封装的剪切板事件\r\nconst btn = document.createElement(\"div\");\r\nbtn.style.display = \"none\";\r\ndocument.body.appendChild(btn);\r\n\r\nfunction setUpText(text = \"\") {\r\n  return new Promise((resolve, reject) => {\r\n    const cli = new ClipboardJS(btn, {\r\n      text() {\r\n        return text;\r\n      }\r\n    });\r\n    // 触发点击事件\\\r\n    const click = new Event(\"click\");\r\n    cli.on(\"success\", function() {\r\n      resolve(text);\r\n      // 无论成功与否都删除\r\n      cli.destroy();\r\n    });\r\n\r\n    cli.on(\"error\", function(e) {\r\n      reject(e.action);\r\n      // 无论成功与否都删除\r\n      cli.destroy();\r\n    });\r\n    btn.dispatchEvent(click);\r\n  });\r\n}\r\n\r\nexport default setUpText;\r\n```\r\n\r\nOK，到这一步基本上就完成了准备工作，下面就回归我们熟悉的 vue 组件开发了\r\n\r\n### copy.vue\r\n\r\n这一步比较简单，就是定义一些 css 属性点击按钮的时候执行`clipboard.js`就行了\r\n\r\n```vue\r\n<template>\r\n  <span>\r\n    <span ref=\"btn\" class=\"v-copy-code-btn\" @click=\"copyClick\">{{\r\n      copyText\r\n    }}</span>\r\n  </span>\r\n</template>\r\n\r\n<script>\r\nimport clipboard from \"./clipboard\";\r\nexport default {\r\n  props: {\r\n    copyText: {\r\n      type: String,\r\n      default: \"复制代码\"\r\n    },\r\n    code: String\r\n  },\r\n  methods: {\r\n    copyClick() {\r\n      clipboard(this.code);\r\n      // 执行复制具体实现省略\r\n    }\r\n  }\r\n};\r\n</script>\r\n\r\n<style>\r\n<!-- 省略 -->\r\n</style>\r\n```\r\n\r\n### 最后\r\n\r\n撒花，完成这一步之后就是将代码发布到 npm 上供大家使用，这个过程就不再描述了。\r\n\r\n最后本人目前准备找工作，有小伙伴内推一下么，不胜感激\r\n",
      "reactions": {
        "url": "https://api.github.com/repos/bosens-China/blog/issues/41/reactions",
        "total_count": 0,
        "+1": 0,
        "-1": 0,
        "laugh": 0,
        "hooray": 0,
        "confused": 0,
        "heart": 0,
        "rocket": 0,
        "eyes": 0
      },
      "timeline_url": "https://api.github.com/repos/bosens-China/blog/issues/41/timeline",
      "performed_via_github_app": null,
      "state_reason": null
    },
    {
      "url": "https://api.github.com/repos/bosens-China/blog/issues/34",
      "repository_url": "https://api.github.com/repos/bosens-China/blog",
      "labels_url": "https://api.github.com/repos/bosens-China/blog/issues/34/labels{/name}",
      "comments_url": "https://api.github.com/repos/bosens-China/blog/issues/34/comments",
      "events_url": "https://api.github.com/repos/bosens-China/blog/issues/34/events",
      "html_url": "https://github.com/bosens-China/blog/issues/34",
      "id": 512000452,
      "node_id": "MDU6SXNzdWU1MTIwMDA0NTI=",
      "number": 34,
      "title": "选择器那些事",
      "user": {
        "login": "bosens-China",
        "id": 39508895,
        "node_id": "MDQ6VXNlcjM5NTA4ODk1",
        "avatar_url": "https://avatars.githubusercontent.com/u/39508895?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bosens-China",
        "html_url": "https://github.com/bosens-China",
        "followers_url": "https://api.github.com/users/bosens-China/followers",
        "following_url": "https://api.github.com/users/bosens-China/following{/other_user}",
        "gists_url": "https://api.github.com/users/bosens-China/gists{/gist_id}",
        "starred_url": "https://api.github.com/users/bosens-China/starred{/owner}{/repo}",
        "subscriptions_url": "https://api.github.com/users/bosens-China/subscriptions",
        "organizations_url": "https://api.github.com/users/bosens-China/orgs",
        "repos_url": "https://api.github.com/users/bosens-China/repos",
        "events_url": "https://api.github.com/users/bosens-China/events{/privacy}",
        "received_events_url": "https://api.github.com/users/bosens-China/received_events",
        "type": "User",
        "site_admin": false
      },
      "labels": [
        {
          "id": 1371686610,
          "node_id": "MDU6TGFiZWwxMzcxNjg2NjEw",
          "url": "https://api.github.com/repos/bosens-China/blog/labels/css%20%E7%9B%B8%E5%85%B3",
          "name": "css 相关",
          "color": "42b883",
          "default": false,
          "description": "css 技巧和基础为主"
        }
      ],
      "state": "open",
      "locked": false,
      "assignee": null,
      "assignees": [],
      "milestone": null,
      "comments": 0,
      "created_at": "2019-10-24T14:56:12Z",
      "updated_at": "2021-12-21T09:47:07Z",
      "closed_at": null,
      "author_association": "OWNER",
      "active_lock_reason": null,
      "body": "> 失踪人口冒个泡\r\n\r\n## 优先级\r\n\r\n入门学习的时候一定就听说过这些概念，在菜鸟教程之类的网站上也肯定学习过，比如类的优先级为 10、标签的优先级为 1，这些都是辅助我们记忆的，下面就来说一说容易出错的点。\r\n\r\n```css\r\n.top {\r\n  margin: 10px;\r\n}\r\n[class] {\r\n  margin: 20px;\r\n}\r\n```\r\n\r\n这里输出的`margin`为多少？\r\n\r\n答案是`20px`，对于类和属性选择器以及伪类优先级是一致的，当然这个例子只是帮你温习的，再来看一个\r\n\r\n```css\r\n/*第一条*/\r\nbody [class] {\r\n  color: #666;\r\n}\r\n/*第二条*/\r\nhtml:not([dir]) {\r\n  color: red;\r\n}\r\n```\r\n\r\n这里两条属性的优先级相等么？\r\n\r\n答案是相等的，对于`:not`这样的逻辑组合伪类影响优先级的是里面的元素，上面第一条是一个标签加上属性选择器优先级为 11，第二条 html 标签加上属性选择器优先级也是 11。\r\n\r\n## 渲染顺序\r\n\r\n上面举了一个例子最终颜色生效为`red`，这是因为后来居上的原则，不过注意这个后来居上说的是整体文档而言。\r\n\r\n```html\r\n<link rel=\"stylesheet\" href=\"a.css\" /> <link rel=\"stylesheet\" href=\"b.css\" />\r\n```\r\n\r\na.css\r\n\r\n```css\r\nbody .foo {\r\n  color: red;\r\n}\r\n```\r\n\r\nb.css\r\n\r\n```css\r\nhtml .foo {\r\n  color: #666;\r\n}\r\n```\r\n\r\n最终`color`的值为`#666`，同时还提醒一下 css 最终生效并不是看元素的距离的远近，而是根据优先级和位置，比如上面的 body 肯定比 html 离得近，但是因为后来居上所以并没有生效。\r\n\r\n## 选择器是否能跨级？\r\n\r\n在开头说了方便记忆我们会给类和标签之类的优先级添加上数字，但是如果你想用数量多就覆盖高一层级的是不可能的\r\n\r\n```css\r\n.a {\r\n  color: red;\r\n}\r\na,\r\na,\r\na,\r\na,\r\na,\r\na,\r\na,\r\na,\r\na,\r\na,\r\na,\r\na,\r\na,\r\na,\r\na,\r\na,\r\na,\r\na {\r\n  color: #666;\r\n}\r\n```\r\n\r\n输出结果还是红色。\r\n\r\n## 增加优先级\r\n\r\n传统添加优先级我们可能会通过给标签添加 id 或者继续嵌套来实现，不过这样做肯定不合适因为后面在想修改可能就需要使用`style`或者`important`了，下面就说下两个小技巧\r\n\r\n1. 使用属性选择器\r\n\r\n```css\r\n.a[class] {\r\n  color: red;\r\n}\r\n.a {\r\n  color: #666;\r\n}\r\n```\r\n\r\n2. 嵌套选择自己\r\n\r\n```css\r\n.a.a {\r\n  color: red;\r\n}\r\n.a {\r\n  color: #666;\r\n}\r\n```\r\n\r\n## 匹配顺序\r\n\r\n说一点新手噩梦，css 的匹配顺序是从右往左，所以嵌套太多层的 css 语句就不要在写了，一般而言 id 选择器和类选择器的解析最快，标签选择器的速度很慢，所以在项目中不要嵌入太多的标签选择器有利于项目的优化。\r\n\r\n## 是否区分大小写\r\n\r\n说这个首先要说一下 html 是否区分大小写，html 对于标签和属性是不区分大小写的，而对属性值则是区分的，css 与 html 保持一致\r\n\r\n```html\r\n<style>\r\n  p {\r\n    color: #666;\r\n  }\r\n  [CLASS] {\r\n    color: red;\r\n  }\r\n  .foo {\r\n    color: white;\r\n  }\r\n</style>\r\n<p class=\"FOO\">hello wrold</p>\r\n```\r\n\r\n这里 p 的 `color` 为 `red`，说明了标签和属性选择器不区分大小写，而对于 class 则是区分的。\r\n",
      "reactions": {
        "url": "https://api.github.com/repos/bosens-China/blog/issues/34/reactions",
        "total_count": 0,
        "+1": 0,
        "-1": 0,
        "laugh": 0,
        "hooray": 0,
        "confused": 0,
        "heart": 0,
        "rocket": 0,
        "eyes": 0
      },
      "timeline_url": "https://api.github.com/repos/bosens-China/blog/issues/34/timeline",
      "performed_via_github_app": null,
      "state_reason": null
    },
    {
      "url": "https://api.github.com/repos/bosens-China/blog/issues/29",
      "repository_url": "https://api.github.com/repos/bosens-China/blog",
      "labels_url": "https://api.github.com/repos/bosens-China/blog/issues/29/labels{/name}",
      "comments_url": "https://api.github.com/repos/bosens-China/blog/issues/29/comments",
      "events_url": "https://api.github.com/repos/bosens-China/blog/issues/29/events",
      "html_url": "https://github.com/bosens-China/blog/issues/29",
      "id": 499886565,
      "node_id": "MDU6SXNzdWU0OTk4ODY1NjU=",
      "number": 29,
      "title": "jsonp实现原理",
      "user": {
        "login": "bosens-China",
        "id": 39508895,
        "node_id": "MDQ6VXNlcjM5NTA4ODk1",
        "avatar_url": "https://avatars.githubusercontent.com/u/39508895?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bosens-China",
        "html_url": "https://github.com/bosens-China",
        "followers_url": "https://api.github.com/users/bosens-China/followers",
        "following_url": "https://api.github.com/users/bosens-China/following{/other_user}",
        "gists_url": "https://api.github.com/users/bosens-China/gists{/gist_id}",
        "starred_url": "https://api.github.com/users/bosens-China/starred{/owner}{/repo}",
        "subscriptions_url": "https://api.github.com/users/bosens-China/subscriptions",
        "organizations_url": "https://api.github.com/users/bosens-China/orgs",
        "repos_url": "https://api.github.com/users/bosens-China/repos",
        "events_url": "https://api.github.com/users/bosens-China/events{/privacy}",
        "received_events_url": "https://api.github.com/users/bosens-China/received_events",
        "type": "User",
        "site_admin": false
      },
      "labels": [
        {
          "id": 1371686609,
          "node_id": "MDU6TGFiZWwxMzcxNjg2NjA5",
          "url": "https://api.github.com/repos/bosens-China/blog/labels/JavaScript",
          "name": "JavaScript",
          "color": "F7DF1E",
          "default": false,
          "description": "JavaScript系列的文章"
        }
      ],
      "state": "open",
      "locked": false,
      "assignee": null,
      "assignees": [],
      "milestone": null,
      "comments": 0,
      "created_at": "2019-09-29T09:16:55Z",
      "updated_at": "2021-12-21T09:46:25Z",
      "closed_at": null,
      "author_association": "OWNER",
      "active_lock_reason": null,
      "body": "简单说一下存在的历史，浏览器存在同源政策，即域名+端口+协议必须一致，很多时候我们需要跨域访问，当然在现在我们可以借助 webpack 的反向代理配合服务器设置 cors 实现访问，但是在之前工程化还没出现的时候就需要有一种方法可以访问所以 jsonp 就出现了。\r\njsonp 的原理就是浏览器的 `script` 标签可以加载不同源的资源，配合后端通过执行函数传递参数，这也是 **jsonp 只支持 get** 的原因，同理的标签还有`img`，我们可以用它来实现访问站点次数的统计，根据上面的原理我们来实现一个模拟的版本\r\n\r\n## 第一版\r\n\r\n```html\r\n<script>\r\n  function callback(v) {\r\n    console.log(\"参数是：\");\r\n    console.log(v);\r\n  }\r\n</script>\r\n<script>\r\n  callback({\r\n    name: \"zhangsan\",\r\n    age: 18\r\n  });\r\n</script>\r\n```\r\n\r\n可以看到就是这个思路，后面的脚本调用这个参数即可。\r\n\r\n## 简单实现一个 jsonp 的函数\r\n\r\n```js\r\ninterface Iparams {\r\n  [propName: string]: any;\r\n}\r\ninterface Ioptions {\r\n  params?: Iparams;\r\n  timeout?: number;\r\n  name?: string;\r\n}\r\nlet uid = 0;\r\nconst jsonp = function jsonp(this: any, url: string, option: Ioptions = {}) {\r\n  return new Promise((resolve, reject) => {\r\n    // 注意，这个id不能重复\r\n    const id = `__uid${uid++}`;\r\n    Reflect.set(window, id, (...rest: any[]) => {\r\n      clear();\r\n      return resolve.call(this, ...rest);\r\n    });\r\n    const { name = \"callback\", params = {}, timeout = 6000 } = option;\r\n    // 清理\r\n    const clear = () => {\r\n      Reflect.set(window, id, () => {});\r\n      script.parentNode.removeChild(script);\r\n      if (timer) {\r\n        clearTimeout(timer);\r\n      }\r\n    };\r\n    // 创建超时任务\r\n    let timer: NodeJS.Timeout;\r\n    if (typeof timeout === \"number\") {\r\n      timer = setTimeout(() => {\r\n        clear();\r\n        return reject(new Error(`Task timeout`));\r\n      }, timeout);\r\n    }\r\n    const script: HTMLScriptElement = document.createElement(\"script\");\r\n    // 处理一下参数最终合并\r\n    const par = new URLSearchParams(params);\r\n    par.append(name, id);\r\n    const href = `${url}?${par}`;\r\n    // 编码一下防止出现中文之类的\r\n    script.src = encodeURI(href);\r\n    document.body.appendChild(script);\r\n    script.addEventListener(\"error\", () => {\r\n      clear();\r\n      return reject(\r\n        new Error(`Failed to create jsonp, request target address is:${url}`)\r\n      );\r\n    });\r\n  });\r\n};\r\nexport default jsonp;\r\n```\r\n\r\n这里为了方便演示使用了`URLSearchParams`对象，它是浏览器的原生对象，用来构造、解析和处理 URL 的查询字符串，当然在生产中还需要`polyfill`，如果不满足兼容性建议手写一个工具处理。\r\n\r\n## 最后\r\n\r\n代码我已经放置到了仓库，欢迎来 [Star](https://github.com/bosens-China/promise-jsonp)\r\n\r\n参考：\r\n\r\n- https://github.com/webmodules/jsonp\r\n",
      "reactions": {
        "url": "https://api.github.com/repos/bosens-China/blog/issues/29/reactions",
        "total_count": 0,
        "+1": 0,
        "-1": 0,
        "laugh": 0,
        "hooray": 0,
        "confused": 0,
        "heart": 0,
        "rocket": 0,
        "eyes": 0
      },
      "timeline_url": "https://api.github.com/repos/bosens-China/blog/issues/29/timeline",
      "performed_via_github_app": null,
      "state_reason": null
    },
    {
      "url": "https://api.github.com/repos/bosens-China/blog/issues/23",
      "repository_url": "https://api.github.com/repos/bosens-China/blog",
      "labels_url": "https://api.github.com/repos/bosens-China/blog/issues/23/labels{/name}",
      "comments_url": "https://api.github.com/repos/bosens-China/blog/issues/23/comments",
      "events_url": "https://api.github.com/repos/bosens-China/blog/issues/23/events",
      "html_url": "https://github.com/bosens-China/blog/issues/23",
      "id": 489595663,
      "node_id": "MDU6SXNzdWU0ODk1OTU2NjM=",
      "number": 23,
      "title": "长列表优化",
      "user": {
        "login": "bosens-China",
        "id": 39508895,
        "node_id": "MDQ6VXNlcjM5NTA4ODk1",
        "avatar_url": "https://avatars.githubusercontent.com/u/39508895?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bosens-China",
        "html_url": "https://github.com/bosens-China",
        "followers_url": "https://api.github.com/users/bosens-China/followers",
        "following_url": "https://api.github.com/users/bosens-China/following{/other_user}",
        "gists_url": "https://api.github.com/users/bosens-China/gists{/gist_id}",
        "starred_url": "https://api.github.com/users/bosens-China/starred{/owner}{/repo}",
        "subscriptions_url": "https://api.github.com/users/bosens-China/subscriptions",
        "organizations_url": "https://api.github.com/users/bosens-China/orgs",
        "repos_url": "https://api.github.com/users/bosens-China/repos",
        "events_url": "https://api.github.com/users/bosens-China/events{/privacy}",
        "received_events_url": "https://api.github.com/users/bosens-China/received_events",
        "type": "User",
        "site_admin": false
      },
      "labels": [
        {
          "id": 1371686609,
          "node_id": "MDU6TGFiZWwxMzcxNjg2NjA5",
          "url": "https://api.github.com/repos/bosens-China/blog/labels/JavaScript",
          "name": "JavaScript",
          "color": "F7DF1E",
          "default": false,
          "description": "JavaScript系列的文章"
        }
      ],
      "state": "open",
      "locked": false,
      "assignee": null,
      "assignees": [],
      "milestone": null,
      "comments": 0,
      "created_at": "2019-09-05T08:10:06Z",
      "updated_at": "2021-12-21T09:45:48Z",
      "closed_at": null,
      "author_association": "OWNER",
      "active_lock_reason": null,
      "body": "## 前言\r\n\r\n在项目中如果能分页实现那最好不过了，不过很多时候长列表不可避免，这里又分两种情况\r\n\r\n1. 第一次不用全部加载完成，这种可以使用懒加载或者说无限滚动的方式来实现\r\n2. 另外一种则是一次要渲染全部数据出现\r\n\r\n下面就来讨论这两种情况如何进行优化，可以对比[列表优化具体实现](https://github.com/bosens-China/VirtualList)的源码来看\r\n(注：下面是用 Vue 实现的，使用其他框架并不影响)\r\n\r\n## 无限滚动\r\n\r\n实现的思路很简单就是根据滚动条是否滚动到底部（总高度 - 可见高度 - 滚动条高度），滚动到底部就添加新的数据\r\n\r\n```js\r\nfunction scroll({ target }) {\r\n  const DISTANCE = 40;\r\n  const h = target.scrollHeight - (target.clientHeight + target.scrollTop);\r\n  if (h < DISTANCE) {\r\n    for (let i = 0, j = this.list.length, l = this.list.length; i < l; i++) {\r\n      this.list.push(j + i);\r\n    }\r\n  }\r\n}\r\n```\r\n\r\n## 虚拟列表\r\n\r\n![v2-f00bb3f5d9815d660d7bcbd87236af86_hd](https://user-images.githubusercontent.com/39508895/64329195-6cc67180-d001-11e9-8104-1256738a1cc2.jpg)\r\n\r\n引用一张图，可以看见我们实现的思路就是只渲染可见部分的列表，每次滚动条变化的时候更改展示的列表，在下面的演示中，我们都会用到一个基础的 html 结构，这里先贴一下\r\n\r\n```html\r\n<div class=\"root\">\r\n  <div class=\"container\"></div>\r\n  <ul class=\"content\">\r\n    <li class=\"item\" v-for=\"item of nowList\" :key=\"item.value\">\r\n      {{ item.value }}\r\n    </li>\r\n  </ul>\r\n</div>\r\n```\r\n\r\n```less\r\n.root {\r\n  border: 1px solid #999;\r\n  list-style: none;\r\n  overflow: auto;\r\n  height: 400px;\r\n  position: relative;\r\n  .container {\r\n    position: absolute;\r\n    left: 0;\r\n    top: 0;\r\n    right: 0;\r\n    z-index: -1;\r\n  }\r\n  .content {\r\n    .container();\r\n    z-index: 1;\r\n    margin: 0;\r\n    padding: 0;\r\n    list-style: none;\r\n  }\r\n  .item {\r\n    border-bottom: 1px solid #ccc;\r\n    padding-left: 40px;\r\n  }\r\n}\r\n```\r\n\r\n上面结构做了两件事情\r\n\r\n1. 固定总列表的高度，让其出现滚动条\r\n2. 用一个遮罩 div 撑起整个列表的高度\r\n\r\n### 固定\r\n\r\n这里假设每个列表的高度为 30px，剩下的部分就是计算出列表的`总体高度`以及`开始索引`和`结束索引`，核心代码只有不到 10 行\r\n\r\n```js\r\nscroll() {\r\n  const dom = this.$refs.root;\r\n  const total = Math.ceil(dom.clientHeight / this.height);\r\n  const start = Math.floor(dom.scrollTop / this.height);\r\n  const end = start + total;\r\n  this.start = start;\r\n  this.end = end;\r\n}\r\n```\r\n\r\n总索引: 当前视图的高度 / 子项的高度，不过注意需要向上取整；\r\n开始索引: 滚动的距离 / 子项的高度\r\n结束索: 总索引 + 开始索引\r\n下面是完整的代码\r\n\r\n```html\r\n<template>\r\n  <div>\r\n    <div class=\"root\" ref=\"root\" @scroll=\"scroll\">\r\n      <div class=\"container\" :style=\"{ height: totalHeight }\"></div>\r\n      <ul class=\"content\" :style=\"{ transform: getTransform }\">\r\n        <li\r\n          class=\"item\"\r\n          :style=\"{ height: height + 'px', lineHeight: height + 'px' }\"\r\n          v-for=\"(item, i) of nowList\"\r\n          :key=\"i\"\r\n        >\r\n          {{ item }}\r\n        </li>\r\n      </ul>\r\n    </div>\r\n  </div>\r\n</template>\r\n\r\n<script>\r\n  export default {\r\n    data() {\r\n      return {\r\n        list: Array(10000)\r\n          .fill(1)\r\n          .map((f, i) => i),\r\n        height: 30,\r\n        start: 0,\r\n        end: 0\r\n      };\r\n    },\r\n    computed: {\r\n      totalHeight() {\r\n        return this.height * this.list.length + \"px\";\r\n      },\r\n      nowList() {\r\n        return this.list.slice(this.start, this.end);\r\n      },\r\n      getTransform() {\r\n        return `translate3d(0,${this.start * this.height}px,0)`;\r\n      }\r\n    },\r\n    mounted() {\r\n      this.scroll();\r\n    },\r\n    methods: {\r\n      scroll() {\r\n        const dom = this.$refs.root;\r\n        const total = Math.ceil(dom.clientHeight / this.height);\r\n        const start = Math.floor(dom.scrollTop / this.height);\r\n        const end = start + total;\r\n        this.start = start;\r\n        this.end = end;\r\n      }\r\n    }\r\n  };\r\n</script>\r\n\r\n<style lang=\"less\" scoped>\r\n  .root {\r\n    border: 1px solid #999;\r\n    list-style: none;\r\n    overflow: auto;\r\n    height: 400px;\r\n    position: relative;\r\n    .container {\r\n      position: absolute;\r\n      left: 0;\r\n      top: 0;\r\n      right: 0;\r\n      z-index: -1;\r\n    }\r\n    .content {\r\n      .container();\r\n      z-index: 1;\r\n      margin: 0;\r\n      padding: 0;\r\n      list-style: none;\r\n    }\r\n    .item {\r\n      border-bottom: 1px solid #ccc;\r\n      padding-left: 40px;\r\n    }\r\n  }\r\n</style>\r\n```\r\n\r\n### 非固定\r\n\r\n非固定需要考虑的更多则是性能的问题，下面先贴一个完整的代码，在需要说明部分已经注释了\r\n\r\n```html\r\n<template>\r\n  <div>\r\n    <div class=\"root\" ref=\"root\" @scroll=\"scroll\">\r\n      <div class=\"container\" :style=\"{ height: totalHeight }\"></div>\r\n      <ul class=\"content\" :style=\"{ transform: getTransform }\">\r\n        <li\r\n          class=\"item\"\r\n          v-for=\"item of nowList\"\r\n          :style=\"{\r\n            height: item.height + 'px',\r\n            lineHeight: item.height + 'px'\r\n          }\"\r\n          :key=\"item.value\"\r\n        >\r\n          {{ item.value }}\r\n        </li>\r\n      </ul>\r\n    </div>\r\n  </div>\r\n</template>\r\n\r\n<script>\r\n  export default {\r\n    data() {\r\n      return {\r\n        list: Array(10000)\r\n          .fill(1)\r\n          .map((f, i) => {\r\n            return {\r\n              value: i,\r\n              height: this.getRandom(10, 100)\r\n            };\r\n          }),\r\n        start: 0,\r\n        end: 0,\r\n        // 指针\r\n        pointer: -1,\r\n        // 缓存\r\n        cache: {},\r\n        // 初始总数\r\n        initialHeight: 50\r\n      };\r\n    },\r\n    computed: {\r\n      totalHeight() {\r\n        // 这里是获取总体高度，判断了两种情况，第一种是给定初始总数，另外一种则是没有，如果没有的话，高度就是已缓存的 + 未缓存的部分\r\n        if (this.initialtotal >= 0) {\r\n          const { top, height } =\r\n            this.pointer >= 0\r\n              ? this.getIndexOffset(this.pointer)\r\n              : { top: 0, height: 0 };\r\n          return `${top +\r\n            height +\r\n            (this.list.length - 1 - this.pointer) * this.initialHeight}px`;\r\n        }\r\n        const { height } = this.list.reduce(function(x, y) {\r\n          return {\r\n            height: x.height + y.height\r\n          };\r\n        });\r\n        return height + \"px\";\r\n      },\r\n      // 可视数据\r\n      nowList() {\r\n        return this.list.slice(\r\n          this.start,\r\n          Math.min(this.end + 1, this.list.length)\r\n        );\r\n      },\r\n      getTransform() {\r\n        return `translate3d(0,${this.getIndexOffset(this.start).top}px,0)`;\r\n      }\r\n    },\r\n    mounted() {\r\n      this.scroll();\r\n    },\r\n    methods: {\r\n      // 滚动事件\r\n      scroll() {\r\n        const dom = this.$refs.root;\r\n        // 获取索引\r\n        const start = this.getIndex(dom.scrollTop);\r\n        // 把当前可视的高度 + 滚动条的高度，再去取索引\r\n        const end = this.getIndex(dom.scrollTop + dom.clientHeight);\r\n        this.start = start;\r\n        this.end = end;\r\n      },\r\n      // 取出指定范围随机数\r\n      getRandom(min, max) {\r\n        return Math.floor(Math.random() * (max - min + 1)) + min;\r\n      },\r\n      // 根据滚动条y获取指定坐标\r\n      getIndex(scrollTop) {\r\n        // 判断思路很简单，如果高度大于滚动条肯定就出现了，另外一种则是判断了边界问题\r\n        let total = 0;\r\n        for (let i = 0, j = this.list.length; i < j; i++) {\r\n          if (total >= scrollTop || j - 1 === i) {\r\n            return i;\r\n          }\r\n          // 这里主要是起缓存作用的\r\n          total += this.getIndexOffset(i).height;\r\n        }\r\n        return 0;\r\n      },\r\n      // 获取指定坐标的位置和高度\r\n      getIndexOffset(index) {\r\n        // 如果存在缓存中直接返回\r\n        if (this.pointer >= index) {\r\n          return this.cache[index];\r\n        }\r\n        let total = 0;\r\n        // 这里是为了比较没有取到的情况\r\n        if (this.pointer >= 0) {\r\n          const li = this.cache[this.pointer];\r\n          total = li.top + li.height;\r\n        }\r\n        // 注意上面因为取的值是li.top + li.height，所以i从 + 1开始\r\n        for (let i = this.pointer + 1; i <= index; i++) {\r\n          const size = this.list[i].height;\r\n          this.cache[i] = {\r\n            top: total,\r\n            height: size\r\n          };\r\n          total += size;\r\n        }\r\n        if (index > this.pointer) {\r\n          this.pointer = index;\r\n        }\r\n\r\n        return this.cache[index];\r\n      }\r\n    }\r\n  };\r\n</script>\r\n\r\n<style lang=\"less\" scoped>\r\n  .root {\r\n    border: 1px solid #999;\r\n    list-style: none;\r\n    overflow: auto;\r\n    height: 400px;\r\n    position: relative;\r\n    .container {\r\n      position: absolute;\r\n      left: 0;\r\n      top: 0;\r\n      right: 0;\r\n      z-index: -1;\r\n    }\r\n    .content {\r\n      .container();\r\n      z-index: 1;\r\n      margin: 0;\r\n      padding: 0;\r\n      list-style: none;\r\n    }\r\n    .item {\r\n      border-bottom: 1px solid #ccc;\r\n      padding-left: 40px;\r\n    }\r\n  }\r\n</style>\r\n```\r\n\r\n上面只最终的实现，实际上跟固定高度相比就是增加了获取索引的方法，固定高度我们是知道对应子项的高度，所以可以通过可视高度来计算，而这里我用了随机数来设置高度，所以需要获取到对应的索引。\r\n上面代码同时也做了两点优化，一是缓存，二是总高度优化\r\n\r\n总高度的实现有两种思路：\r\n\r\n1. 计算所有的高度，这种实际上有点浪费性能；\r\n2. 给定一个大概的值，拿缓存的值 + 没有缓存的值，没有缓存的值就是对应数据的长度 - 已缓存的坐标，之后每次缓存变化的时候再计算；\r\n\r\n缓存则比较简单了，每次计算的时候把指针移动到计算的位置，同时将值添加上\r\n\r\n## 参考文章\r\n\r\n1. https://zhuanlan.zhihu.com/p/34585166\r\n",
      "reactions": {
        "url": "https://api.github.com/repos/bosens-China/blog/issues/23/reactions",
        "total_count": 0,
        "+1": 0,
        "-1": 0,
        "laugh": 0,
        "hooray": 0,
        "confused": 0,
        "heart": 0,
        "rocket": 0,
        "eyes": 0
      },
      "timeline_url": "https://api.github.com/repos/bosens-China/blog/issues/23/timeline",
      "performed_via_github_app": null,
      "state_reason": null
    },
    {
      "url": "https://api.github.com/repos/bosens-China/blog/issues/22",
      "repository_url": "https://api.github.com/repos/bosens-China/blog",
      "labels_url": "https://api.github.com/repos/bosens-China/blog/issues/22/labels{/name}",
      "comments_url": "https://api.github.com/repos/bosens-China/blog/issues/22/comments",
      "events_url": "https://api.github.com/repos/bosens-China/blog/issues/22/events",
      "html_url": "https://github.com/bosens-China/blog/issues/22",
      "id": 485122259,
      "node_id": "MDU6SXNzdWU0ODUxMjIyNTk=",
      "number": 22,
      "title": "通用迭代器实现",
      "user": {
        "login": "bosens-China",
        "id": 39508895,
        "node_id": "MDQ6VXNlcjM5NTA4ODk1",
        "avatar_url": "https://avatars.githubusercontent.com/u/39508895?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bosens-China",
        "html_url": "https://github.com/bosens-China",
        "followers_url": "https://api.github.com/users/bosens-China/followers",
        "following_url": "https://api.github.com/users/bosens-China/following{/other_user}",
        "gists_url": "https://api.github.com/users/bosens-China/gists{/gist_id}",
        "starred_url": "https://api.github.com/users/bosens-China/starred{/owner}{/repo}",
        "subscriptions_url": "https://api.github.com/users/bosens-China/subscriptions",
        "organizations_url": "https://api.github.com/users/bosens-China/orgs",
        "repos_url": "https://api.github.com/users/bosens-China/repos",
        "events_url": "https://api.github.com/users/bosens-China/events{/privacy}",
        "received_events_url": "https://api.github.com/users/bosens-China/received_events",
        "type": "User",
        "site_admin": false
      },
      "labels": [
        {
          "id": 1602397157,
          "node_id": "MDU6TGFiZWwxNjAyMzk3MTU3",
          "url": "https://api.github.com/repos/bosens-China/blog/labels/%E6%B7%B1%E5%85%A5%E7%B3%BB%E5%88%97",
          "name": "深入系列",
          "color": "719192",
          "default": false,
          "description": "主要介绍实现的思路"
        }
      ],
      "state": "open",
      "locked": false,
      "assignee": null,
      "assignees": [],
      "milestone": null,
      "comments": 0,
      "created_at": "2019-08-26T08:47:04Z",
      "updated_at": "2021-12-21T09:45:27Z",
      "closed_at": null,
      "author_association": "OWNER",
      "active_lock_reason": null,
      "body": "> 迭代器在很多语言都很常见，js 的 forEach 就是一个迭代器，下面就来介绍实现一个支持数组、对象、类数组的的 each 函数。\r\n\r\n## 前言\r\n\r\n写之前先整理一下思路\r\n\r\n1. 我们首先需要判断是不是类数组，如果是数组和类数组就使用 for 循环，如果是对象我们就用 for...in 循环。\r\n2. 回调函数的 this 处理，返回 false 终止循环\r\n\r\n## 判断类型\r\n\r\n判断基本类型我们可以使用 `typeof`，不过对于引用类型，比如数组和函数都会返回`object`，那么还有更好的判断方法么？\r\n那就是`Object.prototype.toString`\r\n\r\n```js\r\nObject.prototype.toString.call({}); // \"[object Object]\"\r\nObject.prototype.toString.call([]); // \"[object Array]\"\r\n```\r\n\r\n这里使用`Object.prototype.toString`的原因是一些引用类型的`toString`有自己的实现方式，比如数组的 `toString` 返回的就是以`\",\"`分隔的文本。\r\n数组的判断可以基于上面方法，下面就是封装成一个函数\r\n\r\n```js\r\nfunction isArray(arr) {\r\n  return Object.prototype.toString.call(arr) === \"[object Array]\";\r\n}\r\n```\r\n\r\n下面就来实现判断类数组的的思路，类数组就是指类似于\r\n\r\n```js\r\n{1: 123, 2：45, 6: 789, length: 7}\r\n// or\r\n// nodelist[]\r\n// arguments\r\n// ...\r\n```\r\n\r\n上面列举的几种对象，都存在`length`，而且都是一个对象，所以我们以这个为判断准则，下面就是实现\r\n\r\n```js\r\nfunction isClassArray(arr) {\r\n  var length = !!arr && length in arr && arr.length;\r\n  return (\r\n    isArray(arr) ||\r\n    length === 0 ||\r\n    (typeof arr === \"number\" && length - 1 in arr)\r\n  );\r\n}\r\n```\r\n\r\n判断还是比较简洁的，判断了三种情况\r\n\r\n1. 必须有 `length` 属性\r\n2. `length` 为 0 的情况\r\n3. `length- 1`必须存在\r\n\r\n第一种就不说了，第二种为什么要判断 length 为 `0` 的情况呢？\r\n假设有一个对象`{a: 1, b: 2, length: 0}`，认为它是类数组是不是不太合适，还有`arguments`是不是类数组对象根据函数的传递参数来变化，但是如果没有参数`length`为 0 就返回 false，是不是也不太合适，其实这里主要就是为了判断一些边界的对象\r\n\r\n```js\r\nfunction foo() {\r\n  arguments.length; // 0\r\n}\r\nfoo();\r\n```\r\n\r\n第三点，为什么要求 `length - 1` 存在？\r\n数组的 length 永远是成员数+1，要求`length - 1` 存在实际上这是为了数组和类数组的形式想对应，例如：\r\n\r\n```js\r\nvar a = [, , 2]; // length: 3\r\n// 对应类数组\r\nvar obj = {\r\n  2: 2,\r\n  length: 3\r\n};\r\n```\r\n\r\n上面数组存在`,`我们认为前面两位就是空，但是如果取消了`length - 1`必须存在，那么下面这种写法会出现下面情况\r\n\r\n```js\r\n// length: 2\r\nvar a = [1, ,];\r\nvar obj = {\r\n  0: 1，\r\n  length: 1\r\n};\r\n```\r\n\r\n## each\r\n\r\n上面把所需要用的讲解完毕了，下面就来实现一个最终版的 each\r\n\r\n```js\r\nfunction isArray(arr) {\r\n  return Object.prototype.toString.call(arr) === \"[object Array]\";\r\n}\r\nfunction isClassArray(arr) {\r\n  var length = !!arr && length in arr && arr.length;\r\n  return (\r\n    isArray(arr) ||\r\n    length === 0 ||\r\n    (typeof arr === \"number\" && length - 1 in arr)\r\n  );\r\n}\r\nfunction each(obj, callback) {\r\n  if (typeof obj !== \"object\") {\r\n    return obj;\r\n  }\r\n  // 数组和类数组\r\n  if (isClassArray(obj)) {\r\n    for (let i = 0; i < obj.length; i++) {\r\n      let v = callback.call(obj, i, obj[i]);\r\n      if (v === false) {\r\n        break;\r\n      }\r\n    }\r\n  } else {\r\n    for (let item in obj) {\r\n      let v = callback.call(obj, item, obj[item]);\r\n      if (v === false) {\r\n        break;\r\n      }\r\n    }\r\n  }\r\n}\r\n```\r\n\r\n## 参考\r\n\r\n[JavaScript 专题之类型判断(下) #30](https://github.com/mqyqingfeng/Blog/issues/30)\r\n",
      "reactions": {
        "url": "https://api.github.com/repos/bosens-China/blog/issues/22/reactions",
        "total_count": 0,
        "+1": 0,
        "-1": 0,
        "laugh": 0,
        "hooray": 0,
        "confused": 0,
        "heart": 0,
        "rocket": 0,
        "eyes": 0
      },
      "timeline_url": "https://api.github.com/repos/bosens-China/blog/issues/22/timeline",
      "performed_via_github_app": null,
      "state_reason": null
    },
    {
      "url": "https://api.github.com/repos/bosens-China/blog/issues/19",
      "repository_url": "https://api.github.com/repos/bosens-China/blog",
      "labels_url": "https://api.github.com/repos/bosens-China/blog/issues/19/labels{/name}",
      "comments_url": "https://api.github.com/repos/bosens-China/blog/issues/19/comments",
      "events_url": "https://api.github.com/repos/bosens-China/blog/issues/19/events",
      "html_url": "https://github.com/bosens-China/blog/issues/19",
      "id": 479944938,
      "node_id": "MDU6SXNzdWU0Nzk5NDQ5Mzg=",
      "number": 19,
      "title": "单例模式",
      "user": {
        "login": "bosens-China",
        "id": 39508895,
        "node_id": "MDQ6VXNlcjM5NTA4ODk1",
        "avatar_url": "https://avatars.githubusercontent.com/u/39508895?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bosens-China",
        "html_url": "https://github.com/bosens-China",
        "followers_url": "https://api.github.com/users/bosens-China/followers",
        "following_url": "https://api.github.com/users/bosens-China/following{/other_user}",
        "gists_url": "https://api.github.com/users/bosens-China/gists{/gist_id}",
        "starred_url": "https://api.github.com/users/bosens-China/starred{/owner}{/repo}",
        "subscriptions_url": "https://api.github.com/users/bosens-China/subscriptions",
        "organizations_url": "https://api.github.com/users/bosens-China/orgs",
        "repos_url": "https://api.github.com/users/bosens-China/repos",
        "events_url": "https://api.github.com/users/bosens-China/events{/privacy}",
        "received_events_url": "https://api.github.com/users/bosens-China/received_events",
        "type": "User",
        "site_admin": false
      },
      "labels": [
        {
          "id": 1740561541,
          "node_id": "MDU6TGFiZWwxNzQwNTYxNTQx",
          "url": "https://api.github.com/repos/bosens-China/blog/labels/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F",
          "name": "设计模式",
          "color": "d1a540",
          "default": false,
          "description": "设计模式在JavaScript的实现"
        }
      ],
      "state": "open",
      "locked": false,
      "assignee": null,
      "assignees": [],
      "milestone": null,
      "comments": 0,
      "created_at": "2019-08-13T03:44:23Z",
      "updated_at": "2021-12-21T09:43:21Z",
      "closed_at": null,
      "author_association": "OWNER",
      "active_lock_reason": null,
      "body": "单例模式是很常见的一种设计模式，保证一个类仅有一个实例，并提供一个访问它的全局访问点。\r\n\r\n## 单例实现\r\n\r\n根据上面定义很容易想到用闭包来实现\r\n\r\n```js\r\nvar dom = (function() {\r\n  var d;\r\n  function createdDiv(html) {\r\n    if (d) {\r\n      return d;\r\n    }\r\n    this.html = html;\r\n    this.init();\r\n    return (d = this);\r\n  }\r\n  createdDiv.prototype.init = function() {\r\n    var dom = document.createElement(\"div\");\r\n    dom.innerHTML = this.html;\r\n    document.body.append(dom);\r\n  };\r\n  return createdDiv;\r\n})();\r\nvar d1 = new dom(\"hello wrold\");\r\nvar d2 = new dom(\"你好世界\");\r\nconsole.log(d1 === d2); // true\r\n```\r\n\r\n上面通过变量`d`来判断，没有就生成一个`div`，有的话就返回`d`，不过上面代码生成和保证单一组合在一起实际上违反了面向对象的单一职责，下面就用代理的方式来清除这种耦合。\r\n\r\n## 代理\r\n\r\n还是通过上面代码为例，我们通过观察发现`createdDiv`函数负责`div`的创建和生成，如何保证类的单一，我们可以使用另外一个函数来检测和返回。\r\n\r\n```js\r\nvar dom = (function() {\r\n  var d;\r\n  function createdDiv(html) {\r\n    this.html = html;\r\n    this.init();\r\n  }\r\n  createdDiv.prototype.init = function() {\r\n    var dom = document.createElement(\"div\");\r\n    dom.innerHTML = this.html;\r\n    document.body.append(dom);\r\n  };\r\n  return function(h) {\r\n    if (!d) {\r\n      d = new createdDiv(h);\r\n    }\r\n    return d;\r\n  };\r\n})();\r\nvar d1 = new dom(\"hello wrold\");\r\nvar d2 = new dom(\"你好世界\");\r\nconsole.log(d1 === d2); // true\r\n```\r\n\r\n## 惰性\r\n\r\n以兼容 dom 事件为例，ie 有自己的 dom 事件添加方法，如果我们要写一个兼容的函数可能会这样写\r\n\r\n```js\r\nfunction addEvent(type, el, fn) {\r\n  if (window.addEventListener) {\r\n    el.addEventListener(type, fn, false);\r\n  } else if (window.attachEvent) {\r\n    el.attachEvent(\"on\" + type, fn);\r\n  }\r\n}\r\n```\r\n\r\n不过这里每次运行函数都会判断一次，实际上没有必要，我们可以通过闭包的形式只判断一次\r\n\r\n```js\r\nfunction addEvent(type, el, fn) {\r\n  if (window.addEventListener) {\r\n    return function() {\r\n      el.addEventListener(type, fn, false);\r\n    };\r\n  } else if (window.attachEvent) {\r\n    return function() {\r\n      el.attachEvent(\"on\" + type, fn);\r\n    };\r\n  }\r\n}\r\n```\r\n\r\n惰性的应用很广泛，许多优化也牵扯其中，比如 webpack 对`import()`可以做到代码分割，减少首屏加载时间。\r\n\r\n## 信任函数\r\n\r\n还是通过惰性的例子为例，我们用了一个闭包来实现，不过也可以通过改写这个函数来实现\r\n\r\n```js\r\nfunction addEvent(type, el, fn) {\r\n  if (window.addEventListener) {\r\n    addEvent = function(type, el, fn) {\r\n      el.addEventListener(type, fn, false);\r\n    };\r\n  } else if (window.attachEvent) {\r\n    addEvent = function(type, el, fn) {\r\n      el.attachEvent(\"on\" + type, fn);\r\n    };\r\n  }\r\n}\r\n```\r\n\r\n## es6 之后的单例\r\n\r\n在 javascript 中单例实际上有些特殊，因为并没有类，而且单例的作用只是为了保证类的单一性，那我们可以直接定义一个全局变量就可以做到了\r\n\r\n```js\r\nvar a = {};\r\n```\r\n\r\n这里`a`在全局只会存在一次，不过缺点也很明显，就是会被覆盖和修改以及污染了全局变量，而从 es6 开始引用了模块的机制，它有些特殊，它是运行前加载，而且会将模块的值动态同步，怎么理解这句话呢？\r\n\r\n```js\r\nlet d = 5;\r\nsetTimeout(() => {\r\n  d = 10;\r\n}, 1000);\r\nexport { d };\r\n// 引用\r\n\r\nimport { d } from \"./demo.js\";\r\nconsole.log(d);\r\nsetTimeout(() => {\r\n  console.log(d);\r\n}, 1000);\r\n```\r\n\r\n上面会输出 5 和 10,所以根据模块这一特性可以很轻松实现单例模式\r\n\r\n```js\r\nlet event;\r\nif (!event) {\r\n  if (window.addEventListener) {\r\n    event = function(type, el, fn) {\r\n      el.addEventListener(type, fn, false);\r\n    };\r\n  } else if (window.attachEvent) {\r\n    event = function(type, el, fn) {\r\n      el.attachEvent(\"on\" + type, fn);\r\n    };\r\n  }\r\n}\r\nexport default event;\r\n```\r\n\r\n## 最后\r\n\r\n上面简单介绍了单例的传统实现，以及在 javascript 中的实现，最后额外提一下，es6 新增的`symbol`也可以跟单例想结合使用，它确保了这个属性名是唯一的，我们可以通过`symbol.for`来判断有没有这个`symbol`\r\n",
      "reactions": {
        "url": "https://api.github.com/repos/bosens-China/blog/issues/19/reactions",
        "total_count": 0,
        "+1": 0,
        "-1": 0,
        "laugh": 0,
        "hooray": 0,
        "confused": 0,
        "heart": 0,
        "rocket": 0,
        "eyes": 0
      },
      "timeline_url": "https://api.github.com/repos/bosens-China/blog/issues/19/timeline",
      "performed_via_github_app": null,
      "state_reason": null
    },
    {
      "url": "https://api.github.com/repos/bosens-China/blog/issues/20",
      "repository_url": "https://api.github.com/repos/bosens-China/blog",
      "labels_url": "https://api.github.com/repos/bosens-China/blog/issues/20/labels{/name}",
      "comments_url": "https://api.github.com/repos/bosens-China/blog/issues/20/comments",
      "events_url": "https://api.github.com/repos/bosens-China/blog/issues/20/events",
      "html_url": "https://github.com/bosens-China/blog/issues/20",
      "id": 480491465,
      "node_id": "MDU6SXNzdWU0ODA0OTE0NjU=",
      "number": 20,
      "title": "发布订阅模式",
      "user": {
        "login": "bosens-China",
        "id": 39508895,
        "node_id": "MDQ6VXNlcjM5NTA4ODk1",
        "avatar_url": "https://avatars.githubusercontent.com/u/39508895?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bosens-China",
        "html_url": "https://github.com/bosens-China",
        "followers_url": "https://api.github.com/users/bosens-China/followers",
        "following_url": "https://api.github.com/users/bosens-China/following{/other_user}",
        "gists_url": "https://api.github.com/users/bosens-China/gists{/gist_id}",
        "starred_url": "https://api.github.com/users/bosens-China/starred{/owner}{/repo}",
        "subscriptions_url": "https://api.github.com/users/bosens-China/subscriptions",
        "organizations_url": "https://api.github.com/users/bosens-China/orgs",
        "repos_url": "https://api.github.com/users/bosens-China/repos",
        "events_url": "https://api.github.com/users/bosens-China/events{/privacy}",
        "received_events_url": "https://api.github.com/users/bosens-China/received_events",
        "type": "User",
        "site_admin": false
      },
      "labels": [
        {
          "id": 1740561541,
          "node_id": "MDU6TGFiZWwxNzQwNTYxNTQx",
          "url": "https://api.github.com/repos/bosens-China/blog/labels/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F",
          "name": "设计模式",
          "color": "d1a540",
          "default": false,
          "description": "设计模式在JavaScript的实现"
        }
      ],
      "state": "open",
      "locked": false,
      "assignee": null,
      "assignees": [],
      "milestone": null,
      "comments": 0,
      "created_at": "2019-08-14T05:44:57Z",
      "updated_at": "2021-12-21T09:42:53Z",
      "closed_at": null,
      "author_association": "OWNER",
      "active_lock_reason": null,
      "body": "发布订阅模式也成为观察者模式，以下面三部分组成\r\n\r\n1. 发布者\r\n2. 订阅者\r\n3. 消息队列\r\n\r\n上面介绍了组成可能你还有疑惑，下面就举一个例子，小明打算去售楼处去买一套房子，销售小姐告诉他这套住宅暂时没有房源，小明于是留了手机号码给他，某一天有房源的时候通知他。\r\n上面例子中，发布者就是售楼中心，订阅者就是小明，消息队列就是小明留的手机号码，观察者模式可以让对象松耦合在一起。\r\n\r\n## 实现\r\n\r\n> 下面使用 ES6 的语法来写，如果没有基础，推荐看一遍 es6 入门再来\r\n\r\n上面介绍了定义，就根据上面的定义编写一个可以取消以及支持传递参数的观察者实例\r\n\r\n```js\r\nconst Event = new (class Watch {\r\n  constructor() {\r\n    // 消息队列\r\n    this.list = {};\r\n  }\r\n  // 订阅\r\n  subscribe(key, fn) {\r\n    if (!this.list[key]) {\r\n      // 避免重复\r\n      this.list[key] = new Set();\r\n    }\r\n    this.list[key].add(fn);\r\n  }\r\n  // 触发\r\n  trigger(key, ...args) {\r\n    const v = this.list[key];\r\n    if (!v) {\r\n      return;\r\n    }\r\n    v.forEach((f) => f.apply(this, args), this);\r\n  }\r\n  // 删除，key是必须的\r\n  remove(key, fn) {\r\n    const v = this.list[key];\r\n    if (!v) {\r\n      return false;\r\n    }\r\n    if (v.has(fn)) {\r\n      return v.delete(fn);\r\n    }\r\n    // clear没有返回值，这里返回一个true\r\n    return v.clear() || true;\r\n  }\r\n})();\r\nEvent.subscribe('abc', function (a) {\r\n  console.log(a); // x\r\n});\r\nEvent.trigger('abc', 'x');\r\n```\r\n\r\n上面就实现了简单的观察者模式，不过可以观察上面代码可以发现观察者运行的机制是*先订阅后发布*，有没有办法类似于 QQ 消息一样，可以接收到离线消息，当然这个离线消息只能接收一次。\r\n\r\n## 支持先发布后订阅\r\n\r\n实现的思路很简单，就是通过一个离线消息队列，发布的时候判断这个离线消息队列存在么，如果存在，将消息存放在离线消息队列，当订阅的时候如果发现有离线消息队列就执行一次，之后清空\r\n\r\n```js\r\nconst Event = new (class Watch {\r\n  constructor() {\r\n    // 消息队列\r\n    this.list = {};\r\n    this.offLine = new Set();\r\n  }\r\n  // 订阅\r\n  subscribe(key, fn) {\r\n    if (!this.list[key]) {\r\n      // 避免重复\r\n      this.list[key] = new Set();\r\n    }\r\n    this.list[key].add(fn);\r\n    if (this.offLine) {\r\n      this.offLine.forEach((f) => f(), this);\r\n    }\r\n    this.offLine = null;\r\n  }\r\n  // 触发\r\n  trigger(key, ...args) {\r\n    // 关键代码\r\n    const fn = () => {\r\n      const v = this.list[key];\r\n      if (!v) {\r\n        return;\r\n      }\r\n      v.forEach((f) => f.apply(this, args), this);\r\n    };\r\n    if (this.offLine) {\r\n      this.offLine.add(fn);\r\n    }\r\n    fn();\r\n  }\r\n  // 删除，key是必须的\r\n  remove(key, fn) {\r\n    const v = this.list[key];\r\n    if (!v) {\r\n      return false;\r\n    }\r\n    if (v.has(fn)) {\r\n      return v.delete(fn);\r\n    }\r\n    // clear没有返回值，这里返回一个true\r\n    return v.clear() || true;\r\n  }\r\n})();\r\nEvent.trigger('abc', 'x');\r\nEvent.subscribe('abc', function (a) {\r\n  console.log(a); // x\r\n});\r\n```\r\n\r\n撒花，一个支持取消和先发布后订阅的观察者模式已经实现了，不过还是有待优化的地方，比如命名，我们能不能通过`Event.created('zhangsan').trigger`的形式来调用呢？\r\n\r\n## 命名\r\n\r\n动手写之前，我们先缕清一下头绪\r\n\r\n- 命名是否必须，能不能不通过`created`先调用，比如直接就是`Event.trigger`发布之后再订阅\r\n\r\nok，下面就是针对上面问题实现\r\n\r\n```js\r\n// 定义一个基础类，这个类是实现的核心层\r\nclass Basics {\r\n  _obj = {};\r\n  _default = 'default';\r\n  _created(name = this._default) {\r\n    // 定义消息队列和离线消息队列\r\n    const list = {};\r\n    let offLine = new Set();\r\n    const then = this;\r\n    const obj = {\r\n      // 触发，如果第一次触发就添加到离线队列中\r\n      trigger(key, ...rest) {\r\n        const fn = () => {\r\n          const arr = [list, key, ...rest];\r\n          return then._trigger.apply(then, arr);\r\n        };\r\n        if (offLine) {\r\n          offLine.add(fn);\r\n        }\r\n        return fn();\r\n      },\r\n      // 添加订阅者同时执行离线队列\r\n      subscribe(key, fn) {\r\n        then._subscribe(...[list, key, fn]);\r\n        if (offLine) {\r\n          offLine.forEach((f) => f());\r\n        }\r\n        offLine = null;\r\n      },\r\n      // 删除，key是必须的\r\n      remove(key, fn) {\r\n        const v = this.list[key];\r\n        if (!v) {\r\n          return false;\r\n        }\r\n        if (v.has(fn)) {\r\n          return v.delete(fn);\r\n        }\r\n        // clear没有返回值，这里返回一个true\r\n        return v.clear() || true;\r\n      },\r\n    };\r\n    // 判断命名来决定返回\r\n    return name ? (this._obj[name] ? this._obj[name] : (this._obj[name] = obj)) : obj;\r\n  }\r\n  // 触发\r\n  _trigger(l, k, ...args) {\r\n    const v = l[k];\r\n    if (!v || !v.size) {\r\n      return;\r\n    }\r\n    return Array.from(v, (f) => f.apply(this, args), this);\r\n  }\r\n  _subscribe(list, key, fn) {\r\n    if (!list[key]) {\r\n      list[key] = new Set();\r\n    }\r\n    list[key].add(fn);\r\n  }\r\n}\r\n// 这个是实现类\r\nclass Watch extends Basics {\r\n  constructor() {\r\n    // 必须，es6规定\r\n    super();\r\n    this.created = super._created;\r\n  }\r\n  trigger(key, ...rest) {\r\n    const v = this.created();\r\n    v.trigger(key, ...rest);\r\n  }\r\n  subscribe(key, fn) {\r\n    const v = this.created();\r\n    v.subscribe(key, fn);\r\n  }\r\n  remove(key, fn) {\r\n    const v = this.created();\r\n    v.remove(key, fn);\r\n  }\r\n}\r\nconst Event = new Watch();\r\nEvent.trigger('abc');\r\nEvent.subscribe('abc', function () {\r\n  console.log(123);\r\n});\r\nEvent.created('zhangsan').subscribe('abc', function (c) {\r\n  console.log(c);\r\n});\r\nEvent.created('zhangsan').trigger('abc', 456);\r\n```\r\n\r\n在实际中我们使用观察者模式的例子也有很多，比如一个网站，分为导航和侧边，当用户信息更新的时候展示部分需要更换就可以用到，还有我们用的框架，比如`vue、React`等\r\n",
      "reactions": {
        "url": "https://api.github.com/repos/bosens-China/blog/issues/20/reactions",
        "total_count": 0,
        "+1": 0,
        "-1": 0,
        "laugh": 0,
        "hooray": 0,
        "confused": 0,
        "heart": 0,
        "rocket": 0,
        "eyes": 0
      },
      "timeline_url": "https://api.github.com/repos/bosens-China/blog/issues/20/timeline",
      "performed_via_github_app": null,
      "state_reason": null
    },
    {
      "url": "https://api.github.com/repos/bosens-China/blog/issues/21",
      "repository_url": "https://api.github.com/repos/bosens-China/blog",
      "labels_url": "https://api.github.com/repos/bosens-China/blog/issues/21/labels{/name}",
      "comments_url": "https://api.github.com/repos/bosens-China/blog/issues/21/comments",
      "events_url": "https://api.github.com/repos/bosens-China/blog/issues/21/events",
      "html_url": "https://github.com/bosens-China/blog/issues/21",
      "id": 482752452,
      "node_id": "MDU6SXNzdWU0ODI3NTI0NTI=",
      "number": 21,
      "title": "代理模式",
      "user": {
        "login": "bosens-China",
        "id": 39508895,
        "node_id": "MDQ6VXNlcjM5NTA4ODk1",
        "avatar_url": "https://avatars.githubusercontent.com/u/39508895?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bosens-China",
        "html_url": "https://github.com/bosens-China",
        "followers_url": "https://api.github.com/users/bosens-China/followers",
        "following_url": "https://api.github.com/users/bosens-China/following{/other_user}",
        "gists_url": "https://api.github.com/users/bosens-China/gists{/gist_id}",
        "starred_url": "https://api.github.com/users/bosens-China/starred{/owner}{/repo}",
        "subscriptions_url": "https://api.github.com/users/bosens-China/subscriptions",
        "organizations_url": "https://api.github.com/users/bosens-China/orgs",
        "repos_url": "https://api.github.com/users/bosens-China/repos",
        "events_url": "https://api.github.com/users/bosens-China/events{/privacy}",
        "received_events_url": "https://api.github.com/users/bosens-China/received_events",
        "type": "User",
        "site_admin": false
      },
      "labels": [
        {
          "id": 1740561541,
          "node_id": "MDU6TGFiZWwxNzQwNTYxNTQx",
          "url": "https://api.github.com/repos/bosens-China/blog/labels/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F",
          "name": "设计模式",
          "color": "d1a540",
          "default": false,
          "description": "设计模式在JavaScript的实现"
        }
      ],
      "state": "open",
      "locked": false,
      "assignee": null,
      "assignees": [],
      "milestone": null,
      "comments": 0,
      "created_at": "2019-08-20T09:37:17Z",
      "updated_at": "2021-12-21T09:41:37Z",
      "closed_at": null,
      "author_association": "OWNER",
      "active_lock_reason": null,
      "body": "## 前言\r\n\r\n代理模式是为一个对象提供一个代用品或占位符，以便控制对它的访问。\r\n例如：\r\n![1](https://user-images.githubusercontent.com/39508895/63336089-23272700-c371-11e9-8bf0-f31c74e016b6.jpg)\r\n\r\n下面就介绍最常用的几种场景\r\n\r\n## 保护代理\r\n\r\n例如作为孩子我们总希望他健康成长，在成长路上遇到的烦恼会被家长解决，这样来看其实就是保护代理，下面用一段伪代码来实现。\r\n\r\n```js\r\nfunction Children() {\r\n  this.knowledge = [];\r\n}\r\nChildren.prototype.Study = function(content) {\r\n  // ...学习，增加知识\r\n  this.knowledge.push(content);\r\n};\r\nvar Parent = (function() {\r\n  var small = new Children();\r\n  return {\r\n    knowledge: function(content) {\r\n      if (content === \"bad\") {\r\n        // 坏的，过滤掉\r\n      } else {\r\n        small.Study(content);\r\n      }\r\n    }\r\n  };\r\n})();\r\n```\r\n\r\n上面用伪代码的形式来实现了一个保护例子，不过你可能会困惑，这样不是多此一举么，我们完全可以在`Children`内部实现，不过这样做\r\n\r\n1. 增加了程序耦合度，如果想要过滤更多，或者某一天不过滤了，还要更改代码\r\n2. 违背了单一原则，对于代码的阅读和维护，造成了更多的成本\r\n\r\n## 缓存代理\r\n\r\n缓存代理是很实用的一个例子，例如一个`阶乘函数`，计算 n 的阶乘，最多需要保存 n 个调用记录，我们可能这样写\r\n\r\n```js\r\nfunction factorial(n) {\r\n  if (n === 1) return 1;\r\n  return n * factorial(n - 1);\r\n}\r\nfactorial(5); // 120\r\n```\r\n\r\n不过如果重复计算 5 或者 10，很明显造成了多次浪费，这个时候就可以使用代理，把结果缓存下来，如果存在就直接返回。\r\n\r\n```js\r\nfunction next(n, total) {\r\n  if (n === 1) return 1;\r\n  return n * factorial(n - 1);\r\n}\r\nvar factorial = (function() {\r\n  var obj = {};\r\n  return function(v) {\r\n    if (obj[v]) {\r\n      return obj[v];\r\n    }\r\n    obj[v] = next(v);\r\n    return obj[v];\r\n  };\r\n})();\r\nfactorial(5); // 120\r\nfactorial(5); // 120\r\n```\r\n\r\n上面就将结果缓存了下来，除此之外还可以引用在异步请求中可以节省加载的时间。\r\n\r\n## 应用场景\r\n\r\n上面简单介绍了两种模式，实际上还有很多，比如虚拟代理、远程代理、防火墙代理等，不过这里不做介绍了，下面看看使用场景。\r\n\r\n### jquery\r\n\r\n`jquery`基于链式调用，比如`$('.a').html('').text('')`，不过你会不会很好奇，`$()`调用的时候它是怎么记录这个值的呢，每次调用`$()`存储的 dom 都不相同，实际上它就是借用了代理模式，这里直接贴代码了\r\n\r\n```js\r\nfunction Jquery(dom) {\r\n  this.dom = dom;\r\n}\r\n// 代理者\r\nfunction $(dom) {\r\n  return new Jquery(dom);\r\n}\r\n$.prototype = Jquery.prototype = {\r\n  // 只做演示，不涉及具体代码\r\n  html() {\r\n    return this;\r\n  },\r\n  text() {\r\n    return this;\r\n  }\r\n};\r\n$(\".a\")\r\n  .html(\"\")\r\n  .text(\"\");\r\n```\r\n\r\n### vue\r\n\r\n我们在使用 vue 的时候给定了配置项`data`，它是一个对象，里面的属性会被 vue 响应式处理，我们可以通过`this.`的方式来简单访问，也是用了代理模式，下面就用一段伪 vue 代码来说明\r\n\r\n```js\r\nclass Mvvm {\r\n  constructor(option = {}) {\r\n    this.$option = option;\r\n    this._data = option.data || {};\r\n    // 代理数据\r\n    for (const name in this._data) {\r\n      Object.defineProperty(this, name, {\r\n        configurable: true,\r\n        enumerable: true,\r\n        get() {\r\n          return this._data[name];\r\n        },\r\n        set(v) {\r\n          return (this._data[name] = v);\r\n        }\r\n      });\r\n    }\r\n  }\r\n}\r\nexport default Mvvm;\r\n```\r\n\r\n可以复制上面代码，自己简单试下。\r\n",
      "reactions": {
        "url": "https://api.github.com/repos/bosens-China/blog/issues/21/reactions",
        "total_count": 0,
        "+1": 0,
        "-1": 0,
        "laugh": 0,
        "hooray": 0,
        "confused": 0,
        "heart": 0,
        "rocket": 0,
        "eyes": 0
      },
      "timeline_url": "https://api.github.com/repos/bosens-China/blog/issues/21/timeline",
      "performed_via_github_app": null,
      "state_reason": null
    },
    {
      "url": "https://api.github.com/repos/bosens-China/blog/issues/13",
      "repository_url": "https://api.github.com/repos/bosens-China/blog",
      "labels_url": "https://api.github.com/repos/bosens-China/blog/issues/13/labels{/name}",
      "comments_url": "https://api.github.com/repos/bosens-China/blog/issues/13/comments",
      "events_url": "https://api.github.com/repos/bosens-China/blog/issues/13/events",
      "html_url": "https://github.com/bosens-China/blog/issues/13",
      "id": 479666633,
      "node_id": "MDU6SXNzdWU0Nzk2NjY2MzM=",
      "number": 13,
      "title": "相等运算符比较",
      "user": {
        "login": "bosens-China",
        "id": 39508895,
        "node_id": "MDQ6VXNlcjM5NTA4ODk1",
        "avatar_url": "https://avatars.githubusercontent.com/u/39508895?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bosens-China",
        "html_url": "https://github.com/bosens-China",
        "followers_url": "https://api.github.com/users/bosens-China/followers",
        "following_url": "https://api.github.com/users/bosens-China/following{/other_user}",
        "gists_url": "https://api.github.com/users/bosens-China/gists{/gist_id}",
        "starred_url": "https://api.github.com/users/bosens-China/starred{/owner}{/repo}",
        "subscriptions_url": "https://api.github.com/users/bosens-China/subscriptions",
        "organizations_url": "https://api.github.com/users/bosens-China/orgs",
        "repos_url": "https://api.github.com/users/bosens-China/repos",
        "events_url": "https://api.github.com/users/bosens-China/events{/privacy}",
        "received_events_url": "https://api.github.com/users/bosens-China/received_events",
        "type": "User",
        "site_admin": false
      },
      "labels": [
        {
          "id": 1602397157,
          "node_id": "MDU6TGFiZWwxNjAyMzk3MTU3",
          "url": "https://api.github.com/repos/bosens-China/blog/labels/%E6%B7%B1%E5%85%A5%E7%B3%BB%E5%88%97",
          "name": "深入系列",
          "color": "719192",
          "default": false,
          "description": "主要介绍实现的思路"
        }
      ],
      "state": "open",
      "locked": false,
      "assignee": null,
      "assignees": [],
      "milestone": null,
      "comments": 0,
      "created_at": "2019-08-12T14:08:20Z",
      "updated_at": "2021-12-21T09:40:08Z",
      "closed_at": null,
      "author_association": "OWNER",
      "active_lock_reason": null,
      "body": "> 看《你所不知道的JavaScript》一书，发现对相等运算符的描述推翻了许多人的固有影响，如果熟悉其机制，可以方便我们快速开发\r\n``` js\r\nfunction foo(s) {\r\n  s = s == null ?  true: s;\r\n  // ...\r\n};\r\n```\r\n上面这段代码我们估计经常使用，其实就是使用了隐式转换，下面就来聊聊相等运算符\r\n\r\n## 规则\r\n1. 数值与字符串比较，转化为数值比较\r\n``` js\r\n42 == \"42\";\r\n// 等于\r\n42 == Number(\"42\");\r\n```\r\n2. 布尔型与其他类型比较，转化为数值，之后比较\r\n``` js\r\n\"42\" == true;\r\n// 等于\r\n\"42\" == Number(true);\r\n\"42\" == 1;\r\nNumber(\"42\") == 1;\r\n```\r\n3. undefined 只与 null 相等，其他返回 false\r\n``` js\r\n// 全部false\r\nnull == false;\r\nnull == true;\r\nnull == \"\";\r\nnull == 0;\r\nundefined == true;\r\nundefined == false;\r\nundefined == \"\";\r\nundefined == 0;\r\n```\r\n4. 对象\r\n对象与基本类型比较，会将对象转化为基本类型之后再进行比较；\r\n转化规则很简单，默认调用 `valueOf`，如果返回不是基本类型继续调用 `toStirng`，如果返回还不是基本类型会报错。\r\n``` js\r\n[42] == 42;\r\n// 等于\r\n\"42\" == 42;\r\nNumber(\"42\") == 42;\r\n\r\n\"abc\" == new String(\"abc\");\r\n// 等于\r\n\"abc\" == \"abc\";\r\n```\r\n根据对象转化规则，我们自定义返回的值，比如：\r\n``` js\r\nvar a = [];\r\na.valueOf = function() {\r\n  return 42;\r\n};\r\na.toString = function() {\r\n  return \"123\";\r\n};\r\na == 42; //true\r\n```\r\n\r\n## 实战\r\n上面简单介绍了一下规则，再来看一下隐形的问题\r\n1. [] = ![]\r\n这里会返回 true 原因很简单，根据上述规则其实也就是\"\" == 0比较\r\n2. 0 == '\\n' \r\n这里会返回 true，因为空格和一些其他制表符会被忽略掉。 再来看一些常见的陷阱\r\n``` js\r\n\"0\" == false; // true\r\nfalse == 0; // true\r\nfalse == \"\"; // true\r\nfalse == []; // true\r\n\"\" == []; // true\r\n0 == []; // true\r\n\"\" == 0; // true\r\n```\r\n3. [null] == \"\"\r\n这里为true，可能你在想[null]返回的不就是字符串 null 么，不过很遗憾，**null 和 undefined，在数组中转化为字符串为\"\"**，这是 JavaScript 所规定的。\r\n``` js\r\n[null] == \"\";\r\n// 转化为\r\n\"\" == \"\";\r\n```\r\n\r\n## 最后\r\n``` js\r\n// a可能为true执行下去么\r\nif (a == 2 && a == 3) {\r\n  // 执行里面的代码\r\n}\r\n```",
      "reactions": {
        "url": "https://api.github.com/repos/bosens-China/blog/issues/13/reactions",
        "total_count": 0,
        "+1": 0,
        "-1": 0,
        "laugh": 0,
        "hooray": 0,
        "confused": 0,
        "heart": 0,
        "rocket": 0,
        "eyes": 0
      },
      "timeline_url": "https://api.github.com/repos/bosens-China/blog/issues/13/timeline",
      "performed_via_github_app": null,
      "state_reason": null
    },
    {
      "url": "https://api.github.com/repos/bosens-China/blog/issues/3",
      "repository_url": "https://api.github.com/repos/bosens-China/blog",
      "labels_url": "https://api.github.com/repos/bosens-China/blog/issues/3/labels{/name}",
      "comments_url": "https://api.github.com/repos/bosens-China/blog/issues/3/comments",
      "events_url": "https://api.github.com/repos/bosens-China/blog/issues/3/events",
      "html_url": "https://github.com/bosens-China/blog/issues/3",
      "id": 475021768,
      "node_id": "MDU6SXNzdWU0NzUwMjE3Njg=",
      "number": 3,
      "title": "函数防抖",
      "user": {
        "login": "bosens-China",
        "id": 39508895,
        "node_id": "MDQ6VXNlcjM5NTA4ODk1",
        "avatar_url": "https://avatars.githubusercontent.com/u/39508895?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bosens-China",
        "html_url": "https://github.com/bosens-China",
        "followers_url": "https://api.github.com/users/bosens-China/followers",
        "following_url": "https://api.github.com/users/bosens-China/following{/other_user}",
        "gists_url": "https://api.github.com/users/bosens-China/gists{/gist_id}",
        "starred_url": "https://api.github.com/users/bosens-China/starred{/owner}{/repo}",
        "subscriptions_url": "https://api.github.com/users/bosens-China/subscriptions",
        "organizations_url": "https://api.github.com/users/bosens-China/orgs",
        "repos_url": "https://api.github.com/users/bosens-China/repos",
        "events_url": "https://api.github.com/users/bosens-China/events{/privacy}",
        "received_events_url": "https://api.github.com/users/bosens-China/received_events",
        "type": "User",
        "site_admin": false
      },
      "labels": [
        {
          "id": 1602397157,
          "node_id": "MDU6TGFiZWwxNjAyMzk3MTU3",
          "url": "https://api.github.com/repos/bosens-China/blog/labels/%E6%B7%B1%E5%85%A5%E7%B3%BB%E5%88%97",
          "name": "深入系列",
          "color": "719192",
          "default": false,
          "description": "主要介绍实现的思路"
        }
      ],
      "state": "open",
      "locked": false,
      "assignee": null,
      "assignees": [],
      "milestone": null,
      "comments": 0,
      "created_at": "2019-07-31T09:01:16Z",
      "updated_at": "2021-12-21T09:39:39Z",
      "closed_at": null,
      "author_association": "OWNER",
      "active_lock_reason": null,
      "body": "## 前言\r\n\r\n1. 为什么需要使用防抖函数\r\n   当一个事件触发太多的时候会出现性能问题，比如`mousemove`、`resize`、`scroll`等，看一个没有任何防抖的`mousemove`事件\r\n\r\n![1](https://user-images.githubusercontent.com/39508895/62198507-526ef780-b3b4-11e9-8019-21e510329930.gif)\r\n\r\n2. 什么是防抖?\r\n   简单就是你任意触发我只执行最后一次操作\r\n\r\n根据上面的定义可以很轻松编写出一个简单的防抖函数\r\n\r\n### 实现\r\n\r\n```js\r\n// 第一版\r\nfunction antiShake(call, time) {\r\n  var i = null;\r\n  return function() {\r\n    clearTimeout(i);\r\n    i = setTimeout(call, time);\r\n  };\r\n}\r\n```\r\n\r\n![2](https://user-images.githubusercontent.com/39508895/62198572-77fc0100-b3b4-11e9-8ad5-a46ac6a5a2e1.gif)\r\n\r\n### this 以及参数\r\n\r\n不过这样有一个问题，就是 this 指向不正确以及参数丢失，这里以`mousemove`为例，触发函数的时候会有一个`MouseEvent`对象，如果打印函数参数会发现为`undefined`，下面就来修复一下\r\n\r\n```js\r\n//  第二版\r\nfunction antiShake(call, time) {\r\n  var i = null;\r\n  return function() {\r\n    var that = this;\r\n    var rest = arguments;\r\n    clearTimeout(i);\r\n    i = setTimeout(function() {\r\n      call.apply(that, rest);\r\n    }, time);\r\n  };\r\n}\r\n```\r\n\r\n### 立即执行\r\n\r\n有时候我不想让他等待时间结束在执行，而是一开始就触发\r\n![4](https://user-images.githubusercontent.com/39508895/62198651-99f58380-b3b4-11e9-9fbc-78e805b13910.gif)\r\n\r\n```js\r\n// 第三版\r\nfunction antiShake(call, time, immediately) {\r\n  var i = null;\r\n  return function() {\r\n    var that = this;\r\n    var rest = arguments;\r\n    clearTimeout(i);\r\n    if (immediately) {\r\n      var reversal = !i;\r\n      i = setTimeout(function() {\r\n        i = null;\r\n      }, time);\r\n\r\n      if (reversal) {\r\n        call.apply(that, rest);\r\n      }\r\n    } else {\r\n      i = setTimeout(function() {\r\n        call.apply(that, rest);\r\n      }, time);\r\n    }\r\n  };\r\n}\r\n```\r\n\r\n### 返回值\r\n\r\n异步执行的函数我们没办法同步返回他的值，但是对于立即执行的函数，我们应当把值返回\r\n\r\n```js\r\n// 第四版\r\nfunction antiShake(call, time, immediately) {\r\n  var i = null;\r\n  return function() {\r\n    var that = this;\r\n    var rest = arguments;\r\n    clearTimeout(i);\r\n    if (immediately) {\r\n      var reversal = !i;\r\n      i = setTimeout(function() {\r\n        i = null;\r\n      }, time);\r\n\r\n      if (reversal) {\r\n        return call.apply(that, rest);\r\n      }\r\n    } else {\r\n      i = setTimeout(function() {\r\n        call.apply(that, rest);\r\n      }, time);\r\n    }\r\n  };\r\n}\r\n```\r\n\r\n### 取消\r\n\r\n到这里基本上防抖函数就基本写完了，上述我们用`mousemove`事件举例，但是我想当鼠标移开的时候我想取消这个事件，这也是正常的需求，下面就来实现取消功能\r\n\r\n```js\r\nfunction antiShake(call, time, immediately) {\r\n  var i = null;\r\n  function _private() {\r\n    var that = this;\r\n    var rest = arguments;\r\n    clearTimeout(i);\r\n    if (immediately) {\r\n      var reversal = !i;\r\n      i = setTimeout(function() {\r\n        i = null;\r\n      }, time);\r\n\r\n      if (reversal) {\r\n        return call.apply(that, rest);\r\n      }\r\n    } else {\r\n      i = setTimeout(function() {\r\n        call.apply(that, rest);\r\n      }, time);\r\n    }\r\n  }\r\n  _private.cancel = function() {\r\n    clearTimeout(i);\r\n    i = null;\r\n  };\r\n  return _private;\r\n}\r\n```\r\n\r\n![5](https://user-images.githubusercontent.com/39508895/62198673-a5e14580-b3b4-11e9-9ced-acc7814031dc.gif)\r\n",
      "reactions": {
        "url": "https://api.github.com/repos/bosens-China/blog/issues/3/reactions",
        "total_count": 0,
        "+1": 0,
        "-1": 0,
        "laugh": 0,
        "hooray": 0,
        "confused": 0,
        "heart": 0,
        "rocket": 0,
        "eyes": 0
      },
      "timeline_url": "https://api.github.com/repos/bosens-China/blog/issues/3/timeline",
      "performed_via_github_app": null,
      "state_reason": null
    },
    {
      "url": "https://api.github.com/repos/bosens-China/blog/issues/5",
      "repository_url": "https://api.github.com/repos/bosens-China/blog",
      "labels_url": "https://api.github.com/repos/bosens-China/blog/issues/5/labels{/name}",
      "comments_url": "https://api.github.com/repos/bosens-China/blog/issues/5/comments",
      "events_url": "https://api.github.com/repos/bosens-China/blog/issues/5/events",
      "html_url": "https://github.com/bosens-China/blog/issues/5",
      "id": 479484473,
      "node_id": "MDU6SXNzdWU0Nzk0ODQ0NzM=",
      "number": 5,
      "title": "函数节流",
      "user": {
        "login": "bosens-China",
        "id": 39508895,
        "node_id": "MDQ6VXNlcjM5NTA4ODk1",
        "avatar_url": "https://avatars.githubusercontent.com/u/39508895?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bosens-China",
        "html_url": "https://github.com/bosens-China",
        "followers_url": "https://api.github.com/users/bosens-China/followers",
        "following_url": "https://api.github.com/users/bosens-China/following{/other_user}",
        "gists_url": "https://api.github.com/users/bosens-China/gists{/gist_id}",
        "starred_url": "https://api.github.com/users/bosens-China/starred{/owner}{/repo}",
        "subscriptions_url": "https://api.github.com/users/bosens-China/subscriptions",
        "organizations_url": "https://api.github.com/users/bosens-China/orgs",
        "repos_url": "https://api.github.com/users/bosens-China/repos",
        "events_url": "https://api.github.com/users/bosens-China/events{/privacy}",
        "received_events_url": "https://api.github.com/users/bosens-China/received_events",
        "type": "User",
        "site_admin": false
      },
      "labels": [
        {
          "id": 1602397157,
          "node_id": "MDU6TGFiZWwxNjAyMzk3MTU3",
          "url": "https://api.github.com/repos/bosens-China/blog/labels/%E6%B7%B1%E5%85%A5%E7%B3%BB%E5%88%97",
          "name": "深入系列",
          "color": "719192",
          "default": false,
          "description": "主要介绍实现的思路"
        }
      ],
      "state": "open",
      "locked": false,
      "assignee": null,
      "assignees": [],
      "milestone": null,
      "comments": 0,
      "created_at": "2019-08-12T06:23:18Z",
      "updated_at": "2021-12-21T09:39:31Z",
      "closed_at": null,
      "author_association": "OWNER",
      "active_lock_reason": null,
      "body": "本来打算从零写一个，不过意外看到一篇好文，下面就根据他的思路来实现一个节流，[JavaScript专题之跟着 underscore 学节流 ](https://github.com/mqyqingfeng/Blog/issues/26)\r\n\r\n## 前言\r\n节流有两种实现，第一种使用定时器，另外一种则是根据时间戳，判断两次执行的时间间隔，下面简单些一下这两种的实现。\r\n- 定时器\r\n``` js\r\nfunction throttle(fn, time) {\r\n  let timing = null;\r\n  return function(...rest) {\r\n    if(!timing) {\r\n      timing = setTimeout(() => {\r\n        timing = null;\r\n        fn.apply(this, rest);\r\n      }, time);\r\n    }\r\n  };\r\n};\r\n```\r\n- 时间戳\r\n``` js\r\nfunction throttle (fn, time) {\r\n  let times = 0;\r\n  return function (...rest) {\r\n    const s = time - (new Date().getTime() - times)\r\n    if (s <= 0) {\r\n      times = new Date().getTime();\r\n      fn.apply(this, rest);\r\n    }\r\n  };\r\n};\r\n```\r\n下面就是将两者结合起来\r\n\r\n## 节流\r\n``` js\r\n// 节流\r\n// initial初始立即执行，front最后执行一次\r\nfunction throttle (fn, time, { initial = true, front = false } = {}) {\r\n  // 上一次执行时间\r\n  let times = 0;\r\n  // 定时器\r\n  let timing = null;\r\n  function next (...args) {\r\n    // 判断条件，如果不是初始执行，改用定时器方法执行\r\n    if (!initial && !times) {\r\n      times = new Date().getTime();\r\n    }\r\n    const now = time - (new Date().getTime() - times);\r\n    // now > time是判断更改系统时间的边界问题，now正常情况下，肯定小于time\r\n    if (now <= 0 || now > time) {\r\n      if (!timing) {\r\n        clearTimeout(timing);\r\n        timing = null;\r\n      }\r\n      times = new Date().getTime();\r\n      fn.apply(this, args);\r\n      // 清理一下内存\r\n      if (!timing) {\r\n        args = null;\r\n      }\r\n    } else if (!timing && front) {\r\n      timing = setTimeout(() => {\r\n        timing = null;\r\n        times = initial ? 0 : new Date().getTime();\r\n        fn.apply(this, args);\r\n        if (!timing) {\r\n          args = null;\r\n        }\r\n      }, time);\r\n    }\r\n  }\r\n  // 取消\r\n  next.cancel = function () {\r\n    clearTimeout(timing);\r\n    timing = null;\r\n    // 为0即可，上面有初始判断条件\r\n    times = 0;\r\n  };\r\n  return next;\r\n};\r\n```\r\n## 注意\r\n上面有两个参数，但是不能同时设置为false",
      "reactions": {
        "url": "https://api.github.com/repos/bosens-China/blog/issues/5/reactions",
        "total_count": 0,
        "+1": 0,
        "-1": 0,
        "laugh": 0,
        "hooray": 0,
        "confused": 0,
        "heart": 0,
        "rocket": 0,
        "eyes": 0
      },
      "timeline_url": "https://api.github.com/repos/bosens-China/blog/issues/5/timeline",
      "performed_via_github_app": null,
      "state_reason": null
    },
    {
      "url": "https://api.github.com/repos/bosens-China/blog/issues/7",
      "repository_url": "https://api.github.com/repos/bosens-China/blog",
      "labels_url": "https://api.github.com/repos/bosens-China/blog/issues/7/labels{/name}",
      "comments_url": "https://api.github.com/repos/bosens-China/blog/issues/7/comments",
      "events_url": "https://api.github.com/repos/bosens-China/blog/issues/7/events",
      "html_url": "https://github.com/bosens-China/blog/issues/7",
      "id": 479646858,
      "node_id": "MDU6SXNzdWU0Nzk2NDY4NTg=",
      "number": 7,
      "title": "使用rollup编写现代化模块",
      "user": {
        "login": "bosens-China",
        "id": 39508895,
        "node_id": "MDQ6VXNlcjM5NTA4ODk1",
        "avatar_url": "https://avatars.githubusercontent.com/u/39508895?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bosens-China",
        "html_url": "https://github.com/bosens-China",
        "followers_url": "https://api.github.com/users/bosens-China/followers",
        "following_url": "https://api.github.com/users/bosens-China/following{/other_user}",
        "gists_url": "https://api.github.com/users/bosens-China/gists{/gist_id}",
        "starred_url": "https://api.github.com/users/bosens-China/starred{/owner}{/repo}",
        "subscriptions_url": "https://api.github.com/users/bosens-China/subscriptions",
        "organizations_url": "https://api.github.com/users/bosens-China/orgs",
        "repos_url": "https://api.github.com/users/bosens-China/repos",
        "events_url": "https://api.github.com/users/bosens-China/events{/privacy}",
        "received_events_url": "https://api.github.com/users/bosens-China/received_events",
        "type": "User",
        "site_admin": false
      },
      "labels": [
        {
          "id": 1740577858,
          "node_id": "MDU6TGFiZWwxNzQwNTc3ODU4",
          "url": "https://api.github.com/repos/bosens-China/blog/labels/%E5%B7%A5%E5%85%B7%E7%9B%B8%E5%85%B3",
          "name": "工具相关",
          "color": "f73d62",
          "default": false,
          "description": "工程化相关的东西"
        }
      ],
      "state": "open",
      "locked": false,
      "assignee": null,
      "assignees": [],
      "milestone": null,
      "comments": 0,
      "created_at": "2019-08-12T13:30:02Z",
      "updated_at": "2021-12-21T09:34:35Z",
      "closed_at": null,
      "author_association": "OWNER",
      "active_lock_reason": null,
      "body": "> 之所有选用 rollup 是因为它可以减少打包体积和提高构建速度，下面介绍不会详细讲解配置，你可以自行查阅官方文档\r\n\r\nES6 已经出现很久了，但是为了兼容以前的浏览器，我们还是需要使用各种构建工具，例如 webpack，在使用的时候很方便，可以通过 babel 转换 es6 的语法，比如下面导入一个模块\r\n\r\n`import moduleName from 'module';`\r\n\r\n不过编写一个现代化模块呢，预定目标应该有三点\r\n\r\n1.  支持 typescript，将 ES6 代码转化为 ES5 环境使用\r\n2.  支持构建工具和`script type=\"module\"`的导入\r\n3.  支持 umd 格式引用\r\n\r\n就以下面这段代码为演示，实现上述的目标\r\n\r\n```js\r\nexport default (arr = []) => {\r\n  return Array.from(arr).length;\r\n};\r\n```\r\n\r\n## 准备\r\n\r\n```sh\r\nnpm init -y\r\nnpm i rollup -D\r\ncd.>rollup.config.js\r\nmd src\r\ncd.>src/index.js\r\n```\r\n\r\n这样就创建好我们想要的基本结构了，将上面例子复制到 `index.js` 文件下。\r\n\r\n`rollup`可以通过命令行也可以通过脚本来调用，这里在`package.json`的`scripts`字段，通过脚本调用\r\n\r\n```json\r\n  \"scripts\": {\r\n    \"build\": \"rollup -c\"\r\n  }\r\n```\r\n\r\n`-c`是指配置文件，默认就是`rollup.config.js`所以不需要额外配置了\r\n\r\n## 编写第一个例子\r\n\r\nrollup.config.js\r\n\r\n```js\r\nexport default {\r\n  input: \"./src/index.js\",\r\n  output: [\r\n    {\r\n      file: \"dist/index.esm.browser.js\",\r\n      format: \"es\",\r\n      sourcemap: true\r\n    }\r\n  ]\r\n};\r\n```\r\n\r\n上面配置信息`input`指的是入口文件，`output` 是出口文件，`file`是输出的文件路径，`sourcemap`是是否输出 map 文件，他可以方便调试错误，在开发模块中应该是必须的，`format`是指输出的格式\r\n\r\n- amd\r\n  异步模块定义，用于像 RequireJS 这样的模块加载器\r\n- cjs\r\n  CommonJS，适用于 Node 和 Browserify/Webpack\r\n- es\r\n  将软件包保存为 ES 模块文件\r\n- iife\r\n  一个自动执行的功能，适合作为<\\script>标签。（如果要为应用程序创建一个捆绑包，您可能想要使用它，因为它会使文件大小变小。）\r\n- umd\r\n  通用模块定义，以 amd，cjs 和 iife 为一体\r\n\r\n执行`npm run build`\r\n\r\ndist/index.esm.browser.js\r\n\r\n```js\r\nvar index = (arr = []) => {\r\n  return Array.from(arr).length;\r\n};\r\n\r\nexport default index;\r\n//# sourceMappingURL=index.esm.browser.js.map\r\n```\r\n\r\n可以看到生成的信息十分简洁，上面说到要同时支持`umd` 格式和 `import` 导入，`import`可以通过`es`的形式来供构建工具和`script type=\"module\"`使用，下面就来定义一下 umd 格式\r\n\r\n```js\r\nexport default {\r\n  input: \"./src/index.js\",\r\n  output: [\r\n    {\r\n      file: \"dist/index.esm.browser.js\",\r\n      format: \"es\",\r\n      sourcemap: true\r\n    },\r\n    {\r\n      file: \"dist/index.js\",\r\n      format: \"umd\",\r\n      sourcemap: true,\r\n      name: \"index\"\r\n    }\r\n  ]\r\n};\r\n```\r\n\r\n**注意**使用`umd`或者`iife`必须指定 name 字段，他决定了暴露在全局作用下的变量名，再次执行可以看到`index.js`的信息了。\r\n\r\n## babel\r\n\r\n上面完成了需求的第一步，不过对于 es6 的代码，并没有转化为 es5 的形式，只是将语法转换了，`Array.from`依旧存在，下面使用`babel`来完成需求\r\n\r\n```sh\r\nnpm i @babel/core @babel/preset-env  core-js rollup-plugin-babel rollup-plugin-node-resolve rollup-plugin-commonjs -D\r\n```\r\n\r\nbabel.config.js\r\n\r\n```js\r\nmodule.exports = {\r\n  presets: [\r\n    [\r\n      \"@babel/preset-env\",\r\n      {\r\n        useBuiltIns: \"usage\",\r\n        corejs: 3,\r\n        modules: false\r\n      }\r\n    ]\r\n  ]\r\n};\r\n```\r\n\r\n上面代码的`useBuiltIns`的`usage`是 babel7 的实验性特性，他支持按需加载\r\n\r\nrollup.config.js\r\n\r\n```js\r\nimport babel from \"rollup-plugin-babel\";\r\nimport resolve from \"rollup-plugin-node-resolve\";\r\nimport commonjs from \"rollup-plugin-commonjs\";\r\nexport default {\r\n  input: \"./src/index.js\",\r\n  output: [\r\n    {\r\n      file: \"dist/index.esm.browser.js\",\r\n      format: \"es\",\r\n      sourcemap: true\r\n    },\r\n    {\r\n      file: \"dist/index.js\",\r\n      format: \"umd\",\r\n      sourcemap: true,\r\n      name: \"index\"\r\n    }\r\n  ],\r\n  plugins: [\r\n    commonjs(),\r\n    resolve(),\r\n    babel({\r\n      exclude: [/\\/core-js\\//],\r\n      runtimeHelpers: true,\r\n      sourceMap: true,\r\n      extensions: [\".js\", \".jsx\", \".es6\", \".es\", \".mjs\", \".ts\"]\r\n    })\r\n  ]\r\n};\r\n```\r\n\r\n再次执行可以看到`Arrar.from`已经被`babel`转换为 ES5 的环境了\r\n\r\n## typescript\r\n\r\n这个我们用`babel`提供给我们的`@babel/preset-typescript`即可完成，不过为了支持`typescript`一些其他扩展语法，我们还需要安装一些插件\r\n\r\n```sh\r\nnpm i @babel/preset-typescript @babel/plugin-transform-typescript @babel/plugin-syntax-dynamic-import @babel/plugin-proposal-class-properties -D\r\n```\r\n\r\nbabel.config.js\r\n\r\n```js\r\nmodule.exports = {\r\n  presets: [\r\n    [\r\n      \"@babel/preset-env\",\r\n      {\r\n        useBuiltIns: \"usage\",\r\n        corejs: 3,\r\n        modules: false\r\n      }\r\n    ],\r\n    [\"@babel/preset-typescript\"]\r\n  ],\r\n  plugins: [\r\n    \"@babel/plugin-transform-typescript\",\r\n    \"@babel/plugin-syntax-dynamic-import\",\r\n    \"@babel/plugin-proposal-class-properties\"\r\n  ]\r\n};\r\n```\r\n\r\n修改一下 `src/index.js` 为 `index.ts`，`rollup.config.js` 下`input`字段\r\n\r\n```js\r\nexport default (arr: Array<any> = []): number => {\r\n  return Array.from(arr).length;\r\n};\r\n```\r\n\r\n再次执行`npm run build`，成功输出\r\n\r\n## 优化\r\n\r\n1. 输出代码没有被压缩\r\n2. 每次输出的时候文件夹没有被删除\r\n\r\n上面两个问题，可以通过插件来解决\r\n\r\n```sh\r\nnpm i rollup-plugin-terser rollup-plugin-clear -D\r\n```\r\n\r\nrollup.config.js\r\n\r\n```js\r\nimport babel from \"rollup-plugin-babel\";\r\nimport clear from \"rollup-plugin-clear\";\r\nimport resolve from \"rollup-plugin-node-resolve\";\r\nimport commonjs from \"rollup-plugin-commonjs\";\r\nimport { terser } from \"rollup-plugin-terser\";\r\nexport default {\r\n  input: \"./src/index.ts\",\r\n  output: [\r\n    {\r\n      file: \"dist/index.esm.browser.js\",\r\n      format: \"es\",\r\n      sourcemap: true\r\n    },\r\n    {\r\n      file: \"dist/index.js\",\r\n      format: \"umd\",\r\n      sourcemap: true,\r\n      name: \"index\"\r\n    }\r\n  ],\r\n  plugins: [\r\n    clear({\r\n      targets: [\"dist\"]\r\n    }),\r\n    resolve(),\r\n    commonjs(),\r\n    terser(),\r\n    babel({\r\n      exclude: [/\\/core-js\\//],\r\n      runtimeHelpers: true,\r\n      sourceMap: true,\r\n      extensions: [\".js\", \".jsx\", \".es6\", \".es\", \".mjs\", \".ts\"]\r\n    })\r\n  ]\r\n};\r\n```\r\n这样基本的模块的基本功能就编写完成了",
      "reactions": {
        "url": "https://api.github.com/repos/bosens-China/blog/issues/7/reactions",
        "total_count": 0,
        "+1": 0,
        "-1": 0,
        "laugh": 0,
        "hooray": 0,
        "confused": 0,
        "heart": 0,
        "rocket": 0,
        "eyes": 0
      },
      "timeline_url": "https://api.github.com/repos/bosens-China/blog/issues/7/timeline",
      "performed_via_github_app": null,
      "state_reason": null
    },
    {
      "url": "https://api.github.com/repos/bosens-China/blog/issues/2",
      "repository_url": "https://api.github.com/repos/bosens-China/blog",
      "labels_url": "https://api.github.com/repos/bosens-China/blog/issues/2/labels{/name}",
      "comments_url": "https://api.github.com/repos/bosens-China/blog/issues/2/comments",
      "events_url": "https://api.github.com/repos/bosens-China/blog/issues/2/events",
      "html_url": "https://github.com/bosens-China/blog/issues/2",
      "id": 473943664,
      "node_id": "MDU6SXNzdWU0NzM5NDM2NjQ=",
      "number": 2,
      "title": "漫谈ECMAScript有意思的设计",
      "user": {
        "login": "bosens-China",
        "id": 39508895,
        "node_id": "MDQ6VXNlcjM5NTA4ODk1",
        "avatar_url": "https://avatars.githubusercontent.com/u/39508895?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bosens-China",
        "html_url": "https://github.com/bosens-China",
        "followers_url": "https://api.github.com/users/bosens-China/followers",
        "following_url": "https://api.github.com/users/bosens-China/following{/other_user}",
        "gists_url": "https://api.github.com/users/bosens-China/gists{/gist_id}",
        "starred_url": "https://api.github.com/users/bosens-China/starred{/owner}{/repo}",
        "subscriptions_url": "https://api.github.com/users/bosens-China/subscriptions",
        "organizations_url": "https://api.github.com/users/bosens-China/orgs",
        "repos_url": "https://api.github.com/users/bosens-China/repos",
        "events_url": "https://api.github.com/users/bosens-China/events{/privacy}",
        "received_events_url": "https://api.github.com/users/bosens-China/received_events",
        "type": "User",
        "site_admin": false
      },
      "labels": [
        {
          "id": 1371686608,
          "node_id": "MDU6TGFiZWwxMzcxNjg2NjA4",
          "url": "https://api.github.com/repos/bosens-China/blog/labels/%E6%BC%AB%E8%B0%88%E7%B3%BB%E5%88%97",
          "name": "漫谈系列",
          "color": "e7f3ee",
          "default": false,
          "description": "浅谈类文章"
        }
      ],
      "state": "open",
      "locked": false,
      "assignee": null,
      "assignees": [],
      "milestone": null,
      "comments": 0,
      "created_at": "2019-07-29T09:23:22Z",
      "updated_at": "2021-12-21T09:33:52Z",
      "closed_at": null,
      "author_association": "OWNER",
      "active_lock_reason": null,
      "body": "最近重读《你所不知道的 JavaScript》发现一些有趣的点，想分享下。\r\n\r\n## 块级作用域\r\n\r\nES6 引用了 let 和 const，这实际上带来了块级作用域，在 ES6 之前只存在全局作用域和函数作用域，相信小伙伴对这句话应当不陌生，下面就来聊聊一个 ES6 之前如果实现块级作用域。\r\n\r\n思考下面一个例子代码输出值为多少\r\n\r\n```js\r\nfor (var i = 0; i < 10; i++) {\r\n  setTimeout(function () {\r\n    console.log(i);\r\n  }, 100);\r\n}\r\n```\r\n\r\n这里会输出 10 个 10，因为只存在一个全局变量`i`，我们可以通过立即执行函数来解决这个问题\r\n\r\n```js\r\nfor (var i = 0; i < 10; i++) {\r\n  (function (i) {\r\n    setTimeout(function () {\r\n      console.log(i);\r\n    }, 100);\r\n  })(i);\r\n}\r\n```\r\n\r\n如果在 ES6 环境下还可以使用 let 命令解决，它会在每次循环的时候创建一个作用域，至于为什么能记住上一次的值，那是因为 js 引擎会记住上一次循环的值。\r\n\r\n```js\r\nfor (let i = 0; i < 10; i++) {\r\n  setTimeout(() => {\r\n    console.log(i);\r\n  }, 100);\r\n}\r\n```\r\n\r\n上面的例子帮我们回顾一下没有块级作用域的痛苦之一，实际上我们写项目的时候可能早早的就使用了`babel`，它会通过怎么样的形式将`let`和`const`转化为支持 ES5 的环境呢？\r\n\r\n先看下面一个例子\r\n\r\n```js\r\ntry {\r\n  throw 5;\r\n} catch (e) {\r\n  console.log(e);\r\n}\r\nconsole.log(e); //error e is not defined\r\n```\r\n\r\n这里 try 会创建一个块级作用域，在全局环境下 a 不存在，所以报错了。\r\n聪明的小伙伴可能已经想到了，可以使用 try 来创建块级作用域，理论上是可行的，不过实际上有两点问题\r\n\r\n1. 性能太慢\r\n2. 语法丑陋，要显示的报错\r\n\r\n我们来看下`babel`怎么处理上面的例子\r\n\r\n```js\r\n'use strict';\r\n\r\nvar _loop = function _loop(i) {\r\n  setTimeout(function () {\r\n    console.log(i);\r\n  }, 100);\r\n};\r\n\r\nfor (var i = 0; i < 10; i++) {\r\n  _loop(i);\r\n}\r\n```\r\n\r\n可以看到与立即执行函数基本相同，不过使用立即执行函数创建块级作用域需要注意一点`this`的指向。\r\n\r\n例如这个例子\r\n\r\n```js\r\nconst obj = {\r\n  foo() {\r\n    for (let i = 0; i < 5; i += 1) {\r\n      setTimeout(() => {\r\n        console.log(this.arr[i]);\r\n      }, 1000);\r\n    }\r\n  },\r\n  arr: [1, 2, 3, 4, 5],\r\n};\r\n```\r\n\r\n箭头函数没有自己的 this 对象，是定义时的对象而不是运行时的对象，在这个例子中指向的是 obj；\r\n如果要把上面的代码转化为 ES5 环境支持的代码，我们可以通过作用域的规则来实现\r\n\r\n```js\r\n(function () {\r\n  var _this = this;\r\n  setTimeout(function () {\r\n    console.log(_this.arr[i]);\r\n  }, 1000);\r\n})();\r\n```\r\n\r\n上面就实现了所需的功能\r\n\r\n## 隐藏的 global 对象\r\n\r\n下面代码假设环境为浏览器环境，JavaScript 有许多设计缺陷，其中不使用声明声明变量，会自动将变量创建在`global`上就是其一，不过下面就来漫谈特殊的`global`对象\r\n\r\n```js\r\nvar a = 10;\r\nb = 20;\r\nwindow.a; //10\r\nwindow.b; //20\r\n```\r\n\r\n### index.html\r\n\r\n创建一个带有 id 的 DOM 元素，html 内的 id 元素也会自动反映在`global`对象上，例如下面\r\n\r\n```html\r\n<div id=\"div\"></div>\r\n<script>\r\n  console.log(typeof div); //object\r\n</script>\r\n```\r\n\r\n通过`id`的 DOM 元素，可以直接使用 DOM 上的一些方法，算是一个奇淫巧技\r\n\r\n```js\r\nconsole.log(div.nodeType); //1\r\nconsole.log(div.nodeName); //DIV\r\n//...\r\n```\r\n\r\n不过应该避免使用 id 的 DOM 元素，不易于代码的可读性，更推荐使用标准获取 dom 的方法。\r\n最后提示一点，如果存在相同的`id`dom，css 代码会作用两个相同的元素\r\n",
      "reactions": {
        "url": "https://api.github.com/repos/bosens-China/blog/issues/2/reactions",
        "total_count": 0,
        "+1": 0,
        "-1": 0,
        "laugh": 0,
        "hooray": 0,
        "confused": 0,
        "heart": 0,
        "rocket": 0,
        "eyes": 0
      },
      "timeline_url": "https://api.github.com/repos/bosens-China/blog/issues/2/timeline",
      "performed_via_github_app": null,
      "state_reason": null
    },
    {
      "url": "https://api.github.com/repos/bosens-China/blog/issues/14",
      "repository_url": "https://api.github.com/repos/bosens-China/blog",
      "labels_url": "https://api.github.com/repos/bosens-China/blog/issues/14/labels{/name}",
      "comments_url": "https://api.github.com/repos/bosens-China/blog/issues/14/comments",
      "events_url": "https://api.github.com/repos/bosens-China/blog/issues/14/events",
      "html_url": "https://github.com/bosens-China/blog/issues/14",
      "id": 479671441,
      "node_id": "MDU6SXNzdWU0Nzk2NzE0NDE=",
      "number": 14,
      "title": "理解原型和原型链",
      "user": {
        "login": "bosens-China",
        "id": 39508895,
        "node_id": "MDQ6VXNlcjM5NTA4ODk1",
        "avatar_url": "https://avatars.githubusercontent.com/u/39508895?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bosens-China",
        "html_url": "https://github.com/bosens-China",
        "followers_url": "https://api.github.com/users/bosens-China/followers",
        "following_url": "https://api.github.com/users/bosens-China/following{/other_user}",
        "gists_url": "https://api.github.com/users/bosens-China/gists{/gist_id}",
        "starred_url": "https://api.github.com/users/bosens-China/starred{/owner}{/repo}",
        "subscriptions_url": "https://api.github.com/users/bosens-China/subscriptions",
        "organizations_url": "https://api.github.com/users/bosens-China/orgs",
        "repos_url": "https://api.github.com/users/bosens-China/repos",
        "events_url": "https://api.github.com/users/bosens-China/events{/privacy}",
        "received_events_url": "https://api.github.com/users/bosens-China/received_events",
        "type": "User",
        "site_admin": false
      },
      "labels": [
        {
          "id": 1602397157,
          "node_id": "MDU6TGFiZWwxNjAyMzk3MTU3",
          "url": "https://api.github.com/repos/bosens-China/blog/labels/%E6%B7%B1%E5%85%A5%E7%B3%BB%E5%88%97",
          "name": "深入系列",
          "color": "719192",
          "default": false,
          "description": "主要介绍实现的思路"
        }
      ],
      "state": "open",
      "locked": false,
      "assignee": null,
      "assignees": [],
      "milestone": null,
      "comments": 0,
      "created_at": "2019-08-12T14:17:35Z",
      "updated_at": "2021-12-21T03:38:33Z",
      "closed_at": null,
      "author_association": "OWNER",
      "active_lock_reason": null,
      "body": "> 参考： [深入理解javascript原型和闭包（完结）](https://www.cnblogs.com/wangfupeng1988/p/3977924.html)\r\n\r\nJavaScript是弱类型，除了基本类型都可以理解为对象，这也是为什么说JavaScript中一切皆对象的原因。\r\n\r\n不过在对象中函数比较特殊，对象就是由函数创造出来的，这听起来是不是有点先有鸡后有蛋，先有蛋后有鸡的感觉，这也跟后面要说到的原型有关。\r\n\r\n先说`prototype`属性，这个属性是`函数`所独有的，函数也是对象也可以在自身定义属性和方法，那这个`prototype`属性有什么用呢？\r\n``` js\r\nvar a = {};\r\na.toString();\r\n```\r\n这里我并没有为a定义toString的方法，为什么可以调用呢？就跟prototype属性有关。\r\n\r\n上面只是简写，如果通过构造函数是这样的\r\n``` js\r\nvar a = new Object();\r\na.toString();\r\n```\r\n![https://pic1.zhimg.com/80/v2-038c5818398efc6b4e990b3c2fb3b54c_hd.jpg](https://pic1.zhimg.com/80/v2-038c5818398efc6b4e990b3c2fb3b54c_hd.jpg)\r\n这里可以看到toString的方法，这也是为什么没有定义却没有报错的原因。\r\n\r\n一个对象通过构造函数生成会执行下面四个步骤\r\n1. 创建一个新对象，作为要返回的实例\r\n2. 将新对象的原型（__proto__）指向构造函数的`prototype`属性\r\n3. 将内部的this指向新对象\r\n4. 执行内部代码，如果没有执行返回对象，则返回`this`（新对象）\r\n\r\n从上面可以看到，对象的原型会指向生成对象函数的`prototype`属性，对象本身如果没有属性或者方法，会向原型链查找，如果没有找到会一直找到`Object.prototype`属性上，如果还没有找到就会返回`undefined`。\r\n`Object.prototype`属性上还有原型链么？答案是有，是`Null`。\r\n\r\n上面简短的说了一下，下面通过例子的形式来结合\r\n\r\n## 示例\r\n``` js\r\nvar a = {};\r\n```\r\n这里我定义了一个对象a，根据上面说的每个对象都有一个原型，执行构造函数的`prototype`下面就是原型图。\r\n![https://pic4.zhimg.com/80/v2-c93843e5905a3990c0b1147d0dad7f03_hd.jpg](https://pic4.zhimg.com/80/v2-c93843e5905a3990c0b1147d0dad7f03_hd.jpg)\r\n上面就是一个简单的原型图，下面说一下`constructor`属性，这个属性有什么作用呢？\r\n`constructor`是`prototype`对象下的一个属性，他指向一个函数，与函数的相互依存，还是通过上面变量a来说明吧。\r\n![https://pic1.zhimg.com/80/v2-94e4180728a52844d1204a830249c10c_hd.jpg](https://pic1.zhimg.com/80/v2-94e4180728a52844d1204a830249c10c_hd.jpg)\r\n\r\n可以看到，通过`constructor`可以访问到构造函数，这个属性通常没有什么用，不过可以通用这个属性调用一些构造函数所独有的方法，比如`Date`函数的`now`方法\r\n``` js\r\nvar a = new Date();\r\na.__proto__.constructor.now();\r\n```\r\n这里为了方便演示使用了`_proto_`，不过在实际中不要这样写，因为这个属性只有浏览器才部署。\r\n![https://pic3.zhimg.com/80/v2-3ee04ff512a68800c014b66de0f6b3f2_hd.jpg](https://pic3.zhimg.com/80/v2-3ee04ff512a68800c014b66de0f6b3f2_hd.jpg)\r\n说了这么多，最后根据一张图，来总结一下。\r\n\r\n首先对象是由构造函数创建的（Object），你可能有疑问，函数也是对象，那么函数的`__proto__`指向什么？\r\n答案是`Function.prototype`，所有函数都是由`Fcuntion`创建的，举个例子\r\n``` js\r\nvar a = new Function('a', 'b', 'return a + b');\r\na(1, 2);\r\n```\r\n这里a的`__proto__`等于`Function.prototype`，之前说过prototype是一个对象，所以`Function.prototype`指向`Object.prototype`。\r\n最后说一点，`Function.__proto__`指向的是`Function`自身，他是唯一一个通过自身生成函数的例子，这里只需要了解一下。\r\n\r\n## 最后\r\n说了这么多，原型链好像还没有被提起，每个对象都有自己的原型，原型的对象也是对象，一方面对象可以作为另一个对象的原型，这样层层链接起来的原型就成为原型链。\r\n",
      "reactions": {
        "url": "https://api.github.com/repos/bosens-China/blog/issues/14/reactions",
        "total_count": 0,
        "+1": 0,
        "-1": 0,
        "laugh": 0,
        "hooray": 0,
        "confused": 0,
        "heart": 0,
        "rocket": 0,
        "eyes": 0
      },
      "timeline_url": "https://api.github.com/repos/bosens-China/blog/issues/14/timeline",
      "performed_via_github_app": null,
      "state_reason": null
    },
    {
      "url": "https://api.github.com/repos/bosens-China/blog/issues/65",
      "repository_url": "https://api.github.com/repos/bosens-China/blog",
      "labels_url": "https://api.github.com/repos/bosens-China/blog/issues/65/labels{/name}",
      "comments_url": "https://api.github.com/repos/bosens-China/blog/issues/65/comments",
      "events_url": "https://api.github.com/repos/bosens-China/blog/issues/65/events",
      "html_url": "https://github.com/bosens-China/blog/issues/65",
      "id": 770754319,
      "node_id": "MDU6SXNzdWU3NzA3NTQzMTk=",
      "number": 65,
      "title": "初探 node 接口开发",
      "user": {
        "login": "bosens-China",
        "id": 39508895,
        "node_id": "MDQ6VXNlcjM5NTA4ODk1",
        "avatar_url": "https://avatars.githubusercontent.com/u/39508895?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bosens-China",
        "html_url": "https://github.com/bosens-China",
        "followers_url": "https://api.github.com/users/bosens-China/followers",
        "following_url": "https://api.github.com/users/bosens-China/following{/other_user}",
        "gists_url": "https://api.github.com/users/bosens-China/gists{/gist_id}",
        "starred_url": "https://api.github.com/users/bosens-China/starred{/owner}{/repo}",
        "subscriptions_url": "https://api.github.com/users/bosens-China/subscriptions",
        "organizations_url": "https://api.github.com/users/bosens-China/orgs",
        "repos_url": "https://api.github.com/users/bosens-China/repos",
        "events_url": "https://api.github.com/users/bosens-China/events{/privacy}",
        "received_events_url": "https://api.github.com/users/bosens-China/received_events",
        "type": "User",
        "site_admin": false
      },
      "labels": [
        {
          "id": 1371686609,
          "node_id": "MDU6TGFiZWwxMzcxNjg2NjA5",
          "url": "https://api.github.com/repos/bosens-China/blog/labels/JavaScript",
          "name": "JavaScript",
          "color": "F7DF1E",
          "default": false,
          "description": "JavaScript系列的文章"
        }
      ],
      "state": "open",
      "locked": false,
      "assignee": null,
      "assignees": [],
      "milestone": null,
      "comments": 0,
      "created_at": "2020-12-18T10:03:26Z",
      "updated_at": "2021-12-21T03:35:11Z",
      "closed_at": null,
      "author_association": "OWNER",
      "active_lock_reason": null,
      "body": "接口请求与其它资源请求没有什么不同，都是借助 `http` 协议返回对应的资源，这篇文章简单介绍一下 `node` 开发接口以及如何管理多个接口情况和接口风格。\r\n\r\n标题关联了 node，主要因为 node 开启一个服务器是很简单，而且语法基本相同没有太多负担，这篇文章主要讲解思路，换算到其它语言也是可以的。\r\n\r\n先看一个官网的例子，稍微改造一下让它返回一个固定的`json`数据\r\n\r\n```js\r\nconst http = require('http');\r\n\r\nconst hostname = '127.0.0.1';\r\nconst port = 3000;\r\n\r\nconst server = http.createServer((req, res) => {\r\n  res.statusCode = 200;\r\n  res.writeHead(200, { 'Content-Type': 'application/json' });\r\n  res.write(JSON.stringify({ name: 'hello wrold' }));\r\n  res.end();\r\n});\r\n\r\nserver.listen(port, hostname, () => {\r\n  console.log(`服务器运行在 http://${hostname}:${port}/`);\r\n});\r\n```\r\n\r\n将上面代码复制到文件中，之后借助 `node xxx.js` 的形式就可以预览到效果了。\r\n\r\n## koa\r\n\r\n上面是借助 node 的 `http` 原生模块实现的，当然这种实现没有什么问题，不过追求可扩展和简化开发的目的，这里选择了 koa 作为下面使用的的框架。\r\n\r\nkoa 号称是下一代的 web 开发框架，同样以上面的例子安装一下 koa ，看它怎么实现上面的功能\r\n\r\n```sh\r\nyarn add koa\r\n```\r\n\r\n```js\r\nconst Koa = require('koa');\r\n\r\nconst hostname = '127.0.0.1';\r\nconst port = 3000;\r\n\r\nconst app = new Koa();\r\n\r\napp.use(async (ctx) => {\r\n  ctx.type = 'application/json';\r\n  ctx.body = { name: 'hello wrold' };\r\n});\r\napp.listen(port, hostname, () => {\r\n  console.log(`服务器运行在 http://${hostname}:${port}/`);\r\n});\r\n```\r\n\r\n代码方面还是十分简洁的，这里主要介绍实现思路不过多介绍 koa 的语法，而且实际上 koa 只是对 http 模块进行了封装，文档也没多少推荐看一下官网的介绍即可。\r\n\r\n说到`koa`这里还是聊一下 `koa` 的中间件，下面的代码会经常使用到，`koa` 借助中间件来实现各种拓展，就是类似于插件的功能，它本身非常像洋葱结构\r\n![洋葱](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fada01c271eb43c19fa026d988e30642~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n例如上面的`app.use`就是中间件，中间件的执行顺序以`next`为分割，先执行`next`的前半部分，之后按照倒叙的结构执行后半部分的`next`代码，看一下例子\r\n\r\n```js\r\napp.use(async (ctx, next) => {\r\n  console.log(1);\r\n  await next();\r\n  console.log(2);\r\n});\r\n\r\napp.use(async (ctx, next) => {\r\n  console.log(3);\r\n  await next();\r\n  console.log(4);\r\n});\r\n\r\napp.use(async (ctx, next) => {\r\n  console.log(5);\r\n  await next();\r\n  console.log(6);\r\n});\r\n```\r\n\r\n上面代码的打印结果是`1,3,5,6,4,2`，这块有点绕可以多想一下。\r\n\r\n接口开发中一般都是通过`json`来传递消息，`koa`本身的语法已经很简洁了，但是每次都需要返回想重复的部分，时间长了肯定也会有失误或者漏写拼错的情况，还有抛出错误也需要有一个公共的方法，下面是一个返回信息和抛出错误的设想。\r\n\r\n```js\r\napp.use(async (ctx) => {\r\n  ctx.sendData({ name: 'hello wrold' });\r\n  // 如果发生错误\r\n  ctx.throwError('不满足xxx');\r\n});\r\n```\r\n\r\n如果代码都通过这种形式返回就简单多了，而且实际写在中间件部分的也是可能出现问题的，这里可以通过 `koa` 自带的监听错误来处理，或者通过一个`try`来包裹，可以预料的是一个个手动管理`try`一定会让人抓狂。\r\n\r\n借助中间件的机制很容易编写出一个带有`sendData`和`throwError`的功能，只需要在 ctx 中返回，之后调用 next 让后面的实例执行\r\n\r\n```js\r\napp.use(async (ctx, next) => {\r\n  ctx.sendData = () => {};\r\n  ctx.throwError = () => {};\r\n  await next();\r\n});\r\n```\r\n\r\n上面的例子是简化过的，这里稍微错开一下具体实现之后再详细讲解\r\n\r\n> 中间件的顺序非常重要\r\n\r\n## 接口结构\r\n\r\n上面说了要有一个`sendData`和`throwError`的方法来统一返回信息和抛出错误，这里就说下这两个方法的具体参数以及实现。\r\n\r\n首先接口的返回信息，期待它是固定成下面这种结构\r\n\r\n```json\r\n{\r\n  \"data\": {},\r\n  \"message\": \"ok\",\r\n  \"code\": 200\r\n}\r\n```\r\n\r\n这里 `data` 部分是需要手动返回的，`message` 是可选的，默认的时候可以给一个 ok 以及 200 的 code，这里`code`值是固定死的，方法不允许修改，这样做是因为成功返回一般不需要额外的 code 值\r\n\r\n而错误信息，期待它是这种结构\r\n\r\n```json\r\n{\r\n  \"message\": \"\",\r\n  \"code\": \"400\"\r\n}\r\n```\r\n\r\n这里 message 是必填，而 code 则是可选的。\r\n\r\n这里稍微说一下错误到底使用 `code` 来做区分？还是通过`message`来做区分？\r\n如果通过`code`来做不同状态的区分，那么必然要维护一个 code 列表，其实这是很繁琐的而且单纯的数字记忆也不符合人的记忆，而通过`message`来做提示则基本上可以做到大概可以猜到错误情况，例如可以这样返回\r\n\r\n```json\r\n{\r\n  \"message\": \"error_用户名不能为空\"\r\n}\r\n```\r\n\r\n前面类型后面提示，是不是简洁很多，这两种错误提示自己选择一种即可。\r\n\r\n说了需要实现的功能，方法的实现就很简单了，下面代码是`code`值风格的实现\r\n\r\n```js\r\n// 忽略顶层语法问题，这里是把实现提取出来了\r\nasync (ctx, next) => {\r\n  const content = {\r\n    ...ctx,\r\n    sendData: (data, message = 'ok') => {\r\n      ctx.body = {\r\n        data,\r\n        message,\r\n        code: 200,\r\n      };\r\n      ctx.type = 'application/json';\r\n    },\r\n    throwError: (message = '错误', code = 400) => {\r\n      ctx.body = {\r\n        code,\r\n        message,\r\n      };\r\n      ctx.type = 'application/json';\r\n    },\r\n  };\r\n  try {\r\n    await callback(content);\r\n  } catch (e) {\r\n    ctx.body = {\r\n      code: 400,\r\n      message: (e instanceof Error ? e.message : e) || '系统出现错误',\r\n    };\r\n    ctx.status = 400;\r\n  }\r\n  await next();\r\n};\r\n```\r\n\r\n## REST 风格\r\n\r\nrest 是一种接口风格，简单可以概括成以下几种\r\n\r\n- 使用`get`来获取资源\r\n- 使用`post`来发送请求\r\n- 使用`put`来更新资源\r\n- 使用`delete`来删除资源\r\n\r\n说了这么多使用`rest`的好处有哪些呢？\r\n\r\n首先 rest 只是一种规范，定义这种规范更方便理解和阅读，和代码规范是一个性质\r\n\r\n## 自动导入\r\n\r\n在项目开发中必然存在不同的接口，如何管理这些接口就很有必要的，一个个手动导入管理固然可以，不过当项目足够大的时候，业务变更的时候一个个调整一定让人抓狂。\r\n\r\n下面借助`koa-router`和中间件就编写一个自动导入接口的功能，先看一下`koar-router`的简单使用\r\n\r\n```sh\r\nyarn add @koa/router\r\n```\r\n\r\n```js\r\nconst Koa = require('koa');\r\nconst Router = require('@koa/router');\r\n\r\nconst hostname = '127.0.0.1';\r\nconst port = 3000;\r\nconst app = new Koa();\r\nconst router = new Router();\r\n\r\nrouter.get('/', (ctx, next) => {\r\n  ctx.type = 'application/json';\r\n  ctx.body = { name: 'hello wrold' };\r\n});\r\n\r\napp.use(router.routes()).use(router.allowedMethods());\r\n\r\napp.listen(port, hostname, () => {\r\n  console.log(`服务器运行在 http://${hostname}:${port}/`);\r\n});\r\n```\r\n\r\n要实现这个功能先定义一下规则\r\n\r\n- 只导入`src`目录下`index.js`结尾的接口文件\r\n\r\n  搜索所有符合要求的`index.js`文件，可以借助`glob`模块来实现，借助通配符`'src/**/index.js'`即可。\r\n\r\n- 导入文件，把对应模板返回的字段添加到`router`上\r\n\r\n  这里可以通过 node 原生`require`来读取文件，在具体实现的时候需要稍微注意，必须满足格式的模块才能被导入，而且要添加`try`来捕捉不是`modules`的文件\r\n\r\n在动手实现这个函数之前，还要约定一下`index.js`文件的内的模块格式是什么样的\r\n\r\n```js\r\nconst api = {\r\n  url: '',\r\n  methods: 'get' || ['post'],\r\n  async callback(ctx) {},\r\n};\r\n```\r\n\r\n上面是约定的格式，只有满足这样的结构才会被导入进来，因为开发用的是`ts`这里就不做转换`js`的操作了，如果不想使用 ts 直接忽略掉类型标注看大概实现即可。\r\n\r\nutils.ts\r\n\r\n```js\r\nimport glob from 'glob';\r\nimport path from 'path';\r\nimport _ from 'lodash';\r\nimport { Iobj, Istructure } from '../../typings/structure';\r\n\r\nexport const globFile = (pattern: string): Promise<Array<string>> => {\r\n  return new Promise((resolve, reject) => {\r\n    glob(pattern, (err, files) => {\r\n      if (err) {\r\n        return reject(err);\r\n      }\r\n      return resolve(files);\r\n    });\r\n  });\r\n};\r\n\r\nexport const importModule = async () => {\r\n  const pattern = 'src/**/index.ts';\r\n  const list = await globFile(pattern);\r\n  const listMap = list.map((item) => {\r\n    const f = path.resolve(process.cwd(), item);\r\n    return import(f)\r\n      .then((res) => {\r\n        // 过滤掉default的属性，其它的返回\r\n        return _.omit(res, ['default']);\r\n      })\r\n      .catch(() => null);\r\n  });\r\n  return (await Promise.all(listMap)).filter((f) => f) as Array<Iobj<Istructure>>;\r\n};\r\n\r\n```\r\n\r\n> 这里注意一下，因为用的 ts 所以用了 `import()`如果只是用 node 语法直接 `require` 即可\r\n\r\nindex.ts\r\n\r\n```js\r\nimport Router from '@koa/router';\r\nimport _ from 'lodash';\r\nimport { Ictx, Iobj } from '../../typings/structure';\r\n\r\nimport { importModule } from './utils';\r\nimport Koa from 'koa';\r\n\r\nconst route = async (koa: Koa) => {\r\n  const router = new Router();\r\n  const list = await importModule();\r\n\r\n  for (const fileAll of list) {\r\n    // 将数据解构，这里返回的是{xxx: {url,methods,callback}}这样解构\r\n\r\n    // 过滤不符合条件的模块\r\n    for (const file of Object.values(fileAll)) {\r\n      if (\r\n        !_.isObjectLike(file) ||\r\n        !['url', 'methods', 'callback'].every((f) =>\r\n          Object.keys(file).includes(f)\r\n        )\r\n      ) {\r\n        continue;\r\n      }\r\n      const { url, methods, callback } = file;\r\n      const methodsArr = _.isArray(methods) ? methods : [methods];\r\n      for (const met of methodsArr) {\r\n        router[met](url, async (ctx, next) => {\r\n          const content: Ictx = {\r\n            ...ctx,\r\n            sendData: (data: Iobj, message = 'ok') => {\r\n              ctx.body = {\r\n                data,\r\n                message,\r\n                code: 200,\r\n              };\r\n              ctx.type = 'application/json';\r\n            },\r\n            throwError: (message = '错误', code = 400) => {\r\n              ctx.body = {\r\n                code,\r\n                message,\r\n              };\r\n              ctx.type = 'application/json';\r\n            },\r\n          };\r\n          try {\r\n            await callback(content);\r\n          } catch (e) {\r\n            ctx.body = {\r\n              code: 400,\r\n              message: (e instanceof Error ? e.message : e) || '系统出现错误',\r\n            };\r\n            ctx.status = 400;\r\n          }\r\n          await next();\r\n        });\r\n      }\r\n    }\r\n  }\r\n  koa.use(router.routes()).use(router.allowedMethods());\r\n};\r\n\r\nexport default route;\r\n```\r\n\r\n## 日志\r\n\r\n借助 koa 的中间件也很容易实现日志的功能，这里以[winston](https://github.com/winstonjs/winston)为例\r\n\r\n日志主要记录系统运行时的错误，还记的上面通过`try`来捕捉错误的例子么，现在让他继续抛出错误，直接通过中间件 try 捕捉错误写入到文件。\r\n\r\n```js\r\nimport winston from 'winston';\r\nimport Koa from 'koa';\r\n\r\nimport 'winston-daily-rotate-file';\r\nconst transport = new winston.transports.DailyRotateFile({\r\n  filename: 'log/%DATE%.log',\r\n  datePattern: 'YYYY-MM-DD-HH',\r\n  zippedArchive: true,\r\n  maxSize: '20m',\r\n  maxFiles: '14d',\r\n});\r\n\r\nconst logger = winston.createLogger({\r\n  transports: [transport],\r\n});\r\n\r\nconst asyncwinston = async (\r\n  _ctx: Koa.ParameterizedContext<Koa.DefaultState, Koa.DefaultContext>,\r\n  next: Koa.Next\r\n) => {\r\n  try {\r\n    await next();\r\n  } catch (err) {\r\n    const data = {\r\n      data: err,\r\n      time: new Date().valueOf(),\r\n    };\r\n    if (err instanceof Error) {\r\n      data.data = {\r\n        content: err.message,\r\n        name: err.name,\r\n        stack: err.stack,\r\n      };\r\n    }\r\n    logger.error(JSON.stringify(data));\r\n  }\r\n};\r\n\r\nexport default asyncwinston;\r\n```\r\n\r\n## 启动\r\n\r\n启动就很简单了，把上面暴露的 index.js 通过`koa`的 use 引入\r\n\r\nApp.js\r\n\r\n```js\r\nconst Koa = require('koa');\r\nconst bodyParser = require('koa-bodyparser');\r\nconst route = require('./middleware/route');\r\nconst winston = require('./middleware/winston');\r\n\r\nconst App = async () => {\r\n  const app = new Koa();\r\n  app.use(winston);\r\n  app.use(bodyParser());\r\n  await route(app);\r\n  return app;\r\n};\r\n\r\nmodule.exports = App;\r\n```\r\n\r\nstart.js\r\n\r\n```js\r\nconst Koa = require('koa');\r\nconst ip = require('ip');\r\nconst App = require('./App');\r\n\r\nconst start = async () => {\r\n  const app = await App();\r\n  notice(app);\r\n};\r\n\r\nconst notice = (koa: Koa) => {\r\n  const port = 3000;\r\n  const ipStr = ip.address();\r\n  const str = `http://${ipStr}:${port}`;\r\n  koa.listen(port, () => {\r\n    console.log(`服务器运行在\\n${str}`);\r\n  });\r\n};\r\n\r\nstart();\r\n```\r\n\r\n**这里稍微说明一下为什么分成两个文件，这是因为方便接口测试特意分层的，`start`只做启动的用途**\r\n\r\n最后添加一个`node-dev`的模块，就大功告成了\r\n\r\n10/21 补充\r\n\r\n> 上面的 node-dev，是开发环境下使用的，方便代码的快速重启，在生产环境下可以使用 [pm2](https://github.com/Unitech/pm2)\r\n\r\n```js\r\n// 安装\r\nyarn add node-dev\r\n// 启动\r\nnode-dev start.js\r\n```\r\n\r\n通过`node-dev`启动主要是可以方便修改接口可以直接重载以及通知的方式更明显\r\n\r\n## 接口测试\r\n\r\n12/21 补上\r\n\r\n首先在 src 目录下 新建一个 `index.ts` 文件，用于测试的接口\r\n\r\n```js\r\nimport { Istructure } from '../typings/structure';\r\n\r\nconst testGet: Istructure = {\r\n  url: '/api/:id',\r\n  methods: 'get',\r\n  async callback(ctx) {\r\n    const { id } = ctx?.params;\r\n    ctx?.sendData({ name: 'hello', id });\r\n  },\r\n};\r\nconst testPost: Istructure = {\r\n  url: '/api',\r\n  methods: 'post',\r\n  async callback(ctx) {\r\n    const body = ctx?.request.body;\r\n    ctx?.sendData(body || {});\r\n  },\r\n};\r\n\r\nexport { testGet, testPost };\r\n```\r\n\r\n上面是一个很简单的 post 和 get 请求，之后我们新建一个`__test__`目录，在里面新建一个`index.test.js`文件\r\n\r\n```sh\r\nyarn add @babel/core @babel/preset-env @babel/preset-typescript babel-jest jest supertest\r\n```\r\n\r\n在根目录新建`babel.config.js`文件\r\n\r\n```js\r\n// babel.config.js\r\nmodule.exports = {\r\n  presets: [\r\n    ['@babel/preset-env', { targets: { node: 'current' } }],\r\n    '@babel/preset-typescript',\r\n  ],\r\n};\r\n```\r\n\r\n简单说下，这个 babel 的作用是让我们可以在 js 里面使用 `es6 module` 的语法，同时将 ts 文件转成 js，否则我们这个测试用例是 ts 的根本跑不起来，测试框架方面选用了`jest`测试 http 库使用了`supertest`，其实这块都是可以调整的，单元测试的目的就是对比数据是否符合预期\r\n\r\n`__test__ index.test.js`\r\n\r\n```js\r\nimport App from '../App';\r\n\r\nimport supertest from 'supertest';\r\n\r\ntest('get请求测试', async () => {\r\n  const app = await App();\r\n  const request = supertest(app.listen());\r\n  const id = 6;\r\n  const data = { name: 'hello', id: `${id}` };\r\n  const res = await request.get(`/api/${id}`).expect(200);\r\n  const body = res.body.data;\r\n  expect(body).toEqual(data);\r\n});\r\n\r\ntest('post请求测试', async () => {\r\n  const app = await App();\r\n  const request = supertest(app.listen());\r\n  const data = { name: 'hello', id: 8 };\r\n  const res = await request.post(`/api/`).send(data).expect(200);\r\n  const body = res.body.data;\r\n  expect(body).toEqual(data);\r\n});\r\n```\r\n\r\n运行 `npx jest `，命令行如果没有抛出异常说明我们的代码符合预期，关于更多的 jest 内容可以查看文档\r\n\r\n## 最后\r\n\r\n如果对你有帮助欢迎 `stat`，如果有什么错误之处欢迎指出，关于代码本来全部想用 ts 举例的，但是 ts 并不是一定要上的，所以某些场景我就手动转了一下，看起来有点风格不统一还望谅解\r\n",
      "reactions": {
        "url": "https://api.github.com/repos/bosens-China/blog/issues/65/reactions",
        "total_count": 0,
        "+1": 0,
        "-1": 0,
        "laugh": 0,
        "hooray": 0,
        "confused": 0,
        "heart": 0,
        "rocket": 0,
        "eyes": 0
      },
      "timeline_url": "https://api.github.com/repos/bosens-China/blog/issues/65/timeline",
      "performed_via_github_app": null,
      "state_reason": null
    },
    {
      "url": "https://api.github.com/repos/bosens-China/blog/issues/61",
      "repository_url": "https://api.github.com/repos/bosens-China/blog",
      "labels_url": "https://api.github.com/repos/bosens-China/blog/issues/61/labels{/name}",
      "comments_url": "https://api.github.com/repos/bosens-China/blog/issues/61/comments",
      "events_url": "https://api.github.com/repos/bosens-China/blog/issues/61/events",
      "html_url": "https://github.com/bosens-China/blog/issues/61",
      "id": 680636174,
      "node_id": "MDU6SXNzdWU2ODA2MzYxNzQ=",
      "number": 61,
      "title": "文字高亮",
      "user": {
        "login": "bosens-China",
        "id": 39508895,
        "node_id": "MDQ6VXNlcjM5NTA4ODk1",
        "avatar_url": "https://avatars.githubusercontent.com/u/39508895?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bosens-China",
        "html_url": "https://github.com/bosens-China",
        "followers_url": "https://api.github.com/users/bosens-China/followers",
        "following_url": "https://api.github.com/users/bosens-China/following{/other_user}",
        "gists_url": "https://api.github.com/users/bosens-China/gists{/gist_id}",
        "starred_url": "https://api.github.com/users/bosens-China/starred{/owner}{/repo}",
        "subscriptions_url": "https://api.github.com/users/bosens-China/subscriptions",
        "organizations_url": "https://api.github.com/users/bosens-China/orgs",
        "repos_url": "https://api.github.com/users/bosens-China/repos",
        "events_url": "https://api.github.com/users/bosens-China/events{/privacy}",
        "received_events_url": "https://api.github.com/users/bosens-China/received_events",
        "type": "User",
        "site_admin": false
      },
      "labels": [
        {
          "id": 1371686609,
          "node_id": "MDU6TGFiZWwxMzcxNjg2NjA5",
          "url": "https://api.github.com/repos/bosens-China/blog/labels/JavaScript",
          "name": "JavaScript",
          "color": "F7DF1E",
          "default": false,
          "description": "JavaScript系列的文章"
        }
      ],
      "state": "open",
      "locked": false,
      "assignee": null,
      "assignees": [],
      "milestone": null,
      "comments": 0,
      "created_at": "2020-08-18T02:15:53Z",
      "updated_at": "2021-12-21T03:30:00Z",
      "closed_at": null,
      "author_association": "OWNER",
      "active_lock_reason": null,
      "body": "![bg](https://user-images.githubusercontent.com/39508895/90462493-935eb900-e13b-11ea-902c-dce1e576fbb4.png)\r\n\r\n如上图，可能在搜索之类的时候需要将搜索内容进行高亮，下面聊聊小程序和 web 上如何实现。\r\n\r\n## web 上做法\r\n\r\n可以通过正则表达式`/(高亮的文字)/`来实现\r\n\r\n```js\r\nfunction highlight(str, sep, color) {\r\n  const reg = new RegExp(`\\(${sep}\\)`, 'g');\r\n  return str.replace(reg, `<i style=\"color:${color};\">$1</i>`);\r\n}\r\nhighlight('安徽省合肥市', '安徽', 'reg');\r\n// <i style=\"color:reg;\">安徽</i>省合肥市\r\n```\r\n\r\n这里实现比较简单，稍微注意一下`replace`api 即可，它还可以接收一个函数作为参数，具体内容这里不做讲解了只简单实现一下。\r\n\r\n## 小程序做法\r\n\r\n不同于 web，因为小程序无法手动管理 `dom` 样式，所以思路是将`高亮文字`和普通文字区分开来，例如：\r\n\r\n```js\r\nvar str = '安徽省合肥市蜀山区';\r\n// 如果高亮合肥市，那么我们把他转化为下面这种形式的数组\r\n['安徽省', '合肥市', '蜀山区'];\r\n```\r\n\r\n将普通文字和高亮文字通过数组的形式区分开来，之后再通过`<text>`标签将转换后的数组`for`循环，每次循环的结果与高亮文字对比，如果符合就添加高亮样式。\r\n\r\n```html\r\n<view>\r\n  <text\r\n    style=\"{{item === keyWord ? 'color:' + color + ';' : ''}}\"\r\n    wx:for=\"{{arr}}\"\r\n    wx:key=\"item\"\r\n  >\r\n    {{item}}\r\n  </text>\r\n</view>\r\n```\r\n\r\n整体的思路就是这样，下面说一下实现的细节。\r\n\r\n- 怎么将一段文字转化为上面数组的形式\r\n  其实这块要分为两步，将文字转化为数组我们可以用`split`的方法，之后通过一个变异的`join`将他们拼成数组。\r\n\r\n```js\r\nfunction join(array, str) {\r\n  const arr = [];\r\n  const len = array.length;\r\n  for (let i = 0; i < len - 1; i++) {\r\n    const value = array[i];\r\n    if (!value) {\r\n      arr.push(str);\r\n    } else {\r\n      arr.push(value, str);\r\n    }\r\n  }\r\n  if (array[len - 1]) {\r\n    arr.push(array[len - 1]);\r\n  }\r\n  return arr;\r\n}\r\n```\r\n\r\n把上面的`wxml`代码片段和`join`相关组合一起就可以实现一个文字高亮的效果了。\r\n\r\n为了方便使用，我这里已经封装成一个库了[highlight](https://github.com/bosens-China/highlight)\r\n\r\n## 最后\r\n\r\n相关代码整合到了[Github](https://github.com/bosens-China/highlight)\r\n\r\n如果对你有帮助可以`star`支持作者一下。\r\n",
      "reactions": {
        "url": "https://api.github.com/repos/bosens-China/blog/issues/61/reactions",
        "total_count": 0,
        "+1": 0,
        "-1": 0,
        "laugh": 0,
        "hooray": 0,
        "confused": 0,
        "heart": 0,
        "rocket": 0,
        "eyes": 0
      },
      "timeline_url": "https://api.github.com/repos/bosens-China/blog/issues/61/timeline",
      "performed_via_github_app": null,
      "state_reason": null
    },
    {
      "url": "https://api.github.com/repos/bosens-China/blog/issues/30",
      "repository_url": "https://api.github.com/repos/bosens-China/blog",
      "labels_url": "https://api.github.com/repos/bosens-China/blog/issues/30/labels{/name}",
      "comments_url": "https://api.github.com/repos/bosens-China/blog/issues/30/comments",
      "events_url": "https://api.github.com/repos/bosens-China/blog/issues/30/events",
      "html_url": "https://github.com/bosens-China/blog/issues/30",
      "id": 503803775,
      "node_id": "MDU6SXNzdWU1MDM4MDM3NzU=",
      "number": 30,
      "title": "模拟实现call和apply",
      "user": {
        "login": "bosens-China",
        "id": 39508895,
        "node_id": "MDQ6VXNlcjM5NTA4ODk1",
        "avatar_url": "https://avatars.githubusercontent.com/u/39508895?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bosens-China",
        "html_url": "https://github.com/bosens-China",
        "followers_url": "https://api.github.com/users/bosens-China/followers",
        "following_url": "https://api.github.com/users/bosens-China/following{/other_user}",
        "gists_url": "https://api.github.com/users/bosens-China/gists{/gist_id}",
        "starred_url": "https://api.github.com/users/bosens-China/starred{/owner}{/repo}",
        "subscriptions_url": "https://api.github.com/users/bosens-China/subscriptions",
        "organizations_url": "https://api.github.com/users/bosens-China/orgs",
        "repos_url": "https://api.github.com/users/bosens-China/repos",
        "events_url": "https://api.github.com/users/bosens-China/events{/privacy}",
        "received_events_url": "https://api.github.com/users/bosens-China/received_events",
        "type": "User",
        "site_admin": false
      },
      "labels": [
        {
          "id": 1602397157,
          "node_id": "MDU6TGFiZWwxNjAyMzk3MTU3",
          "url": "https://api.github.com/repos/bosens-China/blog/labels/%E6%B7%B1%E5%85%A5%E7%B3%BB%E5%88%97",
          "name": "深入系列",
          "color": "719192",
          "default": false,
          "description": "主要介绍实现的思路"
        }
      ],
      "state": "open",
      "locked": false,
      "assignee": null,
      "assignees": [],
      "milestone": null,
      "comments": 0,
      "created_at": "2019-10-08T03:31:31Z",
      "updated_at": "2021-12-21T03:07:06Z",
      "closed_at": null,
      "author_association": "OWNER",
      "active_lock_reason": null,
      "body": "> call() 方法使用一个指定的 this 值和单独给出的一个或多个参数来调用一个函数\r\n\r\n上面是 call 的定义，apply 与 call 类似只是第二个参数是一个数组而 call 接收的则是一个参数列表。\r\n\r\n看一个例子\r\n\r\n```js\r\nvar obj = {\r\n  name: \"obj\"\r\n};\r\nfunction foo() {\r\n  return this.name;\r\n}\r\nfoo.call(obj); //obj\r\n```\r\n\r\n上面通过 call 改变了 this 的指向，下面就是模拟实现\r\n\r\n## 实现\r\n\r\ncall 和 apply 是 es5 的方法，既然是模拟实现那肯定不能用 es5 方法了，我们先分析一下怎么来指定 this，this 跟动态作用域类似是在执行时确定，那我们在指定 this 的属性上添加一个方法并且执行，那么这个方法的 this 就是指定 this\r\n\r\n```js\r\nvar obj = {\r\n  name: \"obj\",\r\n  foo: function foo() {\r\n    return this.name;\r\n  }\r\n};\r\n\r\nobj.foo();\r\n```\r\n\r\n上面解决了 this，下面来看下怎么实现参数的传递，call 方法可以传递任意参数列表，我们可以通过`arguments`来获取，它是一个类数组。\r\n\r\n```js\r\nfunction getName() {\r\n  console.log(arguments); //Arguments(5) [1, 2, 3, 4, 5]\r\n}\r\nfunction foo() {\r\n  var args = [];\r\n  for (var i = 0; i < arguments.length; i++) {\r\n    args.push(\"arguments[\" + i + \"]\");\r\n  }\r\n  eval(\"getName(\" + args + \")\");\r\n}\r\nfoo(1, 2, 3, 4, 5);\r\n```\r\n\r\nOK，这两块已经搞定了，下面就是实现\r\n\r\n### call\r\n\r\n```js\r\nFunction.prototype.calls = function(con) {\r\n  con.fn = this;\r\n  // 获取参数\r\n  var args = [];\r\n  for (var i = 1; i < arguments.length; i++) {\r\n    args.push(\"arguments[\" + i + \"]\");\r\n  }\r\n  var result = eval(\"con.fn(\" + args + \")\");\r\n  delete con.fn;\r\n  return result;\r\n};\r\n```\r\n\r\n上面删除属性是为了避免污染，这里的`fn`可以是任意属性名只要保证不重复就行了，不过仔细观察上面函数还是有问题\r\n\r\n1. call 的 this 可以是 `null` 或者 `undefined`；\r\n2. 可以是字符串数字之类的，会转化为包装对象；\r\n\r\n```js\r\nFunction.prototype.calls = function(con) {\r\n  if (con == null) {\r\n    con = typeof window === \"object\" ? window : global;\r\n  }\r\n  con = Object(con);\r\n  con.fn = this;\r\n  // 获取参数\r\n  var args = [];\r\n  for (var i = 1; i < arguments.length; i++) {\r\n    args.push(\"arguments[\" + i + \"]\");\r\n  }\r\n  var result = eval(\"con.fn(\" + args + \")\");\r\n  delete con.fn;\r\n  return result;\r\n};\r\n```\r\n\r\n测试一下\r\n\r\n```js\r\nfunction foo() {\r\n  return this.length;\r\n}\r\nconsole.log(foo.calls(\"obj\")); // 3\r\n```\r\n\r\n撒花，这样就实现了 call\r\n\r\n### apply\r\n\r\n与 call 十分类似，这里就直接贴代码了\r\n\r\n```js\r\nFunction.prototype.applys = function(con, arr) {\r\n  if (con == null) {\r\n    con = typeof window === \"object\" ? window : global;\r\n  }\r\n  con = Object(con);\r\n  con.fn = this;\r\n  var result;\r\n  if (typeof arr === \"object\" && arr.length) {\r\n    var args = [];\r\n    for (var i = 0; i < arr.length; i++) {\r\n      args.push(\"arr[\" + i + \"]\");\r\n    }\r\n    result = eval(\"con.fn(\" + args + \")\");\r\n  } else {\r\n    result = eval(\"con.fn()\");\r\n  }\r\n  delete con.fn;\r\n  return result;\r\n};\r\n```\r\n\r\n## 参考\r\n\r\n1. https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/call\r\n2. https://github.com/mqyqingfeng/Blog/issues/11\r\n",
      "reactions": {
        "url": "https://api.github.com/repos/bosens-China/blog/issues/30/reactions",
        "total_count": 0,
        "+1": 0,
        "-1": 0,
        "laugh": 0,
        "hooray": 0,
        "confused": 0,
        "heart": 0,
        "rocket": 0,
        "eyes": 0
      },
      "timeline_url": "https://api.github.com/repos/bosens-China/blog/issues/30/timeline",
      "performed_via_github_app": null,
      "state_reason": null
    },
    {
      "url": "https://api.github.com/repos/bosens-China/blog/issues/31",
      "repository_url": "https://api.github.com/repos/bosens-China/blog",
      "labels_url": "https://api.github.com/repos/bosens-China/blog/issues/31/labels{/name}",
      "comments_url": "https://api.github.com/repos/bosens-China/blog/issues/31/comments",
      "events_url": "https://api.github.com/repos/bosens-China/blog/issues/31/events",
      "html_url": "https://github.com/bosens-China/blog/issues/31",
      "id": 503856924,
      "node_id": "MDU6SXNzdWU1MDM4NTY5MjQ=",
      "number": 31,
      "title": "模拟实现bind",
      "user": {
        "login": "bosens-China",
        "id": 39508895,
        "node_id": "MDQ6VXNlcjM5NTA4ODk1",
        "avatar_url": "https://avatars.githubusercontent.com/u/39508895?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bosens-China",
        "html_url": "https://github.com/bosens-China",
        "followers_url": "https://api.github.com/users/bosens-China/followers",
        "following_url": "https://api.github.com/users/bosens-China/following{/other_user}",
        "gists_url": "https://api.github.com/users/bosens-China/gists{/gist_id}",
        "starred_url": "https://api.github.com/users/bosens-China/starred{/owner}{/repo}",
        "subscriptions_url": "https://api.github.com/users/bosens-China/subscriptions",
        "organizations_url": "https://api.github.com/users/bosens-China/orgs",
        "repos_url": "https://api.github.com/users/bosens-China/repos",
        "events_url": "https://api.github.com/users/bosens-China/events{/privacy}",
        "received_events_url": "https://api.github.com/users/bosens-China/received_events",
        "type": "User",
        "site_admin": false
      },
      "labels": [
        {
          "id": 1602397157,
          "node_id": "MDU6TGFiZWwxNjAyMzk3MTU3",
          "url": "https://api.github.com/repos/bosens-China/blog/labels/%E6%B7%B1%E5%85%A5%E7%B3%BB%E5%88%97",
          "name": "深入系列",
          "color": "719192",
          "default": false,
          "description": "主要介绍实现的思路"
        }
      ],
      "state": "open",
      "locked": false,
      "assignee": null,
      "assignees": [],
      "milestone": null,
      "comments": 0,
      "created_at": "2019-10-08T06:35:47Z",
      "updated_at": "2021-12-21T03:06:57Z",
      "closed_at": null,
      "author_association": "OWNER",
      "active_lock_reason": null,
      "body": "之前说了[模拟实现 call 和 apply](https://github.com/bosens-China/blog/issues/30)，下面就来实现 bind，首先先看一下定义 bind 定义\r\n\r\n> bind()方法创建一个新的函数，在 bind()被调用时，这个新函数的 this 被 bind 的第一个参数指定，其余的参数将作为新函数的参数供调用时使用。\r\n\r\n## 第一版\r\n\r\n根据定义我们尝试写一下\r\n\r\n```js\r\nFunction.prototype.binds = function(con) {\r\n  var fn = this;\r\n  var args = Array.prototype.slice.call(arguments, 1);\r\n  return function() {\r\n    return fn.apply(con, args);\r\n  };\r\n};\r\n```\r\n\r\n我们来测试一下上面的函数\r\n\r\n```js\r\nvar obj = {\r\n  value: \"zhangsan\"\r\n};\r\nfunction foo(name, age) {\r\n  console.log(this.value); //zhangsan\r\n  console.log(name); // name\r\n  console.log(age); // undefined\r\n}\r\nvar f = foo.binds(obj, \"name\");\r\nf(19);\r\n```\r\n\r\n`age` 输出的跟我们预期的不太一致，这是因为我们没有处理返回函数的参数，用 concat 把参数合并在一起就可以了。\r\n\r\n```js\r\nFunction.prototype.binds = function(con) {\r\n  var fn = this;\r\n  var args = Array.prototype.slice.call(arguments, 1);\r\n  return function() {\r\n    return fn.apply(con, args.concat(Array.prototype.slice.call(arguments)));\r\n  };\r\n};\r\n```\r\n\r\n## 第二版\r\n\r\n上面简单实现了函数的 bind，不过我们来看一下 bind 与构造函数相遇会怎么样\r\n\r\n```js\r\nvar obj = {\r\n  value: \"zhangsan\"\r\n};\r\nfunction Foo(name, age) {\r\n  console.log(this.value); //undefined\r\n  console.log(name);\r\n  console.log(age);\r\n}\r\nvar f = Foo.bind(obj, \"name\");\r\nnew f(19);\r\n```\r\n\r\n上面 `this.value` 的输出为 `undefined`，这是因为 **调用绑定函数时作为 this 参数传递给目标函数的值。 如果使用 new 运算符构造绑定函数，则忽略该值**。\r\n\r\n另外作为构造函数是可以获取到绑定 bind 函数的 `prototype` 的\r\n\r\n```js\r\nfunction Foo() {\r\n  console.log(this.gender); //male\r\n}\r\nFoo.prototype.gender = \"male\";\r\nvar f = Foo.bind(null, \"name\");\r\nnew f();\r\n```\r\n\r\n下面就是来实现上面两点：\r\n\r\n- 怎么来判断是否通过 new 来调用呢？可以通过`instanceof`\r\n\r\n```js\r\nfunction Foo() {\r\n  if (!(this instanceof Foo)) {\r\n    throw Error(\"请通过new调用\");\r\n  }\r\n}\r\nFoo();\r\n```\r\n\r\n- 继承的话我们可以通过寄生组合式继承，这类文章比较多，这里就简单举一个例子\r\n\r\n```js\r\nfunction create(con) {\r\n  var f = function() {};\r\n  f.prototype = con;\r\n  return new f();\r\n}\r\nfunction Par(name) {\r\n  this.name = name;\r\n}\r\nPar.prototype.getName = function() {\r\n  return this.name;\r\n};\r\nfunction Chi(name, age) {\r\n  Par.call(this, name);\r\n  this.age = age;\r\n}\r\nChi.prototype = create(Par.prototype);\r\nChi.prototype.constructor = Chi;\r\nChi.prototype.getDetails = function() {\r\n  var n = this.getName();\r\n  console.log(n, this.age);\r\n};\r\nvar d = new Chi(\"zhangsan\", 16);\r\nd.getDetails();\r\n```\r\n\r\nOK，上面两点解决后我们再来实现一版\r\n\r\n```js\r\nFunction.prototype.binds = function(con) {\r\n  var fn = this;\r\n  var args = Array.prototype.slice.call(arguments, 1);\r\n  var f = function() {};\r\n  if (this.prototype) {\r\n    f.prototype = this.prototype;\r\n  }\r\n  var result = function() {\r\n    return fn.apply(\r\n      this instanceof result ? this : con,\r\n      args.concat(Array.prototype.slice.call(arguments))\r\n    );\r\n  };\r\n  result.prototype = new f();\r\n  return result;\r\n};\r\n```\r\n\r\n## 优化\r\n\r\n观察上面的不难发现 bind 调用的必须是函数，而通过继承我们可能会调用到 bind 所以这里显示报错一下\r\n\r\n```js\r\nvar obj = Object.create(Function.prototype);\r\nconsole.log(obj.bind);\r\n```\r\n\r\n另外对于我们上面定义的`binds`肯定不太优雅，污染了命名空间，这里可以判断一下如果存在 `bind` 就用 `bind` 否则在定义\r\n\r\n## 最终\r\n\r\n```js\r\nif (!Function.prototype.bind) {\r\n  Function.prototype.bind = function(con) {\r\n    if (typeof this !== \"function\") {\r\n      throw new TypeError(\r\n        \"Function.prototype.bind - what is trying to be bound is not callable\"\r\n      );\r\n    }\r\n    var fn = this;\r\n    var args = Array.prototype.slice.call(arguments, 1);\r\n    var f = function() {};\r\n    if (this.prototype) {\r\n      f.prototype = this.prototype;\r\n    }\r\n    var result = function() {\r\n      return fn.apply(\r\n        this instanceof result ? this : con,\r\n        args.concat(Array.prototype.slice.call(arguments))\r\n      );\r\n    };\r\n    result.prototype = new f();\r\n    return result;\r\n  };\r\n}\r\n```\r\n",
      "reactions": {
        "url": "https://api.github.com/repos/bosens-China/blog/issues/31/reactions",
        "total_count": 0,
        "+1": 0,
        "-1": 0,
        "laugh": 0,
        "hooray": 0,
        "confused": 0,
        "heart": 0,
        "rocket": 0,
        "eyes": 0
      },
      "timeline_url": "https://api.github.com/repos/bosens-China/blog/issues/31/timeline",
      "performed_via_github_app": null,
      "state_reason": null
    },
    {
      "url": "https://api.github.com/repos/bosens-China/blog/issues/11",
      "repository_url": "https://api.github.com/repos/bosens-China/blog",
      "labels_url": "https://api.github.com/repos/bosens-China/blog/issues/11/labels{/name}",
      "comments_url": "https://api.github.com/repos/bosens-China/blog/issues/11/comments",
      "events_url": "https://api.github.com/repos/bosens-China/blog/issues/11/events",
      "html_url": "https://github.com/bosens-China/blog/issues/11",
      "id": 479656673,
      "node_id": "MDU6SXNzdWU0Nzk2NTY2NzM=",
      "number": 11,
      "title": "变量提升",
      "user": {
        "login": "bosens-China",
        "id": 39508895,
        "node_id": "MDQ6VXNlcjM5NTA4ODk1",
        "avatar_url": "https://avatars.githubusercontent.com/u/39508895?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bosens-China",
        "html_url": "https://github.com/bosens-China",
        "followers_url": "https://api.github.com/users/bosens-China/followers",
        "following_url": "https://api.github.com/users/bosens-China/following{/other_user}",
        "gists_url": "https://api.github.com/users/bosens-China/gists{/gist_id}",
        "starred_url": "https://api.github.com/users/bosens-China/starred{/owner}{/repo}",
        "subscriptions_url": "https://api.github.com/users/bosens-China/subscriptions",
        "organizations_url": "https://api.github.com/users/bosens-China/orgs",
        "repos_url": "https://api.github.com/users/bosens-China/repos",
        "events_url": "https://api.github.com/users/bosens-China/events{/privacy}",
        "received_events_url": "https://api.github.com/users/bosens-China/received_events",
        "type": "User",
        "site_admin": false
      },
      "labels": [
        {
          "id": 1602397157,
          "node_id": "MDU6TGFiZWwxNjAyMzk3MTU3",
          "url": "https://api.github.com/repos/bosens-China/blog/labels/%E6%B7%B1%E5%85%A5%E7%B3%BB%E5%88%97",
          "name": "深入系列",
          "color": "719192",
          "default": false,
          "description": "主要介绍实现的思路"
        }
      ],
      "state": "open",
      "locked": false,
      "assignee": null,
      "assignees": [],
      "milestone": null,
      "comments": 0,
      "created_at": "2019-08-12T13:49:40Z",
      "updated_at": "2021-12-21T03:06:32Z",
      "closed_at": null,
      "author_association": "OWNER",
      "active_lock_reason": null,
      "body": "> 这里只是用伪代码的形式来说明，实际上变量声明只是执行上下文有关，推荐阅读[\r\nJavaScript深入之变量对象](https://github.com/mqyqingfeng/Blog/issues/5)\r\n\r\n## 太长不看篇\r\n函数参数 > 函数声明 > 变量声明\r\n\r\n## 变量声明\r\n首先想用一个伪生命周期来说这个事情，假设这段代码分为两个阶段，初始化阶段和赋值阶段； 看下面一段代码，用伪系统的话来阐述\r\n``` js\r\nconsole.log(a);\r\nvar a = 10;\r\n```\r\n如果按照上面的声明周期来说，首先变量 a 会在作用域注册一个变量(如果没有)默认赋值为 `undefined`\r\n\r\n初始化完成后，开始执行代码，第一行语句的时候因为变量 a 未经过赋值阶段，这一阶段的值是 `ndefined`，所以打印的结果自然也就是 `undefined`;\r\n\r\n在第二行的时候变量 a 会经过赋值阶段，这时变量 a 的值就是 10 了。\r\n\r\n## 函数声明\r\n函数声明与变量声明规则基本一致，优先级比变量声明要高\r\n\r\n是不是只说这一句话大家有些失望，如果只是单独来说函数声明未免太没意思，下面就结合变量声明来说说函数声明，毕竟代码只有变量声明就做不到有趣了。\r\n``` js\r\na();\r\nvar a = 10;\r\nfunction a() {\r\n  console.log(5);\r\n}\r\n```\r\n上面的执行结果是打印数字 5，为什么会出现这种情况呢？上面我们已经说了函数声明优先于变量声明，那么上面代码实际可以拆封成下面形式\r\n``` js\r\nfunction a() {\r\n  // ...\r\n}\r\na();\r\na = 10;\r\n```\r\n你可能还有疑惑，事实上如果变量提升的时候发现已经存在变量就会默默忽略掉，比如上面的代码变量 a 已经是一个函数了，那么变量声明的 a 会被忽略。\r\n\r\n最后说下函数参数，参数也是变量的一种形式，它的优先级最高，但是同样会受到函数声明的影响\r\n``` js\r\nfunction a(x) {\r\n  console.log(x);\r\n  function x() {}\r\n}\r\na(5);\r\n```\r\n这里输出结果是函数 x，原因是函数声明提升的时候会执行一个覆盖操作，就像我们写代码`x = 5`这样\r\n\r\n## 最后\r\n这里说的有很多地方不足，只是自己的见解，更推荐一篇文章[10 分钟理解执行上下文](https://zhuanlan.zhihu.com/p/25879753)\r\n\r\n最后根据上面的内容讲解一下他布置的一到题目\r\n``` js\r\nconsole.log(x);\r\nvar x = 10;\r\n\r\nconsole.log(x);\r\nx = 20;\r\n\r\nfunction x() {}\r\nconsole.log(x);\r\n\r\nif (true) {\r\n  var a = 1;\r\n} else {\r\n  var b = true;\r\n}\r\n\r\nconsole.log(a);\r\nconsole.log(b);\r\n```\r\n首先初始化阶段，`function x` 最先被提升，后面的变量提升因为已经存在函数 x 的原因会被忽略 第一个 console 输出的是函数` x`，\r\n\r\n之后执行到第二行代码的时候 `x` 被改变变成` 10`，第二个 `console` 输出为 `10`，之后继续被赋值为 `20`，第三个` console` 输出为 `20`，\r\n\r\n第四个和第五个 `console` 的输出分别为 `1` 和` undefined`，这是因为 es5 的环境下并不存在块级作用域，变量 `a` 和 `b` 会执行变量提升这一步骤， \r\n不同的是 `a` 被赋值为了 `1`，而 `b` 因为没有执行到 `var b = true` 所以值还是 `undefined`。",
      "reactions": {
        "url": "https://api.github.com/repos/bosens-China/blog/issues/11/reactions",
        "total_count": 0,
        "+1": 0,
        "-1": 0,
        "laugh": 0,
        "hooray": 0,
        "confused": 0,
        "heart": 0,
        "rocket": 0,
        "eyes": 0
      },
      "timeline_url": "https://api.github.com/repos/bosens-China/blog/issues/11/timeline",
      "performed_via_github_app": null,
      "state_reason": null
    },
    {
      "url": "https://api.github.com/repos/bosens-China/blog/issues/32",
      "repository_url": "https://api.github.com/repos/bosens-China/blog",
      "labels_url": "https://api.github.com/repos/bosens-China/blog/issues/32/labels{/name}",
      "comments_url": "https://api.github.com/repos/bosens-China/blog/issues/32/comments",
      "events_url": "https://api.github.com/repos/bosens-China/blog/issues/32/events",
      "html_url": "https://github.com/bosens-China/blog/issues/32",
      "id": 503866389,
      "node_id": "MDU6SXNzdWU1MDM4NjYzODk=",
      "number": 32,
      "title": "模拟实现new",
      "user": {
        "login": "bosens-China",
        "id": 39508895,
        "node_id": "MDQ6VXNlcjM5NTA4ODk1",
        "avatar_url": "https://avatars.githubusercontent.com/u/39508895?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bosens-China",
        "html_url": "https://github.com/bosens-China",
        "followers_url": "https://api.github.com/users/bosens-China/followers",
        "following_url": "https://api.github.com/users/bosens-China/following{/other_user}",
        "gists_url": "https://api.github.com/users/bosens-China/gists{/gist_id}",
        "starred_url": "https://api.github.com/users/bosens-China/starred{/owner}{/repo}",
        "subscriptions_url": "https://api.github.com/users/bosens-China/subscriptions",
        "organizations_url": "https://api.github.com/users/bosens-China/orgs",
        "repos_url": "https://api.github.com/users/bosens-China/repos",
        "events_url": "https://api.github.com/users/bosens-China/events{/privacy}",
        "received_events_url": "https://api.github.com/users/bosens-China/received_events",
        "type": "User",
        "site_admin": false
      },
      "labels": [
        {
          "id": 1602397157,
          "node_id": "MDU6TGFiZWwxNjAyMzk3MTU3",
          "url": "https://api.github.com/repos/bosens-China/blog/labels/%E6%B7%B1%E5%85%A5%E7%B3%BB%E5%88%97",
          "name": "深入系列",
          "color": "719192",
          "default": false,
          "description": "主要介绍实现的思路"
        }
      ],
      "state": "open",
      "locked": false,
      "assignee": null,
      "assignees": [],
      "milestone": null,
      "comments": 0,
      "created_at": "2019-10-08T07:03:22Z",
      "updated_at": "2021-12-21T03:04:48Z",
      "closed_at": null,
      "author_association": "OWNER",
      "active_lock_reason": null,
      "body": "> new 运算符创建一个用户定义的对象类型的实例或具有构造函数的内置对象的实例。\r\n\r\n上面的定义有点抽象，我们来通过一个例子看 new 运算符扮演的角色\r\n\r\n```js\r\nfunction Foo(name, age) {\r\n  this.name = name;\r\n  this.age = age;\r\n}\r\nFoo.prototype.getName = function() {\r\n  return this.name;\r\n};\r\nFoo.prototype.foo = \"foo\";\r\nvar f = new Foo(\"zhangsan\", 18);\r\nf.getName(); // zhangsan\r\nf.foo; // foo\r\n```\r\n\r\n上面通过 new 创建了一个新的对象，并且这个对象通过原型链访问到了原型上的方法和属性，所以 new 运算符就是执行构造函数返回一个实例对象。\r\n\r\nnew 运算符在执行时执行了下面四步：\r\n\r\n1. 创建一个空的简单 JavaScript 对象（即{}）；\r\n2. 链接该对象（即设置该对象的构造函数）到另一个对象 ；\r\n3. 将步骤 1 新创建的对象作为 this 的上下文 ；\r\n4. 如果该函数没有返回对象，则返回 this。\r\n\r\n## 实现\r\n\r\n根据上面的执行步骤我们来尝试实现下，当然 new 操作符肯定是模拟不了了，下面通过函数的形式展示\r\n\r\n```js\r\nfunction newCall(fn) {\r\n  var args = Array.prototype.slice.call(arguments, 1);\r\n  var obj = {};\r\n  obj.__proto__ = fn.prototype;\r\n  var result = fn.apply(obj, args);\r\n  return result && typeof result === \"object\" ? result : obj;\r\n}\r\n```\r\n\r\nOk，到这里就实现了一个模拟 new 的操作，我们测试一下\r\n\r\n```js\r\nfunction Otaku(name, age) {\r\n  this.name = name;\r\n  this.age = age;\r\n\r\n  this.habit = \"Games\";\r\n}\r\n\r\nOtaku.prototype.strength = 60;\r\n\r\nOtaku.prototype.sayYourName = function() {\r\n  console.log(\"I am \" + this.name);\r\n};\r\n\r\nfunction newCall(fn) {\r\n  var args = Array.prototype.slice.call(arguments, 1);\r\n  var obj = {};\r\n  obj.__proto__ = fn.prototype;\r\n  var result = fn.apply(obj, args);\r\n  return result && typeof result === \"object\" ? result : obj;\r\n}\r\n\r\nvar person = newCall(Otaku, \"Kevin\", \"18\");\r\n\r\nconsole.log(person.name); // Kevin\r\nconsole.log(person.habit); // Games\r\nconsole.log(person.strength); // 60\r\n```\r\n\r\n撒花 ✿✿ ヽ(°▽°)ノ ✿，不过额外提醒一下`__proto__`是浏览器实现的非标准属性，一般情况下不推荐使用，不过既然是模拟 es5 推荐的`Object.setPrototypeOf`肯定没办法用了，只能将就着用了\r\n",
      "reactions": {
        "url": "https://api.github.com/repos/bosens-China/blog/issues/32/reactions",
        "total_count": 0,
        "+1": 0,
        "-1": 0,
        "laugh": 0,
        "hooray": 0,
        "confused": 0,
        "heart": 0,
        "rocket": 0,
        "eyes": 0
      },
      "timeline_url": "https://api.github.com/repos/bosens-China/blog/issues/32/timeline",
      "performed_via_github_app": null,
      "state_reason": null
    },
    {
      "url": "https://api.github.com/repos/bosens-China/blog/issues/59",
      "repository_url": "https://api.github.com/repos/bosens-China/blog",
      "labels_url": "https://api.github.com/repos/bosens-China/blog/issues/59/labels{/name}",
      "comments_url": "https://api.github.com/repos/bosens-China/blog/issues/59/comments",
      "events_url": "https://api.github.com/repos/bosens-China/blog/issues/59/events",
      "html_url": "https://github.com/bosens-China/blog/issues/59",
      "id": 647201487,
      "node_id": "MDU6SXNzdWU2NDcyMDE0ODc=",
      "number": 59,
      "title": "深浅拷贝和extend",
      "user": {
        "login": "bosens-China",
        "id": 39508895,
        "node_id": "MDQ6VXNlcjM5NTA4ODk1",
        "avatar_url": "https://avatars.githubusercontent.com/u/39508895?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bosens-China",
        "html_url": "https://github.com/bosens-China",
        "followers_url": "https://api.github.com/users/bosens-China/followers",
        "following_url": "https://api.github.com/users/bosens-China/following{/other_user}",
        "gists_url": "https://api.github.com/users/bosens-China/gists{/gist_id}",
        "starred_url": "https://api.github.com/users/bosens-China/starred{/owner}{/repo}",
        "subscriptions_url": "https://api.github.com/users/bosens-China/subscriptions",
        "organizations_url": "https://api.github.com/users/bosens-China/orgs",
        "repos_url": "https://api.github.com/users/bosens-China/repos",
        "events_url": "https://api.github.com/users/bosens-China/events{/privacy}",
        "received_events_url": "https://api.github.com/users/bosens-China/received_events",
        "type": "User",
        "site_admin": false
      },
      "labels": [
        {
          "id": 1602397157,
          "node_id": "MDU6TGFiZWwxNjAyMzk3MTU3",
          "url": "https://api.github.com/repos/bosens-China/blog/labels/%E6%B7%B1%E5%85%A5%E7%B3%BB%E5%88%97",
          "name": "深入系列",
          "color": "719192",
          "default": false,
          "description": "主要介绍实现的思路"
        }
      ],
      "state": "open",
      "locked": false,
      "assignee": null,
      "assignees": [],
      "milestone": null,
      "comments": 0,
      "created_at": "2020-06-29T07:59:36Z",
      "updated_at": "2021-12-21T03:04:38Z",
      "closed_at": null,
      "author_association": "OWNER",
      "active_lock_reason": null,
      "body": "## 前言\r\n\r\n深浅拷贝和 extend 是项目中常用的工具类函数，今天就动手实现一下\r\n\r\n下面会重复这几个基础函数，为了简洁下面不会出现相关定义\r\n\r\n```js\r\nfunction isObject(obj) {\r\n  return obj && typeof obj === \"object\";\r\n}\r\nfunction type(obj) {\r\n  return Object.prototype.toString\r\n    .call(obj)\r\n    .replace(/\\[object.(.+?)\\]/, \"$1\")\r\n    .toLowerCase();\r\n}\r\nfunction array(par) {\r\n  return type(par) === \"array\";\r\n}\r\n```\r\n\r\n## 浅拷贝用法\r\n\r\n```js\r\nvar obj = { name: \"test\", args: [{ name: 1 }] };\r\nvar test = { ...obj };\r\n// 修改下原来属性\r\nobj.name = \"foo\";\r\n// test.name test\r\nobj.args.push(\"456\");\r\n// args: (2) [{…}, \"456\"]\r\n```\r\n\r\n从上面例子可以看到，当两个对象出现相同字段的时候，后者会覆盖前者，而不会进行深层次的覆盖。\r\n\r\n由此可以得到一个结论：浅拷贝可以简单理解为只拷贝对象的一层属性，如果拷贝的属性还是对象，那么修改它则会影响到拥有相同属性的对象。\r\n\r\n## 浅拷贝实现\r\n\r\n结合上面的结论，我们动手实现一个函数\r\n\r\n```js\r\nexport function copy(obj) {\r\n  if (!isObject(obj)) {\r\n    return;\r\n  }\r\n  const src = array(obj) ? [] : {};\r\n  for (const key in obj) {\r\n    const value = obj[key];\r\n    if (Object.prototype.hasOwnProperty.call(obj, key)) {\r\n      src[key] = value;\r\n    }\r\n  }\r\n  return src;\r\n}\r\n```\r\n\r\n测试用例\r\n\r\n```js\r\ntest(\"浅拷贝\", () => {\r\n  const value = { a: 123, b: 456, c: [1] };\r\n  const test = copy(value);\r\n  expect(test).toEqual({ a: 123, b: 456, c: [1] });\r\n  expect(value === test).toBeFalsy();\r\n  expect(value.c === test.c).toBeTruthy();\r\n  expect(value.a === test.a).toBeTruthy();\r\n});\r\n```\r\n\r\n## 深拷贝\r\n\r\n上面我们已经实现了浅拷贝，浅拷贝只是简单的拷贝了一层属性，如果是深拷贝呢？\r\n\r\n其实就是对属性为对象进行重复的调用，在实现这个之前先看一个比较简单的做法。\r\n\r\n#### json\r\n\r\n```js\r\nfunction deepAssign(par) {\r\n  return JSON.parse(JSON.stringify(par));\r\n}\r\n// 测试用例\r\nconst value = {a: {name: 456}};\r\nconst test = deepAssign({value);\r\ntest.a === value.a;\r\n//false\r\ndeepAssign({ a() {}, b: /abc/, c: Math.floor, d: null, e: new Set() });\r\n// {b: {}, d: null, e: {}}\r\n```\r\n\r\n需要特别注意用这个方法处理函数、正则之类的对象不会出现预期结果，不过在处理接口返回的数据不失为一种方法。\r\n\r\n#### 递归\r\n\r\n相比`JSON`的方式实现，可以让我们自由定制一些类型，例如上面的`正则`就可以通过`hack`方法创建，为了简化源码，这里只处理对象和数组，对于其他类型的处理可以参考一下第三方库\r\n\r\n```js\r\nfunction deepCopy(obj, has = new WeakMap()) {\r\n  if (!isObject(obj)) {\r\n    return;\r\n  }\r\n  // 避免循环引用\r\n  if (has.has(obj)) {\r\n    return has.get(obj);\r\n  }\r\n  const src = array(obj) ? [] : {};\r\n  has.set(obj, src);\r\n  for (const key in obj) {\r\n    const value = obj[key];\r\n    if (Object.prototype.hasOwnProperty.call(obj, key)) {\r\n      // 注意这一行\r\n      src[key] = isObject(value) ? copy(value, has) : value;\r\n    }\r\n  }\r\n  return src;\r\n}\r\n```\r\n\r\n测试用例\r\n\r\n```js\r\ntest(\"深拷贝\", () => {\r\n  const value = { a: 123, b: 456, c: [1] };\r\n  const test = deepCopy(value);\r\n  expect(test).toEqual({ a: 123, b: 456, c: [1] });\r\n  expect(value === test).toBeFalsy();\r\n  expect(value.c === test.c).toBeFalsy();\r\n  expect(value.a === test.a).toBeTruthy();\r\n});\r\n```\r\n\r\n注意上面用了一个`WeakMap`，这个是为了避免循环引入，你可以把上面的`WeakMap`相关代码去掉，然后在控制台输入下面这个例子，看看会出现什么结果。\r\n\r\n```js\r\nvar a = {};\r\na.a = a;\r\nvar test = deepCopy(a);\r\n```\r\n\r\n## extend\r\n\r\nextend 分为两部分:\r\n\r\n1. 浅合并，`Object.assign`就是浅拷贝；\r\n2. 深合并，没有相关的的 api，需要手动实现\r\n\r\n#### 浅合并使用方法\r\n\r\n在实现这个方法之前，我们约定一下格式\r\n\r\n```js\r\nassign( target [, object1 ] [, objectN ] )\r\n```\r\n\r\n第一个参数为目标对象必须是对象，之后的参数是目标对象，可以不为对象\r\n\r\n```js\r\nvar obj1 = {\r\n  a: 1,\r\n  b: { b1: 1, b2: 2 },\r\n};\r\n\r\nvar obj2 = {\r\n  b: { b1: 3, b3: 4 },\r\n  c: 3,\r\n};\r\n\r\nvar obj3 = {\r\n  d: 4,\r\n};\r\n\r\nconsole.log(assign(obj1, obj2, obj3));\r\n\r\n// {\r\n//    a: 1,\r\n//    b: { b1: 3, b3: 4 },\r\n//    c: 3,\r\n//    d: 4\r\n// }\r\n```\r\n\r\n#### 浅合并实现\r\n\r\n根据上面的约束，动手实现一下\r\n\r\n```js\r\nfunction assign() {\r\n  let target = arguments[0];\r\n  let i = 1,\r\n    leg = arguments.length;\r\n  if (!isObject(target)) {\r\n    target = {};\r\n  }\r\n  for (; i < leg; i++) {\r\n    const value = arguments[i];\r\n    if (value == null) {\r\n      continue;\r\n    }\r\n    for (const name in value) {\r\n      if (Object.prototype.hasOwnProperty.call(value, name)) {\r\n        const copy = value[name];\r\n        target[name] = copy;\r\n      }\r\n    }\r\n  }\r\n  return target;\r\n}\r\n```\r\n\r\n测试用例\r\n\r\n```js\r\ntest(\"浅拷贝\", () => {\r\n  const value1 = { name: \"test\", age: 17 };\r\n  const value2 = { name: \"app\", age: [1, 2, 3] };\r\n  const test = assign(value1, value2, null, undefined, \"abc\");\r\n  expect(assign(test)).toEqual({\r\n    name: \"app\",\r\n    age: [1, 2, 3],\r\n    0: \"a\",\r\n    1: \"b\",\r\n    2: \"c\",\r\n  });\r\n  expect(test.age === value2.age).toBeTruthy();\r\n  var obj1 = {\r\n    a: 1,\r\n    b: { b1: 1, b2: 2 },\r\n  };\r\n\r\n  var obj2 = {\r\n    b: { b1: 3, b3: 4 },\r\n    c: 3,\r\n  };\r\n\r\n  var obj3 = {\r\n    d: 4,\r\n  };\r\n  expect(assign(obj1, obj2, obj3)).toEqual({\r\n    a: 1,\r\n    b: { b1: 3, b3: 4 },\r\n    c: 3,\r\n    d: 4,\r\n  });\r\n});\r\n```\r\n\r\n#### 深合并\r\n\r\n```js\r\nfunction deepAssign(...args) {\r\n  let obj = {};\r\n  for (const value of args) {\r\n    if (array(value)) {\r\n      if (!array(obj)) {\r\n        obj = [];\r\n      }\r\n      // 对数组内容进行深拷贝\r\n      const arr = value.reduce((x, y) => {\r\n        x = x.concat(isObject(y) ? deepAssign([], y) : y);\r\n        return x;\r\n      }, []);\r\n      obj = [...obj, ...arr];\r\n    } else if (isObject(value)) {\r\n      for (let [name, val] of Object.entries(value)) {\r\n        if (isObject(val) && name in obj) {\r\n          val = deepAssign(obj[name], val);\r\n        }\r\n        obj = {\r\n          ...obj,\r\n          [name]: val,\r\n        };\r\n      }\r\n    }\r\n  }\r\n  return obj;\r\n}\r\n```\r\n\r\n`if (isObject(val) && name in obj)`注意这行的判断，只有当 target 属性上有值的时候才会进行递归调用。\r\n\r\n测试用例\r\n\r\n```js\r\ntest(\"深合并\", () => {\r\n  const value1 = [1, 2, { name: { age: [1, 2, 3, 4, 5] } }];\r\n  const value2 = [1, 2, { age: 18 }];\r\n  const test = deepAssign(value1, value2);\r\n  expect(test[2] === value1[2]).toBe(false);\r\n  expect(test).toEqual([\r\n    1,\r\n    2,\r\n    { name: { age: [1, 2, 3, 4, 5] } },\r\n    1,\r\n    2,\r\n    { age: 18 },\r\n  ]);\r\n  const obj1 = { name: [1, 2, 3] };\r\n  const obj2 = { age: 17, name: [4, 5, 6] };\r\n  const obj = deepAssign(obj1, obj2);\r\n  expect(obj).toEqual({ name: [1, 2, 3, 4, 5, 6], age: 17 });\r\n  const a = {};\r\n  a.a = a;\r\n  expect(deepAssign(a)).toEqual({ a: { a } });\r\n});\r\n```\r\n\r\n## 最后\r\n\r\n如果有错误或者不严谨的地方，请务必给予指正，十分感谢。如果喜欢或者有所启发，欢迎 `star`，对作者也是一种鼓励。\r\n",
      "reactions": {
        "url": "https://api.github.com/repos/bosens-China/blog/issues/59/reactions",
        "total_count": 0,
        "+1": 0,
        "-1": 0,
        "laugh": 0,
        "hooray": 0,
        "confused": 0,
        "heart": 0,
        "rocket": 0,
        "eyes": 0
      },
      "timeline_url": "https://api.github.com/repos/bosens-China/blog/issues/59/timeline",
      "performed_via_github_app": null,
      "state_reason": null
    },
    {
      "url": "https://api.github.com/repos/bosens-China/blog/issues/44",
      "repository_url": "https://api.github.com/repos/bosens-China/blog",
      "labels_url": "https://api.github.com/repos/bosens-China/blog/issues/44/labels{/name}",
      "comments_url": "https://api.github.com/repos/bosens-China/blog/issues/44/comments",
      "events_url": "https://api.github.com/repos/bosens-China/blog/issues/44/events",
      "html_url": "https://github.com/bosens-China/blog/issues/44",
      "id": 547208786,
      "node_id": "MDU6SXNzdWU1NDcyMDg3ODY=",
      "number": 44,
      "title": "global对象获取",
      "user": {
        "login": "bosens-China",
        "id": 39508895,
        "node_id": "MDQ6VXNlcjM5NTA4ODk1",
        "avatar_url": "https://avatars.githubusercontent.com/u/39508895?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bosens-China",
        "html_url": "https://github.com/bosens-China",
        "followers_url": "https://api.github.com/users/bosens-China/followers",
        "following_url": "https://api.github.com/users/bosens-China/following{/other_user}",
        "gists_url": "https://api.github.com/users/bosens-China/gists{/gist_id}",
        "starred_url": "https://api.github.com/users/bosens-China/starred{/owner}{/repo}",
        "subscriptions_url": "https://api.github.com/users/bosens-China/subscriptions",
        "organizations_url": "https://api.github.com/users/bosens-China/orgs",
        "repos_url": "https://api.github.com/users/bosens-China/repos",
        "events_url": "https://api.github.com/users/bosens-China/events{/privacy}",
        "received_events_url": "https://api.github.com/users/bosens-China/received_events",
        "type": "User",
        "site_admin": false
      },
      "labels": [
        {
          "id": 1371686609,
          "node_id": "MDU6TGFiZWwxMzcxNjg2NjA5",
          "url": "https://api.github.com/repos/bosens-China/blog/labels/JavaScript",
          "name": "JavaScript",
          "color": "F7DF1E",
          "default": false,
          "description": "JavaScript系列的文章"
        }
      ],
      "state": "open",
      "locked": false,
      "assignee": null,
      "assignees": [],
      "milestone": null,
      "comments": 0,
      "created_at": "2020-01-09T02:19:18Z",
      "updated_at": "2021-12-21T03:03:16Z",
      "closed_at": null,
      "author_association": "OWNER",
      "active_lock_reason": null,
      "body": "global 在开发中经常经常使用，例如下面一段代码调用的就是 global 内置的对象\r\n\r\n```js\r\nconst min = Math.min(...[1, 11, 22, 55, -2, -1]);\r\n```\r\n\r\n这里的 Math 对象就是 global 内置的，在浏览器环境下我们可以通过`window.Math.min`显示调用，而在 node 环境下我们则要通过`global.Math.min`来调用，在实际中我们不会通过`window.Math.min`这种方式来调用，不过却也能看到不同环境下获取 global 对象各不相同。\r\n\r\n下面就以编写一个现代的工具库为假设，这个库要支持全局引用也是很科学的，但是如何让其挂载在全局属性上呢？\r\n\r\n## 第一版\r\n\r\n```js\r\n(function() {\r\n  var _global = this;\r\n  var _ = {};\r\n  _.debounce = function() {};\r\n  // ...一些其他的方法\r\n  return (_global._ = _);\r\n})();\r\n```\r\n\r\n这里的想法是通过全局环境下运行 this 来返回一个全局对象，在全局对象上挂载我们的工具函数，不通过 `window` 显示挂载是因为我们不仅要让这个工具库运行在浏览器环境下,同时也让他运行在 `node` 环境中。\r\n\r\n## 严格模式\r\n\r\n上面的写法是假设在非严格模式下运行，而在严格模式下运行，this 会返回一个`undefined`\r\n\r\n```js\r\n(function() {\r\n  \"use strict\";\r\n  console.log(this === undefined); // true\r\n})();\r\n```\r\n\r\n下面我们来尝试修订一下严格模式下的错误\r\n\r\n```js\r\n(function() {\r\n  // 防止null出现\r\n  function isObjectLike(par) {\r\n    return par && typeof par == \"object\";\r\n  }\r\n  var _global;\r\n  if (isObjectLike(global) && global.global === global) {\r\n    _global = global;\r\n  } else {\r\n    _global = window;\r\n  }\r\n  var _ = {};\r\n  _.debounce = function() {};\r\n  // ...一些其他的方法\r\n  return (_global._ = _);\r\n})();\r\n```\r\n\r\n这里我们通过判断 global 是否存在，如果存在就是 `node` 环境如果不存在就是浏览器环境。\r\n\r\n> `global.global`和`window.window`都是指向自身，可以理解为无限嵌套的属性\r\n\r\n## Web Worker\r\n\r\nWeb Worker 是为 JavaScript 创造多线程环境出现的，不过使用它是有一些限制无法使用 `document、window、parent`等这些对象，所以在上面的例子中如果我们在 Web Worker 环境中一定会报错，因为不存在 `global` 和 `window` 对象\r\n\r\n不过 Worker 可以通过`self`来拿到子线程的全局对象，而且 self 在浏览器环境下也指向 window\r\n\r\n```js\r\n(function() {\r\n  // 防止null出现\r\n  function isObjectLike(par) {\r\n    return par && typeof par == \"object\";\r\n  }\r\n  var _global;\r\n  if (isObjectLike(global) && global.global === global) {\r\n    _global = global;\r\n  } else if (isObjectLike(self) && self === self) {\r\n    _global = self;\r\n  }\r\n  var _ = {};\r\n  _.debounce = function() {};\r\n  // ...一些其他的方法\r\n  return (_global._ = _);\r\n})();\r\n```\r\n\r\n## node 虚拟机\r\n\r\nnode vm（沙盒） 环境下不存在 global 和 window 对象，所以上面代码还是会出现问题，不过我们可以通过\r\n`new Function('return this')()`或者`this`的形式来解决\r\n\r\n```js\r\n(function() {\r\n  // 防止null出现\r\n  function isObjectLike(par) {\r\n    return par && typeof par == \"object\";\r\n  }\r\n  var _global;\r\n  if (isObjectLike(global) && global.global === global) {\r\n    _global = global;\r\n  } else if (isObjectLike(self) && self === self) {\r\n    _global = self;\r\n  } else {\r\n    _global = new Function(\"return this\")();\r\n    // 或者\r\n    // _global = this;\r\n  }\r\n  var _ = {};\r\n  _.debounce = function() {};\r\n  // ...一些其他的方法\r\n  return (_global._ = _);\r\n})();\r\n```\r\n\r\n## Content Security Policy\r\n\r\n上面你可能注意到了，我在上一版提到了两个方法来最后获取 `global` 的值\r\n\r\n- \\_global = new Function(\"return this\")();\r\n- \\_global = this;\r\n\r\n不过在网页安全政策（Content Security Policy）下只会加载信任的白名单，`eval、new Function`这些方法都可能无法使用，只能使用`\\_global = this`来获取 global\r\n\r\n```js\r\n(function() {\r\n  // 防止null出现\r\n  function isObjectLike(par) {\r\n    return par && typeof par == \"object\";\r\n  }\r\n  var _global;\r\n  if (isObjectLike(global) && global.global === global) {\r\n    _global = global;\r\n  } else if (isObjectLike(self) && self === self) {\r\n    _global = self;\r\n  } else {\r\n    // 或者\r\n    _global = this;\r\n  }\r\n  var _ = {};\r\n  _.debounce = function() {};\r\n  // ...一些其他的方法\r\n  return (_global._ = _);\r\n})();\r\n```\r\n\r\n## 微信小程序\r\n\r\n在微信小程序中`global`和`window`都不存在再加上使用的是严格模式，this 会返回`undefined`所以我们还需要在加一个判断\r\n\r\n```js\r\n(function() {\r\n  // 防止null出现\r\n  function isObjectLike(par) {\r\n    return par && typeof par == \"object\";\r\n  }\r\n  var _global;\r\n  if (isObjectLike(global) && global.global === global) {\r\n    _global = global;\r\n  } else if (isObjectLike(self) && self === self) {\r\n    _global = self;\r\n  } else {\r\n    // 或者\r\n    _global = this || {};\r\n  }\r\n  var _ = {};\r\n  _.debounce = function() {};\r\n  // ...一些其他的方法\r\n  return (_global._ = _);\r\n})();\r\n```\r\n\r\n## globalThis\r\n\r\n上面的判断方式是现在社区主流做法，不过在 tc39 的提案中`globalThis`可以获取全局对象，使用方法也很简单\r\n\r\n```js\r\n// 浏览器环境\r\nglobalThis === window; // true\r\n// node\r\nglobalThis === global; // true\r\n```\r\n\r\n目前是`Stage 3`使用的话还是需要做一些兼容性的处理，下面就来写最后一版\r\n\r\n```js\r\n(function() {\r\n  // 防止null出现\r\n  function isObjectLike(par) {\r\n    return par && typeof par == \"object\";\r\n  }\r\n  function getGlobal() {\r\n    if (isObjectLike(globalThis) && globalThis.Object === Object) {\r\n      return globalThis;\r\n    }\r\n    if (isObjectLike(global) && global.global === global) {\r\n      return global;\r\n    }\r\n\r\n    if (isObjectLike(self) && self === self) {\r\n      return self;\r\n    }\r\n    return this || {};\r\n  }\r\n\r\n  var _global = getGlobal();\r\n  var _ = {};\r\n  _.debounce = function() {};\r\n  // ...一些其他的方法\r\n  return (_global._ = _);\r\n})();\r\n```\r\n\r\n## 最后\r\n\r\n本来可以一次写完，不过还是希望循循而进了解写了这么多判断究竟是为什么，最后如果有不正确的地方希望有小伙伴指出来，欢迎 star，对作者也是一种鼓励。\r\n\r\n## 参考链接\r\n\r\n- https://developer.mozilla.org/zh-CN/docs/Web/HTTP/CSP\r\n- https://github.com/mqyqingfeng/Blog/issues/56\r\n- https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/globalThis\r\n- https://github.com/lodash/lodash/blob/master/.internal/root.js\r\n",
      "reactions": {
        "url": "https://api.github.com/repos/bosens-China/blog/issues/44/reactions",
        "total_count": 0,
        "+1": 0,
        "-1": 0,
        "laugh": 0,
        "hooray": 0,
        "confused": 0,
        "heart": 0,
        "rocket": 0,
        "eyes": 0
      },
      "timeline_url": "https://api.github.com/repos/bosens-China/blog/issues/44/timeline",
      "performed_via_github_app": null,
      "state_reason": null
    },
    {
      "url": "https://api.github.com/repos/bosens-China/blog/issues/54",
      "repository_url": "https://api.github.com/repos/bosens-China/blog",
      "labels_url": "https://api.github.com/repos/bosens-China/blog/issues/54/labels{/name}",
      "comments_url": "https://api.github.com/repos/bosens-China/blog/issues/54/comments",
      "events_url": "https://api.github.com/repos/bosens-China/blog/issues/54/events",
      "html_url": "https://github.com/bosens-China/blog/issues/54",
      "id": 588233327,
      "node_id": "MDU6SXNzdWU1ODgyMzMzMjc=",
      "number": 54,
      "title": "使用 canvas 实现贪吃蛇",
      "user": {
        "login": "bosens-China",
        "id": 39508895,
        "node_id": "MDQ6VXNlcjM5NTA4ODk1",
        "avatar_url": "https://avatars.githubusercontent.com/u/39508895?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bosens-China",
        "html_url": "https://github.com/bosens-China",
        "followers_url": "https://api.github.com/users/bosens-China/followers",
        "following_url": "https://api.github.com/users/bosens-China/following{/other_user}",
        "gists_url": "https://api.github.com/users/bosens-China/gists{/gist_id}",
        "starred_url": "https://api.github.com/users/bosens-China/starred{/owner}{/repo}",
        "subscriptions_url": "https://api.github.com/users/bosens-China/subscriptions",
        "organizations_url": "https://api.github.com/users/bosens-China/orgs",
        "repos_url": "https://api.github.com/users/bosens-China/repos",
        "events_url": "https://api.github.com/users/bosens-China/events{/privacy}",
        "received_events_url": "https://api.github.com/users/bosens-China/received_events",
        "type": "User",
        "site_admin": false
      },
      "labels": [
        {
          "id": 1371686609,
          "node_id": "MDU6TGFiZWwxMzcxNjg2NjA5",
          "url": "https://api.github.com/repos/bosens-China/blog/labels/JavaScript",
          "name": "JavaScript",
          "color": "F7DF1E",
          "default": false,
          "description": "JavaScript系列的文章"
        }
      ],
      "state": "open",
      "locked": false,
      "assignee": null,
      "assignees": [],
      "milestone": null,
      "comments": 0,
      "created_at": "2020-03-26T08:13:17Z",
      "updated_at": "2021-12-21T02:57:58Z",
      "closed_at": null,
      "author_association": "OWNER",
      "active_lock_reason": null,
      "body": "<div align=center><img src=\"https://user-images.githubusercontent.com/39508895/139045104-f01d3705-928a-478a-8859-ae6e3cf20c98.png\" alt=\"贪吃蛇\"></div>\r\n\r\n\r\n童年使用的诺基亚基本上都会搭载这款小游戏，最近心血来潮想用 canvas 来实现这个游戏就有了这篇文章，下面讲解一下实现的思路，本文的最终代码已经放到了[codesandbox](https://codesandbox.io/s/peaceful-firefly-c1i43?file=/src/index.js)上。\r\n\r\n当然实现的方式并不止 `canvas` 这一种，还可以使用 `html` + `css` 的形式，这里不讨论优劣取舍，让我们快速开始吧。\r\n\r\n## 游戏规则\r\n\r\n在开发之前先要设计游戏的具体规则是怎么样的，就像是实现`polyfill`也要对照规范一样，贪吃蛇游戏规则还是蛮简单下面概括一下：\r\n\r\n- 初始的时候会被四周墙体包围着，贪吃蛇这时候很虚弱只有一节，墙的周围随机分布着一个鸡蛋（奖励品）\r\n- 按下方向键游戏开始，吃到鸡蛋身体会边长，同时会生成新的鸡蛋\r\n- 撞到墙体和撞到身体会结束游戏\r\n\r\n上面规则概括成代码就是我们需要给一个界面范围、绘制蛇和鸡蛋、让蛇动起来。\r\n\r\n## 基本概念\r\n\r\n`canvas` 是 `html5` 出现的元素，它可以用于数据可视化、动画、游戏、图像操作、视频等方面，它以 `JavaScript` 的方式来进行交互。\r\n\r\n为了方便下面的理解介绍几个基本概念\r\n\r\n- `var ctx = canvas.getContext(contextType);`\r\n\r\n`getContext` 返回 `canvas` 的上下文，`contextType` 指定了何种上下文，它有 `2d`、`webgl`、`webgl2`、`bitmaprenderer`这几种选项，这里只需要 2d 界面，所以填写 2d 即可。\r\n\r\n> 可以根据 `canvas.getContext` 存在判断浏览器支不支持 `canvas` 元素\r\n\r\n- `CanvasRenderingContext2D.clearRect`\r\n\r\n指定矩形区域的像素都变成透明，**注意这个方法不等于完全清除画布，对于一些 `path` 的方法记得手动 `closePath()`**\r\n\r\n- 动画的组成原理\r\n\r\n后续我们需要让贪吃蛇动起来，但是动这个概念是一个伪命题，想一下电视和电影是怎么让我们感觉到动的呢？就是通过一帧帧的画面快速播放得到的视觉效果。\r\n\r\n后面让蛇动起来也是通过定时器来让 `canvas` 不断重绘达到动画的效果。\r\n\r\n## 实现思路\r\n\r\n![坐标](https://user-images.githubusercontent.com/39508895/139045144-fb2d7562-20a8-4c52-a76b-30a1eca7031c.png)\r\n\r\n\r\n如文章首页的示例图片，贪吃蛇可以想象成一个坐标，根据这个坐标很容易得到下面启示：\r\n\r\n- 蛇和鸡蛋都会在坐标中出现，但不会超出\r\n- 撞到坐标的边界即是撞墙\r\n- 每次贪吃蛇移动都需要擦拭移动的路径\r\n- 判断有没有撞到身体和吃不是吃到鸡蛋，判断移动的坐标值是什么即可\r\n\r\n也就是说，贪吃蛇这个游戏最核心的就是坐标这个概念，为了快速得到坐标的信息，我们期待以下面的形式来储存数据。\r\n\r\n```js\r\ninterface CoordinateAll {\r\n  [x: number]: {\r\n    [y: number]: 'block' | 'egg' | 'sanke';\r\n  };\r\n}\r\n// 转化成JavaScript表示\r\n{\r\n  1: {1: 'block', 2: 'egg', 'block'},\r\n  2: {1: 'block', 2: 'block', 'block'},\r\n  // ...\r\n}\r\n```\r\n\r\n为了后续的使用方便，提前定义两个文件\r\n\r\n```js\r\n// utils.js\r\n// 传递一个整数，来循环它\r\nexport const eachNumber = (n, fn) => {\r\n  for (let i = 0; i < n; i++) {\r\n    fn(i);\r\n  }\r\n};\r\n// 返回随机整数\r\nexport const randomNumber = (min, max) => {\r\n  return Math.floor(Math.random() * (max - min + 1)) + min;\r\n};\r\n```\r\n\r\n```js\r\n// const.js\r\n// canvas宽度\r\nexport const WIDTH = 400;\r\n// 高度\r\nexport const HEIGHT = 400;\r\n// 像素x\r\nexport const PIXEL_X = 20;\r\n// 像素y\r\nexport const PIXEL_Y = 20;\r\n// 行\r\nexport const ROW = HEIGHT / PIXEL_Y;\r\n// 列\r\nexport const COLUMN = WIDTH / PIXEL_X;\r\n// 半径\r\nexport const RADIUS = 10;\r\n// 定时器间隔\r\nexport const INTERVAL = 150;\r\n// 鸡蛋颜色\r\nexport const EGG_COLOR = '#767803';\r\n// 蛇颜色\r\nexport const SANKE_COLOR = '#6f5f06';\r\n// 边框颜色\r\nexport const BORDER_COLOR = '#796e09';\r\n```\r\n\r\n后面就开始绘制初始的界面。\r\n\r\n## 初始化界面\r\n\r\n```js\r\nclass Sanke {\r\n  constructor() {\r\n    const canvas = document.createElement('canvas');\r\n    canvas.width = WIDTH;\r\n    canvas.height = HEIGHT;\r\n    this.canvas = canvas;\r\n    document.body.appendChild(canvas);\r\n    const ctx = canvas.getContext('2d');\r\n    this.ctx = ctx;\r\n\r\n    // 蛇身\r\n    this.currentSanke = [];\r\n    // 出现的egg位置\r\n    this.currentEgg = null;\r\n    // 坐标系\r\n    this.coordinateAll = {};\r\n    this.init();\r\n  }\r\n  init() {\r\n    // 创建坐标系\r\n    this.coordinateAll = {};\r\n    eachNumber(ROW, (x) => {\r\n      this.coordinateAll[x] = {};\r\n      eachNumber(COLUMN, (y) => {\r\n        this.coordinateAll[x][y] = 'block';\r\n      });\r\n    });\r\n    const sanke = this.randomCoordinate();\r\n    this.setCoordinate(sanke, 'sanke');\r\n    this.currentSanke = [sanke];\r\n    this.currentEgg = this.randomCoordinate();\r\n    this.setCoordinate(this.currentEgg, 'egg');\r\n    this.repaint();\r\n  }\r\n  repaint() {\r\n    const { ctx, canvas, currentSanke } = this;\r\n    // 绘制egg和绘制sanke\r\n    ctx.clearRect(0, 0, canvas.width, canvas.height);\r\n    ctx.strokeStyle = BORDER_COLOR;\r\n    ctx.strokeRect(0, 0, canvas.width, canvas.height);\r\n    ctx.fillStyle = SANKE_COLOR;\r\n    currentSanke.forEach((item) => {\r\n      ctx.fillRect(item.x * PIXEL_X, item.y * PIXEL_Y, PIXEL_X, PIXEL_Y);\r\n    });\r\n    // 绘制egg\r\n    ctx.beginPath();\r\n    ctx.fillStyle = EGG_COLOR;\r\n    if (!this.currentEgg) {\r\n      this.currentEgg = this.randomCoordinate();\r\n      this.setCoordinate(this.currentEgg, 'egg');\r\n    }\r\n    const { currentEgg } = this;\r\n    ctx.arc(\r\n      0 + RADIUS + currentEgg.x * PIXEL_X,\r\n      0 + RADIUS + currentEgg.y * PIXEL_Y,\r\n      RADIUS,\r\n      0,\r\n      Math.PI * 2,\r\n      true\r\n    );\r\n    ctx.fill();\r\n    ctx.closePath();\r\n  }\r\n\r\n  randomCoordinate() {\r\n    const arr = [];\r\n    eachNumber(ROW, (x) => {\r\n      eachNumber(COLUMN, (y) => {\r\n        const value = this.coordinateAll[x][y];\r\n        if (value === 'block') {\r\n          arr.push({ x, y });\r\n        }\r\n      });\r\n    });\r\n    // 说明无坐标可取\r\n    if (!arr.length) {\r\n      return null;\r\n    }\r\n    return arr[randomNumber(0, arr.length)];\r\n  }\r\n  setCoordinate({ x, y }, value) {\r\n    this.coordinateAll[x][y] = value;\r\n  }\r\n  getCoordinate({ x, y }) {\r\n    if (x < 0 || y < 0 || x > ROW - 1 || y > COLUMN - 1) {\r\n      return null;\r\n    }\r\n    return this.coordinateAll[x][y];\r\n  }\r\n}\r\n```\r\n\r\n代码看起来还是蛮多的，不过之前已经介绍过实现的思路了，接下来一步步分析执行：\r\n\r\n- `constructor`\r\n\r\n这里主要是创建 `canvas` 对象，在 `this` 上绑定一些必要的属性，例如`坐标系`、`egg 位置`和 `sanke 位置`，这里 `currentSanke` ` array` 是因为蛇存在多节，用数组管理比较方便的。\r\n\r\n- `init`\r\n\r\n用 `init` 来完成组装，第一步是创建坐标系，这里给所有的初始元素打上 `block`，它一共三个值：`'block' | 'egg' | 'sanke'`。\r\n后面随机获取蛋的位置和蛇的位置，储存到` coordinateAll` 中，最后调用 `repaint` 完成绘制\r\n\r\n- `repaint`\r\n\r\n这一步就是调用 `canvas` 完成界面绘制，主要用到了两个 `api`\r\n\r\n[ctx.arc](https://developer.mozilla.org/zh-CN/docs/Web/API/CanvasRenderingContext2D/arc) 和 [ctx.fillRect](https://developer.mozilla.org/zh-CN/docs/Web/API/CanvasRenderingContext2D/fillRect)，前者绘制弧形后者填充矩形，先 `clearRect` 后绘制是因为这个方法后续会被重复调用，后面的一些`randomCoordinate`、`setCoordinate`、`getCoordinate`都是跟坐标方法有关，比较简单看一下即可。\r\n\r\n![静态效果](https://user-images.githubusercontent.com/39508895/139045166-b0b27e8d-3517-4e16-a0e7-c8b3cbdb01a3.png)\r\n\r\n\r\n到这里我们就可以得到静态的效果，后面就是让其动起来。\r\n\r\n## 动起来\r\n\r\n想让贪吃蛇动起来，我们需要做两步：\r\n\r\n- 监听方向键，也就是动的方向（也充当启动游戏作用）\r\n- 使用定时器不断的重绘蛇和鸡蛋的位置来造成视觉的移动\r\n\r\n监听方向键很简单，我们直接在 `body` 上监听 `keydown` 即可，这个事件在键盘按下的时候触发\r\n\r\n```js\r\nthis.keydownFn = (e) => {\r\n  const code = e.code;\r\n  const result = ['ArrowDown', 'ArrowUp', 'ArrowLeft', 'ArrowRight'].indexOf(\r\n    code\r\n  );\r\n  if (result <= -1) {\r\n    return;\r\n  }\r\n  this.direction = code;\r\n};\r\nmonitor() {\r\n  document.body.addEventListener('keydown', this.keydownFn);\r\n};\r\n```\r\n\r\n```js\r\nmove() {\r\n  if (this.timeId) {\r\n    clearInterval(this.timeId);\r\n  }\r\n  this.timeId = setInterval(() => {\r\n    const { direction, currentSanke, currentEgg } = this;\r\n    // 如果方向键不存在就返回\r\n    if (!direction) {\r\n      return;\r\n    }\r\n    let nextCoordinate;\r\n    // 蛇头始终是0\r\n    const { x, y } = currentSanke[0];\r\n    switch (direction) {\r\n      case 'ArrowDown':\r\n      case 'ArrowUp':\r\n        nextCoordinate = { x, y: direction === 'ArrowUp' ? y - 1 : y + 1 };\r\n        break;\r\n      case 'ArrowLeft':\r\n      case 'ArrowRight':\r\n        nextCoordinate = { y, x: direction === 'ArrowLeft' ? x - 1 : x + 1 };\r\n        break;\r\n      default:\r\n        break;\r\n    }\r\n    // nextCoordinate的作用是确认下一步是什么类型\r\n    const value = this.getCoordinate(nextCoordinate);\r\n    switch (value) {\r\n      case 'block':\r\n        this.setCoordinate(currentSanke.pop(), 'block');\r\n        currentSanke.unshift(nextCoordinate);\r\n        this.setCoordinate(nextCoordinate, 'sanke');\r\n        break;\r\n      case 'egg':\r\n        this.setCoordinate(currentEgg, 'sanke');\r\n        this.currentEgg = null;\r\n        currentSanke.unshift(nextCoordinate);\r\n        break;\r\n      case 'sanke':\r\n      case null:\r\n        // 游戏结束\r\n        break;\r\n      default:\r\n        break;\r\n    }\r\n    this.repaint();\r\n  }, INTERVAL);\r\n};\r\n```\r\n\r\n之后在 init 中插入这这两个方法\r\n\r\n```js\r\ninit() {\r\n  // ...\r\n  this.monitor();\r\n  this.move();\r\n}\r\n```\r\n\r\n![示例](https://user-images.githubusercontent.com/39508895/139045193-71ae885b-bb3d-4613-82b9-9c7b4d9f6e38.png)\r\n\r\n\r\n到这一步，贪吃蛇也实现了动起来的要求，在 `swtich` 中判断 `value` 的类型来决定坐标值如何变化，之后继续执行 `repaint` 重绘界面\r\n\r\n## 结束游戏\r\n\r\n上面 `move` 对游戏结束只进行了注释，下面就把` case null:`下面语句替换成`this.end`\r\n\r\n```js\r\nend() {\r\n  if (this.timeId) {\r\n    clearInterval(this.timeId);\r\n  }\r\n  this.timeId = null;\r\n  document.body.removeEventListener('keydown', this.keydownFn);\r\n  alert(`游戏结束，当前分数：${(this.currentSanke.length - 1) * 10}`);\r\n};\r\n```\r\n\r\n## 最后\r\n\r\n如果有什么错误请不吝指点，对你有帮助也可以 `start` 一下。\r\n",
      "reactions": {
        "url": "https://api.github.com/repos/bosens-China/blog/issues/54/reactions",
        "total_count": 1,
        "+1": 1,
        "-1": 0,
        "laugh": 0,
        "hooray": 0,
        "confused": 0,
        "heart": 0,
        "rocket": 0,
        "eyes": 0
      },
      "timeline_url": "https://api.github.com/repos/bosens-China/blog/issues/54/timeline",
      "performed_via_github_app": null,
      "state_reason": null
    },
    {
      "url": "https://api.github.com/repos/bosens-China/blog/issues/75",
      "repository_url": "https://api.github.com/repos/bosens-China/blog",
      "labels_url": "https://api.github.com/repos/bosens-China/blog/issues/75/labels{/name}",
      "comments_url": "https://api.github.com/repos/bosens-China/blog/issues/75/comments",
      "events_url": "https://api.github.com/repos/bosens-China/blog/issues/75/events",
      "html_url": "https://github.com/bosens-China/blog/issues/75",
      "id": 975496779,
      "node_id": "MDU6SXNzdWU5NzU0OTY3Nzk=",
      "number": 75,
      "title": "怎么用 Vue Composition 造轮子",
      "user": {
        "login": "bosens-China",
        "id": 39508895,
        "node_id": "MDQ6VXNlcjM5NTA4ODk1",
        "avatar_url": "https://avatars.githubusercontent.com/u/39508895?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bosens-China",
        "html_url": "https://github.com/bosens-China",
        "followers_url": "https://api.github.com/users/bosens-China/followers",
        "following_url": "https://api.github.com/users/bosens-China/following{/other_user}",
        "gists_url": "https://api.github.com/users/bosens-China/gists{/gist_id}",
        "starred_url": "https://api.github.com/users/bosens-China/starred{/owner}{/repo}",
        "subscriptions_url": "https://api.github.com/users/bosens-China/subscriptions",
        "organizations_url": "https://api.github.com/users/bosens-China/orgs",
        "repos_url": "https://api.github.com/users/bosens-China/repos",
        "events_url": "https://api.github.com/users/bosens-China/events{/privacy}",
        "received_events_url": "https://api.github.com/users/bosens-China/received_events",
        "type": "User",
        "site_admin": false
      },
      "labels": [
        {
          "id": 1473940161,
          "node_id": "MDU6TGFiZWwxNDczOTQwMTYx",
          "url": "https://api.github.com/repos/bosens-China/blog/labels/%E6%A1%86%E6%9E%B6%E7%9B%B8%E5%85%B3",
          "name": "框架相关",
          "color": "42b883",
          "default": false,
          "description": "目前Vue和React为主"
        }
      ],
      "state": "open",
      "locked": false,
      "assignee": null,
      "assignees": [],
      "milestone": null,
      "comments": 0,
      "created_at": "2021-08-20T10:51:18Z",
      "updated_at": "2021-08-20T10:51:18Z",
      "closed_at": null,
      "author_association": "OWNER",
      "active_lock_reason": null,
      "body": "\r\n![wallhaven-zmmwzw](https://user-images.githubusercontent.com/39508895/130222612-f8e2410a-4101-47dd-ba41-f488225cb94d.jpg)\r\n\r\n\r\n最近项目临近尾声，终于有时间来对这段工作总结。其实之前使用的一直是 Vue 但是现在公司的主要业务使用是 React 为此还特意看了许多文章，加上实际上这两个框架有很多类似的地方，所以就有了这篇文章。\r\n\r\n因为主要是分享经验所以下面的示例主要作为抛砖引玉的作用，在正式分享之前先科普两个小知识\r\n\r\n- hooks 默认以 use 为前缀，这个是 React 的官方推荐做法，约束大于配置也方便 eslint 等解析工具识别，这里也遵循这个做法；\r\n- watchEffect 与 useEffect 最大的区别就是，watchEffect 可以自动检测依赖，而 useEffect 需要你显示指定；\r\n\r\n```js\r\nconst count = ref(0);\r\nconst onClick = () => {\r\n  count.value++;\r\n};\r\nwatchEffect(() => {\r\n  console.log(`被点击`);\r\n});\r\n```\r\n\r\n例如上面这段代码，当 `onClick` 被触发的时候 watchEffect 不会重复执行，因为它内部有一个收集相关依赖的过程，只有依赖变化才会重新执行，这一点很重要，请记住。\r\n\r\n## 示例\r\n根据常见场景划分了三个类型，如果你有更好的例子欢迎补充\r\n### DOM\r\n\r\n#### 修改页面 title\r\n\r\n```js\r\nimport { ref, watchEffect } from 'vue';\r\n\r\nconst useTitle = (title) => {\r\n  const str = ref(title);\r\n  watchEffect(() => {\r\n    document.title = str.value;\r\n  });\r\n};\r\n```\r\n\r\n调用`useTitle`即可更新标题\r\n\r\n#### 监听页面大小变化\r\n\r\n```js\r\nimport { watchEffect, reactive, toRefs } from 'vue';\r\n\r\nconst useResize = () => {\r\n  const size = reactive({\r\n    width: window.innerWidth,\r\n    height: window.innerHeight,\r\n  });\r\n  const onChange = () => {\r\n    Object.assign(size, {\r\n      width: window.innerWidth,\r\n      height: window.innerHeight,\r\n    });\r\n  };\r\n  watchEffect((onInvalidate) => {\r\n    window.addEventListener('resize', onChange);\r\n    onInvalidate(() => {\r\n      window.removeEventListener('resize', onChange);\r\n    });\r\n  });\r\n  return toRefs(size);\r\n};\r\n```\r\n\r\n这里调用 `toRefs` 的原因是为了解构的情况也可以使用，例如\r\n\r\n```js\r\nconst { width } = useResize();\r\n```\r\n\r\n#### 监听网络是否断开\r\n\r\n```js\r\nimport { ref, watchEffect } from 'vue';\r\n\r\nconst useLineState = () => {\r\n  const line = ref(window.navigator.onLine);\r\n  const onLine = () => {\r\n    line.value = true;\r\n  };\r\n  const onOffline = () => {\r\n    line.value = false;\r\n  };\r\n\r\n  watchEffect((onInvalidate) => {\r\n    window.addEventListener('online', onLine);\r\n    window.addEventListener('offline', onOffline);\r\n    onInvalidate(() => {\r\n      window.removeEventListener('online', onLine);\r\n      window.removeEventListener('offline', onOffline);\r\n    });\r\n  });\r\n\r\n  return line;\r\n};\r\n```\r\n\r\n跟上面的 `useResize` 类似，监听相关事件来决定 `state` 的相关状态\r\n\r\n#### 监听 dom 元素变化\r\n\r\n```js\r\nimport { watchEffect, reactive, toRefs } from 'vue';\r\n\r\nconst isObject = (obj) => typeof obj === 'object' && obj;\r\nconst isElement = (obj) => isObject(obj) && obj.nodeType === Node.ELEMENT_NODE;\r\nconst useResizeObserver = (dom) => {\r\n  if (!isElement(dom)) {\r\n    throw new Error(`DOM is not an element!`);\r\n  }\r\n  const size = reactive(dom.getBoundingClientRect());\r\n  watchEffect((onInvalidate) => {\r\n    const resizeObserver = new ResizeObserver(() => {\r\n      Object.assign(size, dom.getBoundingClientRect());\r\n    });\r\n    onInvalidate(() => {\r\n      resizeObserver.disconnect();\r\n    });\r\n  });\r\n  return toRefs(size);\r\n};\r\n```\r\n\r\n这里监听元素使用了还在实验阶段的 `ResizeObserver` ，为了兼容性请使用 `polyfill`\r\n\r\n### 封装请求\r\n\r\najax 的请求很常见，不过在 vue2.x 中我们很容易写出下面的代码\r\n\r\n```js\r\nmounted(() => {\r\n  fn().then().catch().finally();\r\n});\r\n```\r\n\r\n这样的代码最大的问题就是不够清晰，因为变量在 `data` 中定义，而如果切换成下面这种形式，看起来就会直观许多。\r\n\r\n更多的例子还可以结合 `form` 和 `table` 进行更加深度的 hooks 封装\r\n\r\n```js\r\nconst { data, loading, error } = useRequest(() => {\r\n  //...\r\n});\r\nif (loading) {\r\n  //...\r\n}\r\nif (error) {\r\n  // ...\r\n}\r\n```\r\n\r\n```js\r\nimport { watchEffect, reactive, toRefs } from 'vue';\r\n\r\nconst useRequest = (fn, { manual } = {}) => {\r\n  const obj = reactive({\r\n    loading: false,\r\n    data: undefined,\r\n    error: undefined,\r\n  });\r\n  const run = () => {\r\n    obj.loading = true;\r\n    Promise.resolve(fn())\r\n      .then((data) => {\r\n        obj.data = data;\r\n      })\r\n      .catch((err) => {\r\n        obj.error = err;\r\n      })\r\n      .finally(() => {\r\n        obj.loading = false;\r\n      });\r\n  };\r\n  watchEffect(() => {\r\n    if (!manual) {\r\n      run();\r\n    }\r\n  });\r\n\r\n  return {\r\n    ...toRefs(obj),\r\n    run,\r\n  };\r\n};\r\n```\r\n\r\n### 模拟生命周期\r\n\r\n这里 Vue 官方的自带生命周期已经很齐全了，不过有的生命周期还是可以通过 `watchEffect` 做到模拟。\r\n\r\n例如：`mounted` 和 `beforeUnmount`，这里实现的原理主要就是利用 `watchEffect` 自动检测依赖，那如果不对响应式变量做收集的相关操作其实就是一个 `mounted`\r\n\r\n```js\r\nimport { watchEffect, nextTick } from 'vue';\r\n\r\nconst useMounted = (fn) => {\r\n  watchEffect(() => {\r\n    if (typeof fn !== 'function') {\r\n      return;\r\n    }\r\n    nextTick().then(() => {\r\n      fn();\r\n    });\r\n  });\r\n};\r\n\r\nconst useBeforeUnmount = (fn) => {\r\n  watchEffect((onInvalidate) => {\r\n    onInvalidate(() => {\r\n      if (typeof fn !== 'function') {\r\n        return;\r\n      }\r\n      fn();\r\n    });\r\n  });\r\n};\r\n```\r\n\r\n### 封装持久化\r\n\r\n在一些登录页面中很容易看到记住相关账号和密码，传统的做法就是 `login` 之后存储相关的账号和密码，然后在页面渲染的时候查看相关 `localStorage` 有没有对应的数据。\r\n\r\n这样写做大的问题还是分离，以及书写的代码量很多，下面就介绍一下如何结合 `localStorage` 做到一个支持对象的 hooks\r\n\r\n```js\r\nimport { ref, watchEffect } from 'vue';\r\nconst isObject = (obj) => typeof obj === 'object' && obj;\r\nconst useLocalStorageState = (key, defaultValue) => {\r\n  const value = ref(undefined);\r\n  try {\r\n    value.value = window.localStorage.getItem(key);\r\n    if (value.value === undefined) {\r\n      value.value = defaultValue;\r\n    }\r\n    value.value = JSON.parse(value.value);\r\n  } catch {}\r\n\r\n  watchEffect(() => {\r\n    const v = value.value;\r\n    window.localStorage.setItem(key, isObject(v) ? JSON.stringify(v) : v);\r\n  });\r\n  return value;\r\n};\r\n```\r\n\r\n```js\r\nconst name = useLocalStorageState('name', 'admin');\r\n```\r\n\r\n## 最后\r\n\r\n以上代码全部上传到了[codesandbox](https://codesandbox.io/s/nostalgic-chaum-9bwuo)，如果对你有帮助可以`star`一下\r\n\r\n## 参考文章\r\n\r\n- [精读《怎么用 React Hooks 造轮子》](https://github.com/ascoders/weekly/blob/v2/080.%E7%B2%BE%E8%AF%BB%E3%80%8A%E6%80%8E%E4%B9%88%E7%94%A8%20React%20Hooks%20%E9%80%A0%E8%BD%AE%E5%AD%90%E3%80%8B.md)\r\n",
      "reactions": {
        "url": "https://api.github.com/repos/bosens-China/blog/issues/75/reactions",
        "total_count": 0,
        "+1": 0,
        "-1": 0,
        "laugh": 0,
        "hooray": 0,
        "confused": 0,
        "heart": 0,
        "rocket": 0,
        "eyes": 0
      },
      "timeline_url": "https://api.github.com/repos/bosens-China/blog/issues/75/timeline",
      "performed_via_github_app": null,
      "state_reason": null
    },
    {
      "url": "https://api.github.com/repos/bosens-China/blog/issues/51",
      "repository_url": "https://api.github.com/repos/bosens-China/blog",
      "labels_url": "https://api.github.com/repos/bosens-China/blog/issues/51/labels{/name}",
      "comments_url": "https://api.github.com/repos/bosens-China/blog/issues/51/comments",
      "events_url": "https://api.github.com/repos/bosens-China/blog/issues/51/events",
      "html_url": "https://github.com/bosens-China/blog/issues/51",
      "id": 566103021,
      "node_id": "MDU6SXNzdWU1NjYxMDMwMjE=",
      "number": 51,
      "title": "基于History实现前端路由",
      "user": {
        "login": "bosens-China",
        "id": 39508895,
        "node_id": "MDQ6VXNlcjM5NTA4ODk1",
        "avatar_url": "https://avatars.githubusercontent.com/u/39508895?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bosens-China",
        "html_url": "https://github.com/bosens-China",
        "followers_url": "https://api.github.com/users/bosens-China/followers",
        "following_url": "https://api.github.com/users/bosens-China/following{/other_user}",
        "gists_url": "https://api.github.com/users/bosens-China/gists{/gist_id}",
        "starred_url": "https://api.github.com/users/bosens-China/starred{/owner}{/repo}",
        "subscriptions_url": "https://api.github.com/users/bosens-China/subscriptions",
        "organizations_url": "https://api.github.com/users/bosens-China/orgs",
        "repos_url": "https://api.github.com/users/bosens-China/repos",
        "events_url": "https://api.github.com/users/bosens-China/events{/privacy}",
        "received_events_url": "https://api.github.com/users/bosens-China/received_events",
        "type": "User",
        "site_admin": false
      },
      "labels": [
        {
          "id": 1371686609,
          "node_id": "MDU6TGFiZWwxMzcxNjg2NjA5",
          "url": "https://api.github.com/repos/bosens-China/blog/labels/JavaScript",
          "name": "JavaScript",
          "color": "F7DF1E",
          "default": false,
          "description": "JavaScript系列的文章"
        }
      ],
      "state": "open",
      "locked": false,
      "assignee": null,
      "assignees": [],
      "milestone": null,
      "comments": 0,
      "created_at": "2020-02-17T07:21:46Z",
      "updated_at": "2020-02-17T07:21:46Z",
      "closed_at": null,
      "author_association": "OWNER",
      "active_lock_reason": null,
      "body": "`History`是 HTML5 新增的标准，对比`hash`它的展示更加优雅，但低版本 ie 还有兼容问题。\r\n\r\n首先`History`表示窗口浏览历史，可以通过`pushState`方法添加历史记录，以及通过`go`方法来实现跳转，还有`popstate`事件可以监听到记录变更。\r\n\r\n下面就来分析实现一个`History路由`的基础是什么\r\n\r\n1. 它需要在变更地址的时候，不会导致文档直接跳转，例如`hash路由`的出现是因为 url 的`hash`变更不会导致文档变化；\r\n2. 需要有事件可以辅助我们监听到这个变化;\r\n\r\n这两个要求`History`都能很好满足，当使用`pushState`方法添加一条记录的时候，只会导致浏览器的地址栏发生变化，但是不会跳转到这个地址，并且浏览器也不会检查这个地址，利用这个特性我们可以实现比较优雅的路由地址，例如`https://xxx.com/a`，`a`就是这个路由地址。\r\n\r\n为了方便理解下面实现的代码，简短介绍一下`pushState`\r\n\r\n#### pushState\r\n\r\n`pushState`方法，它有三个参数\r\n\r\n- 第一个是`state`，表示发生`popstate`事件的时候传递的对象；\r\n- title，当前浏览器已经忽略了，传递`''`就好了；\r\n- 网址，要更改的地址，注意要符合同源政策；\r\n\r\n举个例子，当前网站的根路径是`https://xxx.com`，我们使用`pushState`添加一条记录\r\n\r\n```js\r\nhistory.pushState({ path: \"/abc\" }, \"\", \"/abc\");\r\n```\r\n\r\n当前的网址就是`https://xxx.com/abc`。\r\n\r\n#### popstate\r\n\r\n`pushState`事件触发的条件是用户点击`前进`、`后退`按钮或者调用 `History.back()`、`History.forward()`、`History.go()`方法时才会触发。\r\n\r\n触发事件后有一个`event`对象，它有一个`state`属性，就是对应`pushState`方法的第一个参数。\r\n\r\n更多关于`history`的信息可以查阅[MDN](https://developer.mozilla.org/zh-CN/docs/Web/API/History)\r\n\r\n### history 路由实现\r\n\r\n```js\r\nclass Router {\r\n  constructor() {\r\n    this.routes = new Map();\r\n    this.init();\r\n  }\r\n  change(e) {\r\n    // 防止为null\r\n    const { path } = e.state || {};\r\n    this.implement(path);\r\n  }\r\n  init() {\r\n    window.addEventListener(\"popstate\", this.change.bind(this));\r\n    window.addEventListener(\"load\", () => {\r\n      const { pathname } = location;\r\n      history.replaceState({ path: pathname }, \"\", pathname);\r\n      this.implement(pathname);\r\n    });\r\n  }\r\n  implement(path) {\r\n    if (!this.routes.has(path)) {\r\n      return;\r\n    }\r\n    const fn = this.routes.get(path);\r\n    typeof fn == \"function\" && fn.call(this, path);\r\n  }\r\n  go(num) {\r\n    history.go(num);\r\n  }\r\n  route(state, fn) {\r\n    this.routes.set(state, fn);\r\n  }\r\n  push(state) {\r\n    history.pushState({ path: state }, \"\", state);\r\n    this.implement(state);\r\n  }\r\n  replace(state) {\r\n    history.replaceState({ path: state }, \"\", state);\r\n    this.implement(state);\r\n  }\r\n}\r\n```\r\n\r\n这一块比较简单就不做更多赘述了，唯一一点需要注意的就是页面加载完毕也需要监听一次，这里用了`load事件`。\r\n\r\n### 使用方法\r\n\r\n```html\r\n<ul>\r\n  <li><a href=\"/\">hash1</a></li>\r\n  <li><a href=\"/hash2\">hash2</a></li>\r\n  <li><a href=\"/hash3\">hash3</a></li>\r\n</ul>\r\n<div><button class=\"f\">前进</button> <button class=\"b\">后退</button></div>\r\n```\r\n\r\n```js\r\nconst color = {\r\n  \"/\": \"yellow\",\r\n  \"/hash2\": \"#333\",\r\n  \"/hash3\": \"#DDD\"\r\n};\r\nconst route = new Router();\r\nroute.route(\"/\", function(e) {\r\n  document.body.style.background = color[e];\r\n});\r\nroute.route(\"/hash2\", function(e) {\r\n  document.body.style.background = color[e];\r\n});\r\nroute.route(\"/hash3\", function(e) {\r\n  document.body.style.background = color[e];\r\n});\r\nArray.from(document.links).forEach(fn => {\r\n  fn.addEventListener(\"click\", e => {\r\n    e.preventDefault();\r\n    const href = fn.href;\r\n    const { pathname } = new URL(href);\r\n    route.push(pathname);\r\n  });\r\n});\r\nconst backOff = document.querySelector(\".b\");\r\nconst forward = document.querySelector(\".f\");\r\nbackOff.addEventListener(\"click\", () => route.go(-1));\r\nforward.addEventListener(\"click\", () => route.go(1));\r\n```\r\n\r\n这里注意，我直接屏蔽了`a`链接的默认跳转，这个是防止它直接到其他文档。\r\n\r\n### 最后\r\n\r\n关于前端路由的两种实现，这里就抛砖引玉的讲解完成了，剩下的就是在这个原理上更加完善，例如对 404 页面的处理。\r\n\r\n如果有帮助可以 **star** 一下。\r\n",
      "reactions": {
        "url": "https://api.github.com/repos/bosens-China/blog/issues/51/reactions",
        "total_count": 0,
        "+1": 0,
        "-1": 0,
        "laugh": 0,
        "hooray": 0,
        "confused": 0,
        "heart": 0,
        "rocket": 0,
        "eyes": 0
      },
      "timeline_url": "https://api.github.com/repos/bosens-China/blog/issues/51/timeline",
      "performed_via_github_app": null,
      "state_reason": null
    },
    {
      "url": "https://api.github.com/repos/bosens-China/blog/issues/50",
      "repository_url": "https://api.github.com/repos/bosens-China/blog",
      "labels_url": "https://api.github.com/repos/bosens-China/blog/issues/50/labels{/name}",
      "comments_url": "https://api.github.com/repos/bosens-China/blog/issues/50/comments",
      "events_url": "https://api.github.com/repos/bosens-China/blog/issues/50/events",
      "html_url": "https://github.com/bosens-China/blog/issues/50",
      "id": 566035569,
      "node_id": "MDU6SXNzdWU1NjYwMzU1Njk=",
      "number": 50,
      "title": "基于hash实现前端路由",
      "user": {
        "login": "bosens-China",
        "id": 39508895,
        "node_id": "MDQ6VXNlcjM5NTA4ODk1",
        "avatar_url": "https://avatars.githubusercontent.com/u/39508895?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bosens-China",
        "html_url": "https://github.com/bosens-China",
        "followers_url": "https://api.github.com/users/bosens-China/followers",
        "following_url": "https://api.github.com/users/bosens-China/following{/other_user}",
        "gists_url": "https://api.github.com/users/bosens-China/gists{/gist_id}",
        "starred_url": "https://api.github.com/users/bosens-China/starred{/owner}{/repo}",
        "subscriptions_url": "https://api.github.com/users/bosens-China/subscriptions",
        "organizations_url": "https://api.github.com/users/bosens-China/orgs",
        "repos_url": "https://api.github.com/users/bosens-China/repos",
        "events_url": "https://api.github.com/users/bosens-China/events{/privacy}",
        "received_events_url": "https://api.github.com/users/bosens-China/received_events",
        "type": "User",
        "site_admin": false
      },
      "labels": [
        {
          "id": 1371686609,
          "node_id": "MDU6TGFiZWwxMzcxNjg2NjA5",
          "url": "https://api.github.com/repos/bosens-China/blog/labels/JavaScript",
          "name": "JavaScript",
          "color": "F7DF1E",
          "default": false,
          "description": "JavaScript系列的文章"
        }
      ],
      "state": "open",
      "locked": false,
      "assignee": null,
      "assignees": [],
      "milestone": null,
      "comments": 0,
      "created_at": "2020-02-17T03:34:23Z",
      "updated_at": "2020-02-17T03:34:23Z",
      "closed_at": null,
      "author_association": "OWNER",
      "active_lock_reason": null,
      "body": "> 前端路由分为两部分，hash 路由和 History 路由，例如我们常用的 vue-roter 就包含这两部分，这里并不探讨框架是如何进行封装的，而是使用原生的 api 来实现这样一个功能。\r\n\r\n> 预计分为两部分，这里先介绍 hash 路由，实现基本的接受响应和前进后退（为了方便，下面代码不做任何兼容处理）\r\n\r\nhash 指的就是 url 标识符后面`#`号部分的内容（包含#），例如：`https://xxx#abc`这个 url 的 hash 就是`#abc`。\r\n\r\n而 hash 路由就是指接收 hash 的变化更新对应的路由视图，它的优点就是兼容性很好，在 ie 下也能正常工作，不足之处就是`#`这个符号很丑陋。\r\n\r\n### 监听 hash 变化\r\n\r\nwindow 对象上有`hashchange`事件可以监听到 hash 的变化，我们先拿来用用，看看好不好用。\r\n\r\n```js\r\nclass Router {\r\n  constructor() {\r\n    this.hash = new Map();\r\n    this.change = () => {\r\n      const href = this.getHash();\r\n      this.move(href);\r\n    };\r\n    window.addEventListener(\"hashchange\", this.change);\r\n  }\r\n  route(href, fn) {\r\n    this.hash.set(href, fn);\r\n  }\r\n  move(href) {\r\n    if (!this.hash.has(href)) {\r\n      return false;\r\n    }\r\n    const fn = this.hash.get(href);\r\n    if (typeof fn == \"function\") {\r\n      fn.call(this, href);\r\n    }\r\n    return true;\r\n  }\r\n  getHash() {\r\n    return location.hash ? location.hash.slice(1) : \"/\";\r\n  }\r\n}\r\n```\r\n\r\n#### 使用方法\r\n\r\n```js\r\nconst color = {\r\n  hash1: \"#333\",\r\n  hash2: \"#666\",\r\n  hash3: \"#DDD\"\r\n};\r\nconst route = new Router();\r\nroute.route(\"hash1\", function(e) {\r\n  document.body.style.background = color[e];\r\n});\r\nroute.route(\"hash2\", function(e) {\r\n  document.body.style.background = color[e];\r\n});\r\nroute.route(\"hash3\", function(e) {\r\n  document.body.style.background = color[e];\r\n});\r\n```\r\n\r\n这里已经实现了 hash 响应了，不过还是有一个问题就是如果点击 hash 之后刷新浏览器，对应的回调函数并不会执行，所以我们还需要浏览器加载完成后响应对应的回调函数，修订这个问题很简单监听 load 事件即可。\r\n\r\n```js\r\n// 省略其他代码\r\nconstructor() {\r\n    window.addEventListener('load', this.change);\r\n    window.addEventListener(\"hashchange\", this.change);\r\n  }\r\n```\r\n\r\n### 后退功能\r\n\r\n上面完成了基础功能，下面对这个代码进行改造，首先新增一个后退处理。\r\n\r\n实现的思路是新增一个`history`数组来储存变化的 hash，并且创建一个指针，在后退的时候移动指针变化，同时触发对应的函数。\r\n\r\n```js\r\nclass Router {\r\n  constructor() {\r\n    this.hash = new Map();\r\n    // 储存hash变化的数组\r\n    this.history = [];\r\n    // 指针\r\n    this.pointer = this.history.length - 1;\r\n    this.change = () => {\r\n      const href = this.getHash();\r\n      if (!this.move(href)) {\r\n        return console.error(`hash路由${href}无对应处理函数`);\r\n      }\r\n      // 在路由发生变化的时候，同时对history添加，和移动指针\r\n      this.history.push(href);\r\n      this.pointer++;\r\n    };\r\n    // 后退\r\n    this.backOff = () => {\r\n      // 数组下表不能负\r\n      if (this.pointer <= 0) {\r\n        this.pointer = 0;\r\n      } else {\r\n        // 移动下标\r\n        this.pointer -= 1;\r\n      }\r\n      // 读取对应的值，移动hash\r\n      const href = this.history[this.pointer];\r\n      console.log(href, this.pointer, this.history);\r\n      this.setHash(href);\r\n      this.move(href);\r\n    };\r\n    window.addEventListener(\"load\", this.change);\r\n    window.addEventListener(\"hashchange\", this.change);\r\n  }\r\n  route(href, fn) {\r\n    this.hash.set(href, fn);\r\n  }\r\n  move(href) {\r\n    if (!this.hash.has(href)) {\r\n      return false;\r\n    }\r\n    const fn = this.hash.get(href);\r\n    if (typeof fn == \"function\") {\r\n      fn.call(this, href);\r\n    }\r\n    return true;\r\n  }\r\n  getHash() {\r\n    // 过滤掉'#'\r\n    return location.hash ? location.hash.slice(1) : \"/\";\r\n  }\r\n  setHash(href) {\r\n    if (!href) {\r\n      return;\r\n    }\r\n    if (!/^/.test(href)) {\r\n      href = `#${href}`;\r\n    }\r\n    location.hash = href;\r\n  }\r\n}\r\n```\r\n\r\n上面看似实现了后退功能，不过仔细观察上面的代码，我们会发现这样实现是有问题的\r\n\r\n1. 回调函数被执行两次；\r\n2. `history`数组记录的 hash 不对，因为后退是不需要记录的；\r\n\r\n下面来修正这两个问题。\r\n\r\n```js\r\nclass Router {\r\n  constructor() {\r\n    this.hash = new Map();\r\n    // 储存hash变化的数组\r\n    this.history = [];\r\n    // 指针\r\n    this.pointer = this.history.length - 1;\r\n    // 是否后退，默认给false\r\n    this.isBackOff = false;\r\n    this.change = () => {\r\n      const href = this.getHash();\r\n      if (!this.hash.has(href)) {\r\n        return console.error(`hash路由${href}无对应处理函数`);\r\n      }\r\n      if (!this.isBackOff) {\r\n        // 看一下指针长度对不对，如果多余就截取掉\r\n        if (this.pointer < this.history.length - 1) {\r\n          this.history = this.history.slice(0, this.pointer + 1);\r\n        }\r\n        // 在路由发生变化的时候，同时对history添加，和移动指针\r\n        this.history.push(href);\r\n        this.pointer++;\r\n      }\r\n      this.move(href);\r\n      this.isBackOff = false;\r\n    };\r\n    // 后退\r\n    this.backOff = () => {\r\n      this.isBackOff = true;\r\n      // 数组下表不能负\r\n      if (this.pointer <= 0) {\r\n        this.pointer = 0;\r\n      } else {\r\n        // 移动下标\r\n        this.pointer -= 1;\r\n      }\r\n      // 读取对应的值，移动hash\r\n      const href = this.history[this.pointer];\r\n      console.log(href, this.pointer, this.history);\r\n      this.setHash(href);\r\n    };\r\n    window.addEventListener(\"load\", this.change);\r\n    window.addEventListener(\"hashchange\", this.change);\r\n  }\r\n  route(href, fn) {\r\n    this.hash.set(href, fn);\r\n  }\r\n  move(href) {\r\n    const fn = this.hash.get(href);\r\n    if (typeof fn == \"function\") {\r\n      fn.call(this, href);\r\n    }\r\n  }\r\n  getHash() {\r\n    // 过滤掉'#'\r\n    return location.hash ? location.hash.slice(1) : \"/\";\r\n  }\r\n  setHash(href) {\r\n    if (!href) {\r\n      return;\r\n    }\r\n    if (!/^/.test(href)) {\r\n      href = `#${href}`;\r\n    }\r\n    location.hash = href;\r\n  }\r\n}\r\n```\r\n\r\n借助变量`isBackOff`来控制，如果是后退只执行回调函数，当正常操作的时候新增`history`数据，同时清楚多余数组，前进跟后退类似，下面就来实现它。\r\n\r\n### 前进\r\n\r\n思路跟后退的一致，借助变量来进行控制，定义一个前进方法。\r\n\r\n```js\r\nclass Router {\r\n  constructor() {\r\n    this.hash = new Map();\r\n    // 储存hash变化的数组\r\n    this.history = [];\r\n    // 指针\r\n    this.pointer = this.history.length - 1;\r\n    // 是否后退，默认给false\r\n    this.isBackOff = false;\r\n    // 前进标识\r\n    this.isForward = false;\r\n    this.change = () => {\r\n      const href = this.getHash();\r\n      if (!this.hash.has(href)) {\r\n        return console.error(`hash路由${href}无对应处理函数`);\r\n      }\r\n      if (!this.isBackOff && !this.isForward) {\r\n        // 看一下指针长度对不对，如果多余就截取掉\r\n        if (this.pointer < this.history.length - 1) {\r\n          this.history = this.history.slice(0, this.pointer + 1);\r\n        }\r\n        // 在路由发生变化的时候，同时对history添加，和移动指针\r\n        this.history.push(href);\r\n        this.pointer++;\r\n      }\r\n      this.move(href);\r\n      this.isBackOff = false;\r\n      this.isForward = false;\r\n    };\r\n    // 后退\r\n    this.backOff = () => {\r\n      this.isBackOff = true;\r\n      // 数组下表不能负\r\n      if (this.pointer <= 0) {\r\n        this.pointer = 0;\r\n      } else {\r\n        // 移动下标\r\n        this.pointer -= 1;\r\n      }\r\n      // 读取对应的值，移动hash\r\n      const href = this.history[this.pointer];\r\n      console.log(href, this.pointer, this.history);\r\n      this.setHash(href);\r\n    };\r\n    // 前进\r\n    this.forward = () => {\r\n      this.isForward = true;\r\n      // 数组下表不能负\r\n      if (this.pointer >= this.history.length - 1) {\r\n        this.pointer = this.history.length - 1;\r\n      } else {\r\n        // 移动下标\r\n        this.pointer += 1;\r\n      }\r\n      // 读取对应的值，移动hash\r\n      const href = this.history[this.pointer];\r\n      console.log(`前进${href}`, this.pointer, this.history);\r\n      this.setHash(href);\r\n    };\r\n    window.addEventListener(\"load\", this.change);\r\n    window.addEventListener(\"hashchange\", this.change);\r\n  }\r\n  route(href, fn) {\r\n    this.hash.set(href, fn);\r\n  }\r\n  move(href) {\r\n    const fn = this.hash.get(href);\r\n    if (typeof fn == \"function\") {\r\n      fn.call(this, href);\r\n    }\r\n  }\r\n  getHash() {\r\n    // 过滤掉'#'\r\n    return location.hash ? location.hash.slice(1) : \"/\";\r\n  }\r\n  setHash(href) {\r\n    if (!href) {\r\n      return;\r\n    }\r\n    if (!/^/.test(href)) {\r\n      href = `#${href}`;\r\n    }\r\n    location.hash = href;\r\n  }\r\n}\r\n```\r\n\r\n跟后退对比，实质上也只是把后退指针改成前进了，如果想要实现`go`跳转的功能也跟前进、后退思路一样。\r\n\r\n### 使用方法\r\n\r\n```html\r\n<ul>\r\n  <li><a href=\"#hash1\">hash1</a></li>\r\n  <li><a href=\"#hash2\">hash2</a></li>\r\n  <li><a href=\"#hash3\">hash3</a></li>\r\n</ul>\r\n<div><button class=\"f\">前进</button> <button class=\"b\">后退</button></div>\r\n1\r\n```\r\n\r\n```js\r\nconst color = {\r\n  hash1: \"#333\",\r\n  hash2: \"#666\",\r\n  hash3: \"#DDD\"\r\n};\r\nconst route = new Router();\r\nroute.route(\"hash1\", function(e) {\r\n  document.body.style.background = color[e];\r\n});\r\nroute.route(\"hash2\", function(e) {\r\n  document.body.style.background = color[e];\r\n});\r\nroute.route(\"hash3\", function(e) {\r\n  document.body.style.background = color[e];\r\n});\r\nconst backOff = document.querySelector(\".b\");\r\nconst forward = document.querySelector(\".f\");\r\nbackOff.addEventListener(\"click\", route.backOff);\r\nforward.addEventListener(\"click\", route.forward);\r\n```\r\n\r\n### 最后\r\n\r\n这里实现了 hash 路由的`响应变化`和`前进`、`后退`、`404` 的功能，但是还有很多地方需要完善，比如`go`跳转。\r\n\r\n下一节将介绍 `History 路由的实现`，如果喜欢请点击一下 **star**\r\n",
      "reactions": {
        "url": "https://api.github.com/repos/bosens-China/blog/issues/50/reactions",
        "total_count": 0,
        "+1": 0,
        "-1": 0,
        "laugh": 0,
        "hooray": 0,
        "confused": 0,
        "heart": 0,
        "rocket": 0,
        "eyes": 0
      },
      "timeline_url": "https://api.github.com/repos/bosens-China/blog/issues/50/timeline",
      "performed_via_github_app": null,
      "state_reason": null
    },
    {
      "url": "https://api.github.com/repos/bosens-China/blog/issues/28",
      "repository_url": "https://api.github.com/repos/bosens-China/blog",
      "labels_url": "https://api.github.com/repos/bosens-China/blog/issues/28/labels{/name}",
      "comments_url": "https://api.github.com/repos/bosens-China/blog/issues/28/comments",
      "events_url": "https://api.github.com/repos/bosens-China/blog/issues/28/events",
      "html_url": "https://github.com/bosens-China/blog/issues/28",
      "id": 499359943,
      "node_id": "MDU6SXNzdWU0OTkzNTk5NDM=",
      "number": 28,
      "title": "MatchMedia API",
      "user": {
        "login": "bosens-China",
        "id": 39508895,
        "node_id": "MDQ6VXNlcjM5NTA4ODk1",
        "avatar_url": "https://avatars.githubusercontent.com/u/39508895?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bosens-China",
        "html_url": "https://github.com/bosens-China",
        "followers_url": "https://api.github.com/users/bosens-China/followers",
        "following_url": "https://api.github.com/users/bosens-China/following{/other_user}",
        "gists_url": "https://api.github.com/users/bosens-China/gists{/gist_id}",
        "starred_url": "https://api.github.com/users/bosens-China/starred{/owner}{/repo}",
        "subscriptions_url": "https://api.github.com/users/bosens-China/subscriptions",
        "organizations_url": "https://api.github.com/users/bosens-China/orgs",
        "repos_url": "https://api.github.com/users/bosens-China/repos",
        "events_url": "https://api.github.com/users/bosens-China/events{/privacy}",
        "received_events_url": "https://api.github.com/users/bosens-China/received_events",
        "type": "User",
        "site_admin": false
      },
      "labels": [
        {
          "id": 1580833992,
          "node_id": "MDU6TGFiZWwxNTgwODMzOTky",
          "url": "https://api.github.com/repos/bosens-China/blog/labels/%E5%AE%9E%E9%AA%8C%E6%80%A7%20API",
          "name": "实验性 API",
          "color": "7aa9d6",
          "default": false,
          "description": "还未定稿的API"
        }
      ],
      "state": "open",
      "locked": false,
      "assignee": null,
      "assignees": [],
      "milestone": null,
      "comments": 0,
      "created_at": "2019-09-27T10:12:54Z",
      "updated_at": "2019-09-27T10:14:33Z",
      "closed_at": null,
      "author_association": "OWNER",
      "active_lock_reason": null,
      "body": "\r\n![456](https://user-images.githubusercontent.com/39508895/65761913-63d54580-e152-11e9-89e1-76f82d5df39f.jpg)\r\n\r\n\r\n> 注意`matchMedia`为实验性语法文档可能被重新修订，后面有可能会改变语法，在生产中请配合[matchMedia polyfill](https://github.com/paulirish/matchMedia.js)使用\r\n\r\n通过媒体查询，您可以根据各种设备特征和参数的值或者是否存在来调整您的网站或应用；\r\n\r\n上面是 MDN 对媒体查询的定义，简单情况通过 css 媒体查询 调整页面已经足够了，不过现在页面交互和功能越来越多，比如一个页面要响应式布局，同时在不同屏幕下页面结构不同，是不是感觉有些力不从心了，下面介绍一下`matchMedia`。\r\n\r\n## 使用方法\r\n\r\n```js\r\nvar mqList = window.matchMedia(mediaQueryString);\r\n```\r\n\r\nmatchMedia 可以实现编程方法式媒体查询，参数`mediaQueryString`为媒体语句，返回类型为`MediaQueryList`，下面是一个例子\r\n\r\n```js\r\nif (window.matchMedia(\"(min-width: 400px)\").matches) {\r\n  // 窗口大于等于400 情况\r\n} else {\r\n  // 窗口小于400\r\n}\r\n```\r\n\r\n## MediaQueryList \r\n\r\n- 属性\r\n\r\n  - matches:boolean： 如果当前 document 匹配该媒体查询列表则其值为 true；反之其值为 false。只读；\r\n  - media:DOMString 序列化的媒体查询列表；\r\n\r\n- 方法\r\n  - addListener(call: Function):void\r\n  - removeListener(call: Function):void\r\n\r\n### addListener\r\n\r\n```js\r\nMediaQueryList.addListener(func);\r\n```\r\n\r\nfunc 接收一个参数，初版参数的类型为[MediaQueryListListener ](https://developer.mozilla.org/en-US/docs/Web/API/MediaQueryListListener)新修订的参数类型为[MediaQueryListEvent,](https://developer.mozilla.org/en-US/docs/Web/API/MediaQueryListEvent)\r\n\r\n```js\r\nvar mql = window.matchMedia(\"(max-width: 600px)\");\r\n\r\nfunction screenTest(e) {\r\n  if (e.matches) {\r\n    // 屏幕小于等于600\r\n  } else {\r\n    // 屏幕大于600\r\n  }\r\n}\r\nmql.addListener(screenTest);\r\n```\r\n\r\n### removeListener\r\n\r\n```js\r\nMediaQueryList.removeListener(func);\r\n```\r\n\r\nfunc 表示要删除的回调函数的函数或函数引用\r\n\r\n```js\r\nvar mql = window.matchMedia(\"(max-width: 600px)\");\r\n\r\nfunction screenTest(e) {\r\n  if (e.matches) {\r\n    // 屏幕小于等于600\r\n  } else {\r\n    // 屏幕大于600\r\n  }\r\n}\r\n\r\nmql.addListener(screenTest);\r\n\r\n// 取消监听\r\nmql.removeListener(screenTest);\r\n```\r\n\r\n## 参考\r\n\r\nhttps://developer.mozilla.org/en-US/docs/Web/API/MediaQueryList/media\r\n",
      "reactions": {
        "url": "https://api.github.com/repos/bosens-China/blog/issues/28/reactions",
        "total_count": 0,
        "+1": 0,
        "-1": 0,
        "laugh": 0,
        "hooray": 0,
        "confused": 0,
        "heart": 0,
        "rocket": 0,
        "eyes": 0
      },
      "timeline_url": "https://api.github.com/repos/bosens-China/blog/issues/28/timeline",
      "performed_via_github_app": null,
      "state_reason": null
    },
    {
      "url": "https://api.github.com/repos/bosens-China/blog/issues/26",
      "repository_url": "https://api.github.com/repos/bosens-China/blog",
      "labels_url": "https://api.github.com/repos/bosens-China/blog/issues/26/labels{/name}",
      "comments_url": "https://api.github.com/repos/bosens-China/blog/issues/26/comments",
      "events_url": "https://api.github.com/repos/bosens-China/blog/issues/26/events",
      "html_url": "https://github.com/bosens-China/blog/issues/26",
      "id": 498112062,
      "node_id": "MDU6SXNzdWU0OTgxMTIwNjI=",
      "number": 26,
      "title": "ResizeObserver API",
      "user": {
        "login": "bosens-China",
        "id": 39508895,
        "node_id": "MDQ6VXNlcjM5NTA4ODk1",
        "avatar_url": "https://avatars.githubusercontent.com/u/39508895?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bosens-China",
        "html_url": "https://github.com/bosens-China",
        "followers_url": "https://api.github.com/users/bosens-China/followers",
        "following_url": "https://api.github.com/users/bosens-China/following{/other_user}",
        "gists_url": "https://api.github.com/users/bosens-China/gists{/gist_id}",
        "starred_url": "https://api.github.com/users/bosens-China/starred{/owner}{/repo}",
        "subscriptions_url": "https://api.github.com/users/bosens-China/subscriptions",
        "organizations_url": "https://api.github.com/users/bosens-China/orgs",
        "repos_url": "https://api.github.com/users/bosens-China/repos",
        "events_url": "https://api.github.com/users/bosens-China/events{/privacy}",
        "received_events_url": "https://api.github.com/users/bosens-China/received_events",
        "type": "User",
        "site_admin": false
      },
      "labels": [
        {
          "id": 1580833992,
          "node_id": "MDU6TGFiZWwxNTgwODMzOTky",
          "url": "https://api.github.com/repos/bosens-China/blog/labels/%E5%AE%9E%E9%AA%8C%E6%80%A7%20API",
          "name": "实验性 API",
          "color": "7aa9d6",
          "default": false,
          "description": "还未定稿的API"
        }
      ],
      "state": "open",
      "locked": false,
      "assignee": null,
      "assignees": [],
      "milestone": null,
      "comments": 0,
      "created_at": "2019-09-25T07:51:27Z",
      "updated_at": "2019-09-27T02:03:01Z",
      "closed_at": null,
      "author_association": "OWNER",
      "active_lock_reason": null,
      "body": "\r\n![123](https://user-images.githubusercontent.com/39508895/65580529-6d24ad80-dfac-11e9-868f-328d7427391e.jpg)\r\n\r\n无意之间看到这个 API，发现这个 API 十分实用特来分享一下。\r\n\r\nResizeObserver 可以监听到 Element 的元素的变化，例如大小变化，在之前我们可能要监听 window 对象，因为 resize 定义在 window 上，不过注意这个 API 还是处于实验性阶段，在项目中要配合 [polyfill](https://github.com/que-etc/resize-observer-polyfill) 来使用\r\n\r\n## constructor\r\n\r\n```js\r\nvar ResizeObserver = new ResizeObserver(callback);\r\n```\r\n\r\n使用方法很简单，ResizeObserver 接收一个回调函数作为参数，当尺寸发生变化的时候 `callback` 函数接收一个 `ResizeObserverEntry` 数组，下面看一个例子\r\n\r\n```html\r\n<div class=\"box\"></div>\r\n<script>\r\n  const box = document.querySelector(\".box\");\r\n  const resizeObserver = new ResizeObserver(entries => {\r\n    for (let entry of entries) {\r\n      const dimensions = entry.contentRect;\r\n      console.log(`${dimensions.width} x ${dimensions.height}`);\r\n    }\r\n  });\r\n  resizeObserver.observe(box);\r\n  setTimeout(() => {\r\n    box.style.width = \"99px\";\r\n  }, 1000);\r\n</script>\r\n```\r\n\r\n上面定义了一个 box 的元素，并在一秒后更改宽度 `ResizeObserver` 可以监听到这一更改。\r\n\r\n> 特别提醒一下，添加初始元素的时候默认就会执行执行一次回调，也就是说不用手动执行一次获取初始信息了。\r\n\r\n## ResizeObserverEntry\r\n\r\n你可能好奇 ResizeObserverEntry 会返回什么格式的数据？\r\n它由两部分组成\r\n\r\n- target\r\n  target 很好理解就是我们添加的元素\r\n\r\n- contentRect\r\n  contentRect 其实就是一个盒子信息，它的类型是 [DOMRectReadOnly](https://developer.mozilla.org/zh-CN/docs/Web/API/DOMRectReadOnly),有以下几个属性\r\n  - bottom\r\n    返回的底部坐标值（通常与 y + 高度相同）\r\n  - height\r\n    高度\r\n  - width\r\n    宽度\r\n  - left\r\n    返回的左坐标值（通常与 x 相同）\r\n  - right\r\n    返回的右坐标值（通常与 x + width 相同）\r\n  - top\r\n    返回的顶部坐标值（通常与 y 相同）\r\n  - x\r\n    原点的 x 坐标\r\n  - y\r\n    原点的 y 坐标\r\n\r\n## 方法\r\n\r\n### observe\r\n\r\n```js\r\nresizeObserver.observe(target);\r\n```\r\n\r\n上面的示例中也有用到这个方法，用于添加监听的元素，注意 target 的类型必须是 Element 或 SVGElement 引用。\r\n\r\n### disconnect\r\n\r\n```js\r\nresizeObserver.disconnect();\r\n```\r\n\r\n停止和取消目标对象上所有对 Element 或 SVGElement 的监听。\r\n\r\n### unobserve\r\n\r\n```js\r\nresizeObserver.unobserve(target);\r\n```\r\n\r\n接收一个参数，停止对指定目标的监听，target 的类型为 Element 或 SVGElement 引用\r\n",
      "reactions": {
        "url": "https://api.github.com/repos/bosens-China/blog/issues/26/reactions",
        "total_count": 0,
        "+1": 0,
        "-1": 0,
        "laugh": 0,
        "hooray": 0,
        "confused": 0,
        "heart": 0,
        "rocket": 0,
        "eyes": 0
      },
      "timeline_url": "https://api.github.com/repos/bosens-China/blog/issues/26/timeline",
      "performed_via_github_app": null,
      "state_reason": null
    },
    {
      "url": "https://api.github.com/repos/bosens-China/blog/issues/18",
      "repository_url": "https://api.github.com/repos/bosens-China/blog",
      "labels_url": "https://api.github.com/repos/bosens-China/blog/issues/18/labels{/name}",
      "comments_url": "https://api.github.com/repos/bosens-China/blog/issues/18/comments",
      "events_url": "https://api.github.com/repos/bosens-China/blog/issues/18/events",
      "html_url": "https://github.com/bosens-China/blog/issues/18",
      "id": 479907836,
      "node_id": "MDU6SXNzdWU0Nzk5MDc4MzY=",
      "number": 18,
      "title": "无效的height100%？",
      "user": {
        "login": "bosens-China",
        "id": 39508895,
        "node_id": "MDQ6VXNlcjM5NTA4ODk1",
        "avatar_url": "https://avatars.githubusercontent.com/u/39508895?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bosens-China",
        "html_url": "https://github.com/bosens-China",
        "followers_url": "https://api.github.com/users/bosens-China/followers",
        "following_url": "https://api.github.com/users/bosens-China/following{/other_user}",
        "gists_url": "https://api.github.com/users/bosens-China/gists{/gist_id}",
        "starred_url": "https://api.github.com/users/bosens-China/starred{/owner}{/repo}",
        "subscriptions_url": "https://api.github.com/users/bosens-China/subscriptions",
        "organizations_url": "https://api.github.com/users/bosens-China/orgs",
        "repos_url": "https://api.github.com/users/bosens-China/repos",
        "events_url": "https://api.github.com/users/bosens-China/events{/privacy}",
        "received_events_url": "https://api.github.com/users/bosens-China/received_events",
        "type": "User",
        "site_admin": false
      },
      "labels": [
        {
          "id": 1371686610,
          "node_id": "MDU6TGFiZWwxMzcxNjg2NjEw",
          "url": "https://api.github.com/repos/bosens-China/blog/labels/css%20%E7%9B%B8%E5%85%B3",
          "name": "css 相关",
          "color": "42b883",
          "default": false,
          "description": "css 技巧和基础为主"
        }
      ],
      "state": "open",
      "locked": false,
      "assignee": null,
      "assignees": [],
      "milestone": null,
      "comments": 0,
      "created_at": "2019-08-13T00:34:13Z",
      "updated_at": "2019-08-13T00:34:13Z",
      "closed_at": null,
      "author_association": "OWNER",
      "active_lock_reason": null,
      "body": "之所以写 height，是因为它出现的场所比较多\r\n``` css\r\nbody {\r\n  height: 100%;\r\n}\r\n```\r\n不知道你们有没有这样写过 css 属性，不过很遗憾这是无效的。\r\n\r\n父级没有给定明确的高度么？ 这样说有一定正确性，不过不够全面，在 height 的规范中规定了两种情况 100%可以解析出来\r\n\r\n1. 父级给定明确的高度\r\n这个没什么好说的，平时我们也是这样写的 比如上面 body 没有生效就是因为没有指定 html 的高度，所以要这样写\r\n``` css\r\nhtml,\r\nbody {\r\n  height: 100%;\r\n}\r\n```\r\n\r\n2. 使用绝对定位元素\r\n``` css\r\n.box {\r\n  position: relative;\r\n  .child {\r\n    position: absolute;\r\n    height: 100%;\r\n    widows: 100%;\r\n  }\r\n}\r\n```\r\n这样就获取到了高度，不过注意绝对定位获取的高度与父级给定高度有一定区别\r\n\r\n## 区别\r\ncss 是存在盒子模型的，平时高度和宽度都是作用在 `content-box` 上的，而上面说的第一种方式，高度获取到的就是父级 content 盒子的高度，怎么来证明呢？ `box-sizing` 可以改变作用高度和宽度的盒子，我们来用这个实验。\r\n``` html\r\n<div class=\"box\">\r\n  <div class=\"child\"></div>\r\n</div>\r\n.box {\r\n  width: 180px;\r\n  background: #ddd;\r\n  height: 150px;\r\n  padding: 30px;\r\n  box-sizing: border-box;\r\n  .child {\r\n    height: 100%;\r\n    background: #666;\r\n  }\r\n}\r\n```\r\n可以将上面代码复制到本地运行一下，可以看到子元素的高度并没有占用父元素的 100%。 改写一下，改成绝对定位来实现\r\n``` css\r\n.box {\r\n  width: 180px;\r\n  background: #ddd;\r\n  height: 150px;\r\n  padding: 30px;\r\n  box-sizing: border-box;\r\n  position: relative;\r\n  border: 20px solid;\r\n  .child {\r\n    height: 100%;\r\n    background: #666;\r\n    position: absolute;\r\n    width: 100%;\r\n  }\r\n}\r\n```\r\n对比一下可以看到绝对定位的高度是包含` padding` 区域的\r\n\r\n最后以一个示例结尾\r\n``` html\r\n<div class=\"box\">\r\n  <a href=\"javascript:\" class=\"nav\"></a>\r\n  <a href=\"javascript:\" class=\"nav nav1\"></a>\r\n  <img src=\"https://demo.cssworld.cn/images/common/l/1.jpg\" alt=\"\" />\r\n</div>\r\n.box {\r\n  display: inline-block;\r\n  position: relative;\r\n  .nav {\r\n    position: absolute;\r\n    height: 100%;\r\n    left: 0;\r\n    width: 50%;\r\n    opacity: 0.7;\r\n    background: #ddd;\r\n  }\r\n  .nav1 {\r\n    left: 50%;\r\n    background: #34538b;\r\n  }\r\n}\r\n```\r\n借助绝对定位实现了高度自适应的效果\r\n\r\n## 参考\r\n《css 世界》",
      "reactions": {
        "url": "https://api.github.com/repos/bosens-China/blog/issues/18/reactions",
        "total_count": 0,
        "+1": 0,
        "-1": 0,
        "laugh": 0,
        "hooray": 0,
        "confused": 0,
        "heart": 0,
        "rocket": 0,
        "eyes": 0
      },
      "timeline_url": "https://api.github.com/repos/bosens-China/blog/issues/18/timeline",
      "performed_via_github_app": null,
      "state_reason": null
    }
  ],
  "labelsMap": [
    [
      "3041947800",
      [
        {
          "url": "https://api.github.com/repos/bosens-China/blog/issues/101",
          "repository_url": "https://api.github.com/repos/bosens-China/blog",
          "labels_url": "https://api.github.com/repos/bosens-China/blog/issues/101/labels{/name}",
          "comments_url": "https://api.github.com/repos/bosens-China/blog/issues/101/comments",
          "events_url": "https://api.github.com/repos/bosens-China/blog/issues/101/events",
          "html_url": "https://github.com/bosens-China/blog/issues/101",
          "id": 1998957787,
          "node_id": "I_kwDOCzPAy853Jazb",
          "number": 101,
          "title": "前端面试回顾",
          "user": {
            "login": "bosens-China",
            "id": 39508895,
            "node_id": "MDQ6VXNlcjM5NTA4ODk1",
            "avatar_url": "https://avatars.githubusercontent.com/u/39508895?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/bosens-China",
            "html_url": "https://github.com/bosens-China",
            "followers_url": "https://api.github.com/users/bosens-China/followers",
            "following_url": "https://api.github.com/users/bosens-China/following{/other_user}",
            "gists_url": "https://api.github.com/users/bosens-China/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/bosens-China/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/bosens-China/subscriptions",
            "organizations_url": "https://api.github.com/users/bosens-China/orgs",
            "repos_url": "https://api.github.com/users/bosens-China/repos",
            "events_url": "https://api.github.com/users/bosens-China/events{/privacy}",
            "received_events_url": "https://api.github.com/users/bosens-China/received_events",
            "type": "User",
            "site_admin": false
          },
          "labels": [
            {
              "id": 3041947800,
              "node_id": "MDU6TGFiZWwzMDQxOTQ3ODAw",
              "url": "https://api.github.com/repos/bosens-China/blog/labels/%E4%BB%A3%E7%A0%81%E4%BA%BA%E7%94%9F",
              "name": "代码人生",
              "color": "7B17E3",
              "default": false,
              "description": "和技术无关，人生的感悟"
            }
          ],
          "state": "open",
          "locked": false,
          "assignee": null,
          "assignees": [],
          "milestone": null,
          "comments": 0,
          "created_at": "2023-11-17T12:00:41Z",
          "updated_at": "2024-03-06T09:11:39Z",
          "closed_at": null,
          "author_association": "OWNER",
          "active_lock_reason": null,
          "body": "\r\n趁现在有时间稍微总结一下面试的一些问题\r\n\r\n## one\r\n\r\n- Promise 为什么可以链式调用\r\n- 如果在.then 返回一个值，这个新的 Promise 状态是什么\r\n- 如果想要阻止链式调用，让后续的.then 一直暂停状态有哪些方法\r\n- all 和 allSettled 区别\r\n- 设计一个调度程序，可以让 Promise 并发执行，但是最多只能有 5 个任务在执行\r\n- 说一下什么是事件循环\r\n- nextTick 的实现原理\r\n- 聊一下 Promise 解决了什么问题，以及相关历史\r\n- async 和 await 如果要捕获错误需要怎么做，await 可以单独使用吗\r\n- 项目中使用了那些设计模式\r\n- 发布订阅模式和观察者模式有什么区别\r\n- Vue2 的响应式模式是怎么实现的\r\n- 除了 Promise 还有哪些微任务，以及如果考虑设计一个数据埋点，需要怎么设计\r\n\r\n总体在聊 Promise 这块，顺路说了一下 Vue2，不过初次面试还是当时有点紧张有点问题回答不是很好，面试的结果是通过，不过开的薪资跟我目标还是有很大差异，遂放弃。\r\n\r\n\r\n## two\r\n- 如果要你设计一个低代码，需要考虑哪些问题\r\n- 如何储存开发的公共组件，使用什么形式来保存，注入到页面中\r\n- 对于定制化需求，如何进行代码管理\r\n- 看你写的有关于团队规范的东西，可以简单介绍下吗\r\n- 聊一下什么是状态机\r\n- 什么是状态模式\r\n\r\n总体没怎么聊技术，可能面试官不是前端有关把。给的薪资还是不满意给拒绝掉了。\r\n\r\n### three\r\n\r\n- 什么是 BFC\r\n- 内容盒子和 IE 盒子区别\r\n- 在开发过程中怎么联调接口的（介绍下如何处理跨域）\r\n- TypeScript 使用 interface 还是 type 比较多，为什么\r\n- 怎么实现无痕刷新 token 的\r\n- 怎么部署产品的，聊一下思路\r\n- Docker 常见使用命令\r\n- 如果初始加载需要渲染 3d 模型，但是所需的 vtp 资源比较大，有什么办法可以优化吗\r\n\r\n这个也是搞医疗的，不过是做牙医相关的，感觉面试过程挺一般的，这个面试没通过。\r\n\r\n### four\r\n\r\n- 什么是节流和防抖，什么场景使用，怎么实现\r\n- webpack 和 rollup 有什么不同，打包的大小体积为什么有区别\r\n- CSS 重叠样式表，重叠怎么理解\r\n- Vue 的 diff 和 React 的 diff 有什么不同\r\n- 虚拟 Dom 是什么，为什么要用虚拟 Dom\r\n- 为什么很多框架采用无虚拟 Dom，例如 svelte\r\n- 为什么浏览器只有 body 在界面展示，head 这部分在浏览器中是什么处理的\r\n- cssos 是什么计算的\r\n- tc39 关注了那些最新语法\r\n- 如果后端一直返回数据，需要对 table 进行数据展示要怎么来设计，需要考虑内存储存不够场景\r\n- 怎么实现组件库的整体引用和分别引用，对于 css 样式怎么来实现呢？\r\n- 时间切片是什么，为什么 Vue 没有使用\r\n- React fiber 是什么\r\n- Vue 为什么有静态提升，React 没有，以及 solidjs 怎么实现的\r\n- tree Shink 基于什么实现的\r\n- ESM 和 commonjs 有什么不同\r\n- webpack tree Shink 和 rollup 有什么不同\r\n- Vite 和 Esbuild 的关系怎么来理解\r\n- 什么是 babel，它的作用是什么，以及和 Swc 的区别是什么\r\n- css 动画为什么比 js 动画流畅\r\n\r\n这个面试感觉很多问题没有回答上来，本来觉得都凉了，但是后面通知过了，就感觉还挺有意思。\r\n\r\n## five\r\n- 对于一个数组怎么转换为树结构\r\n- 对于闭包和浅拷贝的理解\r\n- 节流函数如何编写，后执行\r\n- React受控组件和非受控组件区别\r\n- 对于usememo和usecallback你是怎么理解的\r\n- 对于nuxt14的app和pages有什么区别\r\n- app下的增量模式有使用过吗\r\n- app下的img组件要怎么来进行优化\r\n- 对于nuxt布局方面有了解吗\r\n- TypeScript和静态语言方面的类型检查有什么不同吗\r\n- 使用monorepo的形式是什么，为什么这么做\r\n- 有使用过Lighthouse吗，知道它的原理是什么吗？\r\n- 对于性能优化你做了哪些措施，让Lighthouse的指标提升50%\r\n- 有使用过typeScript的验证库吗，可以保证线上运行时和接口返回值的类型一致\r\n- express的实现原理\r\n- 对于大文件的优化措施，对于流模式如何保证客户端断开之后继续从初始位置继续下载\r\n- 对于React的render谈一谈\r\n- Vue3和Vue2的提升点在于什么地方\r\n- TypeScript的泛型如何理解\r\n- TypeScript infercase和type的区别\r\n- TypeScript的协变和逆变区别\r\n- Webpack的插件有哪些钩子，是通过什么来管理整理流程的\r\n- Webpack从打包到构建中间经历了什么\r\n- nest的健康检查使用过没，对于服务挂了有什么应对措施\r\n- 使用过mongodb吗是如何编写的\r\n- 对于脚手架项目你做了哪些，有考虑哪些方面的维度吗\r\n- 对于项目中TypeScript使用any场景，你们公司有什么规范要求吗\r\n- 如何避免使用any呢？\r\n- 谈一谈你做的性能优化方面的举措，从页面加载开始说\r\n- 对于响应式页面你的做法是什么，如果存在多个项目和一个项目你觉得哪种更合适，需要考虑seo的抓取\r\n- 了解事件循环机制吗\r\n- 为什么js是单线程语言\r\n- Tailwind有使用过吗，你的实践做法是什么\r\n\r\n## 最后\r\n\r\n面试过程其实就是查缺补漏的过程，感觉 2023 年对于框架源码以及一个构建工具的实现细节还是要了解很多的。\r\n\r\n这里推荐一个介绍范文来聊自己，对于面试通过怎么和公司聊具体的薪资啥的，可以看我之前的文章 [如何选择合适的公司？](https://juejin.cn/post/6967742961262002190)\r\n\r\n```txt\r\n面试官你好很荣幸参加今天的面试，我叫xxx，毕业于xxx，\r\n距今已经有x年工作经验，擅长React + vue 技术栈，在上家公司担任前端工程师岗位，主要负责其中的xxx和xxx部分的工作，\r\n20xx-20xx年主要在做xx项目，这个项目是结合xxx而出现的，我在里面负责主要开发，以及底层工具的升级优化，最终xxx，\r\n平时还关注前沿技术，对于tc39和新的工具出现第一时间关注，平时还爱好写作，会定期复盘，以上就是我的自我介绍，谢谢。\r\n```\r\n",
          "reactions": {
            "url": "https://api.github.com/repos/bosens-China/blog/issues/101/reactions",
            "total_count": 0,
            "+1": 0,
            "-1": 0,
            "laugh": 0,
            "hooray": 0,
            "confused": 0,
            "heart": 0,
            "rocket": 0,
            "eyes": 0
          },
          "timeline_url": "https://api.github.com/repos/bosens-China/blog/issues/101/timeline",
          "performed_via_github_app": null,
          "state_reason": null
        },
        {
          "url": "https://api.github.com/repos/bosens-China/blog/issues/106",
          "repository_url": "https://api.github.com/repos/bosens-China/blog",
          "labels_url": "https://api.github.com/repos/bosens-China/blog/issues/106/labels{/name}",
          "comments_url": "https://api.github.com/repos/bosens-China/blog/issues/106/comments",
          "events_url": "https://api.github.com/repos/bosens-China/blog/issues/106/events",
          "html_url": "https://github.com/bosens-China/blog/issues/106",
          "id": 2056128095,
          "node_id": "I_kwDOCzPAy856jgZf",
          "number": 106,
          "title": "2023年终总结",
          "user": {
            "login": "bosens-China",
            "id": 39508895,
            "node_id": "MDQ6VXNlcjM5NTA4ODk1",
            "avatar_url": "https://avatars.githubusercontent.com/u/39508895?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/bosens-China",
            "html_url": "https://github.com/bosens-China",
            "followers_url": "https://api.github.com/users/bosens-China/followers",
            "following_url": "https://api.github.com/users/bosens-China/following{/other_user}",
            "gists_url": "https://api.github.com/users/bosens-China/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/bosens-China/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/bosens-China/subscriptions",
            "organizations_url": "https://api.github.com/users/bosens-China/orgs",
            "repos_url": "https://api.github.com/users/bosens-China/repos",
            "events_url": "https://api.github.com/users/bosens-China/events{/privacy}",
            "received_events_url": "https://api.github.com/users/bosens-China/received_events",
            "type": "User",
            "site_admin": false
          },
          "labels": [
            {
              "id": 3041947800,
              "node_id": "MDU6TGFiZWwzMDQxOTQ3ODAw",
              "url": "https://api.github.com/repos/bosens-China/blog/labels/%E4%BB%A3%E7%A0%81%E4%BA%BA%E7%94%9F",
              "name": "代码人生",
              "color": "7B17E3",
              "default": false,
              "description": "和技术无关，人生的感悟"
            }
          ],
          "state": "open",
          "locked": false,
          "assignee": null,
          "assignees": [],
          "milestone": null,
          "comments": 0,
          "created_at": "2023-12-26T07:34:24Z",
          "updated_at": "2023-12-26T07:34:25Z",
          "closed_at": null,
          "author_association": "OWNER",
          "active_lock_reason": null,
          "body": "2023 年的即将走完，趁着现在还有一些时间，给今年发生了许多事情一个阶段性总结。本来很早之前就在计划就要写一篇文章回顾下半年这几个月（打到这行字还是觉得眼眶酸酸的，因为之前的文稿是我口述她敲的，现在在上面基础上加工）。但是中间一直懒散的拖下去直到今天才终于有时间来写这篇文章。\r\n\r\n## 买房\r\n\r\n20 年的时候其实就在关注，当时同事跟我说房价涨了，让我赶紧看房子，不过当时苦于老家有一套贷款房所以需要 5 成首付就一直不了了之这样。随着 7 月政策慢慢放开首付比例，我也把老家的贷款给结清了，所以就继续关注，当时主要看的是新房主打一个人多就参与，期间参与了很多楼盘。\r\n\r\n龙湖光年、朗诗里、臻悦等，不过都一直没摇中，后面时代星河开了，然后参加摇号职住+刚需的身份勉强摇中，顺序还挺靠前。当时工作就在高新区，房子也在附近所以觉得还挺 ok，也没有想太多总感觉自己迟早都要买，就下定决心交了首付。\r\n\r\n不过现在看这个事情，感觉自己做的还是很冲动，说白了就是抗风险能力不足，而且现在还是一个人，如果结婚了夫妻双方的话可能会好一些，而且我买房子当时想的是自住，但是我最近整理自己的思绪才发现，自己其实想的一直都是投资。如果房价下降很严重，其实我根本就不会考虑这个事情了，这还真是不知道说啥了。\r\n\r\n## 被裁\r\n\r\n9 月 16 号的时候公司突然通知裁员，我们领导和我说的，他说他自己也是被裁名单。我在这家公司已经待了 2 年半了，其实也蛮久了一直想着跳槽之类的，所以现在反而有一笔赔偿之类的内心也能接受，后面把年假休了到 21 号正式离职。\r\n\r\n站在目前来看在这家公司在我职业生涯占比达到一半，福利很好而且工作强度很适中，base 因为在合肥甚至还可以远程办公，唯一一点就是偶尔需要出差，我甚至觉得买房的原因就跟在这家公司待久了很有关联，因为公积金是全额缴纳的。当时算账面的时候就觉得压力其实也还好，但是没想到突然发生黑天鹅这样的事情吧，整个小组都被砍掉了。\r\n\r\n后面的一周就在整理简历断断续续投递，期间有 2 个 offer 不过薪资离我期待的目标还是有所差异，最终也没有入职。\r\n\r\n过了 11 月之后就非常焦虑，每天的工作就是找工作，进一步对寒冬有了新的认知，到了 11 月找到了一个薪水达到期待的但是距离很远的工作，勉强入职了。\r\n\r\n## 恋爱\r\n\r\n整体上半年其实过的非常轻松，一个人在陌生城市还是会觉得有些孤独吧，离上一段感情已经过去一年了。但是工作场景很单一，所以就在一些软件上尝试寻找，后面就在青藤认识到了一个女生，简称她为小刘。\r\n\r\n当时看她是 e 人，颜值其实只能说普通这样，但是因为性格是一个互补的这样，所以觉得还是可以继续相处下去。后面就经常一起语音和玩游戏，到后面第一次见面经常约出去玩，第一次牵手啥的，我觉得整体过程都很平顺，果然互相喜欢进度跟做火箭没有太多区别。到 21 号的时候约了一个上海的面试就问她要不要一起顺便玩一下，她同意了。\r\n\r\n去上海面试的过程还算 ok，不过薪水没有达到预期最终也没有去。\r\n\r\n后面两天就去了外滩和迪士尼去玩，其实一直觉得挺愧疚毕竟去上海的主要目的其实是面试，玩的话只是附带的。玩的场景还历历在目一起挑战了很多项目，尤其是极速光轮还挺刺激的。\r\n\r\n后面回到合肥之后就经常一起去吃饭做 diy、玩卡车去游乐园，去公园散步等，每天有这样的一个女生陪伴，真的觉得很幸福，而且她还是英语专业的，每天对我还能监督。我甚至跟她在一起把之后的生活都想象好了。\r\n\r\n## 失恋\r\n\r\n幸福总是短暂的，到了 12 月的时候我感觉她的状态很不对劲，就每天找她聊天都比较冷淡，晚上也不会主动打语音之类的。后面就打了一个电话问她，但是她只是说自己比较忙碌。当时我觉得就是说辞了，心里已经有了不好的感觉，然后晚上她哭着跟我说，家里在闹矛盾父母要闹离婚，当时觉得自己挺不是东西的，没有安慰反而一直想东想西的。\r\n\r\n但是过了一周依然是很冷淡这种，12 月 11 号的时候我有点忍受不了，下午 4 点多打了电话，但是没打通，隔半个小时打一个断断续续打了 11 个，到了 8 点半她微信给我回消息了，大概说\r\n\r\n```txt\r\n小杨我们分开吧，也不要继续给我打电话了。\r\n在一起就就是很懵懵懂懂这样，从一顿饭开始也不知道是不是爱情，但是她觉得不是合适的人，就这样结束吧。\r\n```\r\n\r\n当时说完觉得自己终于得到自己想要了答案了，但是第二天后遗症太大了一直想电话联系，后面短信跟她说，如果不同意就去公司找她，她才勉强接的。\r\n电话说了一些原因啥的，没有告别也没有送花，还有她经常过来找我我迟到这样，还有跟其他同事男朋友对比，觉得我做的很差。\r\n\r\n周四还是决心去尝试了一下，到之前跟她微信说了下，说之前的缺点现在都认知到了，现在自己想尝试改掉，给这样的机会。但是她态度很强烈说不喜欢就是不喜欢，为什么还要勉强，来见我的目的就是想复合我都知道，但是这个不是一时冲动，希望不要在纠结了，否则不要怪她撕破脸之类的。\r\n\r\n当时心里听了就很凉，但是还是说见一面吧，分开见最后一面聊聊。晚上勉强见了一面，但是什么话都说不出来因为她她一直在恳求说我们做朋友吧，我只能苦涩点头。晚上想送她回家，她说不用这样，我坚持送，在地铁上跟我说，现在我就像一个狗皮膏药一样。\r\n\r\n周末的时候抖音联系她室友，问她室友知不知道最近发生了什么事情和矛盾，晚上她给生气给我打了一大段话，大概就是说不是已经同意分手了，为什么还要烦她室友，语气很不客气而且骂了我一顿，里面很多话我觉得太恶毒了，就完全跟我心目中的她颠覆了。说我恶心，装深情，之类的可能就是单纯不喜欢没有感觉了，总之从 9 月到 12 月快到三个月的一个短暂感情就这样结束了。\r\n\r\n## 被裁\r\n\r\n其实就发生在今天（12 月 26 日），昨天部门领导找我谈话，说我最近工作态度太消极了，明天人事会找我聊一下。\r\n\r\n上午人事找到我，传达了部门的最终意见，这边也只能接受了，其实我一直觉得工作对我来说可有可无，没有的话就重新找一份，本来就打算只是过渡，只是感情这个事情一直在纠缠着我，让我觉得很疲倦这样。临近年底可能自己能做的就是休息一段时间，等待明年继续找工作了。\r\n\r\n而且今年在找工作的时候我会觉得技术要求很高，需要持续学习，而且会有淘汰风险的，但是产品岗位就相对而言更好一些，也比较方便晋升之类的。如果有转岗的建议真的可以考虑一下，不过就是不太适合 i 人。\r\n\r\n而且最近这段时间一直在想出路啥的，现在觉得程开发的岗位真的挺适合前端的，就是需要英语要求比较高，需要多补一下。\r\n\r\n## 退房\r\n\r\n这个事情其实思考了很久，当时 7 月份就决定要买，但是 9 月经历了裁员找工作也不是很顺利。就一直在想这个事情，中间也尝试很多方法，去找他们经理谈以及找关系退房等。但是都失败了，目前加上继续失业的这样一个 buff，实在没有心情继续搞下去了。\r\n\r\n而且房产我也持悲观态度，这样稳定 30 年的还贷款真的很有压力的事情，后面可能等结婚之后才会继续考虑了。\r\n\r\n下这个决定也没有想象中的这么痛快，中间一直在拉扯，自己的内心也一直处于纠结状态，但是现在继续上车搞不好真的征信黑了，笑。\r\n\r\n## 最后\r\n\r\n感觉今年应该是我人生非常黑暗的一年，但是也有一些美好的回忆，很喜欢曾国藩的一句话 `物来顺应，未来不迎，当时不杂，既过不恋`，还是需要降低对她人的期待，才能当事情不至于跟自己的内心有很大的这样一个差异。而且我觉得自己真的有点恋爱脑这样，又或者太精神依赖别人了，现在被抽离才这样痛苦吧。\r\n\r\n工作方面工作很久，我反而会觉得技术不是很重要的这样一个标准，尤其是跟我同时期工作的人已经坐上了 leader 的岗位，这让我觉得很有危机感。自己其实也想尝试往管理的岗位走下去，但是可能需要一个契机吧。\r\n\r\n感情方面我没有觉得她亏欠我很多，只是自己一下子接受不了失去吧，有美好的回忆就足够了，有这样的一个人陪伴过我这样一段时光，我觉得也算是一种收获。不过最近在看关于她的一些东西，也还是会有一些莫名复杂的感情吧。\r\n\r\n不过如何2023年就这样度过了，希望新的一年有好的心情与发展。\r\n\r\n最后用一张图结束今年的感情\r\n\r\n<img width=\"624\" alt=\"image\" src=\"https://github.com/bosens-China/blog/assets/39508895/4b36a30f-e840-485a-96ee-a108f023bf59\">\r\n\r\n",
          "reactions": {
            "url": "https://api.github.com/repos/bosens-China/blog/issues/106/reactions",
            "total_count": 0,
            "+1": 0,
            "-1": 0,
            "laugh": 0,
            "hooray": 0,
            "confused": 0,
            "heart": 0,
            "rocket": 0,
            "eyes": 0
          },
          "timeline_url": "https://api.github.com/repos/bosens-China/blog/issues/106/timeline",
          "performed_via_github_app": null,
          "state_reason": null
        },
        {
          "url": "https://api.github.com/repos/bosens-China/blog/issues/68",
          "repository_url": "https://api.github.com/repos/bosens-China/blog",
          "labels_url": "https://api.github.com/repos/bosens-China/blog/issues/68/labels{/name}",
          "comments_url": "https://api.github.com/repos/bosens-China/blog/issues/68/comments",
          "events_url": "https://api.github.com/repos/bosens-China/blog/issues/68/events",
          "html_url": "https://github.com/bosens-China/blog/issues/68",
          "id": 906504178,
          "node_id": "MDU6SXNzdWU5MDY1MDQxNzg=",
          "number": 68,
          "title": "如何选择合适的公司？",
          "user": {
            "login": "bosens-China",
            "id": 39508895,
            "node_id": "MDQ6VXNlcjM5NTA4ODk1",
            "avatar_url": "https://avatars.githubusercontent.com/u/39508895?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/bosens-China",
            "html_url": "https://github.com/bosens-China",
            "followers_url": "https://api.github.com/users/bosens-China/followers",
            "following_url": "https://api.github.com/users/bosens-China/following{/other_user}",
            "gists_url": "https://api.github.com/users/bosens-China/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/bosens-China/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/bosens-China/subscriptions",
            "organizations_url": "https://api.github.com/users/bosens-China/orgs",
            "repos_url": "https://api.github.com/users/bosens-China/repos",
            "events_url": "https://api.github.com/users/bosens-China/events{/privacy}",
            "received_events_url": "https://api.github.com/users/bosens-China/received_events",
            "type": "User",
            "site_admin": false
          },
          "labels": [
            {
              "id": 3041947800,
              "node_id": "MDU6TGFiZWwzMDQxOTQ3ODAw",
              "url": "https://api.github.com/repos/bosens-China/blog/labels/%E4%BB%A3%E7%A0%81%E4%BA%BA%E7%94%9F",
              "name": "代码人生",
              "color": "7B17E3",
              "default": false,
              "description": "和技术无关，人生的感悟"
            }
          ],
          "state": "open",
          "locked": false,
          "assignee": null,
          "assignees": [],
          "milestone": null,
          "comments": 0,
          "created_at": "2021-05-29T16:03:33Z",
          "updated_at": "2021-12-21T10:00:56Z",
          "closed_at": null,
          "author_association": "OWNER",
          "active_lock_reason": null,
          "body": "![背景图片](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7fc336f293cb45d3a308a9ccc0a1aa17~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n虽然金三银四早也过去，不过坦率的说好多公司招聘的需求量依然很大，再加上自己这段时间也在关注，这块所以就简单聊聊从选择公司到入职的一系列问题\r\n\r\n> 这里不涉及如何写简历以及如何回答面试的问题，后面如果有时间会考虑新开一个篇幅来说\r\n\r\n## 求职渠道\r\n\r\n首先如果自己早已有心仪的目标那可以跳过这一步，直接从脉脉或者知乎等各种社交 app 上找到内推信息，然后投递简历等待面试。\r\n\r\n但是如果没有找到满意的目标，那不妨从 `boss 直聘`着手，之前也用了很多其他的招聘 app 比如拉钩，不过坦率的说沟通模式或者说回复消息这块始终没有 boss 直聘来的简洁和清爽。\r\n\r\n## 筛选公司\r\n\r\n之前在知乎看到一个问题就是说`“年轻人到底选择大公司还有小公司”`，当然各种答案各不相同，但是站在自己踩过坑的情况来说还是建议大家选择一个大公司，因为可以节省你很多额外的采坑成本\r\n\r\n- 有着完整加薪结构，不再是口头上的一年两调或者一调；\r\n- 各种福利比较齐全，公积金和社保缴纳等；\r\n- 开发规范和团队协作流程比较成熟，可以接触到完整的开发流程；\r\n\r\n其次要想好自己做什么样的产品，目前按照产品划分可以分为两种\r\n\r\n- to B：提供给企业的产品\r\n- to C：提供给个人的产品\r\n\r\n所以根据上面两条，在加上自己的一些心理底线：\r\n\r\n1. 确定好自己想去什么规模的公司\r\n2. 做的产品业务是什么样子的\r\n3. 期待的薪资结构 + 上下班时间 + 基础性的福利等\r\n\r\n根据上面条件初步筛选出一些公司，下面的话就是看公司的介绍跟自己的符合度怎么样，这里建议大家不要广撒网而是专门精选这样会更有效的针对公司进行准备，其实不仅仅是公司在选择个人，个人也要选择公司，不然其实你会待的很压抑或者说跟你不匹配就是浪费双方的时间。\r\n\r\n这里额外补充一点，在面试之前可以事先沟通好你自己的一些底线信息。避免更多的时间成本浪费，比如我就是要过滤掉公积金社保不足额缴纳的公司，那你就可以直接说，你好方便问一下你们公积金缴纳比例和基数吗？\r\n\r\n最后，如果对方已读不回那就默认凉了，作为不要怀疑自己，找工作从来不是一个简单的事情。\r\n\r\n## 面试准备\r\n\r\n确定好目标跟 hr 沟通的时候我个人觉得稍微突出主题可以提高不少面试几率，我一般喜欢说：“你好看到贵公司的招聘情况觉得蛮符合的，可以发一份简历给你看看吗？”\r\n\r\n不过这个也不是绝对的，毕竟求职还是看符不符合岗位要求，如果你的简历足够丰富，估计每天沟通你的 hr 自己都要排队处理。\r\n\r\n说完打招呼还有一个需要确认就是面试时间和方式，一般而言如果是在职的话优先远程或者电话面试，不然遇到坑的面试官让你感觉时间被浪费，而如果你在外地求职的地点跟你不在同一个地方那如果对方不支持远程我建议你就不要去了，因为很多公司的 hr 对指标有要求，可能你只是一个他们的 kpi。\r\n\r\n当然如果能实地面试更好，可以通过观察公司附近的环境，公司的环境以及人员初步判断一下。\r\n\r\n## 面试结束\r\n\r\n如果你已经把一面、二面之类的全部都过了，只剩下 hr 这一关了那你就可以聊一下关乎切身的福利之类了。\r\n\r\n### 工资\r\n\r\n劳动合同会签订多少，绩效会占比多少，以及绩效是按照每个月发放还是一个季度发放，试用期工资都需要详细了解清楚，而且关于合同上的工资，也是后面如果需要维权情况的的一个重要依据。\r\n\r\n### 五险一金缴纳的基数和比例\r\n\r\n五险一金不缴纳是违法的，但是有的企业为了降低成本选择只缴纳最低的基数。\r\n\r\n公积金会跟你买房的公积金贷款还有还款挂钩，是一个真正的福利；\r\n\r\n而五险虽然目前可能用不到，但是少交肯定是个人的一个损失\r\n\r\n### 加班\r\n\r\n是否有加班工资或者调休，其实我个人是不怎么喜欢加班多的公司，尤其是因为业务很赶的原因或者团队公司氛围造成的，因为这个会影响到你的后续学习，而且每天使你很疲倦，从长远来看逃离加班多的公司对你的职业生涯更友好。\r\n\r\n### 作息时间是怎么样的\r\n\r\n确定好作息时间，看看自己每天需要通勤多久，如果条件允许就搬到公司附近来吧，每天通勤十几分钟真的很有幸福感。\r\n\r\n还有确定好是否可以弹性打卡，如果你像我一样每天喜欢卡着点上班还有扣钱啥的，就需要仔细想下了，不过对于这种公司建议跑路之。\r\n\r\n### 每年会有调薪的机会吗，一个流程是怎么样的\r\n\r\n这里可以简单了解下，对于互联网来说跳槽永远是涨薪的最好机会，不过如果团队氛围不错，再加上涨薪幅度也 ok 我觉得留下来也没有什么不好的\r\n\r\n### 其他各种福利\r\n\r\n比如餐补、房补、交通补、节假日福利、另外的保险等，不过注意不要跟你谈的薪资混合在了一起，比如你税前 20K，结果是各种福利加在一起的，那我觉得就没有什么必要了，还不如不写。\r\n\r\n### 年终奖\r\n\r\n年终奖也可以问下，一般来说最少一个月，多的话三四个月的也是有。\r\n\r\n对于期权之类的，我个人建议先暂时无视之，因为这个东西需要有时间前置条件，到时候你能不能待满这么久都不好说，如果真的待这么久再了解也不迟。\r\n\r\n## 最后\r\n\r\n如果确定好准备去，记得让对方公司发一份`offer`过来，辞职的话正式员工需要一个月，试用期三天，所以你需要跟新公司的 hr 确定好具体的入职时间，以及确定好社保的缴纳时间，避免断交社保造成的影响。\r\n\r\n最后，如果对你有帮助可以点一下`statr`\r\n",
          "reactions": {
            "url": "https://api.github.com/repos/bosens-China/blog/issues/68/reactions",
            "total_count": 0,
            "+1": 0,
            "-1": 0,
            "laugh": 0,
            "hooray": 0,
            "confused": 0,
            "heart": 0,
            "rocket": 0,
            "eyes": 0
          },
          "timeline_url": "https://api.github.com/repos/bosens-China/blog/issues/68/timeline",
          "performed_via_github_app": null,
          "state_reason": null
        }
      ]
    ],
    [
      "6273949336",
      [
        {
          "url": "https://api.github.com/repos/bosens-China/blog/issues/102",
          "repository_url": "https://api.github.com/repos/bosens-China/blog",
          "labels_url": "https://api.github.com/repos/bosens-China/blog/issues/102/labels{/name}",
          "comments_url": "https://api.github.com/repos/bosens-China/blog/issues/102/comments",
          "events_url": "https://api.github.com/repos/bosens-China/blog/issues/102/events",
          "html_url": "https://github.com/bosens-China/blog/issues/102",
          "id": 2020292180,
          "node_id": "I_kwDOCzPAy854azZU",
          "number": 102,
          "title": "Next.js 构建博客之资源抓取 ",
          "user": {
            "login": "bosens-China",
            "id": 39508895,
            "node_id": "MDQ6VXNlcjM5NTA4ODk1",
            "avatar_url": "https://avatars.githubusercontent.com/u/39508895?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/bosens-China",
            "html_url": "https://github.com/bosens-China",
            "followers_url": "https://api.github.com/users/bosens-China/followers",
            "following_url": "https://api.github.com/users/bosens-China/following{/other_user}",
            "gists_url": "https://api.github.com/users/bosens-China/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/bosens-China/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/bosens-China/subscriptions",
            "organizations_url": "https://api.github.com/users/bosens-China/orgs",
            "repos_url": "https://api.github.com/users/bosens-China/repos",
            "events_url": "https://api.github.com/users/bosens-China/events{/privacy}",
            "received_events_url": "https://api.github.com/users/bosens-China/received_events",
            "type": "User",
            "site_admin": false
          },
          "labels": [
            {
              "id": 6273949336,
              "node_id": "LA_kwDOCzPAy88AAAABdfTemA",
              "url": "https://api.github.com/repos/bosens-China/blog/labels/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA",
              "name": "博客搭建",
              "color": "b60205",
              "default": false,
              "description": "介绍博客简单的过程"
            }
          ],
          "state": "open",
          "locked": false,
          "assignee": null,
          "assignees": [],
          "milestone": null,
          "comments": 0,
          "created_at": "2023-12-01T07:36:23Z",
          "updated_at": "2023-12-27T06:47:51Z",
          "closed_at": null,
          "author_association": "OWNER",
          "active_lock_reason": null,
          "body": "![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/93a4556e832740f0b44cb081a6a70b9e~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2998&h=1464&s=549772&e=png&b=fefefe)\r\n\r\n1.  [Next.js 构建博客之资源抓取](https://github.com/bosens-China/blog/issues/102)\r\n2.  [Next.js 构建博客之博客搭建](https://github.com/bosens-China/blog/issues/103)\r\n3.  [Next.js 构建博客之打包 SSG](https://github.com/bosens-China/blog/issues/104)\r\n4.  [Next.js 构建博客之常见问题处理](https://github.com/bosens-China/blog/issues/105)\r\n5.  [Next.js 构建博客之功能拓展](https://github.com/bosens-China/blog/issues/107)\r\n6.  [Next.js 构建博客之自动构建](https://github.com/bosens-China/blog/issues/108)\r\n\r\n这是 Next.js 搭建博客的第一章，整个系列会详细介绍如何结合 GitHub 和 Next.js 搭建自己的博客。\r\n\r\n如果你想看已经部署博客的地址可以[点击查看](https://bosens-china.github.io/blog/)，代码仓库地址[点击查看](https://github.com/bosens-China/blog)。\r\n\r\n在正式开始之前，使用坚果云画了一份流程图，方便后续的理解。\r\n\r\n![image-3.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/755c68b609ea44c6a5ef70fd43cc30da~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1172&h=946&s=293944&e=png&b=fdfdfd)\r\n\r\n整个流程都高度依赖 issues 和 labels，所以在正式讲解 Next.js 之前还需要思考怎么把当前仓库的所有 issues 和 labels 爬取下来，这里 GitHub 官方已经给出了相关的 api 文档，只需要参考调用即可。\r\n不过这里额外补充一下，为什么需要把整体 issues 和 labels 拉取下来再进行 Next.js 拉取呢，主要有三个原因：\r\n\r\n1.  GitHub api 并没有给出总页数多少，我们需要重复调用才知道是否结束，不会像开发项目中知道第几页从当前页数拉取就行；\r\n2.  每天调用的 api 也是有额度限制的，但是在开发环境调用频率很高会导致不能使用就太糟糕了；\r\n3.  可以对拉下来的数据进行拓展；\r\n\r\n## 项目初始化\r\n\r\n整体项目会最终采用一个 MonoRepo 的设计，采用的技术是 pnpm + workspace 形式，下面详细讲解下步骤。\r\n\r\n1.  新建 package.json 文件\r\n\r\n```sh\r\npnpm init -y\r\n```\r\n\r\n2.  创建 pnpm-workspace.yaml 文件，调整文件内容为\r\n\r\n```sh\r\npackages:\r\n  # 所有在 packages/  子目录下的 package\r\n  - \"packages/**\"\r\n  # 不包括在 test 文件夹下的 package\r\n  - \"!**/test/**\"\r\n```\r\n\r\n3.  在 packages 下创建 sideEffect 文件夹，在 sideEffect 下创建 package.json\r\n\r\n```sh\r\ncd packages/sideEffect\r\npnpm init -y\r\n```\r\n\r\n这个 sideEffect 文件最终就是我们加载各种副作用的一个文件夹，拉取 issues 的操作也在这里完成。\r\n\r\n经过上面一些步骤，目前项目的大概雏形已经有了，下面安装一些必备的依赖项方便后续的操作\r\n\r\n```sh\r\npnpm install axios dayjs dotenv fs-extra\r\n```\r\n\r\n之后进入[settings/tokens](https://github.com/settings/tokens)设置个人令牌，在开发环境传递给 GitHub api 接口使用，否则会受到限制[每小时只能请求 60 次](https://docs.github.com/zh/rest/overview/rate-limits-for-the-rest-api?apiVersion=2022-11-28)。\r\n\r\n![image-2.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/37c2c045830c42438cdb8bcad7bfada4~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=3754&h=1316&s=972620&e=png&b=ffffff)\r\n\r\n这里贴一下官方的文档地址 [issues](https://docs.github.com/en/rest/issues/issues?apiVersion=2022-11-28)，下一步就是把当前仓库所有信息拉取下来。\r\n\r\n## 拉取 issues and labels\r\n\r\n创建一个新的 api/index.ts 文件，我们所有相关的跟 GitHub api 都通过这个完成。\r\n\r\n上面在 settings/tokens 创建一个新的 token 保存下来，在 sideEffect 下新建一个.env 文件，将 token 保存成下面键值对形式。\r\n\r\n```sh\r\nAUTHORIZATION=xxx\r\n# GITHUB_REPOSITORY是你的用户名+仓库名组成，根据你自己的仓库调整\r\nGITHUB_REPOSITORY=bosens-China/blog\r\n```\r\n\r\n之后新建一个 utils/request.ts 文件，这个文件就是封装一下 axios 方便使用。\r\n\r\n```js\r\nimport axios from \"axios\";\r\n\r\nexport const instance = axios.create({\r\n  baseURL: \"https://api.github.com/\",\r\n  timeout: 10000,\r\n  headers: {\r\n    Accept: \"application/vnd.github+json\",\r\n    Authorization: `Bearer ${process.env.AUTHORIZATION}`,\r\n    \"X-GitHub-Api-Version\": \"2022-11-28\",\r\n  },\r\n});\r\n```\r\n\r\n之后返回到 api/index.ts 文件\r\n\r\n```js\r\nimport { instance } from \"../utils/request\";\r\nconst { GITHUB_REPOSITORY } = process.env;\r\n\r\nexport const issues = async (page = 1) => {\r\n  const { data } = await instance.get<IssuesDaum[]>(\r\n    `/repos/${GITHUB_REPOSITORY}/issues`,\r\n    {\r\n      params: {\r\n        filter: \"created\",\r\n        state: \"open\",\r\n        sort: \"updated\",\r\n        per_page: 100,\r\n        page,\r\n      },\r\n    }\r\n  );\r\n  return data;\r\n};\r\n\r\nexport const labels = async (page = 1) => {\r\n  const { data } = await instance.get<Label[]>(\r\n    `/repos/${GITHUB_REPOSITORY}/labels`,\r\n    {\r\n      params: {\r\n        per_page: 100,\r\n        page,\r\n      },\r\n    }\r\n  );\r\n  return data;\r\n};\r\n```\r\n\r\n> IssuesDaum 和 Label 是详细的类型定义文件这里忽略掉，如果需要相关类型文件可以[点击访问](https://github.com/bosens-China/blog/blob/main/packages/sideEffect/src/api/type.ts)。\r\n\r\n之后新建 implement.ts 文件，这个文件就是调用 issues 和 labels 接口，然后把信息保存下来。\r\n\r\n上面有说到根据 GitHub 的文档可以看到 labels 和 issues 都是返回一个数组，但是我们并不知道有没有拉取完，所以这边的思路就是创建一个新的文件，让他调用自身直到返回空数组为止。\r\n\r\n```js\r\nconst continued = async <T extends (page?: number) => Promise<unknown[]>>(\r\n  fn: T,\r\n  page = 1\r\n) => {\r\n  const result = (await fn(page)) as ReturnType<T>;\r\n  if (Array.isArray(result) && result.length) {\r\n    const arr = await continued(fn, page + 1);\r\n    result.push(...arr);\r\n  }\r\n  return result;\r\n};\r\n```\r\n\r\n最初的时候创建了一个.env 文件，这个文件是保存开发环境的一些信息，不过根据 esm 加载顺序我们必须要保证在调用其他模块的时候 dotenv 信息已经正确加载，所以这边思路如下。\r\n\r\n创建一个立即执行函数，把需要执行的代码放里面执行即可，或者使用顶层 await 也可以，下面是完整代码\r\n\r\n```js\r\nimport dotenv from \"dotenv\";\r\nimport fs from \"fs-extra\";\r\nimport path from \"path\";\r\n\r\ndotenv.config();\r\n\r\nconst { GITHUB_REPOSITORY } = process.env;\r\n\r\n(async () => {\r\n  console.time(`Start crawling the required data...`);\r\n  const { labels, issues } = await import(\"./api\");\r\n  try {\r\n    const [labelsData, issuesData] = await Promise.all([\r\n      continued(labels),\r\n      continued(issues),\r\n    ]);\r\n    // 考虑到后续可能别人直接拷贝这个项目使用，对label一次插入\r\n    let other = labelsData.find((f) => f.name === \"其他\")!;\r\n    if (!other) {\r\n      other = {\r\n        id: 1000000000,\r\n        node_id: \"MDU6TGFiZWwxMzcxNjg2NjEx\",\r\n        url: `https://api.github.com/repos/${GITHUB_REPOSITORY}/labels/其他`,\r\n        name: \"其他\",\r\n        color: \"f6ecbf\",\r\n        default: false,\r\n        description: \"未找到分类，暂定的文章分类\",\r\n      };\r\n      labelsData.push(other);\r\n    }\r\n    const map: Map<string, typeof issuesData> = new Map();\r\n    issuesData.forEach((item) => {\r\n      if (!item.labels.length) {\r\n        item.labels.push(other);\r\n      }\r\n      item.labels.forEach((label) => {\r\n        const id = `${label.id}`;\r\n        if (!map.has(id)) {\r\n          map.set(id, []);\r\n        }\r\n        map.get(id)?.push(item);\r\n      });\r\n    });\r\n\r\n    await fs.writeJson(\r\n      path.join(__dirname, \"./data.json\"),\r\n      {\r\n        label: labelsData,\r\n        issuesData: issuesData,\r\n        labelsMap: [...map],\r\n      },\r\n      { spaces: 2 }\r\n    );\r\n  } catch (e) {\r\n    console.log(e instanceof Error ? e.message : e);\r\n  }\r\n  console.timeEnd(`Start crawling the required data...`);\r\n})();\r\n```\r\n\r\n## 提供资产\r\n\r\n上面的代码都是 TypeScript，不能直接运行，这里安装 tsx\r\n\r\n```sh\r\npnpm add tsx\r\n```\r\n\r\n它的作用就是调用 TypeScript 代码，相比 ts-node 它不会进行类型检查，速度很快。\r\n\r\n之后在 package.json 下的 scripts 下创建命令，方便快速调用\r\n\r\n```js\r\nscripts: {\r\n  \"crawlingResource\": \"tsx ./src/implement.ts\",\r\n}\r\n```\r\n\r\n之后执行 `pnpm run crawlingResource`，就可以看到在 src 下生成了一个 `data.json` 的文件。\r\n\r\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/29a7e5f878274eda968171222b3bfa12~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2020&h=1478&s=867275&e=png&b=ffffff)\r\n\r\n这里再新建一个 index.ts 文件，方便对 data.json 进行一些封装查询操作。\r\n\r\n```js\r\nimport data from \"./data.json\";\r\n\r\n// 对数据进行封装，方便调用\r\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\r\nexport const classification = new Map(data.labelsMap as any) as Map<\r\n  string,\r\n  typeof data.issuesData\r\n>;\r\n\r\nconst map = new Map<string, (typeof data.label)[number] | undefined>();\r\n\r\nexport const getLabel = (id: string) => {\r\n  if (map.has(id)) {\r\n    return map.get(id);\r\n  }\r\n  const result = data.label.find((f) => f.id === +id);\r\n  map.set(id, result);\r\n  return result;\r\n};\r\n\r\nexport default data;\r\n```\r\n\r\n到这里就把拉取资源的相关写完了，不过还需要在 package.json 暴露出口，让其他模块安装之后可以进行调用\r\n\r\n```js\r\n\"main\": \"./src/index.ts\",\r\n```\r\n\r\n## 最后\r\n\r\n最后记得在当前目录创建一个新的[.gitignore](https://github.com/bosens-China/blog/blob/main/packages/sideEffect/.gitignore \".gitignore\") 文件，将.env 文件忽略。\r\n\r\n第一节内容就讲完了，下一节会介绍 [Next.js 构建博客之博客搭建](https://github.com/bosens-China/blog/issues/103)，如果有书写错误欢迎指出。\r\n",
          "reactions": {
            "url": "https://api.github.com/repos/bosens-China/blog/issues/102/reactions",
            "total_count": 0,
            "+1": 0,
            "-1": 0,
            "laugh": 0,
            "hooray": 0,
            "confused": 0,
            "heart": 0,
            "rocket": 0,
            "eyes": 0
          },
          "timeline_url": "https://api.github.com/repos/bosens-China/blog/issues/102/timeline",
          "performed_via_github_app": null,
          "state_reason": null
        },
        {
          "url": "https://api.github.com/repos/bosens-China/blog/issues/103",
          "repository_url": "https://api.github.com/repos/bosens-China/blog",
          "labels_url": "https://api.github.com/repos/bosens-China/blog/issues/103/labels{/name}",
          "comments_url": "https://api.github.com/repos/bosens-China/blog/issues/103/comments",
          "events_url": "https://api.github.com/repos/bosens-China/blog/issues/103/events",
          "html_url": "https://github.com/bosens-China/blog/issues/103",
          "id": 2020398367,
          "node_id": "I_kwDOCzPAy854bNUf",
          "number": 103,
          "title": "Next.js 构建博客之博客搭建",
          "user": {
            "login": "bosens-China",
            "id": 39508895,
            "node_id": "MDQ6VXNlcjM5NTA4ODk1",
            "avatar_url": "https://avatars.githubusercontent.com/u/39508895?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/bosens-China",
            "html_url": "https://github.com/bosens-China",
            "followers_url": "https://api.github.com/users/bosens-China/followers",
            "following_url": "https://api.github.com/users/bosens-China/following{/other_user}",
            "gists_url": "https://api.github.com/users/bosens-China/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/bosens-China/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/bosens-China/subscriptions",
            "organizations_url": "https://api.github.com/users/bosens-China/orgs",
            "repos_url": "https://api.github.com/users/bosens-China/repos",
            "events_url": "https://api.github.com/users/bosens-China/events{/privacy}",
            "received_events_url": "https://api.github.com/users/bosens-China/received_events",
            "type": "User",
            "site_admin": false
          },
          "labels": [
            {
              "id": 6273949336,
              "node_id": "LA_kwDOCzPAy88AAAABdfTemA",
              "url": "https://api.github.com/repos/bosens-China/blog/labels/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA",
              "name": "博客搭建",
              "color": "b60205",
              "default": false,
              "description": "介绍博客简单的过程"
            }
          ],
          "state": "open",
          "locked": false,
          "assignee": null,
          "assignees": [],
          "milestone": null,
          "comments": 0,
          "created_at": "2023-12-01T08:47:28Z",
          "updated_at": "2023-12-27T06:46:30Z",
          "closed_at": null,
          "author_association": "OWNER",
          "active_lock_reason": null,
          "body": "![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/93a4556e832740f0b44cb081a6a70b9e~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2998&h=1464&s=549772&e=png&b=fefefe)\r\n\r\n1.  [Next.js 构建博客之资源抓取](https://github.com/bosens-China/blog/issues/102)\r\n2.  [Next.js 构建博客之博客搭建](https://github.com/bosens-China/blog/issues/103)\r\n3.  [Next.js 构建博客之打包 SSG](https://github.com/bosens-China/blog/issues/104)\r\n4.  [Next.js 构建博客之常见问题处理](https://github.com/bosens-China/blog/issues/105)\r\n5.  [Next.js 构建博客之功能拓展](https://github.com/bosens-China/blog/issues/107)\r\n6.  [Next.js 构建博客之自动构建](https://github.com/bosens-China/blog/issues/108)\r\n\r\n在上一篇 [Next.js 构建博客之资源抓取](https://github.com/bosens-China/blog/issues/102) 介绍了如何把 GitHub 上的 issues 和 labels 资源拉取下来，方便构建使用。下面就介绍如何使用 Next.js 来完成博客的搭建，以及介绍一下常见会遇到的一些问题。\r\n\r\n如果你想看已经部署博客的地址可以[点击查看](https://bosens-china.github.io/blog/)，代码仓库地址[点击查看](https://github.com/bosens-China/blog)。\r\n\r\n不过需要注意这里不会介绍博客的样式和布局要怎么设计，这个全凭心意。本节主要注重怎么把 issues 和 labels 进行展示，以及路由和详情页面的展示要使用什么技术，可能会遇到的问题等。\r\n\r\n> 这里也不会花费时间来介绍 Next.js 相关的概念，阅读本节默认你已经知道 Next.js 要怎么使用了。\r\n\r\n## 创建\r\n\r\n这里按照[文档的做法](https://nextjs.org/docs/getting-started/installation)\r\n\r\n```sh\r\ncd packages\r\nnpx create-next-app@latest\r\n```\r\n\r\n然后根据提示一步步选择，这里我附一下自己的选择\r\n\r\n```sh\r\nWhat is your project named? view\r\nWould you like to use TypeScript? Yes\r\nWould you like to use ESLint? Yes\r\nWould you like to use Tailwind CSS? No\r\nWould you like to use `src/` directory? N\r\nWould you like to use App Router? (recommended) Yes\r\nWould you like to customize the default import alias (@/*)? Yes\r\nWhat import alias would you like configured? @/*\r\n```\r\n\r\n不过 Next.js 的版本可能会在后面发生变化，以及 api 也可能会调整，这里贴一下自己在写这篇文章时的 Next.js 版本\r\n\r\n```sh\r\n\"next\": \"14.0.2\",\r\n```\r\n\r\n## 首页搭建\r\n\r\n这里分析一下我们现在已经有的信息：\r\n\r\n1.  知道所有 issues\r\n2.  知道所有的 labels\r\n\r\n其中每一个 issue 对应的就是一篇文章，这篇文章可能会存在多个 labels 下，labels 可以简单理解为栏目。\r\n\r\n布局这块，首页和详情变化的部分只是中间区域不同\r\n\r\n![image-1.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f2e5baf970c84267a174ac68161d5115~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2918&h=1508&s=1548515&e=png&b=fefefe)\r\n\r\n![image-2.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f4606d13783a4d2ab41831760d02902f~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2962&h=1494&s=1905526&e=png&b=fefefe)\r\n\r\n其他部分基本是复用的，所以这里就有了思路，在 Next.js 文档中 app/layout.tsx 这个文件是布局文件，每个页面都会默认复用这个文件，除非你显示在子页面创建新的 layout.tsx 文件。\r\n\r\n```js\r\nimport \"./styles/index.scss\";\r\nimport { RightSide } from \"./components/rightSide\";\r\nimport Side from \"./components/side\";\r\n\r\nexport const dynamic = \"error\";\r\n\r\nexport default function RootLayout({\r\n  children,\r\n}: {\r\n  children: React.ReactNode,\r\n}) {\r\n  return (\r\n    <html lang=\"zh\">\r\n      <head></head>\r\n      <body>\r\n        <div id=\"qzhai-net\" className=\"wp qzhai-net\">\r\n          <Side></Side>\r\n          <div className=\"qzhai-net-main\">{children}</div>\r\n          <RightSide></RightSide>\r\n        </div>\r\n      </body>\r\n    </html>\r\n  );\r\n}\r\n```\r\n\r\n之后就是在每次路由变化的时候改变 layout.tsx 下的 children 即可，整个博客系统大概存在 4 个路由：\r\n\r\n- 首页，路由对应 /\r\n- pages 页面，跟首页类似，但是首页路由是 /，如果跳转到第二页就会跳转在这里，路由会变成 page/2，后面的 2 代表具体的页数\r\n- 详情页面，从首页点击文章进行详情，会跳转到具体的详情页面，对应路由为 details/id\r\n- 分类页面，文章会存在分页，对应路由为 types/id\r\n\r\n这里首页的搭建其实跟具体的 pages 页面是一回事，我们新建一个 `components/content/index.tsx 文件`，把相同的功能抽离出来。\r\n\r\n这里首页数据其实就是固定展示前面 20 条，如果存在分页也就是把 issues 的数据进行截取条数进行展示。基于分析的这个情况，我们定义一个 Props，它的内容如下：\r\n\r\n```js\r\ntype Props = {\r\n  // 当前页数\r\n  page: number,\r\n};\r\n```\r\n\r\n之后安装一下依赖，把上一节爬取下来的数据拿来使用\r\n\r\n```sh\r\npnpm add @blog/side-effect\r\n```\r\n\r\n之后简单描述一下 `content/index.tsx`\r\n\r\n```js\r\nimport React, { FC } from \"react\";\r\nimport all from \"@blog/side-effect\";\r\n\r\ninterface Props {\r\n  page: number;\r\n}\r\n\r\nexport const Content: FC<Props> = ({ page }) => {\r\n  const data = all.issuesData.slice((page - 1) * 20, page * 20);\r\n\r\n  return (\r\n    <ul>\r\n      {data.map((f) => {\r\n        return (\r\n          <li key={f.id}>\r\n            <p>{f.title}</p>\r\n            ...\r\n            <p>{f.created_at}</p>\r\n          </li>\r\n        );\r\n      })}\r\n    </ul>\r\n  );\r\n};\r\n```\r\n\r\n之后在 app/page.tsx 中，直接这个页面传递 Content 组件 page 传递 1，就完成了调用，不过在实际的开发中还需要考虑其他额外的情况，例如分页、文章简介截取、图片提取等，这里会专门出一篇文章进行介绍，这里快速略过关注怎么来构建。\r\n\r\n## 详情\r\n\r\n打开爬取 data.json，可以看到文章内容储存在 body 中，那么思路就很简单了，在首页中添加一个 a 标签，在跳转过来的时候携带文章对应的 id，之后把对应的数据进行渲染出来即可。\r\n\r\n![image-3.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ef33b8521c02406b8119c3f9188fabff~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2746&h=954&s=254778&e=png&b=1d1d1d)\r\n\r\n使用 a 标签在 Next.js 中是不推荐的行为，Next.js 提供了 Link 标签，它的作用跟 a 标签一致，遇到需要路由跳转的使用 Link 即可。\r\n\r\n之后创建 details/\\[id]/page.tsx 页面，这里 \\[id] 代表了一个动态参数，会根据传递过来的 id 不同来进行变化，在 Next.js 中还有其他可选参数等，这里不展开一一介绍了，之后重点讲一下详情页面要怎么展示 md 内容。\r\n\r\n```js\r\nimport { useMemo } from \"react\";\r\nimport data, { classification } from \"@blog/side-effect\";\r\n\r\ninterface Params {\r\n  id: string;\r\n}\r\ninterface Props {\r\n  params: Params;\r\n  searchParams: Record<string, string>;\r\n}\r\n\r\nexport default function Page({ params: { id } }: Props) {\r\n  const current = useMemo(() => {\r\n    return data.issuesData.find((f) => f.id === +id);\r\n  }, [id]);\r\n}\r\n```\r\n\r\n上面直接根据 id 来对 issues 进行搜索，之后从 current.body 就可以获取到具体的文章内容，这里推荐使用 bytemd 作为内容展示，bytemd 就是掘金同款编辑器，它包含两部分 Editor, Viewer，这里显然只需要使用 Viewer。\r\n\r\n![image-4.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e0908614c4654f82b416b5902d1e4d0e~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2890&h=1274&s=993564&e=png&b=fefefe)\r\n\r\n对于样式之类的可以参考这个仓库 [juejin-markdown-themes](https://github.com/xitu/juejin-markdown-themes)。\r\n\r\n这一步搭建完成大概会得到一个这样的界面\r\n\r\n![image-5.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/629be287e06243f1bd9b523dd3158d06~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1770&h=1374&s=672378&e=png&b=fdfdfd)\r\n\r\n说明内容已经被成功渲染了。\r\n\r\n> 如果在使用 bytemd 过程中提示，提示使用了 useEffect 之类的钩子，直接在文件顶部添加\r\n>\r\n> ```js\r\n> \"use client\";\r\n> // ...\r\n> ```\r\n>\r\n> 把当前组件渲染方式变成客户端渲染。\r\n\r\n## 栏目\r\n\r\n对于栏目页面则更简单一些，只需要把爬取下来的 labels 的标签进行展示即可，下面是一个示例\r\n\r\n```js\r\n// side.tsx\r\n\r\nimport data from \"@blog/side-effect\";\r\nimport Link from \"next/link\";\r\nimport { classification } from \"@blog/side-effect\";\r\n\r\nexport const Side = () => {\r\n  return (\r\n    <>\r\n      <h4>分类查看</h4>\r\n      <ul>\r\n        {data.label.map((item) => {\r\n          const length = classification.get(`${item.id}`)?.length || 0;\r\n          return (\r\n            <li key={item.id}>\r\n              <Link href={`/types/${item.id}`} title={item.description}>\r\n                {item.name}\r\n                <span className=\"types-notes\">[{length}]</span>\r\n              </Link>\r\n            </li>\r\n          );\r\n        })}\r\n      </ul>\r\n    </>\r\n  );\r\n};\r\n```\r\n\r\n## 分页\r\n\r\n对于分页上面其实也有提及，首页以及分页和点击栏目跳转的页面其实都高度依赖 content 这个组件，所以这个组件的灵活性需要保证。\r\n\r\n1.  需要保证可以自定义 header 区域，例如在首页中，展示的应当是最新文章；\r\n2.  如果是栏目跳转那么需要展示对应的栏目名称；\r\n\r\n其他的其实就是把对应 pages/id，传递给 content 这个组件即可，下面是一个示例\r\n\r\n```js\r\n// page/[page]/page.tsx\r\n\r\ninterface Params {\r\n  // 当前页数\r\n  page: string;\r\n}\r\n\r\ninterface Props {\r\n  params: Params;\r\n  searchParams: Record<string, string>;\r\n}\r\n\r\nexport default function Page(props: Props) {\r\n  const {\r\n    params: { page },\r\n  } = props;\r\n\r\n  return (\r\n    <>\r\n      <Content page={+page}></Content>\r\n    </>\r\n  );\r\n}\r\n```\r\n\r\n## 最后\r\n\r\n这节简单探讨了下如何结合 issues 和 labels 进行使用，在下一节 [Next.js 构建博客之打包 SSG](https://github.com/bosens-China/blog/issues/104) 会介绍如何构建 SSG 的应用。\r\n\r\n如果文章有错别字之类也欢迎指出。\r\n",
          "reactions": {
            "url": "https://api.github.com/repos/bosens-China/blog/issues/103/reactions",
            "total_count": 0,
            "+1": 0,
            "-1": 0,
            "laugh": 0,
            "hooray": 0,
            "confused": 0,
            "heart": 0,
            "rocket": 0,
            "eyes": 0
          },
          "timeline_url": "https://api.github.com/repos/bosens-China/blog/issues/103/timeline",
          "performed_via_github_app": null,
          "state_reason": null
        },
        {
          "url": "https://api.github.com/repos/bosens-China/blog/issues/104",
          "repository_url": "https://api.github.com/repos/bosens-China/blog",
          "labels_url": "https://api.github.com/repos/bosens-China/blog/issues/104/labels{/name}",
          "comments_url": "https://api.github.com/repos/bosens-China/blog/issues/104/comments",
          "events_url": "https://api.github.com/repos/bosens-China/blog/issues/104/events",
          "html_url": "https://github.com/bosens-China/blog/issues/104",
          "id": 2032365832,
          "node_id": "I_kwDOCzPAy855I3EI",
          "number": 104,
          "title": "Next.js 构建博客之打包SSG",
          "user": {
            "login": "bosens-China",
            "id": 39508895,
            "node_id": "MDQ6VXNlcjM5NTA4ODk1",
            "avatar_url": "https://avatars.githubusercontent.com/u/39508895?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/bosens-China",
            "html_url": "https://github.com/bosens-China",
            "followers_url": "https://api.github.com/users/bosens-China/followers",
            "following_url": "https://api.github.com/users/bosens-China/following{/other_user}",
            "gists_url": "https://api.github.com/users/bosens-China/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/bosens-China/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/bosens-China/subscriptions",
            "organizations_url": "https://api.github.com/users/bosens-China/orgs",
            "repos_url": "https://api.github.com/users/bosens-China/repos",
            "events_url": "https://api.github.com/users/bosens-China/events{/privacy}",
            "received_events_url": "https://api.github.com/users/bosens-China/received_events",
            "type": "User",
            "site_admin": false
          },
          "labels": [
            {
              "id": 6273949336,
              "node_id": "LA_kwDOCzPAy88AAAABdfTemA",
              "url": "https://api.github.com/repos/bosens-China/blog/labels/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA",
              "name": "博客搭建",
              "color": "b60205",
              "default": false,
              "description": "介绍博客简单的过程"
            }
          ],
          "state": "open",
          "locked": false,
          "assignee": null,
          "assignees": [],
          "milestone": null,
          "comments": 0,
          "created_at": "2023-12-08T10:09:16Z",
          "updated_at": "2023-12-27T06:45:00Z",
          "closed_at": null,
          "author_association": "OWNER",
          "active_lock_reason": null,
          "body": "![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/93a4556e832740f0b44cb081a6a70b9e~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2998&h=1464&s=549772&e=png&b=fefefe)\r\n\r\n1.  [Next.js 构建博客之资源抓取](https://github.com/bosens-China/blog/issues/102)\r\n2.  [Next.js 构建博客之博客搭建](https://github.com/bosens-China/blog/issues/103)\r\n3.  [Next.js 构建博客之打包 SSG](https://github.com/bosens-China/blog/issues/104)\r\n4.  [Next.js 构建博客之常见问题处理](https://github.com/bosens-China/blog/issues/105)\r\n5.  [Next.js 构建博客之功能拓展](https://github.com/bosens-China/blog/issues/107)\r\n6.  [Next.js 构建博客之自动构建](https://github.com/bosens-China/blog/issues/108)\r\n\r\n这是 Next.js 构建博客的第三篇文章，上一篇文章 [Next.js 构建博客之博客搭建](https://github.com/bosens-China/blog/issues/103) 介绍了博客的搭建过程，这篇文章则重点介绍一下如何将资源打包成 SSG。\r\n\r\n如果你想看已经部署博客的地址可以[点击查看](https://bosens-china.github.io/blog/)，代码仓库地址[点击查看](https://github.com/bosens-China/blog)。\r\n\r\nSSG 的全称是 Static Site Generation 即静态渲染，不过在介绍之前先说一下主流的渲染方式：\r\n\r\n1.  客户端渲染，我们常见的 Vue、React 等默认就是客户端渲染，不过这种方式最大弊端就是首屏速度以及 seo 抓取，这刚好不符合我们博客场景；\r\n\r\n![image-1.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/dd3d25c67a3846509bc58286a50c5ffb~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1080&h=1139&s=312855&e=png&b=fefefe)\r\n\r\n2.  ssr，其实就是代码跑在 nodejs 上，然后输出渲染的 html 字符串，之后浏览器获取 js 资源后执行同构代码，并将 DOM 元素绑定事件等，不过这里也不符合场景，代码最终部署在 GitHub 上其实是没有额外的服务器让我们执行；\r\n\r\n![image-2.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5c352499970c4fa4a30c57e679b735a9~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1080&h=709&s=212161&e=png&b=ffffff)\r\n\r\n3.  SSG，就是将动态数据输出成固定的 html 文件，兼顾了文件缓存以及 seo 的需求，完美符合我们使用场景；\r\n\r\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0f3d1aaae5b64e15a584f8467d5fdf19~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1080&h=1464&s=341627&e=png&b=ffffff)\r\n\r\n## 开启 SSG\r\n\r\n上一篇中我们列举了一下页面的路由：\r\n\r\n- /：首页\r\n- pages：分页页面\r\n- details/:id：详情页面\r\n- types/:id：分类页面\r\n\r\n对于固定的页面我们不需要做什么，但是对于携带 `:id` 的动态页面，我们需要把所有的条件都枚举出来，只有这样才能输出所有的页面信息，不至于点击某一个文章直接 404 了。\r\n\r\n枚举所有条件可以使用 [generateStaticParams](https://nextjs.org/docs/app/api-reference/functions/generate-static-params) 完成，这里看一个官方给出的例子：\r\n\r\n```ts\r\n// app/blog/[slug]/page.js\r\n// Return a list of `params` to populate the [slug] dynamic segment\r\nexport async function generateStaticParams() {\r\n  const posts = await fetch(\"https://.../posts\").then((res) => res.json());\r\n\r\n  return posts.map((post) => ({\r\n    slug: post.slug,\r\n  }));\r\n}\r\n\r\n// Multiple versions of this page will be statically generated\r\n// using the `params` returned by `generateStaticParams`\r\nexport default function Page({ params }) {\r\n  const { slug } = params;\r\n  // ...\r\n}\r\n```\r\n\r\n其中 `[slug]` 代表 slug 这个必填，下面的 generateStaticParams 函数作用就是把所有 slug 通过数组的形式进行返回出来，之后 Page 就正常渲染即可。\r\n\r\n下面抛砖引玉对 types 页面进行改造\r\n\r\n```tsx\r\nimport { classification } from \"@blog/side-effect\";\r\n\r\ninterface Params {\r\n  id: [string];\r\n}\r\ninterface Props {\r\n  params: Params;\r\n  searchParams: Record<string, string>;\r\n}\r\n\r\nexport function generateStaticParams(): Params[] {\r\n  const result: Params[] = [];\r\n  classification.forEach((value, key) => {\r\n    result.push({\r\n      rest: [key],\r\n    });\r\n  });\r\n\r\n  return result;\r\n}\r\n```\r\n\r\n这里就把页面所需的参数给枚举结束，其他页面也这样处理即可，如果页面参数涉及的是多个，例如页面需要 id 和 name，那你也只需要在 generateStaticParams 按照顺序返回即可，例如：\r\n\r\n```js\r\n// app/pages/[...rest]/page.tsx\r\nreturn [\r\n  {\r\n    rest: [id, name],\r\n  },\r\n  {\r\n    rest: [id, name],\r\n  },\r\n  // ...\r\n];\r\n```\r\n\r\n之后调整 next.config.js 文件\r\n\r\n```js\r\nconst nextConfig = {\r\n  // ...\r\n  output: \"export\",\r\n};\r\n\r\nmodule.exports = nextConfig;\r\n```\r\n\r\n之后在 app/layout.tsx 文件添加\r\n\r\n```js\r\nexport const dynamic = \"error\";\r\n```\r\n\r\n这里防止在代码中引用 SSG 不支持的一些功能，具体不支持功能可以[点击查看](https://nextjs.org/docs/app/building-your-application/deploying/static-exports)。\r\n\r\n## 动态标题\r\n\r\n有一些页面，例如 types 这个分类页面其中标题应当是固定的，如果按照 Next 设置成一个固定的也不太符合要求，幸好可以使用 [generateMetadata](https://nextjs.org/docs/app/api-reference/functions/generate-metadata) 函数来完成动态设置。\r\n\r\n```js\r\nimport { Metadata } from \"next\";\r\n\r\n// either Static metadata\r\nexport const metadata: Metadata = {\r\n  title: \"...\",\r\n};\r\n\r\n// or Dynamic metadata\r\nexport async function generateMetadata({ params }) {\r\n  return {\r\n    title: \"...\",\r\n  };\r\n}\r\n```\r\n\r\n看一下给出的示例，大概就明白如何使用了，不过这里在涉及博客的场景通常有一部分的标题是固定的，例如 `yliu 的个人博客｜ css 选择器讲解`，其中前缀可能是固定的，一个个写也太繁琐了，下面就介绍一下如何编写动态标题以及固定前缀。\r\n\r\n### app/layout.tsx\r\n\r\n```js\r\nexport const metadata: Metadata = {\r\n  title: {\r\n    template: `%s | ${data.user.name} 的个人博客`,\r\n    default: `${data.user.name} 的个人博客`,\r\n  },\r\n  description: \"记录生活随笔以及技术博客\",\r\n};\r\n```\r\n\r\n这里 `%s` 是占位符，default 则是如果页面没有设置标题默认输出 xxx 的个人博客标题。\r\n\r\n### app/types/page.tsx\r\n\r\n```js\r\nexport async function generateMetadata({\r\n  params: {\r\n    rest: [id],\r\n  },\r\n}: Props) {\r\n  const current = data.label.find((f) => f.id === +id);\r\n\r\n  return {\r\n    title: current?.name,\r\n  };\r\n}\r\n```\r\n\r\n这里就达到我们的最终效果了，当然其实 Metadata 对象包含很多属性，例如 description、keywords 等，所以如果想针对每个文章输出关键词都不相同可以使用 generateMetadata 来达到效果。\r\n\r\n## 最后\r\n\r\n如果文章有书写错误地方欢迎指出。下一篇 [Next.js 构建博客之常见问题处理](https://github.com/bosens-China/blog/issues/105) 会介绍构建以及开发中常见的一些问题，以及如何处理。\r\n",
          "reactions": {
            "url": "https://api.github.com/repos/bosens-China/blog/issues/104/reactions",
            "total_count": 0,
            "+1": 0,
            "-1": 0,
            "laugh": 0,
            "hooray": 0,
            "confused": 0,
            "heart": 0,
            "rocket": 0,
            "eyes": 0
          },
          "timeline_url": "https://api.github.com/repos/bosens-China/blog/issues/104/timeline",
          "performed_via_github_app": null,
          "state_reason": null
        },
        {
          "url": "https://api.github.com/repos/bosens-China/blog/issues/105",
          "repository_url": "https://api.github.com/repos/bosens-China/blog",
          "labels_url": "https://api.github.com/repos/bosens-China/blog/issues/105/labels{/name}",
          "comments_url": "https://api.github.com/repos/bosens-China/blog/issues/105/comments",
          "events_url": "https://api.github.com/repos/bosens-China/blog/issues/105/events",
          "html_url": "https://github.com/bosens-China/blog/issues/105",
          "id": 2043060455,
          "node_id": "I_kwDOCzPAy855xqDn",
          "number": 105,
          "title": "Next.js 构建博客之常见问题处理",
          "user": {
            "login": "bosens-China",
            "id": 39508895,
            "node_id": "MDQ6VXNlcjM5NTA4ODk1",
            "avatar_url": "https://avatars.githubusercontent.com/u/39508895?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/bosens-China",
            "html_url": "https://github.com/bosens-China",
            "followers_url": "https://api.github.com/users/bosens-China/followers",
            "following_url": "https://api.github.com/users/bosens-China/following{/other_user}",
            "gists_url": "https://api.github.com/users/bosens-China/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/bosens-China/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/bosens-China/subscriptions",
            "organizations_url": "https://api.github.com/users/bosens-China/orgs",
            "repos_url": "https://api.github.com/users/bosens-China/repos",
            "events_url": "https://api.github.com/users/bosens-China/events{/privacy}",
            "received_events_url": "https://api.github.com/users/bosens-China/received_events",
            "type": "User",
            "site_admin": false
          },
          "labels": [
            {
              "id": 6273949336,
              "node_id": "LA_kwDOCzPAy88AAAABdfTemA",
              "url": "https://api.github.com/repos/bosens-China/blog/labels/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA",
              "name": "博客搭建",
              "color": "b60205",
              "default": false,
              "description": "介绍博客简单的过程"
            }
          ],
          "state": "open",
          "locked": false,
          "assignee": null,
          "assignees": [],
          "milestone": null,
          "comments": 0,
          "created_at": "2023-12-15T07:33:00Z",
          "updated_at": "2023-12-27T06:42:59Z",
          "closed_at": null,
          "author_association": "OWNER",
          "active_lock_reason": null,
          "body": "![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/93a4556e832740f0b44cb081a6a70b9e~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2998&h=1464&s=549772&e=png&b=fefefe)\r\n\r\n1.  [Next.js 构建博客之资源抓取](https://github.com/bosens-China/blog/issues/102)\r\n2.  [Next.js 构建博客之博客搭建](https://github.com/bosens-China/blog/issues/103)\r\n3.  [Next.js 构建博客之打包 SSG](https://github.com/bosens-China/blog/issues/104)\r\n4.  [Next.js 构建博客之常见问题处理](https://github.com/bosens-China/blog/issues/105)\r\n5.  [Next.js 构建博客之功能拓展](https://github.com/bosens-China/blog/issues/107)\r\n6.  [Next.js 构建博客之自动构建](https://github.com/bosens-China/blog/issues/108)\r\n\r\n这是 Next.js 构建博客的第四篇文章，上一篇文章 [Next.js 构建博客之打包 SSG](https://github.com/bosens-China/blog/issues/104) 介绍了 Next.js 如何打包成 SSG 文件，这篇文章重点介绍一下在开发中容易遇到的问题。\r\n\r\n如果你想看已经部署博客的地址可以[点击查看](https://bosens-china.github.io/blog/)，代码仓库地址[点击查看](https://github.com/bosens-China/blog)。\r\n\r\n## 图片盗链\r\n\r\n有一些网站会有图片防盗处理，例如掘金，为了减少网站的压力，在其他网站访问资源的时候会直接 403，判断原理是在 http 请求中会有 referer 和 host 参数，当参数不一致就认定为非法。\r\n\r\n![example](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/35aa22292b3347b693fa046bedbe0ffb~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=640&h=494&s=36336&e=webp&b=fcfcfc)\r\n\r\n绕过这个的方式也很简单，就是对 referer 进行修改，默认值是 strict-origin-when-cross-origin。\r\n\r\n> 对于同源的请求，发送来源、路径以及查询字符串。对于在相同安全级别的情况下（HTTPS→HTTPS）的跨源请求，仅发送来源。在目标的安全级别下降的情况下（HTTPS→HTTP）则不发送 Referer 标头。\r\n\r\n那么直接修改 referer 为 no-referrer，整个 Referer 首部会被移除。访问来源信息不随着请求一起发送。\r\n\r\n下面是一个具体的实现代码，对图片加载失败进行拦截处理。\r\n\r\n```js\r\n\"use client\";\r\n\r\nimport { useEffect } from \"react\";\r\n\r\nconst map = new WeakMap();\r\n\r\n// 拦截图片错误，并且正确加载\r\nexport default function AssetsWatch() {\r\n  const replace = (dom: HTMLImageElement) => {\r\n    if (map.get(dom)) {\r\n      return;\r\n    }\r\n    const src = dom.src;\r\n    map.set(dom, 1);\r\n    dom.src = `${process.env.NEXT_PUBLIC_BASE_PATH}/error.svg`;\r\n    fetch(src, {\r\n      mode: \"cors\",\r\n      referrerPolicy: \"no-referrer\",\r\n    })\r\n      .then((response) => {\r\n        if (response.ok) {\r\n          return response.blob();\r\n        }\r\n\r\n        throw new Error(\"Image request failed\");\r\n      })\r\n      .then((blob) => {\r\n        const imageUrlObject = URL.createObjectURL(blob);\r\n        dom.src = imageUrlObject;\r\n      })\r\n      .catch((error) => {\r\n        dom.alt = `图片加载失败`;\r\n        dom.title = `图片加载失败，已回滚到默认图片`;\r\n        dom.setAttribute(\"data-src\", src);\r\n        console.error(\"Error:\", error.message);\r\n      });\r\n  };\r\n\r\n  useEffect(() => {\r\n    // 初始遍历一遍，因为插入时间已经很晚了\r\n    const forEach = () => {\r\n      Array.from(document.images).forEach((img) => {\r\n        const dom = new Image();\r\n        dom.src = img.src;\r\n        dom.onerror = () => {\r\n          replace(img);\r\n        };\r\n      });\r\n    };\r\n    const callback = (e: ErrorEvent) => {\r\n      const dom = e.target as HTMLElement;\r\n      if (!dom || !/img/i.test(dom.nodeName)) {\r\n        return;\r\n      }\r\n      replace(dom as HTMLImageElement);\r\n    };\r\n\r\n    window.addEventListener(\"error\", callback, true);\r\n    forEach();\r\n    return () => {\r\n      window.removeEventListener(\"error\", callback);\r\n    };\r\n  }, []);\r\n\r\n  return null;\r\n}\r\n\r\n```\r\n\r\n如果不太明白，可以参考我这篇文章阅读 [如何优雅处理图片异常](https://juejin.cn/post/6844904046705246216?searchId=202312151526128872E8DDAD9C6494A537)。\r\n\r\n## dynamic 和 Suspense 使用场景\r\n\r\n### dynamic\r\n\r\ndynamic 是 React.lazy 和 Suspense 结合体，一般有三种使用场景\r\n\r\n1.  跳过 ssr\r\n\r\n有一些场景不需要 ssr，例如我添加一个点击量的组件或者添加一个查看图片的功能，这种情况下 ssr 没有任何帮助，这个时候就可以使用 dynamic。\r\n\r\n```js\r\nimport dynamicNext from \"next/dynamic\";\r\n\r\nconst Statistics = dynamicNext(() => import(\"./statistics\"), { ssr: false });\r\n\r\nreturn (\r\n  <>\r\n    <Statistics></Statistics>\r\n  </>\r\n);\r\n```\r\n\r\n2.  延迟加载\r\n\r\n通过延迟加载来减少初始渲染路线，来提高初始加载性能。例如延迟加载客户端组件或者库，在用户点击的时候才进行渲染。\r\n\r\npage.tsx\r\n\r\n```js\r\n\"use client\";\r\n\r\nimport { useState } from \"react\";\r\nimport dynamic from \"next/dynamic\";\r\nconst ComponentA = dynamic(() => import(\"../components/A\"));\r\n\r\nexport default function () {\r\n  return (\r\n    <>\r\n      <ComponentA />\r\n    </>\r\n  );\r\n}\r\n```\r\n\r\ncomponents/A.tsx\r\n\r\n```js\r\n\"use client\";\r\n\r\nimport { useState } from \"react\";\r\n\r\nconst names = [\"Tim\", \"Joe\", \"Bel\", \"Lee\"];\r\n\r\nexport default function Page() {\r\n  const [results, setResults] = useState();\r\n\r\n  return (\r\n    <div>\r\n      <input\r\n        type=\"text\"\r\n        placeholder=\"Search\"\r\n        onChange={async (e) => {\r\n          const { value } = e.currentTarget;\r\n          // Dynamically load fuse.js\r\n          const Fuse = (await import(\"fuse.js\")).default;\r\n          const fuse = new Fuse(names);\r\n\r\n          setResults(fuse.search(value));\r\n        }}\r\n      />\r\n      <pre>Results: {JSON.stringify(results, null, 2)}</pre>\r\n    </div>\r\n  );\r\n}\r\n```\r\n\r\n3.  添加自定义加载组件\r\n\r\n```js\r\nimport dynamic from \"next/dynamic\";\r\n\r\nconst WithCustomLoading = dynamic(\r\n  () => import(\"../components/WithCustomLoading\"),\r\n  {\r\n    loading: () => <p>Loading...</p>,\r\n  }\r\n);\r\n\r\nexport default function Page() {\r\n  return (\r\n    <div>\r\n      <WithCustomLoading />\r\n    </div>\r\n  );\r\n}\r\n```\r\n\r\n### Suspense\r\n\r\n在一些组件中难免会使用到客户端组件，例如添加点击事件，或者使用 useState 等，这个时候就不是服务器组件了，一般要么把整个页面都变成客户端组件，但是这个会导致失去 seo 功能，另外一种则是使用 Suspense 对需要使用客户端的组件进行剥离，下面是一个示例。\r\n\r\n```js\r\nimport { Suspense } from \"react\";\r\nimport SearchBar from \"./search-bar\";\r\n\r\nfunction SearchBarFallback() {\r\n  return <>placeholder</>;\r\n}\r\n\r\nexport default function Page() {\r\n  return (\r\n    <>\r\n      <nav>\r\n        <Suspense fallback={<SearchBarFallback />}>\r\n          <SearchBar />\r\n        </Suspense>\r\n      </nav>\r\n      <h1>Dashboard</h1>\r\n    </>\r\n  );\r\n}\r\n```\r\n\r\n初始情况下 html 会加载 fallback 组件内容，之后水合过程将使用 SearchBar 组件。\r\n\r\n## 不要使用重定向\r\n\r\n因为博客的首页和 pages 页面其实是一个东西，所以想着 / 直接重定向到 page/1 就行，但是发现在使用过程中会有很明显白屏现象，就是 page 页面下的 loading 没有生效。\r\n\r\n所以建议还是不要在首屏使用重定向这个方式。\r\n\r\n## 不要使用 style 样式\r\n\r\n博客的 UI 框架部分使用了 antd，在页面加载的过程中会有一个骨架屏，不过因为 antd5 的版本使用 style 来重构样式，在组件运行的时候注入 `<style />` 方便定制和切换主题，导致 Next.js 使用的时候资源不会被缓存且导致骨架屏最初样式没有被加载出来。\r\n\r\n目前 issues 有相关讨论，但是还没解决。\r\n\r\n解决方法：\r\n\r\n1. 切换低版本 antd\r\n2. 换一个 loading 方案\r\n\r\n## 最后\r\n\r\n如果文章有书写错误地方欢迎指出。下一篇 [Next.js 构建博客之功能拓展](https://github.com/bosens-China/blog/issues/107) 会介绍如何给博客添加点击量以及图片放大缩小等功能。\r\n",
          "reactions": {
            "url": "https://api.github.com/repos/bosens-China/blog/issues/105/reactions",
            "total_count": 0,
            "+1": 0,
            "-1": 0,
            "laugh": 0,
            "hooray": 0,
            "confused": 0,
            "heart": 0,
            "rocket": 0,
            "eyes": 0
          },
          "timeline_url": "https://api.github.com/repos/bosens-China/blog/issues/105/timeline",
          "performed_via_github_app": null,
          "state_reason": null
        },
        {
          "url": "https://api.github.com/repos/bosens-China/blog/issues/107",
          "repository_url": "https://api.github.com/repos/bosens-China/blog",
          "labels_url": "https://api.github.com/repos/bosens-China/blog/issues/107/labels{/name}",
          "comments_url": "https://api.github.com/repos/bosens-China/blog/issues/107/comments",
          "events_url": "https://api.github.com/repos/bosens-China/blog/issues/107/events",
          "html_url": "https://github.com/bosens-China/blog/issues/107",
          "id": 2056162170,
          "node_id": "I_kwDOCzPAy856jot6",
          "number": 107,
          "title": "Next.js 构建博客之功能拓展",
          "user": {
            "login": "bosens-China",
            "id": 39508895,
            "node_id": "MDQ6VXNlcjM5NTA4ODk1",
            "avatar_url": "https://avatars.githubusercontent.com/u/39508895?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/bosens-China",
            "html_url": "https://github.com/bosens-China",
            "followers_url": "https://api.github.com/users/bosens-China/followers",
            "following_url": "https://api.github.com/users/bosens-China/following{/other_user}",
            "gists_url": "https://api.github.com/users/bosens-China/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/bosens-China/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/bosens-China/subscriptions",
            "organizations_url": "https://api.github.com/users/bosens-China/orgs",
            "repos_url": "https://api.github.com/users/bosens-China/repos",
            "events_url": "https://api.github.com/users/bosens-China/events{/privacy}",
            "received_events_url": "https://api.github.com/users/bosens-China/received_events",
            "type": "User",
            "site_admin": false
          },
          "labels": [
            {
              "id": 6273949336,
              "node_id": "LA_kwDOCzPAy88AAAABdfTemA",
              "url": "https://api.github.com/repos/bosens-China/blog/labels/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA",
              "name": "博客搭建",
              "color": "b60205",
              "default": false,
              "description": "介绍博客简单的过程"
            }
          ],
          "state": "open",
          "locked": false,
          "assignee": null,
          "assignees": [],
          "milestone": null,
          "comments": 0,
          "created_at": "2023-12-26T08:18:10Z",
          "updated_at": "2023-12-27T06:41:26Z",
          "closed_at": null,
          "author_association": "OWNER",
          "active_lock_reason": null,
          "body": "![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/93a4556e832740f0b44cb081a6a70b9e~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2998&h=1464&s=549772&e=png&b=fefefe)\r\n\r\n1.  [Next.js 构建博客之资源抓取](https://github.com/bosens-China/blog/issues/102)\r\n2.  [Next.js 构建博客之博客搭建](https://github.com/bosens-China/blog/issues/103)\r\n3.  [Next.js 构建博客之打包 SSG](https://github.com/bosens-China/blog/issues/104)\r\n4.  [Next.js 构建博客之常见问题处理](https://github.com/bosens-China/blog/issues/105)\r\n5.  [Next.js 构建博客之功能拓展](https://github.com/bosens-China/blog/issues/107)\r\n6.  [Next.js 构建博客之自动构建](https://github.com/bosens-China/blog/issues/108)\r\n\r\n这是 Next.js 构建博客的第五篇文章，上一篇文章 [Next.js 构建博客之常见问题处理](https://github.com/bosens-China/blog/issues/105) 介绍了 Next.js 如何处理常见的问题，这一篇主要介绍给博客进行功能增强。\r\n\r\n如果你想看已经部署博客的地址可以[点击查看](https://bosens-china.github.io/blog/)，代码仓库地址[点击查看](https://github.com/bosens-China/blog)。\r\n\r\n## 图片放大缩小\r\n\r\n在详情页面会经常遇到图片，很多时候为了考虑排版只会放一个等比例缩小的图片，而不是任由图片展示初始尺寸，这个时候为了为了查看图片就需要考虑功能的增强了。\r\n\r\n这里介绍一下怎么来进行添加，不过在添加之前需要想一下，图片放大缩小这个功能，我们需要用服务器渲染还是客户端渲染？\r\n\r\n我的建议是客户端渲染即可，因为服务器渲染一方面适合比较通用的部分，另外则是 seo 抓取跟图片本身其实关联不大，默认情况下 html 携带图片 alt 属性就足够了。\r\n\r\n博客的渲染使用了 [@bytemd/react](https://github.com/bytedance/bytemd?tab=readme-ov-file)，看一个官方文档的示例\r\n\r\n```js\r\nimport gfm from \"@bytemd/plugin-gfm\";\r\nimport { Editor, Viewer } from \"@bytemd/react\";\r\n\r\nconst plugins = [\r\n  gfm(),\r\n  // Add more plugins here\r\n];\r\n\r\nconst App = () => {\r\n  const [value, setValue] = useState(\"\");\r\n\r\n  return (\r\n    <Editor\r\n      value={value}\r\n      plugins={plugins}\r\n      onChange={(v) => {\r\n        setValue(v);\r\n      }}\r\n    />\r\n  );\r\n};\r\n```\r\n\r\n传递 value 属性就得到一个完整的 view，不过这里不太符合我们要求，因为我们需要给 `<img />` 添加 `onClik` 事件，有两种思路可以做到：\r\n\r\n1. 一种是@bytemd/react 自定义插件\r\n2. 另外一种就是拦截整体整体区域的点击，利用冒泡机制即可。\r\n\r\n下面是一个示例，使用第二种方式\r\n\r\n```js\r\n const [visible, setVisible] = useState(false);\r\n  const [activeIndex, setActiveIndex] = useState(0);\r\n  useEffect(() => {\r\n    const dom = document.querySelector(\".markdown-body\") as HTMLDivElement;\r\n    const callback = (e: MouseEvent) => {\r\n      const dom = e.target as HTMLImageElement;\r\n      if (!/img/i.test(dom.nodeName)) {\r\n        return;\r\n      }\r\n      const index = imgAll.indexOf(dom.src);\r\n      setActiveIndex(index);\r\n      setVisible(true);\r\n    };\r\n    dom.addEventListener(\"click\", callback);\r\n    return () => {\r\n      dom.removeEventListener(\"click\", callback);\r\n    };\r\n  }, [imgAll]);\r\n```\r\n\r\n之后简单封装一下预览图片组件，这里使用了 [react-viewer](react-viewer)\r\n\r\n```js\r\n\"use client\";\r\nimport { Dispatch, SetStateAction, useEffect, useMemo } from \"react\";\r\nimport Viewer from \"react-viewer\";\r\n\r\ninterface Props {\r\n  imgAll: string[];\r\n  visible: boolean;\r\n  setVisible: Dispatch<SetStateAction<boolean>>;\r\n  activeIndex: number;\r\n}\r\n\r\nexport function Preview({ visible, imgAll, setVisible, activeIndex }: Props) {\r\n  const images = useMemo(() => {\r\n    return imgAll.map((f) => {\r\n      return {\r\n        src: f,\r\n        alt: f.split(\"/\").at(-1),\r\n      };\r\n    });\r\n  }, [imgAll]);\r\n  // 防止点开抖动\r\n  const id = \"article_style\";\r\n\r\n  useEffect(() => {\r\n    if (!visible) {\r\n      const dom = document.querySelector(`#${id}`);\r\n      if (dom) {\r\n        // 延迟去除，防止抖动\r\n        setTimeout(() => {\r\n          document.head.removeChild(dom);\r\n        }, 500);\r\n      }\r\n      return;\r\n    }\r\n    const { clientWidth } = window.document.documentElement;\r\n    const screenDifference = window.innerWidth - clientWidth;\r\n    const content = `\r\n      html body{\r\n        overflow-Y:hidden;\r\n        ${\r\n          screenDifference > 0 ? `width:calc(100% - ${screenDifference}px)` : \"\"\r\n        }\r\n      }\r\n  `;\r\n    const style =\r\n      document.querySelector(`#${id}`) || document.createElement(\"style\");\r\n    style.id = id;\r\n    style.innerHTML = content;\r\n    document.head.appendChild(style);\r\n  }, [visible]);\r\n\r\n  return (\r\n    <Viewer\r\n      visible={visible}\r\n      activeIndex={activeIndex}\r\n      onClose={() => {\r\n        setVisible(false);\r\n      }}\r\n      onMaskClick={() => {\r\n        setVisible(false);\r\n      }}\r\n      images={images}\r\n    />\r\n  );\r\n}\r\n```\r\n\r\n之后引入\r\n\r\n```js\r\nconst Preview = dynamic(() => import(\"./preview\").then((e) => e.Preview), {\r\n  ssr: false,\r\n});\r\n```\r\n\r\n## 点击量\r\n\r\n很多时候需要对文章点击量进行一个整体衡量，包括站点访问量之类的，这里用的是 [不蒜子 - 极简网页计数器](https://busuanzi.ibruce.info/)\r\n\r\n首先安装依赖\r\n\r\n```sh\r\npnpm i busuanzi.pure.js\r\n```\r\n\r\n之后在每次路由发生变化的时候进行监听\r\n\r\n```js\r\n\"use client\";\r\nimport { usePathname } from \"next/navigation\";\r\nimport { fetch } from \"busuanzi.pure.js\";\r\nimport { useUpdateEffect } from \"ahooks\";\r\n\r\n// 给文章添加点击量\r\nexport default function Statistics() {\r\n  const pathname = usePathname();\r\n  useUpdateEffect(() => {\r\n    fetch();\r\n  }, [pathname]);\r\n\r\n  return null;\r\n}\r\n```\r\n\r\n在 app/page.tsx 页面引入\r\n\r\n```js\r\nconst Statistics = dynamicNext(() => import(\"./statistics\"), { ssr: false });\r\n\r\nreturn () => {\r\n  <Statistics></Statistics>;\r\n};\r\n```\r\n\r\n在需要地方引入，例如我需要某一篇文章的访问量，那我就\r\n\r\n```html\r\n<span>\r\n  <i className=\"qzf qzf-eye\" />\r\n  <span id=\"busuanzi_value_page_pv\" suppressHydrationWarning> 0 </span>次\r\n</span>\r\n```\r\n\r\n其他的方式可以看一下文章，最后需要注意一下，需要设置 meta 属性为 `no-referrer-when-downgrade`，具体原因看[不蒜子在 Chrome 85 版本后所有页面统计是同一个数据](https://github.com/fluid-dev/hexo-theme-fluid/issues/376)\r\n\r\n```js\r\nexport const metadata: Metadata = {\r\n  referrer: \"no-referrer-when-downgrade\",\r\n};\r\n```\r\n\r\n## 添加收录\r\n\r\n这里以 Google 为例，可以[访问此网站](https://search.google.com/search-console?resource_id=https%3A%2F%2Fbosens-china.github.io%2Fblog%2F)，根据示例一步步来。\r\n\r\n然后在 app/layout.tsx 中添加下面这样的代码\r\n\r\n```js\r\n  return (\r\n    <html lang=\"zh\">\r\n        <meta\r\n          name=\"google-site-verification\"\r\n          content=\"4FVbyJeMZIl9kKhdo9gaJLqZviP6Z5En9GbS5VD8g6w\"\r\n        />\r\n      </head>\r\n      <body>\r\n\r\n      </body>\r\n    </html>\r\n  );\r\n```\r\n\r\n## 给代码添加复制和在线运行功能\r\n\r\n这块因为这段时间心情很糟糕，代码并没有写完，所以下面全部都是伪代码形式。\r\n\r\n因为渲染 md 用的组件是 [@bytemd/react](https://github.com/bytedance/bytemd?tab=readme-ov-file)，它其实是支持插件拓展的，放一张官方的图\r\n\r\n![example](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/772280b6ab3343eea64699995f4419d6~tplv-k3u1fbpfcp-image.image#?w=402&h=342&s=22477&e=svg&a=1&b=f5ddd5)\r\n\r\n有两个步骤可以完成添加的功能\r\n\r\n- The HTML AST could be manipulated by several rehype plugins\r\n- Some extra DOM manipulation after the HTML being rendered\r\n\r\n最后一种对 ssr 没有帮助，相当于客户端渲染了，不过对 dom 添加之类的操作十分方便我们做一些定制，例如添加复制，我们可以写一个 copy 组件，然后在 dom 元素出现的时候直接使用 `react-dom` `render()` 指定元素就下可以了。\r\n\r\n结合一个官方给出的示例来进行看下\r\n\r\n```js\r\nexport default function mathPlugin(): BytemdPlugin {\r\n  return {\r\n    remark: (processor) => processor.use(remarkMath),\r\n+   viewerEffect({ markdownBody }) {\r\n+     const renderMath = async (selector: string, displayMode: boolean) => {\r\n+       const katex = await import('katex').then((m) => m.default)\r\n+\r\n+       const els = markdownBody.querySelectorAll<HTMLElement>(selector)\r\n+       els.forEach((el) => {\r\n+         katex.render(el.innerText, el, { displayMode })\r\n+       })\r\n+     }\r\n+\r\n+     renderMath('.math.math-inline', false)\r\n+     renderMath('.math.math-display', true)\r\n+   },\r\n  }\r\n}\r\n\r\n```\r\n\r\n相当于就是操作 dom 元素了。\r\n\r\n## 添加搜索功能\r\n\r\n文章搜索也是一个很重要功能，这边分享一下我是怎么做的，首先对于关键词搜索啥的 SSG 是没办法收录的，因为你也不知道到底会有多少关键词。\r\n\r\n分享一下我的做法\r\n\r\n```jsx\r\n<form\r\n  id=\"search-form\"\r\n  method=\"get\"\r\n  action={`${process.env.NEXT_PUBLIC_BASE_PATH}/page/1`}\r\n  className=\"uk-search uk-search-navbar uk-width-1-1 qzhai_so uk-visible@s\"\r\n>\r\n  <input\r\n    className=\"uk-search-input\"\r\n    type=\"search\"\r\n    name=\"s\"\r\n    id=\"s\"\r\n    placeholder=\"搜索\"\r\n    defaultValue=\"\"\r\n  />\r\n</form>\r\n```\r\n\r\n当输入之后 enter 按键被触发会在 page 后面携带 `s?=xxx` 的参数，之后在客户端组件里面通过\r\n\r\n```js\r\nconst searchParams = useSearchParams();\r\nconst search = searchParams.get(\"s\");\r\n```\r\n\r\n来取到对应的值，之后就是对数据进行渲染加红即可，这里说下加红的做法，可以通过正则来替换，把搜索文本替换成\r\n\r\n```html\r\n<span style=\"color:red\">关键词</span>\r\n```\r\n\r\n之后 React 直接渲染 html 字符串就达到了一个高亮的效果。\r\n\r\n这里贴一下我的不完整代码\r\n\r\n```jsx\r\n<Link\r\n  href={path}\r\n  dangerouslySetInnerHTML={{\r\n    __html: s\r\n      ? title.replace(new RegExp(s, \"ig\"), (value: string) => {\r\n          return `<span style=\"color: red\">${value}</span>`;\r\n        })\r\n      : title,\r\n  }}\r\n></Link>\r\n```\r\n\r\n## 最后\r\n\r\n如果文章有错误之类的欢迎指出，顺便下一篇文章 [Next.js 构建博客之自动构建](https://github.com/bosens-China/blog/issues/108) 就是收尾了，主要介绍使用 Github Actions 来完成自动发布，在使用的时候只需要监听 issues 的变化就行。\r\n",
          "reactions": {
            "url": "https://api.github.com/repos/bosens-China/blog/issues/107/reactions",
            "total_count": 0,
            "+1": 0,
            "-1": 0,
            "laugh": 0,
            "hooray": 0,
            "confused": 0,
            "heart": 0,
            "rocket": 0,
            "eyes": 0
          },
          "timeline_url": "https://api.github.com/repos/bosens-China/blog/issues/107/timeline",
          "performed_via_github_app": null,
          "state_reason": null
        },
        {
          "url": "https://api.github.com/repos/bosens-China/blog/issues/108",
          "repository_url": "https://api.github.com/repos/bosens-China/blog",
          "labels_url": "https://api.github.com/repos/bosens-China/blog/issues/108/labels{/name}",
          "comments_url": "https://api.github.com/repos/bosens-China/blog/issues/108/comments",
          "events_url": "https://api.github.com/repos/bosens-China/blog/issues/108/events",
          "html_url": "https://github.com/bosens-China/blog/issues/108",
          "id": 2056976568,
          "node_id": "I_kwDOCzPAy856mvi4",
          "number": 108,
          "title": "Next.js 构建博客之自动构建",
          "user": {
            "login": "bosens-China",
            "id": 39508895,
            "node_id": "MDQ6VXNlcjM5NTA4ODk1",
            "avatar_url": "https://avatars.githubusercontent.com/u/39508895?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/bosens-China",
            "html_url": "https://github.com/bosens-China",
            "followers_url": "https://api.github.com/users/bosens-China/followers",
            "following_url": "https://api.github.com/users/bosens-China/following{/other_user}",
            "gists_url": "https://api.github.com/users/bosens-China/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/bosens-China/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/bosens-China/subscriptions",
            "organizations_url": "https://api.github.com/users/bosens-China/orgs",
            "repos_url": "https://api.github.com/users/bosens-China/repos",
            "events_url": "https://api.github.com/users/bosens-China/events{/privacy}",
            "received_events_url": "https://api.github.com/users/bosens-China/received_events",
            "type": "User",
            "site_admin": false
          },
          "labels": [
            {
              "id": 6273949336,
              "node_id": "LA_kwDOCzPAy88AAAABdfTemA",
              "url": "https://api.github.com/repos/bosens-China/blog/labels/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA",
              "name": "博客搭建",
              "color": "b60205",
              "default": false,
              "description": "介绍博客简单的过程"
            }
          ],
          "state": "open",
          "locked": false,
          "assignee": null,
          "assignees": [],
          "milestone": null,
          "comments": 0,
          "created_at": "2023-12-27T06:37:19Z",
          "updated_at": "2023-12-27T06:39:13Z",
          "closed_at": null,
          "author_association": "OWNER",
          "active_lock_reason": null,
          "body": "![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/93a4556e832740f0b44cb081a6a70b9e~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2998&h=1464&s=549772&e=png&b=fefefe)\r\n\r\n1.  [Next.js 构建博客之资源抓取](https://github.com/bosens-China/blog/issues/102)\r\n2.  [Next.js 构建博客之博客搭建](https://github.com/bosens-China/blog/issues/103)\r\n3.  [Next.js 构建博客之打包 SSG](https://github.com/bosens-China/blog/issues/104)\r\n4.  [Next.js 构建博客之常见问题处理](https://github.com/bosens-China/blog/issues/105)\r\n5.  [Next.js 构建博客之功能拓展](https://github.com/bosens-China/blog/issues/107)\r\n6.  [Next.js 构建博客之自动构建](https://github.com/bosens-China/blog/issues/108)\r\n\r\n这是 Next.js 构建博客的第六篇文章，上一篇文章 [Next.js 构建博客之功能拓展](https://github.com/bosens-China/blog/issues/107) 介绍了 Next.js 如何添加额外的功能，这一篇主要介绍自动化提交部署相关的部分。\r\n\r\n如果你想看已经部署博客的地址可以[点击查看](https://bosens-china.github.io/blog/)，代码仓库地址[点击查看](https://github.com/bosens-China/blog)。\r\n\r\n在正式说之前需要对 Github Actions 有所了解，具体的文章这里推荐两篇\r\n\r\n- [GitHub Actions 入门教程](https://www.ruanyifeng.com/blog/2019/09/getting-started-with-github-actions.html)\r\n- [GitHub Actions 教程：定时发送天气邮件](https://www.ruanyifeng.com/blog/2019/12/github_actions.html)\r\n\r\n阅读完成上面两篇会大概对 Github Actions 是什么东西有所了解，之后就是跟着我一步步操作了\r\n\r\n## GitHub Pages\r\n\r\nNext build 之后是一堆静态文件，可以托管到自己的网站也可以白嫖一下 Github Pages，开启 Github Pages 的方法也很简单。\r\n仓库点击 Settings 找到 Pages，之后设置 GitHub Pages 为 Github Actions 即可。\r\n\r\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1db04c51b6174a35bfe7ef147398fa78~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=3024&h=1714&s=502308&e=png&b=fefefe)\r\n\r\n## nextjs.yml\r\n\r\n新建一个文件 .github/workflows/nextjs.yml\r\n\r\n```sh\r\n# Sample workflow for building and deploying a Next.js site to GitHub Pages\r\n#\r\n# To get started with Next.js see: https://nextjs.org/docs/getting-started\r\n#\r\nname: Deploy Next.js site to Pages\r\n\r\non:\r\n  # Runs on pushes targeting the default branch\r\n  push:\r\n    branches: [\"main\"]\r\n  issues:\r\n    types:\r\n      - opened\r\n      - edited\r\n      - deleted\r\n      - closed\r\n      - reopened\r\n  # Allows you to run this workflow manually from the Actions tab\r\n  workflow_dispatch:\r\n\r\n# Sets permissions of the GITHUB_TOKEN to allow deployment to GitHub Pages\r\npermissions:\r\n  contents: write\r\n  pages: write\r\n  id-token: write\r\n\r\n# Allow only one concurrent deployment, skipping runs queued between the run in-progress and latest queued.\r\n# However, do NOT cancel in-progress runs as we want to allow these production deployments to complete.\r\nconcurrency:\r\n  group: \"pages\"\r\n  cancel-in-progress: false\r\n\r\njobs:\r\n  # Build job\r\n  build:\r\n    runs-on: ubuntu-latest\r\n    steps:\r\n      - name: Checkout\r\n        uses: actions/checkout@v3\r\n\r\n      - uses: pnpm/action-setup@v2\r\n        with:\r\n          version: 8.10.2\r\n\r\n      - name: Setup Node\r\n        uses: actions/setup-node@v3\r\n        with:\r\n          node-version: \"20\"\r\n          cache: pnpm\r\n\r\n      - name: Restore cache\r\n        uses: actions/cache@v3\r\n        with:\r\n          path: |\r\n            .next/cache\r\n          # Generate a new cache whenever packages or source files change.\r\n          key: ${{ runner.os }}-nextjs-${{ hashFiles('**/package-lock.json') }}-${{ hashFiles('**/*.[jt]s', '**/*.[jt]sx') }}\r\n          # If source files changed but packages didn't, rebuild from a prior cache.\r\n          restore-keys: |\r\n            ${{ runner.os }}-nextjs-${{ hashFiles('**/package-lock.json') }}-\r\n\r\n      - name: Install dependencies\r\n        run: pnpm install\r\n\r\n      - name: Build userData\r\n        env:\r\n          GITHUB_REPOSITORY: ${{github.repository}}\r\n          AUTHORIZATION: ${{ secrets.ACTION_DEPLOY_KEY  }}\r\n        run: pnpm run -F @blog/side-effect build\r\n\r\n      - name: Commit and Push Changes\r\n        uses: crazy-max/ghaction-github-pages@v2\r\n        with:\r\n          target_branch: ${{github.ref_name}}\r\n          build_dir: ./\r\n          allow_empty_commit: false\r\n        env:\r\n          # @see https://docs.github.com/cn/actions/reference/authentication-in-a-workflow#about-the-github_token-secret\r\n          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}\r\n\r\n      - name: Setup Pages\r\n        uses: actions/configure-pages@v3\r\n        with:\r\n          # Automatically inject basePath in your Next.js configuration file and disable\r\n          # server side image optimization (https://nextjs.org/docs/api-reference/next/image#unoptimized).\r\n          #\r\n          # You may remove this line if you want to manage the configuration yourself.\r\n          static_site_generator: next\r\n\r\n      - name: Build with Next.js\r\n        run: pnpm run -F @blog/view build\r\n      - name: Upload artifact\r\n        uses: actions/upload-pages-artifact@v2\r\n        with:\r\n          path: ./packages/view/out\r\n\r\n  # Deployment job\r\n  deploy:\r\n    # Deploy to the github-pages environment\r\n    environment:\r\n      name: github-pages\r\n      url: ${{ steps.deployment.outputs.page_url }}\r\n\r\n    runs-on: ubuntu-latest\r\n    needs: build\r\n    steps:\r\n      - name: Deploy to GitHub Pages\r\n        id: deployment\r\n        uses: actions/deploy-pages@v2\r\n\r\n```\r\n\r\n上面放了一个完整的 yml 文件，用文字概述一下它做了哪些事情\r\n\r\n### jobs build\r\n\r\n- 安装系统 ubuntu-latest\r\n- 拉取代码\r\n- 安装 pnpm\r\n- 安装 node\r\n- 添加缓存\r\n- 安装 pnpm 依赖\r\n- 运行爬虫\r\n- 推送 README.md 文件到仓库\r\n- Next build 资源\r\n- 将输出资源上传到磁盘中\r\n\r\n### jobs deploy\r\n\r\n- 安装系统 ubuntu-latest\r\n- 将磁盘文件提交到 pages 下\r\n\r\n整体流程就是这样，结合 on 事件当你代码被提交或者 issues 发生变化，上面的 yml 文件就会被执行。\r\n\r\n> 额外说一下，Github Actions 十分强大，例如可以定时跑爬虫、npm 发版等。\r\n\r\n## 最后\r\n\r\n结合 on 事件可以指定触发的场景，例如我的配置如下\r\n\r\n```sh\r\non:\r\n  # Runs on pushes targeting the default branch\r\n  push:\r\n    branches: [\"main\"]\r\n  issues:\r\n    types:\r\n      - opened\r\n      - edited\r\n      - deleted\r\n      - closed\r\n      - reopened\r\n  # Allows you to run this workflow manually from the Actions tab\r\n  workflow_dispatch:\r\n```\r\n\r\n只有推送分支和 issues 发生变化的时候才执行 Action，例如我想更新我的博客只需要在仓库 new issue 就可以触发这个 Action 然后重新构建我的博客,如果遇到问题可以参考[我的仓库](https://github.com/bosens-China/blog/actions)进行查看。\r\n\r\n![image-1.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ad09cbc5c5ad4629bb272024e1f0ecbc~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=3018&h=1460&s=443589&e=png&b=ffffff)\r\n\r\n最后如果有什么错误或者不对地方欢迎指出，如果对你有帮助也可以 star 支持一下，整个 Nextjs 构建博客全系列就讲完了。\r\n",
          "reactions": {
            "url": "https://api.github.com/repos/bosens-China/blog/issues/108/reactions",
            "total_count": 0,
            "+1": 0,
            "-1": 0,
            "laugh": 0,
            "hooray": 0,
            "confused": 0,
            "heart": 0,
            "rocket": 0,
            "eyes": 0
          },
          "timeline_url": "https://api.github.com/repos/bosens-China/blog/issues/108/timeline",
          "performed_via_github_app": null,
          "state_reason": null
        }
      ]
    ],
    [
      "1473940161",
      [
        {
          "url": "https://api.github.com/repos/bosens-China/blog/issues/79",
          "repository_url": "https://api.github.com/repos/bosens-China/blog",
          "labels_url": "https://api.github.com/repos/bosens-China/blog/issues/79/labels{/name}",
          "comments_url": "https://api.github.com/repos/bosens-China/blog/issues/79/comments",
          "events_url": "https://api.github.com/repos/bosens-China/blog/issues/79/events",
          "html_url": "https://github.com/bosens-China/blog/issues/79",
          "id": 1085659613,
          "node_id": "I_kwDOCzPAy85Atdnd",
          "number": 79,
          "title": "从Vue3看组件开发新写法",
          "user": {
            "login": "bosens-China",
            "id": 39508895,
            "node_id": "MDQ6VXNlcjM5NTA4ODk1",
            "avatar_url": "https://avatars.githubusercontent.com/u/39508895?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/bosens-China",
            "html_url": "https://github.com/bosens-China",
            "followers_url": "https://api.github.com/users/bosens-China/followers",
            "following_url": "https://api.github.com/users/bosens-China/following{/other_user}",
            "gists_url": "https://api.github.com/users/bosens-China/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/bosens-China/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/bosens-China/subscriptions",
            "organizations_url": "https://api.github.com/users/bosens-China/orgs",
            "repos_url": "https://api.github.com/users/bosens-China/repos",
            "events_url": "https://api.github.com/users/bosens-China/events{/privacy}",
            "received_events_url": "https://api.github.com/users/bosens-China/received_events",
            "type": "User",
            "site_admin": false
          },
          "labels": [
            {
              "id": 1473940161,
              "node_id": "MDU6TGFiZWwxNDczOTQwMTYx",
              "url": "https://api.github.com/repos/bosens-China/blog/labels/%E6%A1%86%E6%9E%B6%E7%9B%B8%E5%85%B3",
              "name": "框架相关",
              "color": "42b883",
              "default": false,
              "description": "目前Vue和React为主"
            }
          ],
          "state": "open",
          "locked": false,
          "assignee": null,
          "assignees": [],
          "milestone": null,
          "comments": 0,
          "created_at": "2021-12-21T10:11:38Z",
          "updated_at": "2023-12-08T10:31:52Z",
          "closed_at": null,
          "author_association": "OWNER",
          "active_lock_reason": null,
          "body": "这是一篇迟来的文章，原定是 21 年的文章，当时恰逢 Vue3 正式发布已经过去了一段时间，打算介绍一下在 Vue3 中的一些新写法，不过因为种种原因拖延到了今天才动笔。\r\n\r\n## Hooks\r\n\r\nVue3 最大的提升我觉得在于三点：\r\n\r\n- 第一引入了 Proxy 以及编译器的重写，让性能提升一个台阶；\r\n- 第二 TypeScript 的重写让开发过程更加丝滑；\r\n- 第三则是引入了 Composition API，它提供了一种新的组织组件逻辑的方式\r\n\r\n这里重点讲一下 Composition，它提供了一种全新组织逻辑的方法，在之前 Vue2 中我们只能对组件来进行复用，但是对里面的逻辑就无能无力，因此在 Vue2 中有两种方法：\r\n\r\n- 第一种是 Props 不断的拓展，但是缺点也显而易见，让代码混杂在一起，充满各种判断语句；\r\n- 第二则是使用混入，不过这种会让代码调试起来很麻烦，不知道提供的源头在哪里，且对智能推导也不太友好；\r\n\r\n而 Composition 解决的痛点就是组件逻辑这部分，例如我有一个轮播图的组件，在 Vue2 中我想把这个开源出去，我需要考虑很多场景，例如样式拓展、鼠标移动是否禁止下一页、是否支持键盘等，我需要把这个东西做的足够大而全才能覆盖 99%的场景，但是这样带来的问题就是组件很大，逻辑很多。\r\n但是如果在 Vue3 中我们使用 Composition 则有一种新的思路，我不再提供样式和 html，只提供好逻辑部分，用户自己结合所需场景自己来绘制样式，在需要切换的时候调用 Api 即可，下面是一个伪代码。\r\n\r\n```js\r\nconst { previous, nextPage } = useCarouselMap({ ref: dom });\r\n// 点击下一张\r\nnextPage();\r\n```\r\n\r\n在看一个常见的例子，对于网络请求在 Vue2 中一般放到生命周期 created or mounted 中来调用，不过更推荐在 created 中调用，因为可以时机更早一些，如果需要操纵 dom 相关使用 nextTick 即可，下面是一一个示例。\r\n\r\n```js\r\nexport {\r\n  created() {\r\n    this.loading = true;\r\n    getuser().then((data) => {\r\n      this.user = data;\r\n    }).catch((e) => {\r\n      this.$message.error(e.message);\r\n    }).finally(() => {\r\n      this.loading = false;\r\n    });\r\n  }\r\n}\r\n```\r\n\r\n上面的示例模拟请求了获取用户信息，然后加载 loading，对于错误进行提示。这种代码一天中经常会书写很多遍，但是写的次数很多，会在 data 里面充斥各种 loadingxx 以及 dataxxx 等信息，而且仔细分析代码我们写着么多 then 和 catch 都是对数据进行处理，能不能提炼出这部分关键信息呢？\r\n\r\n假设我们新建一个 useRequest，这里不讨论实现细节，只看我们要如何使用它\r\n\r\n```js\r\nfunction getUsername(): Promise<string> {\r\n  return new Promise((resolve) => {\r\n    setTimeout(() => {\r\n      resolve(Mock.mock(\"@name\"));\r\n    }, 1000);\r\n  });\r\n}\r\nconst { data, error, loading } = useRequest(getUsername);\r\n```\r\n\r\n之后如果发生错误之类的，直接在 watch 里面监听提示即可，结合 useRequest 还可以定制超时、重试、缓存等机制。\r\n\r\n在看一个实际的业务场景，对于 b 端项目经常会和表格打交道，通常布局如下：\r\n\r\n- 搜索栏，对表格的一些信息进行填写和搜索，通常来说就是一个 Input+重置和查询按钮；\r\n- table，对搜索的信息进行展示\r\n- 分页栏，对信息进行过滤展示\r\n\r\n而如果有十几个页面，就算我们封装了一些 hooks 还是会觉得有一些繁琐，这里思考一下上面的三部分我们可不可以继续封装呢？\r\n\r\n假设我有一个 useTable 的 hooks，它接受一个 form，以及一些初始的分页信息，在加上一个接口请求的函数，每次在点击查询的时候把 form 的信息传递给查询函数，在分页变化的时候也传递信息给查询函数。\r\n最后这个 hooks 返回 table 的 props 等信息，是不是就完成了上述的任务呢？\r\n\r\n继续看一段伪代码\r\n\r\n```js\r\nconst [form] = Form.useForm();\r\n\r\nconst { tableProps, submit, reset } = useAntdTable(getTableData, {\r\n  defaultPageSize: 5,\r\n  form,\r\n});\r\n// tableProps传递给table使用\r\n// submit绑定查询按钮，每次点击的时候查询\r\n// reset绑定重置按钮，调用把页面信息回到初始化\r\n```\r\n\r\n上面只是举了一些例子，但是实际开发中，我们基本上可以把很多重复的地方抽离出来进行封装，例如防抖节流、dom 元素是否出现、监听 dom 元素大小等。\r\n\r\n## 新组件\r\n\r\nVue3 中也出现了一些新的组件，算是和 React 全面对齐了，有了这些新的 Api 在日常开发中可以省略需要额外的步骤。\r\n\r\n### Teleport\r\n\r\n```html\r\n<Teleport to=\"#popup\" :disabled=\"displayVideoInline\">\r\n  <video src=\"./my-movie.mp4\">\r\n</Teleport>\r\n```\r\n\r\n看官方文档就是把 slot 元素渲染到指定的位置，那么如果自己想实现一个 message 的时候或者想实现返回顶部等功能的时候就不需要额外借助 dom 来处理之类。\r\n\r\n### Suspense\r\n\r\n```html\r\n<Suspense>\r\n  <!-- 具有深层异步依赖的组件 -->\r\n  <Dashboard />\r\n\r\n  <!-- 在 #fallback 插槽中显示 “正在加载中” -->\r\n  <template #fallback> Loading... </template>\r\n</Suspense>\r\n```\r\n\r\nSuspense 用于加载异步组件，给定一个提示，按照文档说话，以下两种情况可以考虑使用 Suspense：\r\n\r\n- 在 setup 中使用了顶层 await\r\n- setup 函数为 async\r\n\r\n不过该语法还在实验阶段，目前能想到的场景可能就是低代码平台下，远程请求组件使用 Suspense 提示用户正在加载中，请耐心等待。\r\n\r\n## template or jsx\r\n\r\n在日常写业务代码时候通常都是 template，因为这样效率足够高，且编译器会对此进行优化。不过在写组件的时候我更推荐使用 jsx，原因有下面几点：\r\n\r\n- 在写 jsx 的时候类型提示足够友好；\r\n- 习惯了 React 的 jsx，在写 jsx 有一种很舒服的感觉；\r\n- 对于一些很棘手的操作，template 需要传递 slot，但是在 jsx 中只需要包裹一下就结束了；\r\n- 逻辑很连贯，不需要考虑上下文切换了，可以看下面一个例子；\r\n\r\n```js\r\n// 1\r\nexport default {\r\n  setup() {\r\n    return () => <div>...</div>\r\n  }\r\n}\r\n//2\r\n\r\n<script setup></script>\r\n\r\n<template>\r\n  <div>...</div>\r\n</template>\r\n```\r\n\r\n## 其他\r\n\r\n在 Vue2 中经常会把功能挂载到 this 上来进行调用，不过这样的问题在于使用不够清晰。Vue3 现在可以创建多个实例，所以对应的挂载挂载操作也变成\r\n\r\n```js\r\napp.config.globalProperties.$message = message;\r\n```\r\n\r\n其次，对于经常使用的 message 也发生了一些变化，之前\r\n\r\n```js\r\nimport { createVNode, render } from 'vue'\r\n  const vnode = createVNode(\r\n    MessageConstructor,\r\n    props,\r\n    isFunction(props.message) || isVNode(props.message)\r\n      ? {\r\n          default: isFunction(props.message)\r\n            ? props.message\r\n            : () => props.message,\r\n        }\r\n      : null\r\n  )\r\n  vnode.appContext = context || message._context\r\n\r\n  render(vnode, container)\r\n  // instances will remove this item when close function gets called. So we do not need to worry about it.\r\n  appendTo.appendChild(container.firstElementChild!)\r\n\r\n  const vm = vnode.component!\r\n```\r\n\r\n如果在 Vue2 中则是这样写\r\n\r\n```js\r\nlet MessageConstructor = Vue.extend(Main);\r\ninstance = new MessageConstructor({\r\n  data: options,\r\n});\r\ninstance.$mount();\r\ndocument.body.appendChild(instance.$el);\r\n```\r\n\r\n## 最后\r\n\r\n如果文章有书写错误欢迎指出。\r\n",
          "reactions": {
            "url": "https://api.github.com/repos/bosens-China/blog/issues/79/reactions",
            "total_count": 0,
            "+1": 0,
            "-1": 0,
            "laugh": 0,
            "hooray": 0,
            "confused": 0,
            "heart": 0,
            "rocket": 0,
            "eyes": 0
          },
          "timeline_url": "https://api.github.com/repos/bosens-China/blog/issues/79/timeline",
          "performed_via_github_app": null,
          "state_reason": null
        },
        {
          "url": "https://api.github.com/repos/bosens-China/blog/issues/100",
          "repository_url": "https://api.github.com/repos/bosens-China/blog",
          "labels_url": "https://api.github.com/repos/bosens-China/blog/issues/100/labels{/name}",
          "comments_url": "https://api.github.com/repos/bosens-China/blog/issues/100/comments",
          "events_url": "https://api.github.com/repos/bosens-China/blog/issues/100/events",
          "html_url": "https://github.com/bosens-China/blog/issues/100",
          "id": 1955954444,
          "node_id": "I_kwDOCzPAy850lX8M",
          "number": 100,
          "title": "resso 源码解析",
          "user": {
            "login": "bosens-China",
            "id": 39508895,
            "node_id": "MDQ6VXNlcjM5NTA4ODk1",
            "avatar_url": "https://avatars.githubusercontent.com/u/39508895?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/bosens-China",
            "html_url": "https://github.com/bosens-China",
            "followers_url": "https://api.github.com/users/bosens-China/followers",
            "following_url": "https://api.github.com/users/bosens-China/following{/other_user}",
            "gists_url": "https://api.github.com/users/bosens-China/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/bosens-China/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/bosens-China/subscriptions",
            "organizations_url": "https://api.github.com/users/bosens-China/orgs",
            "repos_url": "https://api.github.com/users/bosens-China/repos",
            "events_url": "https://api.github.com/users/bosens-China/events{/privacy}",
            "received_events_url": "https://api.github.com/users/bosens-China/received_events",
            "type": "User",
            "site_admin": false
          },
          "labels": [
            {
              "id": 1473940161,
              "node_id": "MDU6TGFiZWwxNDczOTQwMTYx",
              "url": "https://api.github.com/repos/bosens-China/blog/labels/%E6%A1%86%E6%9E%B6%E7%9B%B8%E5%85%B3",
              "name": "框架相关",
              "color": "42b883",
              "default": false,
              "description": "目前Vue和React为主"
            }
          ],
          "state": "open",
          "locked": false,
          "assignee": null,
          "assignees": [],
          "milestone": null,
          "comments": 0,
          "created_at": "2023-10-22T15:57:10Z",
          "updated_at": "2023-10-22T15:57:25Z",
          "closed_at": null,
          "author_association": "OWNER",
          "active_lock_reason": null,
          "body": "在之前用 React 写一些小项目的时候有时也需要用到状态管理，但是用 Redux 有一种“大材小用”感觉，就在寻找有没有很精巧的实现，最好是响应式的，最后搜索了一番在 Github 发现了两个满足我需求的库：\r\n\r\n- [valtio](https://github.com/pmndrs/valtio)\r\n- [resso](https://github.com/nanxiaobei/resso)\r\n\r\n```jsx\r\n// valtio\r\nimport resso from 'resso';\r\nimport { proxy, useSnapshot } from 'valtio';\r\n\r\nconst state = proxy({ count: 0, text: 'hello' });\r\n\r\nfunction Counter() {\r\n  const snap = useSnapshot(state);\r\n  return (\r\n    <div>\r\n      {snap.count}\r\n      <button onClick={() => ++state.count}>+1</button>\r\n    </div>\r\n  );\r\n}\r\n// resso\r\nconst store = resso({ count: 0, text: 'hello' });\r\n\r\nfunction App() {\r\n  const { count } = store; // data used in UI → must destructure at top first 🥷\r\n  return (\r\n    <>\r\n      {count}\r\n      <button onClick={() => (store.count += 1)}>+</button>\r\n    </>\r\n  );\r\n}\r\n```\r\n\r\n结合官方给出的文档示例还是最终在项目用了 resso，所以就有了这篇文章，同时作者在知乎也专门写了一篇文章介绍他的思路实现[resso，世界上最简单的 React 状态管理器](https://zhuanlan.zhihu.com/p/468417292)。有兴趣小伙伴可以专门去瞅瞅。\r\n\r\n不过在阅读源码实现，需要先了解两个 API：\r\n\r\n- useSyncExternalStore\r\n- ReactDOM.unstable_batchedUpdates\r\n\r\n## useSyncExternalStore\r\n\r\n这个 API 可能你完全陌生，事实上我也是，后面专门去官方文档查阅了一下 [useSyncExternalStore](https://zh-hans.react.dev/reference/react/useSyncExternalStore)，它的作用可以简单理解为订阅外部的 store，例如我们在使用 redux 之类的时候，它可能不是通过 useState 的形式而是在外部维护了一个 store，然后结合发布订阅模式来实现数据的更新。\r\n\r\n下面用官方给出的切换离线和在线 hooks 例子快速看下这个 api\r\n\r\n```js\r\nimport { useSyncExternalStore } from 'react';\r\n\r\nfunction getSnapshot() {\r\n  return navigator.onLine;\r\n}\r\nfunction subscribe(callback) {\r\n  window.addEventListener('online', callback);\r\n  window.addEventListener('offline', callback);\r\n  return () => {\r\n    window.removeEventListener('online', callback);\r\n    window.removeEventListener('offline', callback);\r\n  };\r\n}\r\n\r\nfunction ChatIndicator() {\r\n  const isOnline = useSyncExternalStore(subscribe, getSnapshot);\r\n  // ...\r\n}\r\n```\r\n\r\n这里每次 online 或者 offline 发生变化执行回调函数，而每次执行 getSnapshot 如果返回值不同，就会让 React 重新渲染组件。\r\n\r\n> 每次对比 getSnapshot 返回值使用的是 Object.is。\r\n\r\n## unstable_batchedUpdates\r\n\r\n之所以介绍这个 API 其实和性能优化有关，在 React18 之前对于非同步代码和不是 react 事件处理函数 setState 不会进行批处理，例如下面代码：\r\n\r\n```js\r\nimport React, { useEffect, useState } from 'react';\r\n\r\nconst App: React.FC = () => {\r\n  console.log('App组件渲染了！');\r\n  const [count1, setCount1] = useState(0);\r\n  const [count2, setCount2] = useState(0);\r\n  useEffect(() => {\r\n    document.body.addEventListener('click', () => {\r\n      setCount1((count) => count + 1);\r\n      setCount2((count) => count + 1);\r\n    });\r\n    // 在原生js事件中不会进行批处理\r\n  }, []);\r\n  return (\r\n    <>\r\n      <div>count1： {count1}</div>\r\n      <div>count2： {count2}</div>\r\n    </>\r\n  );\r\n};\r\n\r\nexport default App;\r\n```\r\n\r\n这里每次点击组件都会渲染两次，共计输出六次 console.log 信息。\r\n\r\n但是有什么办法可以改变呢？下面用 ReactDOM.unstable_batchedUpdates 重写上面这个例子\r\n\r\n```js\r\nimport React, { useEffect, useState } from 'react';\r\n\r\nconst App: React.FC = () => {\r\n  console.log('App组件渲染了！');\r\n  const [count1, setCount1] = useState(0);\r\n  const [count2, setCount2] = useState(0);\r\n  useEffect(() => {\r\n    document.body.addEventListener('click', () => {\r\n      ReactDOM.unstable_batchedUpdates(() => {\r\n        setCount1((count) => count + 1);\r\n        setCount2((count) => count + 1);\r\n      });\r\n    });\r\n  }, []);\r\n  return (\r\n    <>\r\n      <div>count1： {count1}</div>\r\n      <div>count2： {count2}</div>\r\n    </>\r\n  );\r\n};\r\n\r\nexport default App;\r\n```\r\n\r\n这样就会每次更新状态组件只渲染一次了，最后提示一下 **unstable_batchedUpdates 是同步代码**。\r\n\r\n## 实现思想\r\n\r\n在代码阅读之前有必要说下它的设计实现思想是啥子。\r\n\r\n在使用 redux 的时候，我们更新可能是通过 `dispatch` 这样的一个函数来完成，但是有没有其他方式呢？ES6 引入了 proxy 可以对对象的值进行劫持，每次更新都可以获取到对应的 key 和 value。\r\n\r\n> 事实上在 Vue2 中也可以通过监听属性的 seter 来实现监听，虽然效果不完整。\r\n\r\n试着定义一个 store\r\n\r\n```js\r\nexport const store = { a: 123, b: 456 };\r\n```\r\n\r\n在组件中分别使用\r\n\r\n```js\r\n// 组件 A\r\nconst {a} = store;\r\n\r\n// 组件B\r\nconst {a,b} = store;\r\n```\r\n\r\n更新方式也很简单，直接更改 store 属性就行，例如：\r\n\r\n```js\r\n// 组件 A 和 B 都得到更新\r\nstore.b = 'b';\r\n```\r\n\r\n那么要怎么实现上述我们定义的这样一个使用方式呢？\r\n\r\n作者是通过 proxy 每次 get 的时候自动把对应的 key 值保存到 map 键名，而对应的 setState 作为 value，例如在组件 A 和 B 它们可能是这样储存的。\r\n\r\n```js\r\n// 组件 A\r\nconst [a, setA] = useState(store.a);\r\n// 组件 B\r\nconst [a, setA] = useState(store.a);\r\nconst [b, setB] = useState(store.b);\r\n// map\r\nconst listenerMap = {\r\n  a: [setA, setA],\r\n  b: [setB],\r\n};\r\n\r\n```\r\n\r\n之后监听修改的属性，如果有更新直接调用对应 key 下的 setState 就可以做到更新。\r\n``` js\r\n// 假设更新 A\r\nlistenerMap.a.forEach((setA) => setA(store.a));\r\n```\r\n\r\n## 源码分析\r\n\r\n作者是通过 TypeScript 来实现的，但是这里关注具体的实现，对于类型直接删除了，如果有需要小伙伴可以自行去阅读。\r\n\r\n因为代码量不是很大，所以这里直接通过贴代码+注释的形式来进行讲解。\r\n\r\n```js\r\n// 这里因为是状态库，需要考虑不同的 React 版本，React18 可以直接 import React 来获取 useSyncExternalStore\r\nimport { useSyncExternalStore } from 'use-sync-external-store/shim';\r\n\r\n// 判断是否为开发环境\r\nconst __DEV__ = process.env.NODE_ENV !== 'production';\r\n\r\n// 判断是否为对象， {} 这样的，通用的 map、set 之类的对象都统统不可以\r\nconst isObj = (val) => {\r\n  return Object.prototype.toString.call(val) === '[object Object]';\r\n};\r\n\r\n// 这里是一个标识符后面讲解\r\nlet isGetStateInMethod = false;\r\n\r\nlet run = (fn) => {\r\n  fn();\r\n};\r\n\r\nconst resso = (obj) => {\r\n  // 初始检查\r\n  if (__DEV__ && !isObj(obj)) {\r\n    throw new Error('object required');\r\n  }\r\n\r\n  /*\r\n   * 它储存的形式为 {[key:string]: Set()}\r\n   */\r\n  const state = {};\r\n  /*\r\n   * 它储存的形式为 {key: Function}\r\n   */\r\n  const methods = {};\r\n\r\n  Object.keys(obj).forEach((key) => {\r\n    const initVal = obj[key];\r\n    // 给 methods 添加属性\r\n    if (initVal instanceof Function) {\r\n      methods[key] = (...args) => {\r\n        isGetStateInMethod = true;\r\n        const res = initVal(...args);\r\n        isGetStateInMethod = false;\r\n        return res;\r\n      };\r\n      return;\r\n    }\r\n    // 给 state 添加属性\r\n    const listeners = new Set();\r\n\r\n    state[key] = {\r\n      // 添加 getSnapshot 到 listeners\r\n      subscribe: (listener) => {\r\n        listeners.add(listener);\r\n        return () => listeners.delete(listener);\r\n      },\r\n      // 数据快照\r\n      getSnapshot: () => obj[key],\r\n      // 更新方法\r\n      setSnapshot: (val) => {\r\n        if (val !== obj[key]) {\r\n          obj[key] = val;\r\n          run(() => listeners.forEach((listener) => listener()));\r\n        }\r\n      },\r\n      useSnapshot: () => {\r\n        return useSyncExternalStore(\r\n          state[key].subscribe,\r\n          state[key].getSnapshot,\r\n          state[key].getSnapshot\r\n        );\r\n      },\r\n    };\r\n  });\r\n\r\n  const setState = (key, val) => {\r\n    // 只更新初始 obj 定义属性\r\n    if (key in obj) {\r\n      if (key in state) {\r\n        // 判断是属性更新还是函数调用更新\r\n        const newVal = val instanceof Function ? val(obj[key]) : val;\r\n        // 调用上文的 setSnapshot\r\n        state[key].setSnapshot(newVal);\r\n      } else if (__DEV__) {\r\n        throw new Error(`\\`${key}\\` is a method, can not update`);\r\n      }\r\n    } else if (__DEV__) {\r\n      throw new Error(`\\`${key}\\` is not initialized in store`);\r\n    }\r\n  };\r\n\r\n  return new Proxy(() => undefined, {\r\n    get: (_target, key) => {\r\n      if (key in methods) {\r\n        return methods[key];\r\n      }\r\n      // 重点讲下这段代码，首先判断是否为 state，也就是上文中初始传递的对象非函数部分\r\n      if (key in state) {\r\n        // 这里判断是否 isGetStateInMethod 主要是因为可能存在在 methods 中来引用 store 中的属性，所以如果是这种情况直接返回\r\n        if (isGetStateInMethod) {\r\n          return obj[key];\r\n        }\r\n        // 这里从外部拿到对应的值返回，如果不是在最外层使用（React 限制，不可以在回调之类的函数内使用use之类方法，这里直接返回 obj 下的值）\r\n        try {\r\n          return state[key].useSnapshot();\r\n        } catch (err) {\r\n          return obj[key];\r\n        }\r\n      }\r\n      if (__DEV__) {\r\n        if (key !== 'prototype' && key !== 'name' && key !== 'displayName') {\r\n          throw new Error(`\\`${key}\\` is not initialized in store`);\r\n        }\r\n      }\r\n    },\r\n    // 这里监听属性变动，例如这种形式调用更新 store.count = 60;\r\n    set: (_target, key, val) => {\r\n      setState(key, val);\r\n      return true;\r\n    },\r\n\r\n    /* \r\n    * apple是指函数调用，官方文档是支持下面这种形式来更新的\r\n    * store({ count: 60, text: 'world' });\r\n    * 参数分别是目标对象、目标对象的上下文对象（this）和目标对象的参数数组\r\n    * 这里之所以解构成 [firstArg, oneAction] 形式是因为，除了上面这种方式还可以\r\n      store('count', (prev) => prev + 1); \r\n      store((prev) => ({\r\n        count: prev.count + 1,\r\n        text: prev.text === 'hello' ? 'world' : 'hello',\r\n      }));\r\n    */\r\n    apply: (_target, _thisArg, [firstArg, oneAction]) => {\r\n      // store('count', (prev) => prev + 1);\r\n      if (typeof firstArg === 'string') {\r\n        setState(firstArg, oneAction);\r\n        return;\r\n      }\r\n      // store({ count: 60, text: 'world' });\r\n      if (isObj(firstArg)) {\r\n        const newObj = firstArg;\r\n        Object.keys(newObj).forEach((key) => {\r\n          setState(key, newObj[key]);\r\n        });\r\n        return;\r\n      }\r\n      //  store((prev) => ({\r\n      //   count: prev.count + 1,\r\n      //   text: prev.text === 'hello' ? 'world' : 'hello',\r\n      // }));\r\n      if (typeof firstArg === 'function') {\r\n        const newObj = firstArg(obj);\r\n        Object.keys(newObj).forEach((key) => {\r\n          setState(key, newObj[key]);\r\n        });\r\n      }\r\n    },\r\n  });\r\n};\r\n\r\n// 这里是给用户暴露配置，例如上面说的，你想要在异步代码中执行批量更新 unstable_batchedupdates\r\nresso.config = ({ batch }) => {\r\n  run = batch;\r\n};\r\n\r\nexport default resso;\r\n```\r\n\r\n## 最后\r\n\r\n这是一篇很早之前就想写的文章，一直拖到现在才完成，最后如果有理解错误或者文笔错误欢迎指出，同时有可以内推的岗位欢迎滴滴。\r\n\r\n文章参考：\r\n\r\n- [React 性能优化之 unstable_batchedupdates（batch）用法详解](https://juejin.cn/post/6860308689313693709)\r\n- [React18 新特性解读 & 完整版升级指南](https://juejin.cn/post/7094037148088664078)\r\n",
          "reactions": {
            "url": "https://api.github.com/repos/bosens-China/blog/issues/100/reactions",
            "total_count": 0,
            "+1": 0,
            "-1": 0,
            "laugh": 0,
            "hooray": 0,
            "confused": 0,
            "heart": 0,
            "rocket": 0,
            "eyes": 0
          },
          "timeline_url": "https://api.github.com/repos/bosens-China/blog/issues/100/timeline",
          "performed_via_github_app": null,
          "state_reason": null
        },
        {
          "url": "https://api.github.com/repos/bosens-China/blog/issues/96",
          "repository_url": "https://api.github.com/repos/bosens-China/blog",
          "labels_url": "https://api.github.com/repos/bosens-China/blog/issues/96/labels{/name}",
          "comments_url": "https://api.github.com/repos/bosens-China/blog/issues/96/comments",
          "events_url": "https://api.github.com/repos/bosens-China/blog/issues/96/events",
          "html_url": "https://github.com/bosens-China/blog/issues/96",
          "id": 1672296843,
          "node_id": "I_kwDOCzPAy85jrTmL",
          "number": 96,
          "title": "hook下如何书写发布订阅",
          "user": {
            "login": "bosens-China",
            "id": 39508895,
            "node_id": "MDQ6VXNlcjM5NTA4ODk1",
            "avatar_url": "https://avatars.githubusercontent.com/u/39508895?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/bosens-China",
            "html_url": "https://github.com/bosens-China",
            "followers_url": "https://api.github.com/users/bosens-China/followers",
            "following_url": "https://api.github.com/users/bosens-China/following{/other_user}",
            "gists_url": "https://api.github.com/users/bosens-China/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/bosens-China/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/bosens-China/subscriptions",
            "organizations_url": "https://api.github.com/users/bosens-China/orgs",
            "repos_url": "https://api.github.com/users/bosens-China/repos",
            "events_url": "https://api.github.com/users/bosens-China/events{/privacy}",
            "received_events_url": "https://api.github.com/users/bosens-China/received_events",
            "type": "User",
            "site_admin": false
          },
          "labels": [
            {
              "id": 1473940161,
              "node_id": "MDU6TGFiZWwxNDczOTQwMTYx",
              "url": "https://api.github.com/repos/bosens-China/blog/labels/%E6%A1%86%E6%9E%B6%E7%9B%B8%E5%85%B3",
              "name": "框架相关",
              "color": "42b883",
              "default": false,
              "description": "目前Vue和React为主"
            }
          ],
          "state": "open",
          "locked": false,
          "assignee": null,
          "assignees": [],
          "milestone": null,
          "comments": 1,
          "created_at": "2023-04-18T03:43:26Z",
          "updated_at": "2023-06-01T08:44:54Z",
          "closed_at": null,
          "author_association": "OWNER",
          "active_lock_reason": null,
          "body": "这篇文章的思路来源为 [ahooks](https://github.com/alibaba/hooks/blob/master/packages/hooks/src/useEventEmitter/index.ts)，因为 react 已经有相对应的实现了，所以这里主要介绍 vue 下如何实现一个 hook 的发布订阅。\r\n\r\n假设有一个需求，当价格发生改变的时候刷新列表，在 vue 中很自然而然想到调用 watch 观察，但是这样的调用还是有点繁琐。例如下面一段伪代码\r\n\r\n```js\r\nimport { ref, watch } from 'vue';\r\n\r\nconst isChange = ref(false);\r\nconst refreshList = () => {\r\n  // 省略\r\n  isChange.value = false;\r\n};\r\n\r\nconst onClick = () => {\r\n  isChange.value = true;\r\n};\r\n\r\nwatch(isChange, (val) => {\r\n  if (!val) {\r\n    return;\r\n  }\r\n  refreshList();\r\n});\r\n```\r\n\r\n但是仔细观察一下，其实我们只是想让变化的时候通知一下，然后调用 refreshList 即可。\r\n\r\n且我们也不希望每次都复制这样一段代码在其他组件中重复使用，基于上面的场景我们很容易想到可以写一个发布订阅的模块来实现我们需求。\r\n\r\n## EventEmitter\r\n\r\n```js\r\nclass EventEmitter {\r\n  subscriptions = new Set();\r\n\r\n  emit = (val) => {\r\n    for (const subscription of this.subscriptions) {\r\n      subscription(val);\r\n    }\r\n  };\r\n\r\n  useSubscription = (callback) => {\r\n    this.subscriptions.add(subscription);\r\n  };\r\n}\r\n```\r\n\r\n上面的发布订阅模块很简单，`useSubscription` 来订阅，`emit` 来进行通知。下面是使用形式\r\n\r\n```js\r\nconst event = new EventEmitter();\r\nconst refreshList = () => {};\r\nconst fn = (val) => {\r\n  if (val !== 'refresh') {\r\n    return;\r\n  }\r\n  refreshList();\r\n};\r\nevent.useSubscription('refresh', fn);\r\n\r\nconst onClick = () => {\r\n  event.emit('refresh');\r\n};\r\n\r\nonUnmounted(() => {\r\n  event.subscriptions.delete(fn);\r\n});\r\n```\r\n\r\n使用方式稍微简化了一下，不过也多出了 `onUnmounted`，这也谈不上方便，因为会有额外的心智负担，上面之所以单独写一个 `fn` 就是因为卸载的时候需要卸载对应的函数才行。\r\n\r\n基于简化和不想重复管理的需求，我们再重新写一版，这里我们采用 hook 的形式来书写\r\n\r\n## useEventEmitter\r\n\r\n```js\r\nclass EventEmitter {\r\n  subscriptions = new Set();\r\n\r\n  emit = (val) => {\r\n    for (const subscription of this.subscriptions) {\r\n      subscription(val);\r\n    }\r\n  };\r\n\r\n  useSubscription = (callback) => {\r\n    this.subscriptions.add(callback);\r\n    onUnmounted(() => {\r\n      this.subscriptions.delete(callback);\r\n    });\r\n  };\r\n}\r\nconst useEventEmitter = () => {\r\n  const event = new EventEmitter();\r\n\r\n  return event;\r\n};\r\n```\r\n\r\n上面的逻辑改变了一下，我们在 `useSubscription` 中调用 `onUnmounted` 来完成一个自动的卸载。\r\n\r\n之后使用方法\r\n\r\n```js\r\nconst event = useEventEmitter();\r\n\r\nconst refreshList = () => {};\r\n\r\nevent.useSubscription((val) => {\r\n  if (val !== 'refresh') {\r\n    return;\r\n  }\r\n  refreshList();\r\n});\r\n\r\nconst onClick = () => {\r\n  event.emit('refresh');\r\n};\r\n```\r\n\r\n这里就达到我们期待的一个效果了，不过还是有需要改进的地方：\r\n\r\n在使用发布订阅的场景基本上组件之间的层级会嵌套很多，例如上面每次调用 `useEventEmitter` 生成一个新的 `event` 所以通过单例简化为全局唯一的 event 即可，或者也可以借助 `provide` 和 `inject` 解决这一问题\r\n\r\n## 改进之后\r\n\r\n```js\r\nclass EventEmitter {\r\n  subscriptions = new Set();\r\n\r\n  emit = (val) => {\r\n    for (const subscription of this.subscriptions) {\r\n      subscription(val);\r\n    }\r\n  };\r\n\r\n  useSubscription = (callback) => {\r\n    this.subscriptions.add(callback);\r\n    onUnmounted(() => {\r\n      this.subscriptions.delete(callback);\r\n    });\r\n  };\r\n}\r\nconst event = new EventEmitter();\r\nconst useEventEmitter = () => {\r\n  return event;\r\n};\r\n```\r\n",
          "reactions": {
            "url": "https://api.github.com/repos/bosens-China/blog/issues/96/reactions",
            "total_count": 0,
            "+1": 0,
            "-1": 0,
            "laugh": 0,
            "hooray": 0,
            "confused": 0,
            "heart": 0,
            "rocket": 0,
            "eyes": 0
          },
          "timeline_url": "https://api.github.com/repos/bosens-China/blog/issues/96/timeline",
          "performed_via_github_app": null,
          "state_reason": null
        },
        {
          "url": "https://api.github.com/repos/bosens-China/blog/issues/74",
          "repository_url": "https://api.github.com/repos/bosens-China/blog",
          "labels_url": "https://api.github.com/repos/bosens-China/blog/issues/74/labels{/name}",
          "comments_url": "https://api.github.com/repos/bosens-China/blog/issues/74/comments",
          "events_url": "https://api.github.com/repos/bosens-China/blog/issues/74/events",
          "html_url": "https://github.com/bosens-China/blog/issues/74",
          "id": 931481508,
          "node_id": "MDU6SXNzdWU5MzE0ODE1MDg=",
          "number": 74,
          "title": "为 React 添加双向绑定 hooks",
          "user": {
            "login": "bosens-China",
            "id": 39508895,
            "node_id": "MDQ6VXNlcjM5NTA4ODk1",
            "avatar_url": "https://avatars.githubusercontent.com/u/39508895?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/bosens-China",
            "html_url": "https://github.com/bosens-China",
            "followers_url": "https://api.github.com/users/bosens-China/followers",
            "following_url": "https://api.github.com/users/bosens-China/following{/other_user}",
            "gists_url": "https://api.github.com/users/bosens-China/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/bosens-China/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/bosens-China/subscriptions",
            "organizations_url": "https://api.github.com/users/bosens-China/orgs",
            "repos_url": "https://api.github.com/users/bosens-China/repos",
            "events_url": "https://api.github.com/users/bosens-China/events{/privacy}",
            "received_events_url": "https://api.github.com/users/bosens-China/received_events",
            "type": "User",
            "site_admin": false
          },
          "labels": [
            {
              "id": 1473940161,
              "node_id": "MDU6TGFiZWwxNDczOTQwMTYx",
              "url": "https://api.github.com/repos/bosens-China/blog/labels/%E6%A1%86%E6%9E%B6%E7%9B%B8%E5%85%B3",
              "name": "框架相关",
              "color": "42b883",
              "default": false,
              "description": "目前Vue和React为主"
            }
          ],
          "state": "open",
          "locked": false,
          "assignee": null,
          "assignees": [],
          "milestone": null,
          "comments": 0,
          "created_at": "2021-06-28T11:43:52Z",
          "updated_at": "2021-12-21T10:03:06Z",
          "closed_at": null,
          "author_association": "OWNER",
          "active_lock_reason": null,
          "body": "最近换了一家新公司，用的技术栈`react`为主，所以上周紧急的看了一下`react`相关的文档，也对照文档写了几个 demo，不过在开发阶段我的体验还是蛮差的。\r\n\r\n- 生态很繁荣，但是不知道那种方案是最佳\r\n- 开发效率很繁琐（这一点待商榷）\r\n\r\n刚刚简单写了一个 todolist 的功能，不过在对 list 进行保存、修改、删除的时候，感觉很酸爽\r\n\r\n```js\r\n// ...\r\nconst list = myContent.list[props.index]!;\r\nlist.title = inp;\r\nlist.show = false;\r\nmyContent.setlist([...myContent.list]);\r\n```\r\n\r\n大量这样的代码，所以就想通过 hook + 数据劫持 来实现下面这样的功能\r\n\r\n```js\r\nimport { useModel } from './utils';\r\nconst app = () => {\r\n  // ... 省略其他代码\r\n  const [arr] = useModel([]);\r\n  arr.push(1);\r\n};\r\n```\r\n\r\n在 push 之类的操作时，自动帮我们完成`setArr([...arr])`这样的操作\r\n\r\n## 实现思路\r\n\r\n之前想借鉴`useEffect, useCallback`之类自带的 hook 来实现，不过很遗憾这个必须要显示调用`setxxx`才会触发，所以现在摆在面前的如何通过变化之后通过回调来触发 set 的操作。\r\n\r\n因为之前使用的是 vue 所以脑海中最先蹦出的就是通过`Object.defineProperty`来劫持数据\r\n\r\n> 这里补充一点，proxy 的效果更好，不过这里会有一些兼容性问题，后面我会将这些功能封装成一个库，优先使用`proxy`之后降级到`Object.defineProperty`\r\n\r\n## Object.defineProperty\r\n\r\n刷过面试题的应该对这个 api 应该不陌生，它是 vue2.x 实现数据劫持的关键，通过拦截对象的 get 和 set 属性，之后分发事件来通知视图进行更新。\r\n\r\n不过这个 api 是有一些缺点的，尤其是对数组而言\r\n\r\n- 不支持拦截`length`属性，这点很关键，会导致我们直接修改`arr.length = 0`无效，原因是内部引擎的规定不允许监听\r\n\r\n- 不支持方法监听，例如使用 push 等\r\n\r\n明确上面两点之后，我们就来动手设计这个`useModel`应该怎么写，思路借鉴 vue2.x 的写法，\r\n\r\n- 约定不能直接修改`length`，例如：`arr[100] = {}`；\r\n- 使用变异方法`push、pop、shift、unshift、splice、sort、reverse`来完成对数组的删除和其他修改；\r\n- 允许修改存在的数组下标，可以直接修改 arr[0]这样的数据；\r\n\r\n> 这里稍微提一下 vue 官方不允许修改已存在数组下标是因为存在性能考虑\r\n\r\n## 实现思路\r\n\r\n实现思路很简单，主要就是递归遍历对象的所有属性，之后将属性改用`get`和`set`的形式进行定义，在对象属性值更改的时候来调用`useState`返回的 set 方法进行数据的更新。\r\n\r\n而数组的变异方法监听，则是通过改写数组的原型链实现，例如\r\n\r\n```js\r\nconst arr = [];\r\nconst myProto = Object.create(Array.prototype);\r\nconst arrFn = arr.push;\r\nmyProto.push = (...rest) => {\r\n  consoole.log(1);\r\n  arrFn.push.apply(arr, rest);\r\n};\r\nObject.setPrototypeOf(arr, myProto);\r\n// 1\r\narr.push(1);\r\n```\r\n\r\n将这个数组的 `__propo__`指向我们自定义的原型对象上，这个原型对象上有 push、pop 等变异方法，通过调用变异方法完成对原数组的的操作和对 set 的更新\r\n\r\n![实现思路](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/db03f6a89974472f9bd617577d3b6365~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n## 具体实现\r\n\r\n代码量并不是很大，所以直接放代码了，一些关键的地方已经进行了注释\r\n\r\n```js\r\nimport { useState } from 'react';\r\nconst isObject = (obj) => {\r\n  return (typeof obj === 'object' && obj) || typeof obj === 'function';\r\n};\r\n// 直接改写成一个通用遍历，这里进行类型判断，后续的useModel则不需要进行判断了\r\nconst each = (obj, change) => {\r\n  if (!isObject(obj)) {\r\n    return;\r\n  }\r\n  const isArr = Array.isArray(obj);\r\n  const keys = isArr ? obj : Object.keys(obj);\r\n  for (let i = 0, len = keys.length; i < len; i++) {\r\n    const key = isArr ? i : keys[i];\r\n    const value = obj[key];\r\n    change(key, value);\r\n  }\r\n};\r\nexport const useModel = (obj) => {\r\n  const [model, setModel] = useState(obj);\r\n  // 更新的时候直接更新顶层对象即可，因为这是hook写法不存在class的局部替换\r\n  const setRootValue = () => {\r\n    if (Array.isArray(model)) {\r\n      setModel([...model]);\r\n      return;\r\n    }\r\n    setModel(Object.assign({...model});\r\n  };\r\n  // 定义对象的key\r\n  const defineProperty = (key, value, o) => {\r\n    Object.defineProperty(o, key, {\r\n      enumerable: true,\r\n      get() {\r\n        return value;\r\n      },\r\n      set(v) {\r\n        if (v === value || (Number.isNaN(v) && Number.isNaN(value))) {\r\n          return;\r\n        }\r\n        value = v;\r\n        setRootValue();\r\n      },\r\n    });\r\n  };\r\n  const definePropertyArray = (all) => {\r\n    const myProto = Object.create(Array.prototype);\r\n    each(['push', 'pop', 'shift', 'unshift', 'splice', 'sort', 'reverse'], (_, value) => {\r\n      const fn = all[value];\r\n      myProto[value] = (...rest) => {\r\n        fn.apply(all, rest);\r\n        setRootValue();\r\n      };\r\n    });\r\n    Object.setPrototypeOf(all, myProto);\r\n  };\r\n  const observer = (all) => {\r\n    each(all, (key, value) => {\r\n      defineProperty(key, value, all);\r\n      observer(value);\r\n    });\r\n    if (Array.isArray(all)) {\r\n      definePropertyArray(all);\r\n    }\r\n  };\r\n  observer(model);\r\n  return [model, setRootValue];\r\n};\r\n```\r\n\r\n> 注意，上面并没有在`Object.defineProperty`set 的时候继续执行深度监听，是因为 hook 在改变的时候就会重新执行这个方法，所以并不需要深度监听\r\n\r\n## 最后\r\n\r\n如果写的有什么不对的地方欢迎指出，如果对你有帮助可以点一下`start`\r\n\r\n为了方便验证效果，放一个[示例代码（可能需要翻墙）](https://codesandbox.io/s/eloquent-kilby-1cdj7?from-embed=&file=/src/App.js)\r\n",
          "reactions": {
            "url": "https://api.github.com/repos/bosens-China/blog/issues/74/reactions",
            "total_count": 0,
            "+1": 0,
            "-1": 0,
            "laugh": 0,
            "hooray": 0,
            "confused": 0,
            "heart": 0,
            "rocket": 0,
            "eyes": 0
          },
          "timeline_url": "https://api.github.com/repos/bosens-China/blog/issues/74/timeline",
          "performed_via_github_app": null,
          "state_reason": null
        },
        {
          "url": "https://api.github.com/repos/bosens-China/blog/issues/41",
          "repository_url": "https://api.github.com/repos/bosens-China/blog",
          "labels_url": "https://api.github.com/repos/bosens-China/blog/issues/41/labels{/name}",
          "comments_url": "https://api.github.com/repos/bosens-China/blog/issues/41/comments",
          "events_url": "https://api.github.com/repos/bosens-China/blog/issues/41/events",
          "html_url": "https://github.com/bosens-China/blog/issues/41",
          "id": 539716296,
          "node_id": "MDU6SXNzdWU1Mzk3MTYyOTY=",
          "number": 41,
          "title": "VuePress插件开发不完全指南",
          "user": {
            "login": "bosens-China",
            "id": 39508895,
            "node_id": "MDQ6VXNlcjM5NTA4ODk1",
            "avatar_url": "https://avatars.githubusercontent.com/u/39508895?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/bosens-China",
            "html_url": "https://github.com/bosens-China",
            "followers_url": "https://api.github.com/users/bosens-China/followers",
            "following_url": "https://api.github.com/users/bosens-China/following{/other_user}",
            "gists_url": "https://api.github.com/users/bosens-China/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/bosens-China/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/bosens-China/subscriptions",
            "organizations_url": "https://api.github.com/users/bosens-China/orgs",
            "repos_url": "https://api.github.com/users/bosens-China/repos",
            "events_url": "https://api.github.com/users/bosens-China/events{/privacy}",
            "received_events_url": "https://api.github.com/users/bosens-China/received_events",
            "type": "User",
            "site_admin": false
          },
          "labels": [
            {
              "id": 1473940161,
              "node_id": "MDU6TGFiZWwxNDczOTQwMTYx",
              "url": "https://api.github.com/repos/bosens-China/blog/labels/%E6%A1%86%E6%9E%B6%E7%9B%B8%E5%85%B3",
              "name": "框架相关",
              "color": "42b883",
              "default": false,
              "description": "目前Vue和React为主"
            }
          ],
          "state": "open",
          "locked": false,
          "assignee": null,
          "assignees": [],
          "milestone": null,
          "comments": 0,
          "created_at": "2019-12-18T14:30:58Z",
          "updated_at": "2021-12-21T09:47:25Z",
          "closed_at": null,
          "author_association": "OWNER",
          "active_lock_reason": null,
          "body": "最近用 `vuepress` 把社区的 typeScript 翻译文章打包成了一个[在线文档](https://bosens-china.github.io/Typescript-manual/dist/)，不过有一些插件社区没有或者实现的不符合自己定制需求，所以决定自定义实现一个，这篇文化以掘金`复制代码`功能为例子。\r\n先看一下开发完成的界面\r\n\r\n![1](https://user-images.githubusercontent.com/39508895/71094442-f3384500-21e5-11ea-91b5-a0de07c72903.png)\r\n\r\n\r\n先看一下官方给出的架构图\r\n![](https://user-gold-cdn.xitu.io/2019/12/18/16f195bad0aeb2f4?w=1774&h=2334&f=png&s=65238)\r\n是不是感觉有点头疼，这里记不住没有关系，我们只需要知道**插件是在 node 环境下运行**，所以我们插件的返回形式必须是`CommonJS`形式。\r\n\r\n与 vue 类似，`vuepress`也有生命周期\r\n\r\n- ready\r\n\r\n可以简单理解为初始化完成调用\r\n\r\n- updated\r\n\r\n页面更新调用\r\n\r\n- generated\r\n\r\n生产环境构建完成调用\r\n\r\n### 实现思路\r\n\r\n因为`vuepress`会将 md 文件打包成多份 html 文件，所以在每次文件地址变更的时候我们都需要知道这个变更之后更新我们的组件，根据上面的生命周期可以在`updated`实现我们的需求\r\n\r\n至于如何将复制粘贴的组件插入到指定的`code`中，我们可以在页面加载完成后，搜索所有的指定节点，之后通过`appendChild`将组件插入\r\n\r\n### 项目结构\r\n\r\n```sh\r\ncopy\r\n├─ clientRootMixin.js\r\n├─ clipboard.js\r\n├─ copy.vue\r\n└─ index.js\r\n```\r\n\r\n- index.js\r\n\r\n暴露的出口文件\r\n\r\n- copy.vue\r\n\r\n具体实现复制代码组件\r\n\r\n- clipboard.js\r\n\r\n负责实现置剪切板文本\r\n\r\n- clientRootMixin.js\r\n\r\n负责实现将组件插入到不同的页面之中\r\n\r\n### index.js\r\n\r\n上面说了我们要开发一个复制代码的插件，我们就先按照简单的做法定义三个参数\r\n\r\n- 第一个是选择器的范围\r\n- 第二个是复制代码显示的文本\r\n- 第三个则是回调函数，负责接收变更消息，实现自定义的动画效果\r\n\r\n在官方给出的例子，有两种方式使用插件\r\n\r\n```js\r\n// 例1\r\nmodule.exports = {\r\n  plugins: [\r\n    [\r\n      \"vuepress-plugin-xxx\",\r\n      {\r\n        /* options */\r\n      }\r\n    ]\r\n  ]\r\n};\r\n// 例2\r\nmodule.exports = {\r\n  plugins: {\r\n    xxx: {\r\n      /* options */\r\n    }\r\n  }\r\n};\r\n```\r\n\r\n可以看到，如果有参数的话可以这样传递，那么我们定义的插件第一步就是要处理这个参数，当然也可以不接受，如果不接受直接返回一个对象就可以了\r\n\r\n```js\r\nmodule.exports = {\r\n  // ...\r\n};\r\n```\r\n\r\n下面来定义一个简单接受`options`的函数\r\n\r\n```js\r\n// 对象式\r\n\r\nmodule.exports = {\r\n  define: {\r\n    selector: options.selector || 'div[class*=\"language-\"] pre',\r\n    copyText: options.copyText || \"复制代码\",\r\n    change: options.change\r\n  }\r\n};\r\n// 函数式:\r\nmodule.exports = (options, context) => ({\r\n  define() {\r\n    return {\r\n      selector: options.selector || 'div[class*=\"language-\"] pre',\r\n      copyText: options.copyText || \"复制代码\",\r\n      change: options.change\r\n    };\r\n  }\r\n});\r\n```\r\n\r\n注意必须返回是`CommonJS`形式，上面我们通过`define`属性来定义供我们插件内部使用的全局变量，他支持函数和对象两种形式，可以理解为 vue 的 data 属性\r\n\r\n这一步比较简单，就不做其他过多说明了，上面我们提到了需要将组件注入到所有页面中，这一步是`clientRootMixin.js`所需要负责的事情，下面就是实现它，我们需要在`index.js`引入它，一个完整的`index.js`看起来应该是这样\r\n\r\n```js\r\nconst path = require(\"path\");\r\n\r\nmodule.exports = (options = {}, ctx) => ({\r\n  define: {\r\n    // ...\r\n  },\r\n  clientRootMixin: path.resolve(__dirname, \"clientRootMixin.js\")\r\n});\r\n```\r\n\r\n### clientRootMixin.js\r\n\r\n`clientRootMixin` 可以让我们控制根文组件的生命周期，这里我们只需要监听`updated`事件，之后把`copy.vue`插入到当前页面内即可\r\n\r\n```js\r\nimport CodeCopy from \"./copy.vue\";\r\nimport Vue from \"vue\";\r\n\r\nexport default {\r\n  updated() {\r\n    // 等待dom加载完成之后执行\r\n    this.$nextTick(() => {\r\n      this.update();\r\n    });\r\n  },\r\n  methods: {\r\n    update() {\r\n      // 获取所有的dom，之后在所有的代码块上插入vue的组件\r\n      const dom = Array.from(document.querySelectorAll(selector));\r\n      dom.forEach(el => {\r\n        // 判断一下，当前节点是不是已经插入了\r\n        if (/v-copy/.test(el.className)) {\r\n          return;\r\n        }\r\n        // 创建copy组件\r\n        const C = Vue.extend(CodeCopy);\r\n        const copy = new C();\r\n        // 下面这些是组件的props以及一些私有属性\r\n        copy.copyText = copyText;\r\n        copy.code = el.textContent;\r\n        copy._parent = el;\r\n        copy.$mount();\r\n        el.className += ` v- copy`;\r\n        el.appendChild(copy.$el);\r\n      });\r\n    }\r\n  }\r\n};\r\n```\r\n\r\nOK，到这一步也完成了，下面就是怎么把代码置入剪切板了\r\n\r\n### clipboard.js\r\n\r\n- navigator.clipboard\r\n  支持异步剪贴板\r\n- document.execCommand()\r\n  兼容性比较好一些，但是只能同步剪贴板\r\n\r\n上面是两种原生的方式，不过这里因为是作为库使用，需要考虑兼容性问题，所以我选择了已经封装好的`clipboard.js`作为实现复制粘贴，下面是具体的封装方法，这一步可以跳过\r\n\r\n```js\r\nimport ClipboardJS from \"clipboard\";\r\n// 封装的剪切板事件\r\nconst btn = document.createElement(\"div\");\r\nbtn.style.display = \"none\";\r\ndocument.body.appendChild(btn);\r\n\r\nfunction setUpText(text = \"\") {\r\n  return new Promise((resolve, reject) => {\r\n    const cli = new ClipboardJS(btn, {\r\n      text() {\r\n        return text;\r\n      }\r\n    });\r\n    // 触发点击事件\\\r\n    const click = new Event(\"click\");\r\n    cli.on(\"success\", function() {\r\n      resolve(text);\r\n      // 无论成功与否都删除\r\n      cli.destroy();\r\n    });\r\n\r\n    cli.on(\"error\", function(e) {\r\n      reject(e.action);\r\n      // 无论成功与否都删除\r\n      cli.destroy();\r\n    });\r\n    btn.dispatchEvent(click);\r\n  });\r\n}\r\n\r\nexport default setUpText;\r\n```\r\n\r\nOK，到这一步基本上就完成了准备工作，下面就回归我们熟悉的 vue 组件开发了\r\n\r\n### copy.vue\r\n\r\n这一步比较简单，就是定义一些 css 属性点击按钮的时候执行`clipboard.js`就行了\r\n\r\n```vue\r\n<template>\r\n  <span>\r\n    <span ref=\"btn\" class=\"v-copy-code-btn\" @click=\"copyClick\">{{\r\n      copyText\r\n    }}</span>\r\n  </span>\r\n</template>\r\n\r\n<script>\r\nimport clipboard from \"./clipboard\";\r\nexport default {\r\n  props: {\r\n    copyText: {\r\n      type: String,\r\n      default: \"复制代码\"\r\n    },\r\n    code: String\r\n  },\r\n  methods: {\r\n    copyClick() {\r\n      clipboard(this.code);\r\n      // 执行复制具体实现省略\r\n    }\r\n  }\r\n};\r\n</script>\r\n\r\n<style>\r\n<!-- 省略 -->\r\n</style>\r\n```\r\n\r\n### 最后\r\n\r\n撒花，完成这一步之后就是将代码发布到 npm 上供大家使用，这个过程就不再描述了。\r\n\r\n最后本人目前准备找工作，有小伙伴内推一下么，不胜感激\r\n",
          "reactions": {
            "url": "https://api.github.com/repos/bosens-China/blog/issues/41/reactions",
            "total_count": 0,
            "+1": 0,
            "-1": 0,
            "laugh": 0,
            "hooray": 0,
            "confused": 0,
            "heart": 0,
            "rocket": 0,
            "eyes": 0
          },
          "timeline_url": "https://api.github.com/repos/bosens-China/blog/issues/41/timeline",
          "performed_via_github_app": null,
          "state_reason": null
        },
        {
          "url": "https://api.github.com/repos/bosens-China/blog/issues/75",
          "repository_url": "https://api.github.com/repos/bosens-China/blog",
          "labels_url": "https://api.github.com/repos/bosens-China/blog/issues/75/labels{/name}",
          "comments_url": "https://api.github.com/repos/bosens-China/blog/issues/75/comments",
          "events_url": "https://api.github.com/repos/bosens-China/blog/issues/75/events",
          "html_url": "https://github.com/bosens-China/blog/issues/75",
          "id": 975496779,
          "node_id": "MDU6SXNzdWU5NzU0OTY3Nzk=",
          "number": 75,
          "title": "怎么用 Vue Composition 造轮子",
          "user": {
            "login": "bosens-China",
            "id": 39508895,
            "node_id": "MDQ6VXNlcjM5NTA4ODk1",
            "avatar_url": "https://avatars.githubusercontent.com/u/39508895?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/bosens-China",
            "html_url": "https://github.com/bosens-China",
            "followers_url": "https://api.github.com/users/bosens-China/followers",
            "following_url": "https://api.github.com/users/bosens-China/following{/other_user}",
            "gists_url": "https://api.github.com/users/bosens-China/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/bosens-China/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/bosens-China/subscriptions",
            "organizations_url": "https://api.github.com/users/bosens-China/orgs",
            "repos_url": "https://api.github.com/users/bosens-China/repos",
            "events_url": "https://api.github.com/users/bosens-China/events{/privacy}",
            "received_events_url": "https://api.github.com/users/bosens-China/received_events",
            "type": "User",
            "site_admin": false
          },
          "labels": [
            {
              "id": 1473940161,
              "node_id": "MDU6TGFiZWwxNDczOTQwMTYx",
              "url": "https://api.github.com/repos/bosens-China/blog/labels/%E6%A1%86%E6%9E%B6%E7%9B%B8%E5%85%B3",
              "name": "框架相关",
              "color": "42b883",
              "default": false,
              "description": "目前Vue和React为主"
            }
          ],
          "state": "open",
          "locked": false,
          "assignee": null,
          "assignees": [],
          "milestone": null,
          "comments": 0,
          "created_at": "2021-08-20T10:51:18Z",
          "updated_at": "2021-08-20T10:51:18Z",
          "closed_at": null,
          "author_association": "OWNER",
          "active_lock_reason": null,
          "body": "\r\n![wallhaven-zmmwzw](https://user-images.githubusercontent.com/39508895/130222612-f8e2410a-4101-47dd-ba41-f488225cb94d.jpg)\r\n\r\n\r\n最近项目临近尾声，终于有时间来对这段工作总结。其实之前使用的一直是 Vue 但是现在公司的主要业务使用是 React 为此还特意看了许多文章，加上实际上这两个框架有很多类似的地方，所以就有了这篇文章。\r\n\r\n因为主要是分享经验所以下面的示例主要作为抛砖引玉的作用，在正式分享之前先科普两个小知识\r\n\r\n- hooks 默认以 use 为前缀，这个是 React 的官方推荐做法，约束大于配置也方便 eslint 等解析工具识别，这里也遵循这个做法；\r\n- watchEffect 与 useEffect 最大的区别就是，watchEffect 可以自动检测依赖，而 useEffect 需要你显示指定；\r\n\r\n```js\r\nconst count = ref(0);\r\nconst onClick = () => {\r\n  count.value++;\r\n};\r\nwatchEffect(() => {\r\n  console.log(`被点击`);\r\n});\r\n```\r\n\r\n例如上面这段代码，当 `onClick` 被触发的时候 watchEffect 不会重复执行，因为它内部有一个收集相关依赖的过程，只有依赖变化才会重新执行，这一点很重要，请记住。\r\n\r\n## 示例\r\n根据常见场景划分了三个类型，如果你有更好的例子欢迎补充\r\n### DOM\r\n\r\n#### 修改页面 title\r\n\r\n```js\r\nimport { ref, watchEffect } from 'vue';\r\n\r\nconst useTitle = (title) => {\r\n  const str = ref(title);\r\n  watchEffect(() => {\r\n    document.title = str.value;\r\n  });\r\n};\r\n```\r\n\r\n调用`useTitle`即可更新标题\r\n\r\n#### 监听页面大小变化\r\n\r\n```js\r\nimport { watchEffect, reactive, toRefs } from 'vue';\r\n\r\nconst useResize = () => {\r\n  const size = reactive({\r\n    width: window.innerWidth,\r\n    height: window.innerHeight,\r\n  });\r\n  const onChange = () => {\r\n    Object.assign(size, {\r\n      width: window.innerWidth,\r\n      height: window.innerHeight,\r\n    });\r\n  };\r\n  watchEffect((onInvalidate) => {\r\n    window.addEventListener('resize', onChange);\r\n    onInvalidate(() => {\r\n      window.removeEventListener('resize', onChange);\r\n    });\r\n  });\r\n  return toRefs(size);\r\n};\r\n```\r\n\r\n这里调用 `toRefs` 的原因是为了解构的情况也可以使用，例如\r\n\r\n```js\r\nconst { width } = useResize();\r\n```\r\n\r\n#### 监听网络是否断开\r\n\r\n```js\r\nimport { ref, watchEffect } from 'vue';\r\n\r\nconst useLineState = () => {\r\n  const line = ref(window.navigator.onLine);\r\n  const onLine = () => {\r\n    line.value = true;\r\n  };\r\n  const onOffline = () => {\r\n    line.value = false;\r\n  };\r\n\r\n  watchEffect((onInvalidate) => {\r\n    window.addEventListener('online', onLine);\r\n    window.addEventListener('offline', onOffline);\r\n    onInvalidate(() => {\r\n      window.removeEventListener('online', onLine);\r\n      window.removeEventListener('offline', onOffline);\r\n    });\r\n  });\r\n\r\n  return line;\r\n};\r\n```\r\n\r\n跟上面的 `useResize` 类似，监听相关事件来决定 `state` 的相关状态\r\n\r\n#### 监听 dom 元素变化\r\n\r\n```js\r\nimport { watchEffect, reactive, toRefs } from 'vue';\r\n\r\nconst isObject = (obj) => typeof obj === 'object' && obj;\r\nconst isElement = (obj) => isObject(obj) && obj.nodeType === Node.ELEMENT_NODE;\r\nconst useResizeObserver = (dom) => {\r\n  if (!isElement(dom)) {\r\n    throw new Error(`DOM is not an element!`);\r\n  }\r\n  const size = reactive(dom.getBoundingClientRect());\r\n  watchEffect((onInvalidate) => {\r\n    const resizeObserver = new ResizeObserver(() => {\r\n      Object.assign(size, dom.getBoundingClientRect());\r\n    });\r\n    onInvalidate(() => {\r\n      resizeObserver.disconnect();\r\n    });\r\n  });\r\n  return toRefs(size);\r\n};\r\n```\r\n\r\n这里监听元素使用了还在实验阶段的 `ResizeObserver` ，为了兼容性请使用 `polyfill`\r\n\r\n### 封装请求\r\n\r\najax 的请求很常见，不过在 vue2.x 中我们很容易写出下面的代码\r\n\r\n```js\r\nmounted(() => {\r\n  fn().then().catch().finally();\r\n});\r\n```\r\n\r\n这样的代码最大的问题就是不够清晰，因为变量在 `data` 中定义，而如果切换成下面这种形式，看起来就会直观许多。\r\n\r\n更多的例子还可以结合 `form` 和 `table` 进行更加深度的 hooks 封装\r\n\r\n```js\r\nconst { data, loading, error } = useRequest(() => {\r\n  //...\r\n});\r\nif (loading) {\r\n  //...\r\n}\r\nif (error) {\r\n  // ...\r\n}\r\n```\r\n\r\n```js\r\nimport { watchEffect, reactive, toRefs } from 'vue';\r\n\r\nconst useRequest = (fn, { manual } = {}) => {\r\n  const obj = reactive({\r\n    loading: false,\r\n    data: undefined,\r\n    error: undefined,\r\n  });\r\n  const run = () => {\r\n    obj.loading = true;\r\n    Promise.resolve(fn())\r\n      .then((data) => {\r\n        obj.data = data;\r\n      })\r\n      .catch((err) => {\r\n        obj.error = err;\r\n      })\r\n      .finally(() => {\r\n        obj.loading = false;\r\n      });\r\n  };\r\n  watchEffect(() => {\r\n    if (!manual) {\r\n      run();\r\n    }\r\n  });\r\n\r\n  return {\r\n    ...toRefs(obj),\r\n    run,\r\n  };\r\n};\r\n```\r\n\r\n### 模拟生命周期\r\n\r\n这里 Vue 官方的自带生命周期已经很齐全了，不过有的生命周期还是可以通过 `watchEffect` 做到模拟。\r\n\r\n例如：`mounted` 和 `beforeUnmount`，这里实现的原理主要就是利用 `watchEffect` 自动检测依赖，那如果不对响应式变量做收集的相关操作其实就是一个 `mounted`\r\n\r\n```js\r\nimport { watchEffect, nextTick } from 'vue';\r\n\r\nconst useMounted = (fn) => {\r\n  watchEffect(() => {\r\n    if (typeof fn !== 'function') {\r\n      return;\r\n    }\r\n    nextTick().then(() => {\r\n      fn();\r\n    });\r\n  });\r\n};\r\n\r\nconst useBeforeUnmount = (fn) => {\r\n  watchEffect((onInvalidate) => {\r\n    onInvalidate(() => {\r\n      if (typeof fn !== 'function') {\r\n        return;\r\n      }\r\n      fn();\r\n    });\r\n  });\r\n};\r\n```\r\n\r\n### 封装持久化\r\n\r\n在一些登录页面中很容易看到记住相关账号和密码，传统的做法就是 `login` 之后存储相关的账号和密码，然后在页面渲染的时候查看相关 `localStorage` 有没有对应的数据。\r\n\r\n这样写做大的问题还是分离，以及书写的代码量很多，下面就介绍一下如何结合 `localStorage` 做到一个支持对象的 hooks\r\n\r\n```js\r\nimport { ref, watchEffect } from 'vue';\r\nconst isObject = (obj) => typeof obj === 'object' && obj;\r\nconst useLocalStorageState = (key, defaultValue) => {\r\n  const value = ref(undefined);\r\n  try {\r\n    value.value = window.localStorage.getItem(key);\r\n    if (value.value === undefined) {\r\n      value.value = defaultValue;\r\n    }\r\n    value.value = JSON.parse(value.value);\r\n  } catch {}\r\n\r\n  watchEffect(() => {\r\n    const v = value.value;\r\n    window.localStorage.setItem(key, isObject(v) ? JSON.stringify(v) : v);\r\n  });\r\n  return value;\r\n};\r\n```\r\n\r\n```js\r\nconst name = useLocalStorageState('name', 'admin');\r\n```\r\n\r\n## 最后\r\n\r\n以上代码全部上传到了[codesandbox](https://codesandbox.io/s/nostalgic-chaum-9bwuo)，如果对你有帮助可以`star`一下\r\n\r\n## 参考文章\r\n\r\n- [精读《怎么用 React Hooks 造轮子》](https://github.com/ascoders/weekly/blob/v2/080.%E7%B2%BE%E8%AF%BB%E3%80%8A%E6%80%8E%E4%B9%88%E7%94%A8%20React%20Hooks%20%E9%80%A0%E8%BD%AE%E5%AD%90%E3%80%8B.md)\r\n",
          "reactions": {
            "url": "https://api.github.com/repos/bosens-China/blog/issues/75/reactions",
            "total_count": 0,
            "+1": 0,
            "-1": 0,
            "laugh": 0,
            "hooray": 0,
            "confused": 0,
            "heart": 0,
            "rocket": 0,
            "eyes": 0
          },
          "timeline_url": "https://api.github.com/repos/bosens-China/blog/issues/75/timeline",
          "performed_via_github_app": null,
          "state_reason": null
        }
      ]
    ],
    [
      "3661377607",
      [
        {
          "url": "https://api.github.com/repos/bosens-China/blog/issues/84",
          "repository_url": "https://api.github.com/repos/bosens-China/blog",
          "labels_url": "https://api.github.com/repos/bosens-China/blog/issues/84/labels{/name}",
          "comments_url": "https://api.github.com/repos/bosens-China/blog/issues/84/comments",
          "events_url": "https://api.github.com/repos/bosens-China/blog/issues/84/events",
          "html_url": "https://github.com/bosens-China/blog/issues/84",
          "id": 1085661897,
          "node_id": "I_kwDOCzPAy85AteLJ",
          "number": 84,
          "title": "如何编写爬虫",
          "user": {
            "login": "bosens-China",
            "id": 39508895,
            "node_id": "MDQ6VXNlcjM5NTA4ODk1",
            "avatar_url": "https://avatars.githubusercontent.com/u/39508895?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/bosens-China",
            "html_url": "https://github.com/bosens-China",
            "followers_url": "https://api.github.com/users/bosens-China/followers",
            "following_url": "https://api.github.com/users/bosens-China/following{/other_user}",
            "gists_url": "https://api.github.com/users/bosens-China/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/bosens-China/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/bosens-China/subscriptions",
            "organizations_url": "https://api.github.com/users/bosens-China/orgs",
            "repos_url": "https://api.github.com/users/bosens-China/repos",
            "events_url": "https://api.github.com/users/bosens-China/events{/privacy}",
            "received_events_url": "https://api.github.com/users/bosens-China/received_events",
            "type": "User",
            "site_admin": false
          },
          "labels": [
            {
              "id": 3661377607,
              "node_id": "LA_kwDOCzPAy87aPDBH",
              "url": "https://api.github.com/repos/bosens-China/blog/labels/Node%E7%B3%BB%E5%88%97",
              "name": "Node系列",
              "color": "9F9262",
              "default": false,
              "description": "和node.js相关内容"
            }
          ],
          "state": "open",
          "locked": false,
          "assignee": null,
          "assignees": [],
          "milestone": null,
          "comments": 0,
          "created_at": "2021-12-21T10:13:58Z",
          "updated_at": "2023-11-17T11:59:21Z",
          "closed_at": null,
          "author_association": "OWNER",
          "active_lock_reason": null,
          "body": "这是一篇鸽了许久的文章，最近失业在家重构博客的时候发现还有一些文章没有来的及写，就有了这篇文章。\r\n\r\n最终代码放到了 [codesandbox](https://codesandbox.io/p/sandbox/busy-wildflower-q43lt2?layout=%257B%2522sidebarPanel%2522%253A%2522EXPLORER%2522%252C%2522rootPanelGroup%2522%253A%257B%2522direction%2522%253A%2522horizontal%2522%252C%2522contentType%2522%253A%2522UNKNOWN%2522%252C%2522type%2522%253A%2522PANEL_GROUP%2522%252C%2522id%2522%253A%2522ROOT_LAYOUT%2522%252C%2522panels%2522%253A%255B%257B%2522type%2522%253A%2522PANEL_GROUP%2522%252C%2522contentType%2522%253A%2522UNKNOWN%2522%252C%2522direction%2522%253A%2522vertical%2522%252C%2522id%2522%253A%2522clp2k6dly0007356kqdw5bh31%2522%252C%2522sizes%2522%253A%255B70%252C30%255D%252C%2522panels%2522%253A%255B%257B%2522type%2522%253A%2522PANEL_GROUP%2522%252C%2522contentType%2522%253A%2522EDITOR%2522%252C%2522direction%2522%253A%2522horizontal%2522%252C%2522id%2522%253A%2522EDITOR%2522%252C%2522panels%2522%253A%255B%257B%2522type%2522%253A%2522PANEL%2522%252C%2522contentType%2522%253A%2522EDITOR%2522%252C%2522id%2522%253A%2522clp2k6dly0003356klqgb2kzt%2522%257D%255D%252C%2522sizes%2522%253A%255B100%255D%257D%252C%257B%2522type%2522%253A%2522PANEL_GROUP%2522%252C%2522contentType%2522%253A%2522SHELLS%2522%252C%2522direction%2522%253A%2522horizontal%2522%252C%2522id%2522%253A%2522SHELLS%2522%252C%2522panels%2522%253A%255B%257B%2522type%2522%253A%2522PANEL%2522%252C%2522contentType%2522%253A%2522SHELLS%2522%252C%2522id%2522%253A%2522clp2k6dly0005356kspa50kd2%2522%257D%255D%252C%2522sizes%2522%253A%255B100%255D%257D%255D%257D%252C%257B%2522type%2522%253A%2522PANEL_GROUP%2522%252C%2522contentType%2522%253A%2522DEVTOOLS%2522%252C%2522direction%2522%253A%2522vertical%2522%252C%2522id%2522%253A%2522DEVTOOLS%2522%252C%2522panels%2522%253A%255B%257B%2522type%2522%253A%2522PANEL%2522%252C%2522contentType%2522%253A%2522DEVTOOLS%2522%252C%2522id%2522%253A%2522clp2k6dly0006356kl2fsaioe%2522%257D%255D%252C%2522sizes%2522%253A%255B100%255D%257D%255D%252C%2522sizes%2522%253A%255B100%252C0%255D%257D%252C%2522tabbedPanels%2522%253A%257B%2522clp2k6dly0003356klqgb2kzt%2522%253A%257B%2522id%2522%253A%2522clp2k6dly0003356klqgb2kzt%2522%252C%2522activeTabId%2522%253A%2522clp2k7p3q010g356klvqy0ikb%2522%252C%2522tabs%2522%253A%255B%257B%2522id%2522%253A%2522clp2k6dly0002356k4946imr6%2522%252C%2522mode%2522%253A%2522permanent%2522%252C%2522type%2522%253A%2522FILE%2522%252C%2522filepath%2522%253A%2522%252Fpackage.json%2522%252C%2522state%2522%253A%2522IDLE%2522%257D%252C%257B%2522type%2522%253A%2522FILE%2522%252C%2522filepath%2522%253A%2522%252Ftsconfig.json%2522%252C%2522id%2522%253A%2522clp2k6zz1008e356kiq200e70%2522%252C%2522mode%2522%253A%2522permanent%2522%252C%2522state%2522%253A%2522IDLE%2522%257D%252C%257B%2522type%2522%253A%2522FILE%2522%252C%2522filepath%2522%253A%2522%252Fsrc%252Futils.ts%2522%252C%2522id%2522%253A%2522clp2k7p3q010g356klvqy0ikb%2522%252C%2522mode%2522%253A%2522permanent%2522%252C%2522state%2522%253A%2522IDLE%2522%257D%252C%257B%2522type%2522%253A%2522FILE%2522%252C%2522filepath%2522%253A%2522%252Fsrc%252Findex.ts%2522%252C%2522id%2522%253A%2522clp2k8c8m01jj356kcv37xobs%2522%252C%2522mode%2522%253A%2522permanent%2522%252C%2522state%2522%253A%2522IDLE%2522%257D%252C%257B%2522type%2522%253A%2522FILE%2522%252C%2522filepath%2522%253A%2522%252Fsrc%252Faxios.ts%2522%252C%2522id%2522%253A%2522clp2k8ox101s6356ka9fnaetk%2522%252C%2522mode%2522%253A%2522permanent%2522%252C%2522state%2522%253A%2522IDLE%2522%257D%252C%257B%2522type%2522%253A%2522FILE%2522%252C%2522filepath%2522%253A%2522%252Fsrc%252Fapi.ts%2522%252C%2522id%2522%253A%2522clp2k9ayh02d7356krmh12x58%2522%252C%2522mode%2522%253A%2522permanent%2522%257D%255D%257D%252C%2522clp2k6dly0006356kl2fsaioe%2522%253A%257B%2522tabs%2522%253A%255B%255D%252C%2522id%2522%253A%2522clp2k6dly0006356kl2fsaioe%2522%257D%252C%2522clp2k6dly0005356kspa50kd2%2522%253A%257B%2522id%2522%253A%2522clp2k6dly0005356kspa50kd2%2522%252C%2522tabs%2522%253A%255B%257B%2522id%2522%253A%2522clp2k6dly0004356k7xhf76kd%2522%252C%2522mode%2522%253A%2522permanent%2522%252C%2522type%2522%253A%2522TASK_LOG%2522%252C%2522taskId%2522%253A%2522start%2522%257D%255D%252C%2522activeTabId%2522%253A%2522clp2k6dly0004356k7xhf76kd%2522%257D%257D%252C%2522showDevtools%2522%253Afalse%252C%2522showShells%2522%253Atrue%252C%2522showSidebar%2522%253Atrue%252C%2522sidebarPanelSize%2522%253A15%257D)\r\n\r\n## 准备工作\r\n\r\n编写爬虫之前需要调查一下需要爬取的网站是什么形式来渲染的\r\n\r\n1. 如果是 spa 页面则只需要拿到账号信息，通常是 token 或者 cookie 之类的，之后直接调取接口即可；\r\n2. 如果是服务器渲染返回的，则可能需要对 dom 结构解析来获取到正确的答案。\r\n\r\n这里主要介绍场景 2，今年的时候买房就是我用爬虫 + 邮箱来定时推送，来保证获取新房的第一手信息，这里也主要结合我做的这个场景来讲解。\r\n\r\n\r\n![image-20231116161442987.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1e30d1813d6444feb361c25b697bb991~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2164&h=974&s=511265&e=png&b=ffffff)\r\n\r\n观察一下页面，可以发现思路就是把 html 结构解析，然后 forEach 子项，然后添加到数组，循环这个过程就可以。\r\n\r\n因为是 node 环境实际上是没有 dom 结构的，所以我们还需要使用特定库来完成解析，这里用的是[cheerio](https://github.com/cheeriojs/cheerio)，它提供类似 jQuery 的语法\r\n\r\n```js\r\nconst cheerio = require(\"cheerio\");\r\nconst $ = cheerio.load('<h2 class=\"title\">Hello world</h2>');\r\n\r\n$(\"h2.title\").text(\"Hello there!\");\r\n$(\"h2\").addClass(\"welcome\");\r\n\r\n$.html();\r\n//=> <html><head></head><body><h2 class=\"title welcome\">Hello there!</h2></body></html>\r\n```\r\n\r\n最后在观察一下页面 url，发现如果跳转第二页变成了 https://www.hfzfzlw.com/spf/Scheme/?p=2&xmmc=&qy=&djzt=\r\n\r\n所以这里很明显了，只需要更改 p 的内容就可以得到一个遍历的效果。\r\n\r\n## 编写\r\n\r\n网络请求库这里使用了 axios，它支持 web 和 node 环境下使用，当然也可以使用其他的请求库。\r\n\r\n```sh\r\nnpm i cheerio axios dayjs\r\n```\r\n\r\n首先需要对 axios 进行一层封装\r\n\r\n```js\r\n// axios.ts\r\nimport axios from \"axios\";\r\nexport const instance = axios.create({\r\n  headers: {\r\n    \"User-Agent\":\r\n      \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/113.0.0.0 Safari/537.36\",\r\n  },\r\n});\r\n```\r\n\r\n这里 User-Agent 字段是描述请求发起的设备信息，这里多准备一些，然后随机发送，例如可以使用 [random-useragent](https://www.npmjs.com/package/random-useragent)，在 instance.interceptors.request.use 中进行拦截，动态更改。\r\n\r\n之后定义一下所需的接口格式\r\n\r\n```ts\r\nexport interface ListProps {\r\n  id: string;\r\n  // 详情url方便后续拓展需求\r\n  url: string;\r\n  // 项目名称\r\n  entryName: string;\r\n  // 楼栋\r\n  building: string[];\r\n  // 开发商\r\n  enterpriseName: string;\r\n  // 区域\r\n  region: string;\r\n  // 开始时间 number\r\n  startTime: number;\r\n  // 结束时间，number\r\n  endTime: number;\r\n  // 总数量\r\n  total: number;\r\n  // 状态\r\n  registrationStatus: string;\r\n  // 开始时间\r\n  start: string;\r\n  // 结束时间\r\n  end: string;\r\n}\r\n```\r\n\r\n剩下就是开始编写，首先：\r\n\r\n1. 获取初始页面内容，这里要解析第一页数据，然后查找需要循环次数；\r\n2. forEach 其他页面，然后储存结果\r\n\r\n```js\r\n// api.ts\r\nimport { instance } from \"./axios\";\r\n\r\nexport const getPage = async (page = 1) => {\r\n  const { data } = await instance.get<string>(`https://www.hfzfzlw.com/spf/Scheme/?p=${page}&xmmc=&qy=&djzt=`;)\r\n  return data;\r\n};\r\n```\r\n\r\n首先定义一个接口的文件，方便后续添加其他页面的接口，之后定义 utils.ts 文件，添加解析 html 的功能。\r\n\r\n```ts\r\nimport { load } from \"cheerio\";\r\nimport dayjs from \"dayjs\";\r\n\r\nexport const BASE_URL = \"http://www.hfzfzlw.com\";\r\n\r\nexport interface ListProps {\r\n  id: string;\r\n  // 详情url方便后续拓展需求\r\n  url: string;\r\n  // 项目名称\r\n  entryName: string;\r\n  // 楼栋\r\n  building: string[];\r\n  // 开发商\r\n  enterpriseName: string;\r\n  // 区域\r\n  region: string;\r\n  // 开始时间 number\r\n  startTime: number;\r\n  // 结束时间，number\r\n  endTime: number;\r\n  // 总数量\r\n  total: number;\r\n  // 状态\r\n  registrationStatus: string;\r\n  // 开始时间\r\n  start: string;\r\n  // 结束时间\r\n  end: string;\r\n}\r\n\r\nexport const analysis = (html: string): ListProps[] => {\r\n  const $ = load(html);\r\n  const arr: ListProps[] = [];\r\n  $(\"tr:not(.table_bg)\").each((_i, el) => {\r\n    // eslint-disable-next-line @typescript-eslint/consistent-type-assertions\r\n    const obj = {} as ListProps;\r\n\r\n    $(el)\r\n      .find(\"td\")\r\n      .each((index, item) => {\r\n        const a = $(item).find(\"a\");\r\n        const value = $(item).text().trim();\r\n        switch (index) {\r\n          case 0:\r\n            obj.id = $(item).find(\"span\").text().trim();\r\n            obj.url = `${BASE_URL}${a.attr(\"href\") ?? \"\"}`;\r\n            obj.entryName = a.text().trim();\r\n            return;\r\n          case 1:\r\n            obj.building = value.split(\",\");\r\n            return;\r\n          case 2:\r\n            obj.enterpriseName = value;\r\n            return;\r\n          case 3:\r\n            obj.region = value;\r\n            return;\r\n          case 4:\r\n            // eslint-disable-next-line no-case-declarations\r\n            const [start, end] = value\r\n              .split(\"至\")\r\n              .map((f) => dayjs(f.trim()).valueOf()) as [number, number];\r\n            obj.startTime = start;\r\n            obj.endTime = end;\r\n            obj.start = dayjs(start).format(\"YYYY-MM-DD HH:mm:ss\");\r\n            obj.end = dayjs(end).format(\"YYYY-MM-DD HH:mm:ss\");\r\n            return;\r\n          case 5:\r\n            obj.total = +value;\r\n            return;\r\n          case 6:\r\n            obj.registrationStatus = value;\r\n        }\r\n      });\r\n    arr.push(obj);\r\n  });\r\n  return arr;\r\n};\r\n\r\nexport const getTotal = (html: string) => {\r\n  const $ = load(html);\r\n  return +$(\".green-black a\")\r\n    .eq(-3)\r\n    .attr(\"href\")\r\n    .match(/p=(\\d+)&/)[1];\r\n};\r\n```\r\n\r\n之后在 index.ts 编写具体的爬取逻辑\r\n\r\n```ts\r\n// index.ts\r\nimport { getPage } from \"./api\";\r\nimport { getTotal, analysis } from \"./utils\";\r\n\r\nconst App = async () => {\r\n  const html = await getPage();\r\n  const len = getTotal(html);\r\n  const tasks = await Promise.all(\r\n    Array.from({ length: len - 1 }).map((_, index) => {\r\n      return getPage(index + 2);\r\n    })\r\n  );\r\n  const result = [html, ...tasks].map((f) => {\r\n    return analysis(f);\r\n  });\r\n  return result;\r\n};\r\nApp();\r\n```\r\n\r\n## ...404\r\n\r\n上面状态下是理想情况，但是如果你真的这样运行会发现突然服务器没有响应了，然后你用其他 ip 的设备来访问，发现还是可以运行的。\r\n\r\n那么问题出在哪里呢？很大概率就是被对方网站进行了拉黑，恶意爬取网站会大量占用服务器的资源和带宽，对于有经验的后端都会考虑到这种场景，对访问频繁的 IP 进行限制，例如 IP 封锁，提示验证码等。\r\n\r\n下面就介绍一些常见绕过的方法。\r\n\r\n## 限速\r\n\r\n上面的代码我们仔细观察一下，发现其实是一下子并发很多条过去，这种场景下可能会导致触发对方的安全机制，那么换个角度来说，我们给每个任务进行限速，然后让其排队来完成是不是就可以减少被发现的概率呢。\r\n\r\n说干就干，更新一下 utils 方法\r\n\r\n```ts\r\nconst wait = (time: number) => {\r\n  return new Promise((resolve, reject) => {\r\n    setTimeout(() => {\r\n      resolve(true);\r\n    }, time);\r\n  });\r\n};\r\n\r\nexport const rateLimiting = async <T extends (...rest: any) => any>(\r\n  arr: T[],\r\n  time: number\r\n) => {\r\n  let i = 0;\r\n  const result: ReturnType<T>[] = [];\r\n  for (const iterator of arr) {\r\n    const o = await iterator();\r\n    result.push(o);\r\n    if (++i < arr.length - 1) {\r\n      await wait(time);\r\n    }\r\n  }\r\n\r\n  return result as Array<Awaited<ReturnType<T>>>;\r\n};\r\n```\r\n\r\n```ts\r\nimport { getPage } from \"./api\";\r\nimport { getTotal, analysis, rateLimiting } from \"./utils\";\r\n\r\nconst App = async () => {\r\n  const html = await getPage();\r\n  const len = getTotal(html);\r\n  const arr = Array.from({ length: len - 1 }).map((_, index) => {\r\n    return () => getPage(index + 2);\r\n  });\r\n  const tasks = await rateLimiting(arr, 3000);\r\n  const result = [html, ...tasks].map((f) => {\r\n    return () => analysis(f);\r\n  });\r\n  return result;\r\n};\r\n```\r\n\r\nok，这样就完成了限速相关的编写，当然实际场景中还需要考虑重试等机制。那么除了限速还有其他方式吗？\r\n\r\n## IP 池\r\n\r\n除了上面的方式，我们还可以维护一个 ip 来进行操作，例如我有大概 100 个代理 IP\r\n\r\n1. 维护一个队列，每次请求之后记录爬取时间和响应时间；\r\n2. 依次请求，排除掉正在爬取的代理 IP；\r\n3. 之后对照响应的时间 - 现在时间，如果大于正常人类浏览时间就继续下一次；\r\n\r\n这里推荐几个我正在使用的代理池，推荐使用 docker 的形式来进行启动\r\n\r\n```yml\r\n// docker-compose.yml\r\nversion: '2'\r\nservices:\r\n  proxy1:\r\n    image: 'jhao104/proxy_pool'\r\n    ports:\r\n      - '5010:5010'\r\n    depends_on:\r\n      - proxy_redis\r\n    environment:\r\n      DB_CONN: 'redis://@proxy_redis:6379/0'\r\n\r\n  proxy_redis:\r\n    image: 'redis'\r\n\r\n  proxy2:\r\n    image: 'boses/ipproxypool'\r\n    restart: always\r\n    privileged: true\r\n    ports:\r\n      - 8000:8000\r\n```\r\n\r\n具体如何维护代理池，然后请求重试这里就不一一写出来了，如果有兴趣可以看我写的这个项目 [Hefei-NewHouse](https://github.com/bosens-China/Hefei-NewHouse/tree/master/packages/reptile/src/utils/proxyPool)。\r\n\r\n如果为了稳定也可以考虑一些付费的IP池，对于验证码之类的措施可以接入到验证码平台，当然这个是收费的。\r\n\r\n## robots.txt\r\n\r\n在编写爬虫中，需要注意一下对方网站根目录是否存在 robots.txt 文件，这个相当于一个默认规则来告诉网络爬虫哪些页面可以被抓取，哪些不应该被抓取。这是遵循网络爬虫协议（Robots Exclusion Protocol）的标准做法。\r\n\r\n```txt\r\nUser-agent: *\r\nDisallow: /private/\r\nAllow: /public/\r\n```\r\n\r\n上述示例表示，对于所有爬虫（User-agent: \\*），不允许访问 \"/private/\" 目录下的页面，但允许访问 \"/public/\" 目录下的页面。\r\n\r\n> 虽然这个不是强制的，但是还是建议遵循这个规则，否则出现法律相关问题可能蹲局子。\r\n\r\n## 最后\r\n\r\n这里只简单介绍了一些编写爬虫的规则，对于规则 1 没有进行额外的拓展，有兴趣的小伙伴可以思考一下知乎如何写一个爬虫。\r\n\r\n最后提醒一下，在法律层面上，未经允许的爬取可能违反计算机犯罪法、数据保护法或其他相关法规，这可能导致法律责任。因此，最好在进行任何形式的爬取之前，仔细阅读目标网站的使用条款和服务协议，并确保你的行为是合法的。\r\n",
          "reactions": {
            "url": "https://api.github.com/repos/bosens-China/blog/issues/84/reactions",
            "total_count": 0,
            "+1": 0,
            "-1": 0,
            "laugh": 0,
            "hooray": 0,
            "confused": 0,
            "heart": 0,
            "rocket": 0,
            "eyes": 0
          },
          "timeline_url": "https://api.github.com/repos/bosens-China/blog/issues/84/timeline",
          "performed_via_github_app": null,
          "state_reason": null
        },
        {
          "url": "https://api.github.com/repos/bosens-China/blog/issues/99",
          "repository_url": "https://api.github.com/repos/bosens-China/blog",
          "labels_url": "https://api.github.com/repos/bosens-China/blog/issues/99/labels{/name}",
          "comments_url": "https://api.github.com/repos/bosens-China/blog/issues/99/comments",
          "events_url": "https://api.github.com/repos/bosens-China/blog/issues/99/events",
          "html_url": "https://github.com/bosens-China/blog/issues/99",
          "id": 1951726236,
          "node_id": "I_kwDOCzPAy850VPqc",
          "number": 99,
          "title": "koa洋葱结构解析",
          "user": {
            "login": "bosens-China",
            "id": 39508895,
            "node_id": "MDQ6VXNlcjM5NTA4ODk1",
            "avatar_url": "https://avatars.githubusercontent.com/u/39508895?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/bosens-China",
            "html_url": "https://github.com/bosens-China",
            "followers_url": "https://api.github.com/users/bosens-China/followers",
            "following_url": "https://api.github.com/users/bosens-China/following{/other_user}",
            "gists_url": "https://api.github.com/users/bosens-China/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/bosens-China/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/bosens-China/subscriptions",
            "organizations_url": "https://api.github.com/users/bosens-China/orgs",
            "repos_url": "https://api.github.com/users/bosens-China/repos",
            "events_url": "https://api.github.com/users/bosens-China/events{/privacy}",
            "received_events_url": "https://api.github.com/users/bosens-China/received_events",
            "type": "User",
            "site_admin": false
          },
          "labels": [
            {
              "id": 3661377607,
              "node_id": "LA_kwDOCzPAy87aPDBH",
              "url": "https://api.github.com/repos/bosens-China/blog/labels/Node%E7%B3%BB%E5%88%97",
              "name": "Node系列",
              "color": "9F9262",
              "default": false,
              "description": "和node.js相关内容"
            }
          ],
          "state": "open",
          "locked": false,
          "assignee": null,
          "assignees": [],
          "milestone": null,
          "comments": 0,
          "created_at": "2023-10-19T09:33:07Z",
          "updated_at": "2023-10-19T09:33:17Z",
          "closed_at": null,
          "author_association": "OWNER",
          "active_lock_reason": null,
          "body": "![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/dbf97f99bdf142bbb9c18449b82700e3~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1149&h=1000&s=159098&e=png&b=fefefe)\r\n\r\n经常在使用 koa 的时候，通过 `.use` 的形式来注册各种中间件，例如下面一段代码\r\n\r\n```js\r\napp.use(async (ctx, next) => {\r\n  console.log(1);\r\n  await next();\r\n  console.log(2);\r\n});\r\napp.use(async (ctx, next) => {\r\n  console.log(3);\r\n  await next();\r\n  console.log(4);\r\n});\r\n```\r\n\r\n这里会输出 1,3,4,2，下面就来翻看一下源码看看这个中间件实现的具体原理。\r\n\r\n在看具体代码之前，先温习一下，使用 koa 的最小运行代码是什么样的\r\n\r\n```js\r\nconst Koa = require(\"koa\");\r\nconst app = new Koa();\r\n\r\n// response\r\napp.use((ctx) => {\r\n  ctx.body = \"Hello Koa\";\r\n});\r\n\r\napp.listen(3000);\r\n```\r\n\r\n可以看到，最后通过 listen 方法来启动服务，那我们重点先看下 use 和 listen 做了什么事情。\r\n\r\n## [use](https://github.com/koajs/koa/blob/master/lib/application.js#L140C1-L145C4)\r\n\r\n```js\r\n  use (fn) {\r\n    if (typeof fn !== 'function') throw new TypeError('middleware must be a function!')\r\n    debug('use %s', fn._name || fn.name || '-')\r\n    this.middleware.push(fn)\r\n    return this\r\n  }\r\n```\r\n\r\n代码比较少，这里直接贴上去了，use 的主要作用就是给 middleware 添加相对应的 fn。\r\n\r\n## [listen](https://github.com/koajs/koa/blob/master/lib/application.js#L97)\r\n\r\n```js\r\n  listen (...args) {\r\n    debug('listen')\r\n    const server = http.createServer(this.callback())\r\n    return server.listen(...args)\r\n  }\r\n```\r\n\r\n这里 server 是 http 的库的方法，我们先不管，主要看一下 this.callback 做了什么事情。\r\n\r\n```js\r\n  callback () {\r\n    const fn = this.compose(this.middleware)\r\n\r\n    if (!this.listenerCount('error')) this.on('error', this.onerror)\r\n\r\n    const handleRequest = (req, res) => {\r\n      const ctx = this.createContext(req, res)\r\n      if (!this.ctxStorage) {\r\n        return this.handleRequest(ctx, fn)\r\n      }\r\n      return this.ctxStorage.run(ctx, async () => {\r\n        return await this.handleRequest(ctx, fn)\r\n      })\r\n    }\r\n\r\n    return handleRequest\r\n  }\r\n```\r\n\r\nhandleRequest 这个函数的实现如下\r\n\r\n```js\r\n  handleRequest (ctx, fnMiddleware) {\r\n    const res = ctx.res\r\n    res.statusCode = 404\r\n    const onerror = err => ctx.onerror(err)\r\n    const handleResponse = () => respond(ctx)\r\n    onFinished(res, onerror)\r\n    return fnMiddleware(ctx).then(handleResponse).catch(onerror)\r\n  }\r\n\r\n```\r\n\r\n可以看到，最终是把 this.compose 返回的 fn 进行了调用，那么由此可以知道 this.compose 就是具体中间件调度的具体实现。\r\n\r\n## compose\r\n\r\nthis.compose 可以在 constructor 中看到，默认情况下就是 [koa-compose](https://github.com/koajs/compose)，这个库也非常精简只有 50 行代码，下面会通过注释的形式来对源码进行一个说明。\r\n\r\n```js\r\n// 省略部分注释和部分代码\r\n\r\nfunction compose(middleware) {\r\n  // 判断传递是否为数组，且每个数组都必须为函数，否则抛出异常\r\n  if (!Array.isArray(middleware))\r\n    throw new TypeError(\"Middleware stack must be an array!\");\r\n  for (const fn of middleware) {\r\n    if (typeof fn !== \"function\")\r\n      throw new TypeError(\"Middleware must be composed of functions!\");\r\n  }\r\n  // 这里默认返回一个函数，handleRequest函数会调用这个返回的函数，并且传递 context\r\n  return function (context, next) {\r\n    let index = -1;\r\n    // 默认情况下执行一次 dispatch ，dispatch因为是函数声明所以会提升到做作用域顶部\r\n    return dispatch(0);\r\n    function dispatch(i) {\r\n      // 通常情况下不会遇到，但是如果执行两次就会抛出异常，例如第一次调用index为-1，i为0，第二次执行则变成index为0，i也为0则抛出错误\r\n      if (i <= index)\r\n        return Promise.reject(new Error(\"next() called multiple times\"));\r\n      index = i;\r\n      let fn = middleware[i];\r\n      // 这里从koa的实现可以看到，是没有传递next的，所以这行代码可以跳过\r\n      if (i === middleware.length) fn = next;\r\n      // 执行到最后一项的时候直接返回不再继续递归下去\r\n      if (!fn) return Promise.resolve();\r\n      try {\r\n        // 这里实现很巧妙，利用了bind的原理，bind的第一个参数为this，之后的参数为函数的预设值，最后返回一个函数\r\n        // 然后根据Promise.resolve的实现规范，如果传递的Promise.resolve是一个Promise要等待新的Promise执行完成之后决定状态\r\n        // 这里推荐看下PromiseA+规范实现\r\n        return Promise.resolve(fn(context, dispatch.bind(null, i + 1)));\r\n      } catch (err) {\r\n        return Promise.reject(err);\r\n      }\r\n    }\r\n  };\r\n}\r\n```\r\n\r\nok，这里基本上就讲完了，还是对照最初的示例来看\r\n\r\n```js\r\napp.use(async (ctx, next) => {\r\n  console.log(1);\r\n  await next();\r\n  console.log(2);\r\n});\r\napp.use(async (ctx, next) => {\r\n  console.log(3);\r\n  await next();\r\n  console.log(4);\r\n});\r\n```\r\n\r\n这里传递给 compose([fn1, fn2])，之后 i 为 0，返回\r\n\r\n```js\r\nconst fn = async (ctx, next) => {\r\n  console.log(1);\r\n  await next();\r\n  console.log(2);\r\n};\r\nreturn Promise.resolve(fn(context, dispatch.bind(null, i + 1)));\r\n```\r\n\r\n之后 i 为 1 的时候\r\n\r\n```js\r\nconst fn = async (ctx, next) => {\r\n  console.log(3);\r\n  await next();\r\n  console.log(4);\r\n};\r\nreturn Promise.resolve(fn(context, dispatch.bind(null, i + 1)));\r\n```\r\n\r\n此时 i 为 2，发现数组取不到值了，执行\r\n\r\n```js\r\nif (!fn) return Promise.resolve();\r\n```\r\n\r\n回到最最后一步，还没有解释为什么会洋葱结构这样来执行代码\r\n\r\n```js\r\napp.use(async (ctx, next) => {\r\n  console.log(1);\r\n  await next();\r\n  console.log(2);\r\n});\r\napp.use(async (ctx, next) => {\r\n  console.log(3);\r\n  await next();\r\n  console.log(4);\r\n});\r\n```\r\n\r\n这里我们知道先执行第一个函数\r\n\r\n1. 输出 console.log(1);\r\n2. 执行的过程中遇到 `await next()` 会执行 next，而从源码 `dispatch.bind(null, i + 1)` 可以知道下一项就是第二个函数\r\n3. 执行第二个函数\r\n4. 输出 console.log(3)\r\n5. 继续执行 `await next()` 从源码知道 i 为 2 的时候，返回的是 `if (!fn) return Promise.resolve();`\r\n6. 执行 conosle.log(4)，返回 Promise 状态为已完成，结果为 undefined\r\n7. 执行 console.log(2)\r\n\r\n上面可能有点绕，但是其实 koa-compose 利用了事件循环的机制，对于微任务每次执行都会放到微任务队列，等待主线程执行栈调用，而栈的特点就是先进后出，所以这也是为什么会输出 1,3,4,2 的原因了。\r\n\r\n## 最后\r\n\r\n如果文章有说的不对地方欢迎指出，最后本人正在找工作，有相关 hc 岗位欢迎滴滴。\r\n",
          "reactions": {
            "url": "https://api.github.com/repos/bosens-China/blog/issues/99/reactions",
            "total_count": 0,
            "+1": 0,
            "-1": 0,
            "laugh": 0,
            "hooray": 0,
            "confused": 0,
            "heart": 0,
            "rocket": 0,
            "eyes": 0
          },
          "timeline_url": "https://api.github.com/repos/bosens-China/blog/issues/99/timeline",
          "performed_via_github_app": null,
          "state_reason": null
        },
        {
          "url": "https://api.github.com/repos/bosens-China/blog/issues/90",
          "repository_url": "https://api.github.com/repos/bosens-China/blog",
          "labels_url": "https://api.github.com/repos/bosens-China/blog/issues/90/labels{/name}",
          "comments_url": "https://api.github.com/repos/bosens-China/blog/issues/90/comments",
          "events_url": "https://api.github.com/repos/bosens-China/blog/issues/90/events",
          "html_url": "https://github.com/bosens-China/blog/issues/90",
          "id": 1115786958,
          "node_id": "I_kwDOCzPAy85CgY7O",
          "number": 90,
          "title": "vite 源码解析之 create-vite ",
          "user": {
            "login": "bosens-China",
            "id": 39508895,
            "node_id": "MDQ6VXNlcjM5NTA4ODk1",
            "avatar_url": "https://avatars.githubusercontent.com/u/39508895?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/bosens-China",
            "html_url": "https://github.com/bosens-China",
            "followers_url": "https://api.github.com/users/bosens-China/followers",
            "following_url": "https://api.github.com/users/bosens-China/following{/other_user}",
            "gists_url": "https://api.github.com/users/bosens-China/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/bosens-China/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/bosens-China/subscriptions",
            "organizations_url": "https://api.github.com/users/bosens-China/orgs",
            "repos_url": "https://api.github.com/users/bosens-China/repos",
            "events_url": "https://api.github.com/users/bosens-China/events{/privacy}",
            "received_events_url": "https://api.github.com/users/bosens-China/received_events",
            "type": "User",
            "site_admin": false
          },
          "labels": [
            {
              "id": 3661377607,
              "node_id": "LA_kwDOCzPAy87aPDBH",
              "url": "https://api.github.com/repos/bosens-China/blog/labels/Node%E7%B3%BB%E5%88%97",
              "name": "Node系列",
              "color": "9F9262",
              "default": false,
              "description": "和node.js相关内容"
            }
          ],
          "state": "open",
          "locked": false,
          "assignee": null,
          "assignees": [],
          "milestone": null,
          "comments": 0,
          "created_at": "2022-01-27T05:20:46Z",
          "updated_at": "2022-01-27T05:20:46Z",
          "closed_at": null,
          "author_association": "OWNER",
          "active_lock_reason": null,
          "body": "\r\n![home](https://user-images.githubusercontent.com/39508895/151296625-9fdcf1c2-7cfb-40b8-8c55-4ffe42540073.png)\r\n\r\n\r\n如题这是一个系列文章不过更新起来可能很缓慢，从 [vite](https://github.com/vitejs/vite) 出来之际我就开始关注，目前 [npm](https://www.npmjs.com/package/vite) 的包下载量为 `1,589,416+`，可以看到已经非常稳定了。而且开发十分香，完全就是开箱即用，下面就来探讨一下 vite 是如何将项目创建到目录中的。\r\n\r\n## 使用方式\r\n\r\n目前比较火的管理代码形式为 monorepo，Vue3 和 vite 都采取了这种方式，打开 [packages](https://github.com/vitejs/vite/tree/main/packages) 可以很明显看到分布在 packages 下的各个包，这篇文章重点聊一聊 `create-vite`。\r\n\r\n打开 create-vite 目录可以看到下面结构\r\n\r\n![界面](https://user-images.githubusercontent.com/39508895/151296636-12bc9f7f-8483-42d2-b75b-8a95463e9a7a.png)\r\n\r\n\r\n其中以 **template-** 开头的文件为模板文件，而 \\_\\_test\\_\\_ 开头的是测试文件，`updateVersions.ts` 是更新相关 template 文件夹下的 `package.json` 文件让其与 vite 的版本号保持一致。\r\n\r\n我们重点看 index.js 文件，这个文件负责具体的创建，不过在说源码之前先看下文档的使用形式\r\n\r\n- `npm init vite@latest`\r\n- `npm init vite@latest my-vue-app --template vue`\r\n\r\n这里 init 其实是一个快捷指令，它相当于把 `create-vite` 简化成只需要 `init create-后面部分即可`，yarn 下的 create 也跟 npm init 类似。\r\n\r\n如果直接使用第一种形式，vite 会询问一系列信息，例如包的名称、模板等，而使用第二种形式则可以省略询问信息。\r\n\r\n> [vite 镜像网站](https://vitejs.bootcss.com/guide/#using-unreleased-commits)\r\n\r\n## 源码\r\n\r\nvite-create 使用了三个模块，这里提前说下它们的作用是什么\r\n\r\n### minimist\r\n\r\n[minimist](https://www.npmjs.com/package/minimist) 的作用就是将命令行输入的信息解析出来，例如上面我们使用 `npm init vite@latest my-vue-app --template vue` 它会将其解析成下面内容\r\n\r\n```js\r\n{\r\n  _: ['my-vue-app'],\r\n  template: 'vue'\r\n}\r\n```\r\n\r\n### prompts\r\n\r\n[prompts](https://www.npmjs.com/package/prompts) 则是与用户交互的一个包，它提供了 `input`、`select` 等交互方式，更多内容可以查看文档了解。\r\n\r\n### kolorist\r\n\r\n[kolorist](https://www.npmjs.com/package/kolorist) 它是一个 color 包，主要作用就是让 node 展示的文字更有趣，不再是默认的颜色。\r\n\r\n### 流程\r\n\r\nvite-create 将任务放到了 init 函数中，为了保持阅读体验这里直接在代码中进行讲解\r\n\r\n```js\r\nasync function init() {\r\n  // 获取默认输入的文件夹名称，例如 npm init vite@latest my-vue-app --template vue 这个时候 targetDir 为 my-vue-app\r\n  let targetDir = argv._[0];\r\n  // 获取是否有指定的 template\r\n  let template = argv.template || argv.t;\r\n  // 默认创建项目名称\r\n  const defaultProjectName = !targetDir ? 'vite-project' : targetDir;\r\n  // prompts 返回的一系列结果\r\n  let result = {};\r\n\r\n  /*\r\n   * prompts 如果 type 为 null 不会执行下去，并且 prompts 的 tasks 是按照顺序执行下去的\r\n   */\r\n\r\n  try {\r\n    result = await prompts(\r\n      [\r\n        // 如果没有指定 targetDir 则需要用户手动输入\r\n        {\r\n          type: targetDir ? null : 'text',\r\n          name: 'projectName',\r\n          message: reset('Project name:'),\r\n          initial: defaultProjectName,\r\n          onState: (state) =>\r\n            (targetDir = state.value.trim() || defaultProjectName),\r\n        },\r\n        // 如果目标目录存在，要求用户指定处理方式，是删除还是退出\r\n        {\r\n          type: () =>\r\n            !fs.existsSync(targetDir) || isEmpty(targetDir) ? null : 'confirm',\r\n          name: 'overwrite',\r\n          message: () =>\r\n            (targetDir === '.'\r\n              ? 'Current directory'\r\n              : `Target directory \"${targetDir}\"`) +\r\n            ` is not empty. Remove existing files and continue?`,\r\n        },\r\n        //如果上一步选择删除为 false 退出\r\n        {\r\n          type: (_, { overwrite } = {}) => {\r\n            if (overwrite === false) {\r\n              throw new Error(red('✖') + ' Operation cancelled');\r\n            }\r\n            return null;\r\n          },\r\n          name: 'overwriteChecker',\r\n        },\r\n        // 校验输入项目名称是否符合 npm 名称，如果不符合规则则不能通过\r\n        {\r\n          type: () => (isValidPackageName(targetDir) ? null : 'text'),\r\n          name: 'packageName',\r\n          message: reset('Package name:'),\r\n          initial: () => toValidPackageName(targetDir),\r\n          validate: (dir) =>\r\n            isValidPackageName(dir) || 'Invalid package.json name',\r\n        },\r\n        // 用户如果直接传递的 template 不存在模板中让其重新选择\r\n        {\r\n          type: template && TEMPLATES.includes(template) ? null : 'select',\r\n          name: 'framework',\r\n          message:\r\n            typeof template === 'string' && !TEMPLATES.includes(template)\r\n              ? reset(\r\n                  `\"${template}\" isn't a valid template. Please choose from below: `\r\n                )\r\n              : reset('Select a framework:'),\r\n          initial: 0,\r\n          choices: FRAMEWORKS.map((framework) => {\r\n            const frameworkColor = framework.color;\r\n            return {\r\n              title: frameworkColor(framework.name),\r\n              value: framework,\r\n            };\r\n          }),\r\n        },\r\n        // 选择是 js 项目还是 ts 项目\r\n        {\r\n          type: (framework) =>\r\n            framework && framework.variants ? 'select' : null,\r\n          name: 'variant',\r\n          message: reset('Select a variant:'),\r\n          // @ts-ignore\r\n          choices: (framework) =>\r\n            framework.variants.map((variant) => {\r\n              const variantColor = variant.color;\r\n              return {\r\n                title: variantColor(variant.name),\r\n                value: variant.name,\r\n              };\r\n            }),\r\n        },\r\n      ],\r\n      // 如果没有选择 crrl + c 退出\r\n      {\r\n        onCancel: () => {\r\n          throw new Error(red('✖') + ' Operation cancelled');\r\n        },\r\n      }\r\n    );\r\n  } catch (cancelled) {\r\n    console.log(cancelled.message);\r\n    return;\r\n  }\r\n\r\n  // user choice associated with prompts\r\n  const { framework, overwrite, packageName, variant } = result;\r\n\r\n  const root = path.join(cwd, targetDir);\r\n  // 上面提到了如果目录存在，则要求进行删除\r\n  if (overwrite) {\r\n    emptyDir(root);\r\n  } else if (!fs.existsSync(root)) {\r\n    // 如果不存在目录创建\r\n    fs.mkdirSync(root);\r\n  }\r\n\r\n  // determine template\r\n  template = variant || framework || template;\r\n\r\n  console.log(`\\nScaffolding project in ${root}...`);\r\n\r\n  // 当前模板文件所在路径\r\n  const templateDir = path.join(__dirname, `template-${template}`);\r\n\r\n  const write = (file, content) => {\r\n    const targetPath = renameFiles[file]\r\n      ? path.join(root, renameFiles[file])\r\n      : path.join(root, file);\r\n    if (content) {\r\n      fs.writeFileSync(targetPath, content);\r\n    } else {\r\n      copy(path.join(templateDir, file), targetPath);\r\n    }\r\n  };\r\n\r\n  /*\r\n   * 写入文件，package.json 单独处理\r\n   */\r\n  const files = fs.readdirSync(templateDir);\r\n  for (const file of files.filter((f) => f !== 'package.json')) {\r\n    write(file);\r\n  }\r\n\r\n  const pkg = require(path.join(templateDir, `package.json`));\r\n\r\n  pkg.name = packageName || targetDir;\r\n\r\n  write('package.json', JSON.stringify(pkg, null, 2));\r\n\r\n  // 这里是查看调用程序的是 yarn 还是 npm 或者 pnpm\r\n  const pkgInfo = pkgFromUserAgent(process.env.npm_config_user_agent);\r\n  const pkgManager = pkgInfo ? pkgInfo.name : 'npm';\r\n\r\n  console.log(`\\nDone. Now run:\\n`);\r\n  if (root !== cwd) {\r\n    console.log(`  cd ${path.relative(cwd, root)}`);\r\n  }\r\n  switch (pkgManager) {\r\n    case 'yarn':\r\n      console.log('  yarn');\r\n      console.log('  yarn dev');\r\n      break;\r\n    default:\r\n      console.log(`  ${pkgManager} install`);\r\n      console.log(`  ${pkgManager} run dev`);\r\n      break;\r\n  }\r\n  console.log();\r\n}\r\n```\r\n\r\n上面的流程还是很清晰的概括下来就是\r\n\r\n- 要求用户输入创建所需要的项目名称（如果用户指定跳过\r\n- 如果项目存在，则询问是否删除\r\n- 校验输入的名称是否符合 `npm.name` 的要求\r\n- 如果用户指定 template 则进行校验，指定 template 如果不存在重新要求选择\r\n- 拉取指定模板仓库，将其 copy 到目标文件夹下\r\n- 修改 package.json 文件输入\r\n- 输出完成信息，结束\r\n\r\n之前讲解 `init` 函数为了阅读省略了一些前置定义的变量，这里放出来。\r\n\r\n```js\r\nconst cwd = process.cwd();\r\n\r\nconst FRAMEWORKS = [\r\n  {\r\n    name: 'vanilla',\r\n    color: yellow,\r\n    variants: [\r\n      {\r\n        name: 'vanilla',\r\n        display: 'JavaScript',\r\n        color: yellow,\r\n      },\r\n      {\r\n        name: 'vanilla-ts',\r\n        display: 'TypeScript',\r\n        color: blue,\r\n      },\r\n    ],\r\n  },\r\n  {\r\n    name: 'vue',\r\n    color: green,\r\n    variants: [\r\n      {\r\n        name: 'vue',\r\n        display: 'JavaScript',\r\n        color: yellow,\r\n      },\r\n      {\r\n        name: 'vue-ts',\r\n        display: 'TypeScript',\r\n        color: blue,\r\n      },\r\n    ],\r\n  },\r\n  {\r\n    name: 'react',\r\n    color: cyan,\r\n    variants: [\r\n      {\r\n        name: 'react',\r\n        display: 'JavaScript',\r\n        color: yellow,\r\n      },\r\n      {\r\n        name: 'react-ts',\r\n        display: 'TypeScript',\r\n        color: blue,\r\n      },\r\n    ],\r\n  },\r\n  {\r\n    name: 'preact',\r\n    color: magenta,\r\n    variants: [\r\n      {\r\n        name: 'preact',\r\n        display: 'JavaScript',\r\n        color: yellow,\r\n      },\r\n      {\r\n        name: 'preact-ts',\r\n        display: 'TypeScript',\r\n        color: blue,\r\n      },\r\n    ],\r\n  },\r\n  {\r\n    name: 'lit',\r\n    color: lightRed,\r\n    variants: [\r\n      {\r\n        name: 'lit',\r\n        display: 'JavaScript',\r\n        color: yellow,\r\n      },\r\n      {\r\n        name: 'lit-ts',\r\n        display: 'TypeScript',\r\n        color: blue,\r\n      },\r\n    ],\r\n  },\r\n  {\r\n    name: 'svelte',\r\n    color: red,\r\n    variants: [\r\n      {\r\n        name: 'svelte',\r\n        display: 'JavaScript',\r\n        color: yellow,\r\n      },\r\n      {\r\n        name: 'svelte-ts',\r\n        display: 'TypeScript',\r\n        color: blue,\r\n      },\r\n    ],\r\n  },\r\n];\r\n\r\nconst TEMPLATES = FRAMEWORKS.map(\r\n  (f) => (f.variants && f.variants.map((v) => v.name)) || [f.name]\r\n).reduce((a, b) => a.concat(b), []);\r\n\r\nconst renameFiles = {\r\n  _gitignore: '.gitignore',\r\n};\r\n```\r\n\r\n`FRAMEWORKS` 定义了模板的信息，而 `TEMPLATES` 简单来说就是将 `TEMPLATES.name` 下的信息返回，\r\n配合 prompts 做校验和重新选择使用，它的值如下\r\n\r\n```js\r\n[\r\n  'vanilla',\r\n  'vanilla-ts',\r\n  'vue',\r\n  'vue-ts',\r\n  'react',\r\n  'react-ts',\r\n  'preact',\r\n  'preact-ts',\r\n  'lit',\r\n  'lit-ts',\r\n  'svelte',\r\n  'svelte-ts',\r\n];\r\n```\r\n\r\n`renameFiles` 则是重命名文件，将一些特殊的文件重新命名输出。\r\n\r\n当然 vite-create 也用了 `fs` 的 `path` 的一些方法，这里选取重点的几个函数讲解，剩余的几个函数可以自行去源码查看 [create-vite/index.js](https://github.com/vitejs/vite/blob/main/packages/create-vite/index.js)\r\n\r\n**emptyDir**\r\n\r\n```js\r\nfunction emptyDir(dir) {\r\n  if (!fs.existsSync(dir)) {\r\n    return;\r\n  }\r\n  for (const file of fs.readdirSync(dir)) {\r\n    const abs = path.resolve(dir, file);\r\n    // baseline is Node 12 so can't use rmSync :(\r\n    if (fs.lstatSync(abs).isDirectory()) {\r\n      emptyDir(abs);\r\n      fs.rmdirSync(abs);\r\n    } else {\r\n      fs.unlinkSync(abs);\r\n    }\r\n  }\r\n}\r\n```\r\n\r\n这个方法是删除文件夹，node 的删除文件夹必须保证文件夹内没有文件，所以需要递归一层层的删除。\r\n\r\n**isEmpty**\r\n\r\n```js\r\nfunction isEmpty(path) {\r\n  return fs.readdirSync(path).length === 0;\r\n}\r\n```\r\n\r\n这个方法比较简单，判断目标文件夹的文件数量，如果不存在表示为空。\r\n\r\n**copy**\r\n\r\n```js\r\nfunction copy(src, dest) {\r\n  const stat = fs.statSync(src);\r\n  if (stat.isDirectory()) {\r\n    copyDir(src, dest);\r\n  } else {\r\n    fs.copyFileSync(src, dest);\r\n  }\r\n}\r\n```\r\n\r\n配合 `copyDir` 方法，来完成整体 `copy` 目录的操作\r\n\r\n**copyDir**\r\n\r\n```js\r\nfunction copyDir(srcDir, destDir) {\r\n  fs.mkdirSync(destDir, { recursive: true });\r\n  for (const file of fs.readdirSync(srcDir)) {\r\n    const srcFile = path.resolve(srcDir, file);\r\n    const destFile = path.resolve(destDir, file);\r\n    copy(srcFile, destFile);\r\n  }\r\n}\r\n```\r\n\r\n将 src 目录下的内容 copy 到 dest 下，这里首先创建 destDir 目录，之后调用 copy 方法，而 `copy` 方法只会拷贝文件如果是文件夹继续调用 `copyDir`。\r\n\r\n## \\_\\_test\\_\\_\r\n\r\n上面已经把 create-vite 创建的流程讲了一遍，不过在软件开发中单元测试也是一个大头，所以这里看下 vite-create 是怎么写的单元测试。\r\n\r\n在 `cli.spec.ts` 文件中，vite 引用了两个库\r\n\r\n- [execa](https://github.com/sindresorhus/execa)：封装 `child_process` 使用起来更加方便；\r\n- [fs-extra](https://github.com/jprichardson/node-fs-extra)：封装的 fs 库，提供了更高级的用法，例如 copy、remove 等；\r\n\r\n在 jest 运行之前 cli.spce.ts 定义了一些变量\r\n\r\n```js\r\n// ..返回到 index.js,package.json 存在的这个目录\r\nconst CLI_PATH = join(__dirname, '..');\r\n// 项目名称\r\nconst projectName = 'test-app';\r\n// 生成的目录路径\r\nconst genPath = join(__dirname, projectName);\r\n\r\n/*\r\n * 封装的 run 方法，node CLI_PATH 会默认执行 CLI_PATH 下 index.js 文件\r\n */\r\nconst run = (\r\n  args: string[],\r\n  options: SyncOptions<string> = {}\r\n): ExecaSyncReturnValue<string> => {\r\n  return commandSync(`node ${CLI_PATH} ${args.join(' ')}`, options);\r\n};\r\n\r\n/*\r\n * 写入 package.json 文件，为了方便测试后续的 package.json 信息\r\n */\r\n// Helper to create a non-empty directory\r\nconst createNonEmptyDir = () => {\r\n  // Create the temporary directory\r\n  mkdirpSync(genPath);\r\n\r\n  // Create a package.json file\r\n  const pkgJson = join(genPath, 'package.json');\r\n  writeFileSync(pkgJson, '{ \"foo\": \"bar\" }');\r\n};\r\n\r\n// Vue 3 starter template\r\nconst templateFiles = readdirSync(join(CLI_PATH, 'template-vue'))\r\n  // _gitignore is renamed to .gitignore\r\n  .map((filePath) => (filePath === '_gitignore' ? '.gitignore' : filePath))\r\n  .sort();\r\n\r\n// 运行之前执行步骤，只会执行一次\r\nbeforeAll(() => remove(genPath));\r\n// 每次运行之后执行步骤\r\nafterEach(() => remove(genPath));\r\n```\r\n\r\nok，上面就把一些关键的点说了，我们来逐条分析测试用例\r\n\r\n### prompts for the project name if none supplied\r\n\r\n```js\r\ntest('prompts for the project name if none supplied', () => {\r\n  const { stdout, exitCode } = run([]);\r\n  expect(stdout).toContain('Project name:');\r\n});\r\n```\r\n\r\n[toContain](https://jestjs.io/zh-Hans/docs/expect) 作用简单来说就是匹配数组有没有当前值信息，这条 test 是为了验证如果没有输入项目名称是否出现 prompts 交互信息\r\n\r\n> 这里可以出现交互得益于使用的 execa 库，这个是它的功能之一\r\n\r\n### prompts for the framework if none supplied\r\n\r\n```js\r\ntest('prompts for the framework if none supplied', () => {\r\n  const { stdout } = run([projectName]);\r\n  expect(stdout).toContain('Select a framework:');\r\n});\r\n```\r\n\r\n按照 init 函数的分析，输入名称并且项目没有重复的，且用户也没有指定 template 就需要选择框架了，这条 jest 就是为了测试 prompts 顺序。\r\n\r\n### prompts for the framework on not supplying a value for --template\r\n\r\n```js\r\ntest('prompts for the framework on not supplying a value for --template', () => {\r\n  const { stdout } = run([projectName, '--template']);\r\n  expect(stdout).toContain('Select a framework:');\r\n});\r\n```\r\n\r\n继续测试 framework 情况。如果指定 `--template` 但是没有指定 vue、react， minimist 会将其解析成 true，当然也不符合情况。\r\n\r\n### prompts for the framework on supplying an invalid template\r\n\r\n```js\r\ntest('prompts for the framework on supplying an invalid template', () => {\r\n  const { stdout } = run([projectName, '--template', 'unknown']);\r\n  expect(stdout).toContain(\r\n    `\"unknown\" isn't a valid template. Please choose from below:`\r\n  );\r\n});\r\n```\r\n\r\n指定错误的 template 会出现错误提示，校验 init 函数的验证。\r\n\r\n### asks to overwrite non-empty target directory\r\n\r\n```js\r\ntest('asks to overwrite non-empty target directory', () => {\r\n  createNonEmptyDir();\r\n  const { stdout } = run([projectName], { cwd: __dirname });\r\n  expect(stdout).toContain(`Target directory \"${projectName}\" is not empty.`);\r\n});\r\n```\r\n\r\n测试项目目录如果存在情况，createNonEmptyDir 这个方法前面有讲到，确保目录一定存在并且写入一些 package.json 信息。\r\n\r\n### asks to overwrite non-empty current directory\r\n\r\n```js\r\ntest('asks to overwrite non-empty current directory', () => {\r\n  createNonEmptyDir();\r\n  const { stdout } = run(['.'], { cwd: genPath, input: 'test-app\\n' });\r\n  expect(stdout).toContain(`Current directory is not empty.`);\r\n});\r\n```\r\n\r\n测试输入项目名称不能为 `.`，`.` 会返回当前 `process.cwd()` 目录，按照 init 函数的流程，如果目录存在会提示是否删除，如果执行了删除就是一个重大 bug 了。\r\n\r\n### successfully scaffolds a project based on vue starter template\r\n\r\n```js\r\ntest('successfully scaffolds a project based on vue starter template', () => {\r\n  const { stdout } = run([projectName, '--template', 'vue'], {\r\n    cwd: __dirname,\r\n  });\r\n  const generatedFiles = readdirSync(genPath).sort();\r\n\r\n  // Assertions\r\n  expect(stdout).toContain(`Scaffolding project in ${genPath}`);\r\n  expect(templateFiles).toEqual(generatedFiles);\r\n});\r\n```\r\n\r\n这里测试了两条\r\n\r\n- 走完了所有流程；\r\n- 确定输出的文件信息和 templateFiles 是一样的；\r\n\r\n### works with the -t alias\r\n\r\n```js\r\ntest('works with the -t alias', () => {\r\n  const { stdout } = run([projectName, '-t', 'vue'], {\r\n    cwd: __dirname,\r\n  });\r\n  const generatedFiles = readdirSync(genPath).sort();\r\n\r\n  // Assertions\r\n  expect(stdout).toContain(`Scaffolding project in ${genPath}`);\r\n  expect(templateFiles).toEqual(generatedFiles);\r\n});\r\n```\r\n\r\n这里主要是测试简写语法是否可以识别。\r\n\r\n## 最后\r\n\r\n如果文章有错别字或者不对的地方欢迎指出。\r\n",
          "reactions": {
            "url": "https://api.github.com/repos/bosens-China/blog/issues/90/reactions",
            "total_count": 0,
            "+1": 0,
            "-1": 0,
            "laugh": 0,
            "hooray": 0,
            "confused": 0,
            "heart": 0,
            "rocket": 0,
            "eyes": 0
          },
          "timeline_url": "https://api.github.com/repos/bosens-China/blog/issues/90/timeline",
          "performed_via_github_app": null,
          "state_reason": null
        },
        {
          "url": "https://api.github.com/repos/bosens-China/blog/issues/89",
          "repository_url": "https://api.github.com/repos/bosens-China/blog",
          "labels_url": "https://api.github.com/repos/bosens-China/blog/issues/89/labels{/name}",
          "comments_url": "https://api.github.com/repos/bosens-China/blog/issues/89/comments",
          "events_url": "https://api.github.com/repos/bosens-China/blog/issues/89/events",
          "html_url": "https://github.com/bosens-China/blog/issues/89",
          "id": 1103349199,
          "node_id": "I_kwDOCzPAy85Bw8XP",
          "number": 89,
          "title": "使用 TypeScript 来编写 cli 程序",
          "user": {
            "login": "bosens-China",
            "id": 39508895,
            "node_id": "MDQ6VXNlcjM5NTA4ODk1",
            "avatar_url": "https://avatars.githubusercontent.com/u/39508895?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/bosens-China",
            "html_url": "https://github.com/bosens-China",
            "followers_url": "https://api.github.com/users/bosens-China/followers",
            "following_url": "https://api.github.com/users/bosens-China/following{/other_user}",
            "gists_url": "https://api.github.com/users/bosens-China/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/bosens-China/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/bosens-China/subscriptions",
            "organizations_url": "https://api.github.com/users/bosens-China/orgs",
            "repos_url": "https://api.github.com/users/bosens-China/repos",
            "events_url": "https://api.github.com/users/bosens-China/events{/privacy}",
            "received_events_url": "https://api.github.com/users/bosens-China/received_events",
            "type": "User",
            "site_admin": false
          },
          "labels": [
            {
              "id": 3661377607,
              "node_id": "LA_kwDOCzPAy87aPDBH",
              "url": "https://api.github.com/repos/bosens-China/blog/labels/Node%E7%B3%BB%E5%88%97",
              "name": "Node系列",
              "color": "9F9262",
              "default": false,
              "description": "和node.js相关内容"
            }
          ],
          "state": "open",
          "locked": false,
          "assignee": null,
          "assignees": [],
          "milestone": null,
          "comments": 0,
          "created_at": "2022-01-14T09:35:23Z",
          "updated_at": "2022-01-14T09:37:18Z",
          "closed_at": null,
          "author_association": "OWNER",
          "active_lock_reason": null,
          "body": "新的一年已经开始，之前在知乎刷到一篇新年展望贴 [2022 前端技术领域会有哪些新的变化？](https://www.zhihu.com/question/493891614/answer/2269197391)，里面的小伙伴回答了很多，这里稍微归纳一下回答：\r\n\r\n- Monorepo\r\n- TypeScript\r\n- ESBuild\r\n- ESM 化\r\n- pnpm\r\n- ...\r\n\r\n上面的回答中 `TypeScript` 提及的次数很多，原因很是随着项目复杂程度的日趋增加，需要对代码进行一个严格管理，且 TypeScript 对编辑器的智能提示太香了，用完之后根本没办法拒绝。且越多框架和生态都在往其迁徙，作为 er 的一份子，我们也应当进行拥抱。\r\n\r\n这里以 node cli 的开发场景进行举例，因为它的使用随处可见，例如 `vite`、`react` 或者内部自己使用的脚手架。\r\n\r\n## 如何开发命令行\r\n\r\n> 这里推荐一下阮一峰的 [Node.js 命令行程序开发教程](https://www.ruanyifeng.com/blog/2015/05/command-line-with-node.html) 文章，因为篇幅的问题，这里不过多讲解无关内容。\r\n\r\n在编写一个命令行程序之前通常会做两件事情：\r\n\r\n1. 在入口文件第一行添加 `#!/usr/bin/env node`，它的意思是告诉系统如何正确处理这个脚本；\r\n2. 在`package.json`的 bin 字段下添加脚本的名称跟路径，例如：\r\n\r\n```json\r\nbin: {\r\n    \"create\": \"xxx\"\r\n}\r\n```\r\n\r\n上面 bin 字段会在安装 package 的时候将 `bin 命令` 放置到 `node_modules` 下的 `bin 目录`。\r\n\r\n平时使用的 webpack 之所以在 `scripts` 执行的 `webpack xxx` 可以通过，就是因为查找 `bin 目录` 存在 webpack 的命令。\r\n\r\n回到主题，上面说了使用 TypeScript 的原因是因为程序的复杂程度在日趋增加，那如果我们想使用 TypeScript 来开发一个 cli 程序有正确的姿势是什么呢？\r\n\r\n直接在 TypeScript 的文件上添加 `#!/usr/bin/env node` ？\r\n\r\n```ts\r\n#!/usr/bin/env node\r\nconst obj: Obj = {};\r\n// xxx\r\n```\r\n\r\n上面的做法肯定不行，因为 node 并不认识这些语法，下面就来列举一下日常使用的方式。\r\n\r\n## tsc\r\n\r\ntsc 是安装 TypeScript 提供给我们的一个命令，它的作用就是编译 TypeScript 文件，例如\r\n\r\n```sh\r\ntsc index.ts\r\n```\r\n\r\n如果目录存在 `tsconfig.json` 文件，运行 tsc 会将所有符合的 TypeScript 文件输出到 `outDir` 目录下。\r\n\r\n不过使用 tsc 来完成构建有两点问题：\r\n\r\n- 不能清理死代码；\r\n- 输出的 `outDir`没有跟资源文件进行绑定；\r\n\r\n第一点很好理解，我们使用 rollup 等工具，在指定 input 文件的时候会进行一个依赖收集，如果没有执行到的代码就是一个死代码，不会被最终 build 出来，不过使用 tsc 很显然它是没有这个能力的。\r\n\r\n而第二点说的则是，如果 cli 工具需要完成拉取目录的操作，例如\r\n\r\n```sh\r\n- index.ts\r\n- template-modules\r\n- template-server\r\n- template-react\r\n```\r\n\r\n上面 `index.ts` 是程序入口文件，而其他的 `template 文件夹` 只是静态资源，平时使用 JavaScript 通过 `__dirname + 文件夹名称` 即可确定目录，而现在使用 tsc，它只会将 `index.ts` 输出到 `outDir` 下，假设 `outDir` 为 `'./dist'`\r\n\r\n```sh\r\n- dist\r\n-  index.ts\r\n- template-modules\r\n- template-server\r\n- template-react\r\n```\r\n\r\n如果还按照 `__dirname + 文件夹名称` 形式运行代码是获取不到 template 等文件夹的。\r\n\r\n综合来看，如果项目很简单可以使用 tsc 的形式，而如果包含 `__dirname` 语法或者静态资源的项目则需要注意路径问题。\r\n\r\n## rollup\r\n\r\nrollup 是下一代的打包器，vue 和 react 都使用此进行打包，因为它的使用很简单其次生成的代码比 webpack 更可读体积更小。\r\n\r\n使用 rollup 同样也可以完成 cli 打包，只需要在 `rollup.config.js` 进行相关的配置即可，下面以我最常用的配置为例\r\n\r\n```js\r\n/* eslint-disable @typescript-eslint/indent */\r\n\r\nimport fs from \"fs-extra\";\r\nimport { defineConfig } from \"rollup\";\r\nimport { babel } from \"@rollup/plugin-babel\";\r\nimport commonjs from \"@rollup/plugin-commonjs\";\r\nimport path from \"path\";\r\nimport json from \"@rollup/plugin-json\";\r\nimport { preserveShebangs } from \"rollup-plugin-preserve-shebangs\";\r\nimport { terser } from \"rollup-plugin-terser\";\r\nimport { nodeResolve } from \"@rollup/plugin-node-resolve\";\r\nimport { dependencies } from \"../package.json\";\r\nimport { cwd } from \"process\";\r\nimport copyPlugin from \"rollup-plugin-copy\";\r\nimport { string } from \"rollup-plugin-string\";\r\nimport config from \"./config\";\r\n\r\nimport { DEFAULT_EXTENSIONS } from \"@babel/core\";\r\n\r\nconst extensions = [...DEFAULT_EXTENSIONS, \".ts\"];\r\n\r\nconst dist = path.join(cwd(), \"dist\");\r\nfs.removeSync(dist);\r\n\r\nexport default defineConfig(\r\n  config.map((item) => {\r\n    const { name } = path.parse(item.src);\r\n    // copy文件\r\n    const copy = item.copy || [];\r\n\r\n    return defineConfig({\r\n      input: item.src,\r\n      // 禁止打包外部依赖\r\n      external: [...Object.keys(dependencies), \"@babel/runtime\"],\r\n      plugins: [\r\n        nodeResolve({ extensions, rootDir: __dirname }),\r\n        commonjs(),\r\n        json(),\r\n        babel({\r\n          babelHelpers: \"runtime\",\r\n          exclude: /exclude/,\r\n          extensions,\r\n          presets: [[\"@babel/preset-env\"], \"@babel/preset-typescript\"],\r\n          // 禁止打包重复模块\r\n          plugins: [\"@babel/plugin-transform-runtime\"],\r\n        }),\r\n        terser(),\r\n        copyPlugin({\r\n          targets: copy.map((item) => {\r\n            return { src: item, dest: dist };\r\n          }),\r\n        }),\r\n        preserveShebangs(),\r\n        // 导入非js资源\r\n        string({\r\n          include: \"**/*.{md,html}\",\r\n          exclude: [],\r\n        }),\r\n      ],\r\n      output: {\r\n        file: path.join(\r\n          dist,\r\n          item.format === \"cjs\" ? `${name}.js` : `${name}.${item.format}.js`\r\n        ),\r\n        format: item.format,\r\n        sourcemap: true,\r\n        exports: \"auto\",\r\n      },\r\n    });\r\n  })\r\n);\r\n```\r\n\r\n指定 inout 运行 rollup 即可完成打包，不过使用 rollup 打包同样也有优缺点\r\n\r\n### 优点\r\n\r\n- 可以清除无效代码；\r\n- 可以进行代码压缩；\r\n\r\n### 缺点\r\n\r\n- 书写代码需要配置，以及每次发布之前都需要 build（虽然可以 watch，但是也是占用资源；\r\n- 导入静态资源，例如上面 tsc 举例拉取静态资源的时候，需要配置插件将资源复制到 build 目录下，之后通过 `__dirname` 形式来使用\r\n\r\n## ts-node\r\n\r\n除了上面介绍的两种，还可以使用 ts-node 来完成，最开头的时候讲了开发 cli 不能直接使用 TypeScript 的原因就是 node 不识别语法，那如果可以做到运行时编译到 JavaScript 不久可以了吗？\r\n\r\n入口文件还是一个普通的 JavaScript 文件，后续的文件通过 ts-node 来解析语法运行。\r\n\r\n```js\r\n#!/usr/bin/env node\r\nrequire(\"ts-node\").register({\r\n  /* options */\r\n});\r\n// 后面可以直接加载ts文件\r\nrequire(\"./index.ts\");\r\n```\r\n\r\n> 更多选项可以参考 https://typestrong.org/ts-node/api/interfaces/RegisterOptions.html\r\n\r\n### 优点\r\n\r\n- 改动很小，跟原生 TypeScript 写法没区别；\r\n\r\n### 缺点\r\n\r\n- 不支持死代码去除；\r\n- 运行速度很慢；\r\n\r\n使用 ts-node 最致命的缺点还是加载很慢，因为是运行时解析，且还会校验 TypeScript 文件。\r\n\r\n## es-build\r\n\r\n这是基于 ts-node 思路来的变异方法，es-build 是基于 go 语言开发的打包器，它去除了运行时校验，支持并发。\r\n\r\n这里贴一张官方的对比图来进行展示，如果想了解更多内容请查看 [官方](https://esbuild.github.io/)。\r\n![image](https://user-images.githubusercontent.com/39508895/149493087-842eb40e-4a2e-4eac-9f48-a4f1cbc5a4b1.png)\r\n\r\n\r\nes-build 会将代码编译，不过这里我们需要的是直接运行，es-build 没有提供相关的方法。我们取巧一下在将入口文件 require 导入的 TypeScript 文件全部编译，之后写到TypeScript文件目录下运行，运行程序结束之后删除文件。\r\n\r\n幸运的是，不需要手动来完成这样一件事情，社区已经有相关的库 [esbuild-register](https://github.com/egoist/esbuild-register)，我们直接使用即可。\r\n\r\n```js\r\n#!/usr/bin/env node\r\nrequire(\"esbuild-register/dist/node\");\r\n// 后面可以直接加载ts文件\r\nrequire(\"./index.ts\");\r\n```\r\n\r\n当前优缺点跟 ts-node 基本相同，运行速度慢得到了改变。\r\n\r\n## 最后\r\n\r\n综合来看，如果你想享受 TypeScript 语法不想做太多的改动，es-build 的方案绝对是最佳实践，虽然不支持 rollup 等这样的生态，但是结合 eslint 的工具对代码进行检查，还是可以很大程度改善。\r\n\r\n如果文章有什么错别字或者讲解不对地方欢迎指出，如果对你有帮助可以 `star` 支持一下。\r\n",
          "reactions": {
            "url": "https://api.github.com/repos/bosens-China/blog/issues/89/reactions",
            "total_count": 0,
            "+1": 0,
            "-1": 0,
            "laugh": 0,
            "hooray": 0,
            "confused": 0,
            "heart": 0,
            "rocket": 0,
            "eyes": 0
          },
          "timeline_url": "https://api.github.com/repos/bosens-China/blog/issues/89/timeline",
          "performed_via_github_app": null,
          "state_reason": null
        }
      ]
    ],
    [
      "1908144759",
      [
        {
          "url": "https://api.github.com/repos/bosens-China/blog/issues/98",
          "repository_url": "https://api.github.com/repos/bosens-China/blog",
          "labels_url": "https://api.github.com/repos/bosens-China/blog/issues/98/labels{/name}",
          "comments_url": "https://api.github.com/repos/bosens-China/blog/issues/98/comments",
          "events_url": "https://api.github.com/repos/bosens-China/blog/issues/98/events",
          "html_url": "https://github.com/bosens-China/blog/issues/98",
          "id": 1849714138,
          "node_id": "I_kwDOCzPAy85uQGXa",
          "number": 98,
          "title": "[javaScript]ES2023 引入非破坏性方法",
          "user": {
            "login": "bosens-China",
            "id": 39508895,
            "node_id": "MDQ6VXNlcjM5NTA4ODk1",
            "avatar_url": "https://avatars.githubusercontent.com/u/39508895?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/bosens-China",
            "html_url": "https://github.com/bosens-China",
            "followers_url": "https://api.github.com/users/bosens-China/followers",
            "following_url": "https://api.github.com/users/bosens-China/following{/other_user}",
            "gists_url": "https://api.github.com/users/bosens-China/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/bosens-China/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/bosens-China/subscriptions",
            "organizations_url": "https://api.github.com/users/bosens-China/orgs",
            "repos_url": "https://api.github.com/users/bosens-China/repos",
            "events_url": "https://api.github.com/users/bosens-China/events{/privacy}",
            "received_events_url": "https://api.github.com/users/bosens-China/received_events",
            "type": "User",
            "site_admin": false
          },
          "labels": [
            {
              "id": 1908144759,
              "node_id": "MDU6TGFiZWwxOTA4MTQ0NzU5",
              "url": "https://api.github.com/repos/bosens-China/blog/labels/ES6%E7%B3%BB%E5%88%97",
              "name": "ES6系列",
              "color": "0366d6",
              "default": false,
              "description": "ES6的最新语法"
            }
          ],
          "state": "open",
          "locked": false,
          "assignee": null,
          "assignees": [],
          "milestone": null,
          "comments": 0,
          "created_at": "2023-08-14T12:49:24Z",
          "updated_at": "2023-08-14T12:51:32Z",
          "closed_at": null,
          "author_association": "OWNER",
          "active_lock_reason": null,
          "body": "对于 Array 的一些操作，例如 reverse、sort 等都会改变原数组，ES2023 对以下这些方法进行了拓展，提供了相同功能但是返回新副本的方法。\r\n\r\n- toReversed\r\n- toSorted\r\n- toSpliced\r\n- with\r\n\r\n下面进行一个详细的介绍。\r\n\r\n## toReversed\r\n\r\n- reverse：反转数组元素，但是会改变数组本身\r\n- toReversed：跟 reverse 功能相同，但是返回新副本不会改变数组本身\r\n\r\n示例 1.js\r\n\r\n```\r\n// reverse\r\nconst a = [1, 2, 3];\r\nconst b = a.reverse();\r\n\r\nconsole.log(a); // [3, 2, 1]\r\nconsole.log(b); // [3, 2, 1]\r\n\r\n// toReversed 👍\r\nconst c = [1, 2, 3];\r\nconst d = c.toReversed();\r\n\r\nconsole.log(c); // [1, 2, 3]\r\nconsole.log(d); // [3, 2, 1]\r\n```\r\n\r\n## toSorted\r\n\r\n- sort：对数组进行排序，但是会改变数组本身\r\n- toSorted：跟 sort 方法一样，但是返回新副本\r\n\r\n示例 2.js\r\n\r\n```\r\n// sort\r\nconst a = [3, 1, 2];\r\nconst b = a.sort();\r\n\r\nconsole.log(a); // [1, 2, 3]\r\nconsole.log(b); // [1, 2, 3]\r\n\r\n// toSorted 👍\r\nconst c = [3, 1, 2];\r\nconst d = c.toSorted();\r\n\r\nconsole.log(c); // [3, 1, 2]\r\nconsole.log(d); // [1, 2, 3]\r\n```\r\n\r\n## toSpliced\r\n\r\n- splice：非常万能的方法可以对数组进行删除、替换数元素以及添加新元素\r\n- toSpliced：跟 splice 一样，但是操作不会对原数组进行改变\r\n\r\n不过，由于 splice 和 toSpliced 的返回值存在以下差异，因此处理它们时似乎需要小心。\r\n\r\n- splice 的返回值被删除值的数组\r\n- toSpliced 的返回值返回从数组中删除元素的副本\r\n\r\n示例 3.js\r\n\r\n```\r\n// splice\r\nconst a = [1, 2, 3, 4];\r\nconst b = a.splice(1,2);\r\n\r\nconsole.log(a); // [1,4]\r\nconsole.log(b); // [2,3]　返回值是删除的值排列的值\r\n\r\n// toSpliced 👍\r\nconst c = [1, 2, 3, 4];\r\nconst d = c.toSpliced(1,2);\r\n\r\nconsole.log(c); // [1,2,3,4]\r\nconsole.log(d); // [1,4]　返回从数组中删除元素的副本\r\n```\r\n\r\n## with\r\n\r\n在第一个参数中指定数组的索引号，并将该元素替换为第二个参数的值。\r\n\r\nJS 已经有一个单独的 [with](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/with)\r\n语句，但它已被弃用，所以它很混乱，因为它与这次添加的数组操作的 with 方法重叠。\r\n\r\n示例 4.js\r\n\r\n```\r\n// with 👍\r\nconst c = [1, 2, 3, 4];\r\nconst d = c.with(1,'👍');\r\n\r\nconsole.log(c); // [1, 2, 3, 4]\r\nconsole.log(d); // [1, '👍', 3, 4]\r\n```\r\n\r\n## 最后\r\n\r\n这些方法的出现，使得你不需要每次都浅复制，代码看起来很清爽。\r\n",
          "reactions": {
            "url": "https://api.github.com/repos/bosens-China/blog/issues/98/reactions",
            "total_count": 0,
            "+1": 0,
            "-1": 0,
            "laugh": 0,
            "hooray": 0,
            "confused": 0,
            "heart": 0,
            "rocket": 0,
            "eyes": 0
          },
          "timeline_url": "https://api.github.com/repos/bosens-China/blog/issues/98/timeline",
          "performed_via_github_app": null,
          "state_reason": null
        },
        {
          "url": "https://api.github.com/repos/bosens-China/blog/issues/82",
          "repository_url": "https://api.github.com/repos/bosens-China/blog",
          "labels_url": "https://api.github.com/repos/bosens-China/blog/issues/82/labels{/name}",
          "comments_url": "https://api.github.com/repos/bosens-China/blog/issues/82/comments",
          "events_url": "https://api.github.com/repos/bosens-China/blog/issues/82/events",
          "html_url": "https://github.com/bosens-China/blog/issues/82",
          "id": 1085661350,
          "node_id": "I_kwDOCzPAy85AteCm",
          "number": 82,
          "title": "Babel to Class之私有属性（3）",
          "user": {
            "login": "bosens-China",
            "id": 39508895,
            "node_id": "MDQ6VXNlcjM5NTA4ODk1",
            "avatar_url": "https://avatars.githubusercontent.com/u/39508895?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/bosens-China",
            "html_url": "https://github.com/bosens-China",
            "followers_url": "https://api.github.com/users/bosens-China/followers",
            "following_url": "https://api.github.com/users/bosens-China/following{/other_user}",
            "gists_url": "https://api.github.com/users/bosens-China/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/bosens-China/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/bosens-China/subscriptions",
            "organizations_url": "https://api.github.com/users/bosens-China/orgs",
            "repos_url": "https://api.github.com/users/bosens-China/repos",
            "events_url": "https://api.github.com/users/bosens-China/events{/privacy}",
            "received_events_url": "https://api.github.com/users/bosens-China/received_events",
            "type": "User",
            "site_admin": false
          },
          "labels": [
            {
              "id": 1908144759,
              "node_id": "MDU6TGFiZWwxOTA4MTQ0NzU5",
              "url": "https://api.github.com/repos/bosens-China/blog/labels/ES6%E7%B3%BB%E5%88%97",
              "name": "ES6系列",
              "color": "0366d6",
              "default": false,
              "description": "ES6的最新语法"
            }
          ],
          "state": "open",
          "locked": false,
          "assignee": null,
          "assignees": [],
          "milestone": null,
          "comments": 0,
          "created_at": "2021-12-21T10:13:22Z",
          "updated_at": "2021-12-28T09:51:19Z",
          "closed_at": null,
          "author_association": "OWNER",
          "active_lock_reason": null,
          "body": "## 前言\r\n\r\n这是《Babel to Class》系列的第三篇\r\n\r\n- [Babel to Class之编译（1）](https://github.com/bosens-China/blog/issues/80)\r\n- [Babel to Class 做了什么（2）](https://github.com/bosens-China/blog/issues/81)\r\n- [Babel to Class之原生构造函数继承（4）](https://github.com/bosens-China/blog/issues/88)\r\n\r\n这个系列主要讲 Class 的普通写法、继承、私有属性和原生构造函数继承 `babel` 是如何实现这一过程的。\r\n> 注：文章顺序存在关联，请按照顺序阅读。\r\n\r\n## 前置知识点\r\n\r\n### WeakMap\r\n\r\n`WeakMap` 是 ES6 新加入的数据结构，它与 `map` 类似，但是键为弱引用。\r\n\r\n> 弱引用就是指不计入垃圾回收次数，当引用被垃圾回收 `WeakMap` 对应键值自动消失。\r\n\r\n> 更多内容请参考[文档](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/WeakMap)\r\n\r\n### WeakSet\r\n\r\n与 `WeakMap` 类似，不同在于 `WeakSet` 只有键名，没有键值。\r\n\r\n> 更多内容请参考[文档](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/WeakSet)\r\n\r\n### Class 私有属性\r\n\r\n之前 `Class` 要实现私有属性只能通过，`Symbol` 或者外部变量来实现，不过都各有缺点，现在新的提案 [proposal-private-methods](https://github.com/tc39/proposal-private-methods) 添加了私有属性和私有方法，使用方式很简单，直接`#<name>`即可。\r\n\r\n```js\r\nclass Test {\r\n  #age = 12;\r\n  #getage() {}\r\n}\r\n```\r\n\r\n私有属性只能在构造函数内部调用，如果在非内部调用则抛出异常（在 static 上调用也是可以的）。\r\n\r\n## 示例文件\r\n\r\n```js\r\nclass Test {\r\n  #age = 17;\r\n  static #name = 'zhangsan';\r\n\r\n  #getAge() {\r\n    console.log(this.#age);\r\n  }\r\n  static #getName() {\r\n    console.log(this.#name);\r\n  }\r\n\r\n  all() {\r\n    this.#getAge();\r\n    Test.#getName();\r\n  }\r\n}\r\nconst test = new Test();\r\ntest.all();\r\n```\r\n\r\n以下内容根据此文件进行讲解。\r\n\r\n## babel\r\n\r\n```js\r\n'use strict';\r\n\r\nfunction _classCallCheck(instance, Constructor) {\r\n  if (!(instance instanceof Constructor)) {\r\n    throw new TypeError('Cannot call a class as a function');\r\n  }\r\n}\r\n\r\nfunction _defineProperties(target, props) {\r\n  for (var i = 0; i < props.length; i++) {\r\n    var descriptor = props[i];\r\n    descriptor.enumerable = descriptor.enumerable || false;\r\n    descriptor.configurable = true;\r\n    if ('value' in descriptor) descriptor.writable = true;\r\n    Object.defineProperty(target, descriptor.key, descriptor);\r\n  }\r\n}\r\n\r\nfunction _createClass(Constructor, protoProps, staticProps) {\r\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\r\n  if (staticProps) _defineProperties(Constructor, staticProps);\r\n  Object.defineProperty(Constructor, 'prototype', { writable: false });\r\n  return Constructor;\r\n}\r\n\r\nfunction _classPrivateMethodInitSpec(obj, privateSet) {\r\n  _checkPrivateRedeclaration(obj, privateSet);\r\n  privateSet.add(obj);\r\n}\r\n\r\nfunction _classPrivateFieldInitSpec(obj, privateMap, value) {\r\n  _checkPrivateRedeclaration(obj, privateMap);\r\n  privateMap.set(obj, value);\r\n}\r\n\r\nfunction _checkPrivateRedeclaration(obj, privateCollection) {\r\n  if (privateCollection.has(obj)) {\r\n    throw new TypeError(\r\n      'Cannot initialize the same private elements twice on an object'\r\n    );\r\n  }\r\n}\r\n\r\nfunction _classStaticPrivateMethodGet(receiver, classConstructor, method) {\r\n  _classCheckPrivateStaticAccess(receiver, classConstructor);\r\n  return method;\r\n}\r\n\r\nfunction _classPrivateMethodGet(receiver, privateSet, fn) {\r\n  if (!privateSet.has(receiver)) {\r\n    throw new TypeError('attempted to get private field on non-instance');\r\n  }\r\n  return fn;\r\n}\r\n\r\nfunction _classStaticPrivateFieldSpecGet(\r\n  receiver,\r\n  classConstructor,\r\n  descriptor\r\n) {\r\n  _classCheckPrivateStaticAccess(receiver, classConstructor);\r\n  _classCheckPrivateStaticFieldDescriptor(descriptor, 'get');\r\n  return _classApplyDescriptorGet(receiver, descriptor);\r\n}\r\n\r\nfunction _classCheckPrivateStaticFieldDescriptor(descriptor, action) {\r\n  if (descriptor === undefined) {\r\n    throw new TypeError(\r\n      'attempted to ' + action + ' private static field before its declaration'\r\n    );\r\n  }\r\n}\r\n\r\nfunction _classCheckPrivateStaticAccess(receiver, classConstructor) {\r\n  if (receiver !== classConstructor) {\r\n    throw new TypeError('Private static access of wrong provenance');\r\n  }\r\n}\r\n\r\nfunction _classPrivateFieldGet(receiver, privateMap) {\r\n  var descriptor = _classExtractFieldDescriptor(receiver, privateMap, 'get');\r\n  return _classApplyDescriptorGet(receiver, descriptor);\r\n}\r\n\r\nfunction _classExtractFieldDescriptor(receiver, privateMap, action) {\r\n  if (!privateMap.has(receiver)) {\r\n    throw new TypeError(\r\n      'attempted to ' + action + ' private field on non-instance'\r\n    );\r\n  }\r\n  return privateMap.get(receiver);\r\n}\r\n\r\nfunction _classApplyDescriptorGet(receiver, descriptor) {\r\n  if (descriptor.get) {\r\n    return descriptor.get.call(receiver);\r\n  }\r\n  return descriptor.value;\r\n}\r\n\r\nvar _age = /*#__PURE__*/ new WeakMap();\r\n\r\nvar _getAge = /*#__PURE__*/ new WeakSet();\r\n\r\nvar Test = /*#__PURE__*/ (function () {\r\n  debugger;\r\n  function Test() {\r\n    _classCallCheck(this, Test);\r\n\r\n    _classPrivateMethodInitSpec(this, _getAge);\r\n\r\n    _classPrivateFieldInitSpec(this, _age, {\r\n      writable: true,\r\n      value: 17,\r\n    });\r\n  }\r\n\r\n  _createClass(Test, [\r\n    {\r\n      key: 'all',\r\n      value: function all() {\r\n        _classPrivateMethodGet(this, _getAge, _getAge2).call(this);\r\n\r\n        _classStaticPrivateMethodGet(Test, Test, _getName).call(Test);\r\n      },\r\n    },\r\n  ]);\r\n\r\n  return Test;\r\n})();\r\n\r\nfunction _getAge2() {\r\n  console.log(_classPrivateFieldGet(this, _age));\r\n}\r\n\r\nfunction _getName() {\r\n  console.log(_classStaticPrivateFieldSpecGet(this, Test, _name));\r\n}\r\n\r\nvar _name = {\r\n  writable: true,\r\n  value: 'zhangsan',\r\n};\r\nvar test = new Test();\r\ntest.all();\r\n```\r\n\r\n以下方法出现在之前讲解过的篇幅中就不再赘述\r\n\r\n- `_classCallCheck`\r\n- `_defineProperties`\r\n- `_createClass`\r\n\r\n### \\_checkPrivateRedeclaration\r\n\r\n```js\r\nfunction _checkPrivateRedeclaration(obj, privateCollection) {\r\n  if (privateCollection.has(obj)) {\r\n    throw new TypeError(\r\n      'Cannot initialize the same private elements twice on an object'\r\n    );\r\n  }\r\n}\r\n```\r\n\r\n验证 `WeakSet` 上是否存在构造函数，如果存在直接抛出错误。\r\n\r\n### \\_classPrivateMethodInitSpec\r\n\r\n```js\r\nfunction _classPrivateMethodInitSpec(obj, privateSet) {\r\n  _checkPrivateRedeclaration(obj, privateSet);\r\n  privateSet.add(obj);\r\n}\r\n```\r\n\r\n在 `WeakSet` 上添加构造函数。\r\n\r\n### \\_classPrivateFieldInitSpec\r\n\r\n```js\r\nfunction _classPrivateFieldInitSpec(obj, privateMap, value) {\r\n  _checkPrivateRedeclaration(obj, privateMap);\r\n  privateMap.set(obj, value);\r\n}\r\n```\r\n\r\n在 `WeakMap` 上添加私有属性（属性描述符形式）。\r\n\r\n### \\_classPrivateMethodGet\r\n\r\n```js\r\nfunction _classPrivateMethodGet(receiver, privateSet, fn) {\r\n  if (!privateSet.has(receiver)) {\r\n    throw new TypeError('attempted to get private field on non-instance');\r\n  }\r\n  return fn;\r\n}\r\n```\r\n\r\n验证是否在构造函数内部调用，如果外部则抛出错误 `试图在非实例上获取私有字段`。\r\n\r\n### \\_classCheckPrivateStaticAccess\r\n\r\n```js\r\nfunction _classCheckPrivateStaticAccess(receiver, classConstructor) {\r\n  if (receiver !== classConstructor) {\r\n    throw new TypeError('Private static access of wrong provenance');\r\n  }\r\n}\r\n```\r\n\r\n判断静态属性的来源是否合法，例如\r\n\r\n```js\r\nclass A {\r\n  static #name() {}\r\n}\r\n\r\nclass Test {\r\n  static #name() {\r\n    A.#name();\r\n  }\r\n\r\n  all() {\r\n    Test.#name();\r\n  }\r\n}\r\n\r\nconst test = new Test();\r\ntest.all();\r\n```\r\n\r\n我们在 `Test` 获取` A.#name` 这种情况下就要抛出异常。\r\n\r\n### \\_classStaticPrivateMethodGet\r\n\r\n```js\r\nfunction _classStaticPrivateMethodGet(receiver, classConstructor, method) {\r\n  _classCheckPrivateStaticAccess(receiver, classConstructor);\r\n  return method;\r\n}\r\n```\r\n\r\n验证通过返回 `method`。\r\n\r\n### \\_classExtractFieldDescriptor\r\n\r\n```js\r\nfunction _classExtractFieldDescriptor(receiver, privateMap, action) {\r\n  if (!privateMap.has(receiver)) {\r\n    throw new TypeError(\r\n      'attempted to ' + action + ' private field on non-instance'\r\n    );\r\n  }\r\n  return privateMap.get(receiver);\r\n}\r\n```\r\n\r\n验证 `WeakMap` 是否有构造函数，如果没有则抛出非法获取实例错误，否则返回对应的 key。\r\n\r\n### \\_classApplyDescriptorGet\r\n\r\n```js\r\nfunction _classApplyDescriptorGet(receiver, descriptor) {\r\n  if (descriptor.get) {\r\n    return descriptor.get.call(receiver);\r\n  }\r\n  return descriptor.value;\r\n}\r\n```\r\n\r\n返回私有属性，根据属性描述符，如果是 `get、set` 这种形式储存，直接调用 `get 函数` 返回，否则返回 `value`。\r\n\r\n### \\_classCheckPrivateStaticFieldDescriptor\r\n\r\n```js\r\nfunction _classCheckPrivateStaticFieldDescriptor(descriptor, action) {\r\n  if (descriptor === undefined) {\r\n    throw new TypeError(\r\n      'attempted to ' + action + ' private static field before its declaration'\r\n    );\r\n  }\r\n}\r\n```\r\n\r\n判断属性描述符是否存在，不存在抛出异常。\r\n\r\n### \\_classStaticPrivateFieldSpecGet\r\n\r\n```js\r\nfunction _classStaticPrivateFieldSpecGet(\r\n  receiver,\r\n  classConstructor,\r\n  descriptor\r\n) {\r\n  _classCheckPrivateStaticAccess(receiver, classConstructor);\r\n  _classCheckPrivateStaticFieldDescriptor(descriptor, 'get');\r\n  return _classApplyDescriptorGet(receiver, descriptor);\r\n}\r\n```\r\n\r\n返回静态私有方法\r\n\r\n- 调用 `_classCheckPrivateStaticAccess` 确保构造函数和调用函数一致；\r\n- 调用 `_classCheckPrivateStaticFieldDescriptor` 确保静态私有属性一致；\r\n- 调用 `_classApplyDescriptorGet` 返回私有属性;\r\n\r\n### \\_classPrivateFieldGet\r\n\r\n```js\r\nfunction _classPrivateFieldGet(receiver, privateMap) {\r\n  var descriptor = _classExtractFieldDescriptor(receiver, privateMap, 'get');\r\n  return _classApplyDescriptorGet(receiver, descriptor);\r\n}\r\n```\r\n\r\n返回静态私有属性。\r\n\r\n## 执行过程\r\n\r\n上面已经放过 babel 过的代码，这里就不重复了，重点看下执行的过程，从`var _age = /*#__PURE__*/ new WeakMap();`这段代码开始。\r\n\r\n- 创建 `_age` 和 `_getAge` 的 `Weak` 对象；\r\n- 调用 `_createClass` 给 Test 完成 prototype 赋值；\r\n- `new Test`，进入 Test 构造函数内部；\r\n- 调用 `_classCallCheck` 确保为 `new` 调用；\r\n- 调用 `_classPrivateMethodInitSpec`，让 `_getAge` 添加当前 `this`；\r\n- 调用 `_classPrivateFieldInitSpec`，给 `_age` 添加属性，key 为 this，value 为属性描述符；\r\n- 调用 `all` 方法；\r\n- 执行 `_classPrivateMethodGet(this, _getAge, _getAge2).call(this);`，它的作用验证通过后调用 `_getAge2`；\r\n- `_getAge2` 内部执行 `_classPrivateFieldGet`，返回 `_age` 设置的属性描述符;\r\n- 返回 `all` 内部执行 `_classStaticPrivateMethodGet(Test, Test, _getName).call(Test);`这一行，它的作用是验证后执行 `_getName`；\r\n- `_getName` 内部执行 `_classStaticPrivateFieldSpecGet` 它返回属性描述符；\r\n- 输出结果，结束；\r\n\r\n## 实现私有属性方法\r\n\r\n从上面过程中可以看到，实现私有方法的主要步骤是通过 `WeakMap` 来完成，如果不考虑验证过程，可以很简单实现。\r\n\r\n```js\r\nconst privateName = new WeakMap();\r\n\r\nclass Test {\r\n  constructor() {\r\n    privateName.set(this, 'zhangsan');\r\n  }\r\n  getName() {\r\n    return privateName.get(this);\r\n  }\r\n}\r\n```\r\n\r\n## 最后\r\n\r\n如果有什么不正确或者书写错误欢迎指出。\r\n",
          "reactions": {
            "url": "https://api.github.com/repos/bosens-China/blog/issues/82/reactions",
            "total_count": 0,
            "+1": 0,
            "-1": 0,
            "laugh": 0,
            "hooray": 0,
            "confused": 0,
            "heart": 0,
            "rocket": 0,
            "eyes": 0
          },
          "timeline_url": "https://api.github.com/repos/bosens-China/blog/issues/82/timeline",
          "performed_via_github_app": null,
          "state_reason": null
        },
        {
          "url": "https://api.github.com/repos/bosens-China/blog/issues/81",
          "repository_url": "https://api.github.com/repos/bosens-China/blog",
          "labels_url": "https://api.github.com/repos/bosens-China/blog/issues/81/labels{/name}",
          "comments_url": "https://api.github.com/repos/bosens-China/blog/issues/81/comments",
          "events_url": "https://api.github.com/repos/bosens-China/blog/issues/81/events",
          "html_url": "https://github.com/bosens-China/blog/issues/81",
          "id": 1085660852,
          "node_id": "I_kwDOCzPAy85Atd60",
          "number": 81,
          "title": "Babel to Class之继承（2）",
          "user": {
            "login": "bosens-China",
            "id": 39508895,
            "node_id": "MDQ6VXNlcjM5NTA4ODk1",
            "avatar_url": "https://avatars.githubusercontent.com/u/39508895?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/bosens-China",
            "html_url": "https://github.com/bosens-China",
            "followers_url": "https://api.github.com/users/bosens-China/followers",
            "following_url": "https://api.github.com/users/bosens-China/following{/other_user}",
            "gists_url": "https://api.github.com/users/bosens-China/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/bosens-China/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/bosens-China/subscriptions",
            "organizations_url": "https://api.github.com/users/bosens-China/orgs",
            "repos_url": "https://api.github.com/users/bosens-China/repos",
            "events_url": "https://api.github.com/users/bosens-China/events{/privacy}",
            "received_events_url": "https://api.github.com/users/bosens-China/received_events",
            "type": "User",
            "site_admin": false
          },
          "labels": [
            {
              "id": 1908144759,
              "node_id": "MDU6TGFiZWwxOTA4MTQ0NzU5",
              "url": "https://api.github.com/repos/bosens-China/blog/labels/ES6%E7%B3%BB%E5%88%97",
              "name": "ES6系列",
              "color": "0366d6",
              "default": false,
              "description": "ES6的最新语法"
            }
          ],
          "state": "open",
          "locked": false,
          "assignee": null,
          "assignees": [],
          "milestone": null,
          "comments": 0,
          "created_at": "2021-12-21T10:12:50Z",
          "updated_at": "2021-12-28T09:51:06Z",
          "closed_at": null,
          "author_association": "OWNER",
          "active_lock_reason": null,
          "body": "## 前言\r\n\r\n这是《Babel to Class》系列的第二篇\r\n\r\n- [Babel to Class之编译（1）](https://github.com/bosens-China/blog/issues/80)\r\n- [Babel to Class之私有属性（3）](https://github.com/bosens-China/blog/issues/82)\r\n- [Babel to Class之原生构造函数继承（4）](https://github.com/bosens-China/blog/issues/88)\r\n\r\n这个系列主要讲 Class 的普通写法、继承、私有属性和原生构造函数继承 `babel` 是如何实现这一过程的。\r\n> 注：文章顺序存在关联，请按照顺序阅读。\r\n\r\n## 前置知识点\r\n\r\n### super\r\n\r\n`super` 通常用于 Class 继承中调用父类构造函数，以及在方法中调用父类方法。\r\n\r\n```js\r\nclass Rectangle {\r\n  logNbSides() {\r\n    return 'I have 4 sides';\r\n  }\r\n}\r\n\r\nclass Square extends Rectangle {\r\n  logDescription() {\r\n    return super.logNbSides() + ' which are all equal';\r\n  }\r\n}\r\n```\r\n\r\n> 更多的内容请参考 [super](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/super)\r\n\r\n### Object.create\r\n\r\n`Object.create(proto，[propertiesObject])`\r\n\r\n`Object.create` 用于创建一个新的对象，并将新的对象原型设置在 `proto` 上，它还支持第二个参数，第二个参数为对象每个对象的值为属性描述符。\r\n\r\n```js\r\nvar o = Object.create(Object.prototype, {\r\n  // foo会成为所创建对象的数据属性\r\n  foo: {\r\n    writable: true,\r\n    configurable: true,\r\n    value: 'hello',\r\n  },\r\n  // bar会成为所创建对象的访问器属性\r\n  bar: {\r\n    configurable: false,\r\n    get: function () {\r\n      return 10;\r\n    },\r\n    set: function (value) {\r\n      console.log('Setting `o.bar` to', value);\r\n    },\r\n  },\r\n});\r\n```\r\n\r\n> 更多内容请参考 [Object.create](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/create)\r\n\r\n### Reflect.construct\r\n\r\n```js\r\nReflect.construct(target, argumentsList[, newTarget])\r\n```\r\n\r\n- target：被运行的目标构造函数\r\n- argumentsList：类数组，目标构造函数调用时的参数。\r\n- newTarget：作为新创建对象的原型对象的 constructor 属性， 参考 new.target 操作符，默认值为 target。\r\n\r\n`Reflect.construct` 的作用相当于不用 `new` 操作符调用构造函数，创建对象。\r\n\r\n```js\r\nclass Foo {}\r\nvar obj = new Foo(...args);\r\nvar obj = Reflect.construct(Foo, args);\r\n```\r\n\r\n注意点：\r\n\r\n1. 使用 `Reflect.construct` 创建对象，`new.target` 会自动指向 newTarget，\r\n2. 如果指定 newTarget，`new.target` 会指向 newTarget 且构造函数内部的 this 为 newTarget\r\n\r\n> 更多内容请参考 [Reflect.construct](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Reflect/construct)\r\n\r\n### Class\r\n\r\n- Class extends 继承的必须是 `null` 或者 `function`（class 也是 function），否则抛出错误；\r\n- Class 子类 extends 父类的时候必须在 `constructor` 显式调用 `super()`，否则抛出错误；\r\n\r\n## 示例代码\r\n\r\n```js\r\nclass Parent {\r\n  constructor() {\r\n    this.age = 17;\r\n  }\r\n\r\n  getAge() {\r\n    return this.age;\r\n  }\r\n\r\n  static getName() {\r\n    return this.name;\r\n  }\r\n}\r\n\r\nclass Child extends Parent {\r\n  constructor() {\r\n    super();\r\n    this.name = 'child';\r\n  }\r\n\r\n  static name = 'child';\r\n\r\n  getAll() {\r\n    return {\r\n      name: this.name,\r\n      age: this.age,\r\n    };\r\n  }\r\n}\r\n\r\nconst child = new Child();\r\nconsole.log(child.getAll());\r\nconsole.log(Child.getName());\r\n```\r\n\r\n以下讲解基于上面的内容而来。\r\n\r\n## babel\r\n\r\n```js\r\n'use strict';\r\n\r\nfunction _typeof(obj) {\r\n  // ...省略实现\r\n}\r\n\r\nfunction _inherits(subClass, superClass) {\r\n  // ...省略实现\r\n}\r\n\r\nfunction _setPrototypeOf(o, p) {\r\n  // ...省略实现\r\n}\r\n\r\nfunction _createSuper(Derived) {\r\n  // ...省略实现\r\n}\r\n\r\nfunction _possibleConstructorReturn(self, call) {\r\n  // ...省略实现\r\n}\r\n\r\nfunction _assertThisInitialized(self) {\r\n  // ...省略实现\r\n}\r\n\r\nfunction _isNativeReflectConstruct() {\r\n  // ...省略实现\r\n}\r\n\r\nfunction _getPrototypeOf(o) {\r\n  // ...省略实现\r\n}\r\n\r\nfunction _defineProperty(obj, key, value) {\r\n  // ...省略实现\r\n}\r\n\r\nfunction _classCallCheck(instance, Constructor) {\r\n  // ...省略实现\r\n}\r\n\r\nfunction _defineProperties(target, props) {\r\n  // ...省略实现\r\n}\r\n\r\nfunction _createClass(Constructor, protoProps, staticProps) {\r\n  // ...省略实现\r\n}\r\n\r\nvar Parent = /*#__PURE__*/ (function () {\r\n  function Parent() {\r\n    _classCallCheck(this, Parent);\r\n\r\n    this.age = 17;\r\n  }\r\n\r\n  _createClass(\r\n    Parent,\r\n    [\r\n      {\r\n        key: 'getAge',\r\n        value: function getAge() {\r\n          return this.age;\r\n        },\r\n      },\r\n    ],\r\n    [\r\n      {\r\n        key: 'getName',\r\n        value: function getName() {\r\n          return this.name;\r\n        },\r\n      },\r\n    ],\r\n  );\r\n\r\n  return Parent;\r\n})();\r\n\r\nvar Child = /*#__PURE__*/ (function (_Parent) {\r\n  _inherits(Child, _Parent);\r\n\r\n  var _super = _createSuper(Child);\r\n\r\n  function Child() {\r\n    var _this;\r\n\r\n    _classCallCheck(this, Child);\r\n\r\n    _this = _super.call(this);\r\n    _this.name = 'child';\r\n    return _this;\r\n  }\r\n\r\n  _createClass(Child, [\r\n    {\r\n      key: 'getAll',\r\n      value: function getAll() {\r\n        return {\r\n          name: this.name,\r\n          age: this.age,\r\n        };\r\n      },\r\n    },\r\n  ]);\r\n\r\n  return Child;\r\n})(Parent);\r\n\r\n_defineProperty(Child, 'name', 'child');\r\n\r\nvar child = new Child();\r\nconsole.log(child.getAll());\r\nconsole.log(Child.getName());\r\n```\r\n\r\n下面函数在 [Babel to Class 做了什么（1）](https://github.com/bosens-China/blog/issues/80) 讲解过了\r\n\r\n- `_defineProperty`\r\n- `_classCallCheck`\r\n- `_defineProperties`\r\n- `_createClass`\r\n\r\n所以不再赘述，重点先看新出现的函数。\r\n\r\n### \\_typeof\r\n\r\n```js\r\nfunction _typeof(obj) {\r\n  '@babel/helpers - typeof';\r\n  return (\r\n    (_typeof =\r\n      'function' == typeof Symbol && 'symbol' == typeof Symbol.iterator\r\n        ? function (obj) {\r\n            return typeof obj;\r\n          }\r\n        : function (obj) {\r\n            return obj && 'function' == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype\r\n              ? 'symbol'\r\n              : typeof obj;\r\n          }),\r\n    _typeof(obj)\r\n  );\r\n}\r\n```\r\n\r\n这个函数的作用为类型判断。\r\n\r\n- `'function' == typeof Symbol && 'symbol' == typeof Symbol.iterator`\r\n  这段化意思是如果支持原生的 `Symbol` 就直接执行 `typeof` 即可\r\n\r\n- `obj && 'function' == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype`\r\n  这段代码主要是用于判断低版本不兼容 `Symbol` 的浏览器是不是使用了 `polyfill` 库，如果是的化就返回 `symbol`\r\n\r\n- 其他情况返回 `typeof` 结果\r\n\r\n### \\_inherits\r\n\r\n```js\r\nfunction _inherits(subClass, superClass) {\r\n  if (typeof superClass !== 'function' && superClass !== null) {\r\n    throw new TypeError('Super expression must either be null or a function');\r\n  }\r\n  Object.defineProperty(subClass, 'prototype', {\r\n    value: Object.create(superClass && superClass.prototype, {\r\n      constructor: { value: subClass, writable: true, configurable: true },\r\n    }),\r\n    writable: false,\r\n  });\r\n  if (superClass) _setPrototypeOf(subClass, superClass);\r\n}\r\n```\r\n\r\n- 这段代码首先判断继承的 `superClass` 是否符合要求\r\n- 其次对 `subClass.prototype` 进行设置确保 `prototype` 属性非遍历\r\n- 设置原型，将 `subClass` 的原型设置为 `superClass`\r\n\r\n### \\_setPrototypeOf\r\n\r\n```js\r\nfunction _setPrototypeOf(o, p) {\r\n  _setPrototypeOf =\r\n    Object.setPrototypeOf ||\r\n    function _setPrototypeOf(o, p) {\r\n      o.__proto__ = p;\r\n      return o;\r\n    };\r\n  return _setPrototypeOf(o, p);\r\n}\r\n```\r\n\r\n设置原型链的方法，首先调用原生的 `Object.setPrototypeOf` 方法，如果不支持尝试使用 `__proto__`，`__proto__`是浏览器实现的一个私有属性，在其他环境下不是必须实现。\r\n\r\n不过仔细观察，你会发现它还使用了一个函数懒加载，确保判断只执行一次，后续直接不会改变了。\r\n\r\n### \\_createSuper\r\n\r\n```js\r\nfunction _createSuper(Derived) {\r\n  var hasNativeReflectConstruct = _isNativeReflectConstruct();\r\n  return function _createSuperInternal() {\r\n    var Super = _getPrototypeOf(Derived),\r\n      result;\r\n    if (hasNativeReflectConstruct) {\r\n      var NewTarget = _getPrototypeOf(this).constructor;\r\n      result = Reflect.construct(Super, arguments, NewTarget);\r\n    } else {\r\n      result = Super.apply(this, arguments);\r\n    }\r\n    return _possibleConstructorReturn(this, result);\r\n  };\r\n}\r\n```\r\n\r\n这段代码的作用是返回 `super`\r\n\r\n- `_isNativeReflectConstruct` 这个函数我们后面讲解，它的作用就是判断当前环境支不支持 `Reflect.construct`\r\n- `_possibleConstructorReturn` 这个函数后面讲解，作用为判断 Class 符不符合要求\r\n\r\n### \\_possibleConstructorReturn\r\n\r\n```js\r\nfunction _possibleConstructorReturn(self, call) {\r\n  debugger;\r\n  if (call && (_typeof(call) === 'object' || typeof call === 'function')) {\r\n    return call;\r\n  } else if (call !== void 0) {\r\n    throw new TypeError('Derived constructors may only return object or undefined');\r\n  }\r\n  return _assertThisInitialized(self);\r\n}\r\n```\r\n\r\n这个函数用于判断 Class 和 extends 的 Class 符不符合要求\r\n\r\n- `call && (_typeof(call) === 'object' || typeof call === 'function')`\r\n\r\n这个相当于判断 isObject，构造函数被调用是可以返回一个对象的\r\n\r\n```js\r\nfunction Foo() {\r\n  return { name: 1 };\r\n}\r\nnew Foo();\r\n// {name: 1}\r\n```\r\n\r\n如果不是对象也没有默认返回 `undefined`，则直接抛出错误\r\n\r\n- `_assertThisInitialized`，这个函数用于判断子类有没有调用 `super`，如果没有调用抛出错误\r\n\r\n### \\_isNativeReflectConstruct\r\n\r\n```js\r\nfunction _isNativeReflectConstruct() {\r\n  if (typeof Reflect === 'undefined' || !Reflect.construct) return false;\r\n  if (Reflect.construct.sham) return false;\r\n  if (typeof Proxy === 'function') return true;\r\n  try {\r\n    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));\r\n    return true;\r\n  } catch (e) {\r\n    return false;\r\n  }\r\n}\r\n```\r\n\r\n判断当前环境支不支持 `Reflect.construct`，它的判断思路为前置判断，如果不符合早早返回\r\n\r\n- `if (typeof Reflect === 'undefined' || !Reflect.construct) return false;`，不支持原生返回 `false`\r\n- `if (Reflect.construct.sham) return false;`，`polyfill` 的则也返回 `false`\r\n- `if (typeof Proxy === 'function') return true;`，返回 `true` 的原因是因为，`Proxy` 的兼容性比 `Reflect` 差，如果 `Proxy` 支持 `Reflect` 一定也支持\r\n  - [proxy 兼容性总览](https://caniuse.com/?search=proxy)\r\n  - [Reflect 兼容性总览](https://caniuse.com/?search=Reflect)\r\n- `Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));`，如果都符合直接运行，前面说过 `Reflect.construct` 支持第三个参数，如果运行没报错返回 `true`\r\n\r\n### \\_getPrototypeOf\r\n\r\n```js\r\nfunction _getPrototypeOf(o) {\r\n  _getPrototypeOf = Object.setPrototypeOf\r\n    ? Object.getPrototypeOf\r\n    : function _getPrototypeOf(o) {\r\n        return o.__proto__ || Object.getPrototypeOf(o);\r\n      };\r\n  return _getPrototypeOf(o);\r\n}\r\n```\r\n\r\n这段代码为获取原型，跟 `_setPrototypeOf` 函数类似，如果当前环境支持优先使用 `Object.getPrototypeOf` 上的，否则回滚。\r\n\r\n## 运行流程\r\n\r\n讲解到这里，继承基本讲完了，现在把完整代码贴以下，之后讲一下运行的流程\r\n\r\n```js\r\n'use strict';\r\n\r\nfunction _typeof(obj) {\r\n  '@babel/helpers - typeof';\r\n  return (\r\n    (_typeof =\r\n      'function' == typeof Symbol && 'symbol' == typeof Symbol.iterator\r\n        ? function (obj) {\r\n            return typeof obj;\r\n          }\r\n        : function (obj) {\r\n            return obj && 'function' == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype\r\n              ? 'symbol'\r\n              : typeof obj;\r\n          }),\r\n    _typeof(obj)\r\n  );\r\n}\r\n\r\nfunction _inherits(subClass, superClass) {\r\n  if (typeof superClass !== 'function' && superClass !== null) {\r\n    throw new TypeError('Super expression must either be null or a function');\r\n  }\r\n  Object.defineProperty(subClass, 'prototype', {\r\n    value: Object.create(superClass && superClass.prototype, {\r\n      constructor: { value: subClass, writable: true, configurable: true },\r\n    }),\r\n    writable: false,\r\n  });\r\n  if (superClass) _setPrototypeOf(subClass, superClass);\r\n}\r\n\r\nfunction _setPrototypeOf(o, p) {\r\n  _setPrototypeOf =\r\n    Object.setPrototypeOf ||\r\n    function _setPrototypeOf(o, p) {\r\n      o.__proto__ = p;\r\n      return o;\r\n    };\r\n  return _setPrototypeOf(o, p);\r\n}\r\n\r\nfunction _createSuper(Derived) {\r\n  var hasNativeReflectConstruct = _isNativeReflectConstruct();\r\n  return function _createSuperInternal() {\r\n    var Super = _getPrototypeOf(Derived),\r\n      result;\r\n    if (hasNativeReflectConstruct) {\r\n      var NewTarget = _getPrototypeOf(this).constructor;\r\n      result = Reflect.construct(Super, arguments, NewTarget);\r\n    } else {\r\n      result = Super.apply(this, arguments);\r\n    }\r\n    return _possibleConstructorReturn(this, result);\r\n  };\r\n}\r\n\r\nfunction _possibleConstructorReturn(self, call) {\r\n  if (call && (_typeof(call) === 'object' || typeof call === 'function')) {\r\n    return call;\r\n  } else if (call !== void 0) {\r\n    throw new TypeError('Derived constructors may only return object or undefined');\r\n  }\r\n  return _assertThisInitialized(self);\r\n}\r\n\r\nfunction _assertThisInitialized(self) {\r\n  if (self === void 0) {\r\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\r\n  }\r\n  return self;\r\n}\r\n\r\nfunction _isNativeReflectConstruct() {\r\n  if (typeof Reflect === 'undefined' || !Reflect.construct) return false;\r\n  if (Reflect.construct.sham) return false;\r\n  if (typeof Proxy === 'function') return true;\r\n  try {\r\n    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));\r\n    return true;\r\n  } catch (e) {\r\n    return false;\r\n  }\r\n}\r\n\r\nfunction _getPrototypeOf(o) {\r\n  _getPrototypeOf = Object.setPrototypeOf\r\n    ? Object.getPrototypeOf\r\n    : function _getPrototypeOf(o) {\r\n        return o.__proto__ || Object.getPrototypeOf(o);\r\n      };\r\n  return _getPrototypeOf(o);\r\n}\r\n\r\nfunction _defineProperty(obj, key, value) {\r\n  if (key in obj) {\r\n    Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true });\r\n  } else {\r\n    obj[key] = value;\r\n  }\r\n  return obj;\r\n}\r\n\r\nfunction _classCallCheck(instance, Constructor) {\r\n  if (!(instance instanceof Constructor)) {\r\n    throw new TypeError('Cannot call a class as a function');\r\n  }\r\n}\r\n\r\nfunction _defineProperties(target, props) {\r\n  for (var i = 0; i < props.length; i++) {\r\n    var descriptor = props[i];\r\n    descriptor.enumerable = descriptor.enumerable || false;\r\n    descriptor.configurable = true;\r\n    if ('value' in descriptor) descriptor.writable = true;\r\n    Object.defineProperty(target, descriptor.key, descriptor);\r\n  }\r\n}\r\n\r\nfunction _createClass(Constructor, protoProps, staticProps) {\r\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\r\n  if (staticProps) _defineProperties(Constructor, staticProps);\r\n  Object.defineProperty(Constructor, 'prototype', { writable: false });\r\n  return Constructor;\r\n}\r\n\r\nvar Parent = /*#__PURE__*/ (function () {\r\n  function Parent() {\r\n    _classCallCheck(this, Parent);\r\n\r\n    this.age = 17;\r\n  }\r\n\r\n  _createClass(\r\n    Parent,\r\n    [\r\n      {\r\n        key: 'getAge',\r\n        value: function getAge() {\r\n          return this.age;\r\n        },\r\n      },\r\n    ],\r\n    [\r\n      {\r\n        key: 'getName',\r\n        value: function getName() {\r\n          return this.name;\r\n        },\r\n      },\r\n    ],\r\n  );\r\n\r\n  return Parent;\r\n})();\r\n\r\nvar Child = /*#__PURE__*/ (function (_Parent) {\r\n  _inherits(Child, _Parent);\r\n\r\n  var _super = _createSuper(Child);\r\n\r\n  function Child() {\r\n    var _this;\r\n\r\n    _classCallCheck(this, Child);\r\n\r\n    _this = _super.call(this);\r\n    _this.name = 'child';\r\n    return _this;\r\n  }\r\n\r\n  _createClass(Child, [\r\n    {\r\n      key: 'getAll',\r\n      value: function getAll() {\r\n        return {\r\n          name: this.name,\r\n          age: this.age,\r\n        };\r\n      },\r\n    },\r\n  ]);\r\n\r\n  return Child;\r\n})(Parent);\r\n\r\n_defineProperty(Child, 'name', 'child');\r\n\r\nvar child = new Child();\r\nconsole.log(child.getAll());\r\nconsole.log(Child.getName());\r\n```\r\n\r\n代码从 `var Parent = /*#__PURE__*/ (function () {` 这段开始\r\n\r\n- 调用 `_createClass`，将 `prototype 属性` 和 `static 属性` 设置到 Parent 函数上\r\n- 之后代码往下执行，到`var Child = /*#__PURE__*/ (function (_Parent) {`\r\n- 调用 `_inherits`，判断 Parent 符合要求，设置 `Child.prototype` 属性，设置 Child 原型\r\n- 调用 `_createSuper`，获取 `super`\r\n- 调用 `_createClass`，设置 `prototype 属性` 和 `static 属性` 设置到 Child 函数上\r\n- 调用 `_defineProperty`，覆盖 Child 上的属性，确保是可以遍历修改的\r\n- new Child\r\n- Child 函数内部执行 `_classCallCheck`，确保一定为 `new` 调用\r\n- 在 Child 函数内部执行 `_super.call(this)` 操作，调用父类构造函数\r\n- Parent 内部，调用 `_classCallCheck`，确保 `new` 调用\r\n- 返回 Parent 的 this 值\r\n- Child 内部修改 Parent 返回的 this 值，进行重写\r\n- 执行后续代码...\r\n\r\n## 跟 es5 继承的差异\r\n\r\n从上面代码不难看到跟 es5 写的继承有很大差异\r\n\r\n1. `prototype` 不可以遍历；\r\n2. 不通过 `new` 调用显式报错；\r\n3. Class 的继承不仅是将子类的 `prototype` 指向父类的 `prototype`，同时也将子类的原型指向了父类；\r\n4. 得益于子类原型指向父类，静态方法和属性也可以调用；\r\n\r\n## 最后\r\n\r\n如果有什么不正确或者书写错误欢迎指出。\r\n",
          "reactions": {
            "url": "https://api.github.com/repos/bosens-China/blog/issues/81/reactions",
            "total_count": 0,
            "+1": 0,
            "-1": 0,
            "laugh": 0,
            "hooray": 0,
            "confused": 0,
            "heart": 0,
            "rocket": 0,
            "eyes": 0
          },
          "timeline_url": "https://api.github.com/repos/bosens-China/blog/issues/81/timeline",
          "performed_via_github_app": null,
          "state_reason": null
        },
        {
          "url": "https://api.github.com/repos/bosens-China/blog/issues/80",
          "repository_url": "https://api.github.com/repos/bosens-China/blog",
          "labels_url": "https://api.github.com/repos/bosens-China/blog/issues/80/labels{/name}",
          "comments_url": "https://api.github.com/repos/bosens-China/blog/issues/80/comments",
          "events_url": "https://api.github.com/repos/bosens-China/blog/issues/80/events",
          "html_url": "https://github.com/bosens-China/blog/issues/80",
          "id": 1085660079,
          "node_id": "I_kwDOCzPAy85Atduv",
          "number": 80,
          "title": "Babel to Class之编译（1）",
          "user": {
            "login": "bosens-China",
            "id": 39508895,
            "node_id": "MDQ6VXNlcjM5NTA4ODk1",
            "avatar_url": "https://avatars.githubusercontent.com/u/39508895?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/bosens-China",
            "html_url": "https://github.com/bosens-China",
            "followers_url": "https://api.github.com/users/bosens-China/followers",
            "following_url": "https://api.github.com/users/bosens-China/following{/other_user}",
            "gists_url": "https://api.github.com/users/bosens-China/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/bosens-China/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/bosens-China/subscriptions",
            "organizations_url": "https://api.github.com/users/bosens-China/orgs",
            "repos_url": "https://api.github.com/users/bosens-China/repos",
            "events_url": "https://api.github.com/users/bosens-China/events{/privacy}",
            "received_events_url": "https://api.github.com/users/bosens-China/received_events",
            "type": "User",
            "site_admin": false
          },
          "labels": [
            {
              "id": 1908144759,
              "node_id": "MDU6TGFiZWwxOTA4MTQ0NzU5",
              "url": "https://api.github.com/repos/bosens-China/blog/labels/ES6%E7%B3%BB%E5%88%97",
              "name": "ES6系列",
              "color": "0366d6",
              "default": false,
              "description": "ES6的最新语法"
            }
          ],
          "state": "open",
          "locked": false,
          "assignee": null,
          "assignees": [],
          "milestone": null,
          "comments": 0,
          "created_at": "2021-12-21T10:12:08Z",
          "updated_at": "2021-12-28T09:48:18Z",
          "closed_at": null,
          "author_association": "OWNER",
          "active_lock_reason": null,
          "body": "## 前言\r\n\r\n这是《Babel to Class》系列的第一篇\r\n\r\n- [Babel to Class之继承（2）](https://github.com/bosens-China/blog/issues/81)\r\n- [Babel to Class之私有属性（3）](https://github.com/bosens-China/blog/issues/82)\r\n- [Babel to Class之原生构造函数继承（4）](https://github.com/bosens-China/blog/issues/88)\r\n\r\n这个系列主要讲 Class 的普通写法、继承、私有属性和原生构造函数继承 `babel` 是如何实现这一过程的。\r\n> 注：文章顺序存在关联，请按照顺序阅读。\r\n\r\n## 前置知识点\r\n\r\n### Object.defineProperty\r\n\r\n`Object.defineProperty(obj, prop, descriptor)` 用于定义对象属性，它有三个参数分为别：对象，对象 key，以及属性描述符。\r\n\r\n属性描述符默认不传递具体的值则为 `false`\r\n\r\n```js\r\nconst a = {};\r\nObject.defineProperty(a, 'd', {});\r\nObject.getOwnPropertyDescriptor(a, 'd');\r\n// {value: undefined, writable: false, enumerable: false, configurable: false}\r\n```\r\n\r\n有两种调用形式\r\n\r\n```js\r\nvar o = {};\r\n\r\n// 1.\r\nObject.defineProperty(o, 'a', {\r\n  value: 37,\r\n  writable: true,\r\n  enumerable: true,\r\n  configurable: true,\r\n});\r\n\r\n// 2.\r\nvar bValue = 38;\r\nObject.defineProperty(o, 'b', {\r\n  get() {\r\n    return bValue;\r\n  },\r\n  set(newValue) {\r\n    bValue = newValue;\r\n  },\r\n  enumerable: true,\r\n  configurable: true,\r\n});\r\n```\r\n\r\n> 更多内容，以及属性描述符包含那些，请[参考文档](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty)\r\n\r\n### Class\r\n\r\n- `Class`必须通过 `new` 调用，否则抛出 `Uncaught TypeError: Class constructor A cannot be invoked without 'new'`\r\n- `Class`的 `prototype` 属性默认不可遍历\r\n\r\n## 示例文件\r\n\r\n```js\r\nclass Test {\r\n  constructor() {\r\n    this.name = '张三';\r\n  }\r\n\r\n  _age = 18;\r\n\r\n  get age() {\r\n    return this._age;\r\n  }\r\n\r\n  set age(value) {\r\n    this._age = value;\r\n  }\r\n\r\n  getName() {\r\n    return this.name;\r\n  }\r\n\r\n  static getClassName() {\r\n    return this.name;\r\n  }\r\n\r\n  static name = 'TestClass';\r\n}\r\n```\r\n\r\n上面就是准备好的示例文件，结构很简单，我们看下 `babel` 会将代码转码成什么样\r\n\r\n## babel\r\n\r\n为了方便讲解，下面通过注释的形式来解读，阅读部分请从 `const Test = /* #__PURE__ */ (function () {` 这段开始。\r\n\r\n```js\r\n'use strict';\r\n\r\nfunction _classCallCheck(instance, Constructor) {\r\n  /*\r\n   * Class必须通过new调用，这是判断调用的this跟Test进行instanceof对比，如果不符合抛出错误\r\n   */\r\n  if (!(instance instanceof Constructor)) {\r\n    throw new TypeError('Cannot call a class as a function');\r\n  }\r\n}\r\n\r\n/**\r\n * 用于给对象定义属性\r\n * 注意它判断了value属性是否存在，这是因为存在两种写法\r\n * 一种是传递value的普通\r\n * 另外一种是传递get和set的形式\r\n */\r\nfunction _defineProperties(target, props) {\r\n  for (let i = 0; i < props.length; i++) {\r\n    const descriptor = props[i];\r\n    descriptor.enumerable = descriptor.enumerable || false;\r\n    descriptor.configurable = true;\r\n    if ('value' in descriptor) descriptor.writable = true;\r\n    Object.defineProperty(target, descriptor.key, descriptor);\r\n  }\r\n}\r\n\r\n/**\r\n * 初始化Class属性\r\n * 先从函数的prototype属性来进行定义\r\n * 后面定义Constructor本身的属性\r\n */\r\nfunction _createClass(Constructor, protoProps, staticProps) {\r\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\r\n  if (staticProps) _defineProperties(Constructor, staticProps);\r\n  Object.defineProperty(Constructor, 'prototype', { writable: false });\r\n  return Constructor;\r\n}\r\n\r\n/**\r\n * 用于给Test实例和本身定义属性\r\n * 之所以进行一个 in 判定是为了覆盖本身已经有的属性\r\n * 例如class.name属性，这个本身已经存在 {value: 'A', writable: false, enumerable: false, configurable: true}\r\n * 但是我们从新定义就要属性描述符全部为true\r\n */\r\nfunction _defineProperty(obj, key, value) {\r\n  if (key in obj) {\r\n    Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true });\r\n  } else {\r\n    obj[key] = value;\r\n  }\r\n  return obj;\r\n}\r\n\r\nconst Test = /* #__PURE__ */ (function () {\r\n  function Test() {\r\n    // 初始进行new调用判断\r\n    _classCallCheck(this, Test);\r\n    // 实例属性写法\r\n    _defineProperty(this, '_age', 18);\r\n\r\n    this.name = '张三';\r\n  }\r\n\r\n  // 初始化，后面分为为prototype属性以及静态属性\r\n  _createClass(\r\n    Test,\r\n    [\r\n      {\r\n        key: 'age',\r\n        get: function get() {\r\n          return this._age;\r\n        },\r\n        set: function set(value) {\r\n          this._age = value;\r\n        },\r\n      },\r\n      {\r\n        key: 'getName',\r\n        value: function getName() {\r\n          return this.name;\r\n        },\r\n      },\r\n    ],\r\n    [\r\n      {\r\n        key: 'getClassName',\r\n        value: function getClassName() {\r\n          return this.name;\r\n        },\r\n      },\r\n    ],\r\n  );\r\n\r\n  return Test;\r\n})();\r\n\r\n_defineProperty(Test, 'name', 'TestClass');\r\n```\r\n\r\n概况一下上面流程：\r\n\r\n1. 初始化 `Class` 上的 `prototype 属性`以及 `static 属性`\r\n2. `new Class` 的时候，对 Class 的调用形式进行判断\r\n3. `new` 过程中赋值实例属性\r\n4. 执行...\r\n\r\n## 最后\r\n\r\n如果有什么不正确或者书写错误欢迎指出。\r\n",
          "reactions": {
            "url": "https://api.github.com/repos/bosens-China/blog/issues/80/reactions",
            "total_count": 0,
            "+1": 0,
            "-1": 0,
            "laugh": 0,
            "hooray": 0,
            "confused": 0,
            "heart": 0,
            "rocket": 0,
            "eyes": 0
          },
          "timeline_url": "https://api.github.com/repos/bosens-China/blog/issues/80/timeline",
          "performed_via_github_app": null,
          "state_reason": null
        }
      ]
    ],
    [
      "1371686608",
      [
        {
          "url": "https://api.github.com/repos/bosens-China/blog/issues/97",
          "repository_url": "https://api.github.com/repos/bosens-China/blog",
          "labels_url": "https://api.github.com/repos/bosens-China/blog/issues/97/labels{/name}",
          "comments_url": "https://api.github.com/repos/bosens-China/blog/issues/97/comments",
          "events_url": "https://api.github.com/repos/bosens-China/blog/issues/97/events",
          "html_url": "https://github.com/bosens-China/blog/issues/97",
          "id": 1745358720,
          "node_id": "I_kwDOCzPAy85oCA-A",
          "number": 97,
          "title": "使用jsx来编写模板",
          "user": {
            "login": "bosens-China",
            "id": 39508895,
            "node_id": "MDQ6VXNlcjM5NTA4ODk1",
            "avatar_url": "https://avatars.githubusercontent.com/u/39508895?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/bosens-China",
            "html_url": "https://github.com/bosens-China",
            "followers_url": "https://api.github.com/users/bosens-China/followers",
            "following_url": "https://api.github.com/users/bosens-China/following{/other_user}",
            "gists_url": "https://api.github.com/users/bosens-China/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/bosens-China/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/bosens-China/subscriptions",
            "organizations_url": "https://api.github.com/users/bosens-China/orgs",
            "repos_url": "https://api.github.com/users/bosens-China/repos",
            "events_url": "https://api.github.com/users/bosens-China/events{/privacy}",
            "received_events_url": "https://api.github.com/users/bosens-China/received_events",
            "type": "User",
            "site_admin": false
          },
          "labels": [
            {
              "id": 1371686608,
              "node_id": "MDU6TGFiZWwxMzcxNjg2NjA4",
              "url": "https://api.github.com/repos/bosens-China/blog/labels/%E6%BC%AB%E8%B0%88%E7%B3%BB%E5%88%97",
              "name": "漫谈系列",
              "color": "e7f3ee",
              "default": false,
              "description": "浅谈类文章"
            }
          ],
          "state": "open",
          "locked": false,
          "assignee": null,
          "assignees": [],
          "milestone": null,
          "comments": 0,
          "created_at": "2023-06-07T08:36:19Z",
          "updated_at": "2023-06-07T08:36:19Z",
          "closed_at": null,
          "author_association": "OWNER",
          "active_lock_reason": null,
          "body": "## 前言\r\n\r\n模板引擎这个应该都不陌生，最早可以追溯到前后端还没分离的时候，后端为了循环、判断值之类简化编写流程而使用的，毕竟手动拼接字符串之类的也太麻烦了。\r\n\r\n下面是 php [easytpl](https://github.com/phppkg/easytpl) 的一个示例，从这个可以看到模板引擎的基本用途。\r\n\r\n```php\r\nuse PhpPkg\\EasyTpl\\EasyTemplate;\r\n\r\n$tplCode = <<<'CODE'\r\nMy name is {{ $name | strtoupper }},\r\nMy develop tags:\r\n\r\n{{ foreach($tags as $tag) }}\r\n- {{ $tag }}\r\n\r\n{{ endforeach }}\r\nCODE;\r\n\r\n$t = new EasyTemplate();\r\n\r\n$str = $t->renderString($tplCode, [\r\n    'name' => 'inhere',\r\n    'tags' => ['php', 'go', 'java'],\r\n]);\r\n\r\necho $str;\r\n```\r\n\r\n上面这对代码会输出\r\n\r\n```md\r\nMy name is INHERE,\r\nMy develop tags:\r\n\r\n- php\r\n- go\r\n- java\r\n```\r\n\r\n回到 JavaScript，随着职能的不断提升前端也面临同样的问题，于是社区涌现了一堆库，例如：\r\n\r\n- [ejs](https://ejs.co/)\r\n- [nunjucks](http://mozilla.github.io/nunjucks/templating.html)\r\n- [pug](https://pugjs.org/api/getting-started.html)\r\n- ...\r\n\r\n上面的几个使用方法都大同小异，都是通过内置一些语法来简化重复的书写。不过思考一下使用模板引擎会有什么缺点？\r\n\r\n下面是一段 ejs 代码示例\r\n\r\n```html\r\n<% if (resultPreSale.length) { %>\r\n<h2>本次新增入网楼栋：<%= resultPreSale.length %>个</h2>\r\n<ul>\r\n  <% resultPreSale.forEach(function(item){ %>\r\n  <li>\r\n    <p>\r\n      <a href=\"<%= item.url %>\"> 项目名称：<%= item.entryName %> </a>\r\n    </p>\r\n    <p>楼幢号：<%= item.buildingNumber %></p>\r\n    <p>许可面积(㎡)：<%= item.permittedArea %></p>\r\n    <p>发放日期：<%= item.time %></p>\r\n  </li>\r\n  <% }); %>\r\n</ul>\r\n<% } %>\r\n```\r\n\r\n从上面的示例可以看到以下缺点：\r\n\r\n1. 缺少语法提示：在使用编辑器的时候使用相对应语法都会有提示，但是上面在使用 `forEach` 之类的根本不会有提示；\r\n2. 不能借助 Eslint、TypeScript 来提前检查编写错误：例如有一些 props 没有传递或者类型缺少，以及变量不存在而引用等错误，必须运行之后才会发现错误；\r\n3. 有额外的学习成本，每个模板引擎的语法其实都不一样，例如 ejs 和 pug 就不一致；\r\n\r\n## jsx\r\n\r\n回归到最熟悉的 jsx 本身，得益于 React 的流行 jsx 这种灵活方便的语法就是首选，首先生态很丰富可以跟 TypeScript 和 eslint 无缝衔接，且语法跟 js 基本一致不会增加额外的学习成本，且跟编辑器配合很好可以有语法提示。\r\n\r\n下面是一段示例\r\n\r\n```jsx\r\nconst App = (props: Props) => {\r\n  return (\r\n    <>\r\n      <PreSale resultPreSale={props.resultPreSale}></PreSale>\r\n      <List resultList={props.resultList}></List>\r\n      <List resultList={props.residueList} title={<h2>其他正在摇号项目（{props.residueList.length}个）：</h2>}></List>\r\n      <p>本次爬取时间：{props.currentTime}</p>\r\n      <style>{style}</style>\r\n    </>\r\n  );\r\n};\r\n```\r\n\r\njsx 基础的语法和如何解析这里并不关心，说回主题如何使用 jsx 来编写模板呢？\r\n\r\n### 解析 jsx\r\n\r\n模板返回的都是字符串的形式，但是上面示例的 App 明显是一个函数，所以首先需要把 jsx 转换为字符串，幸运的是社区有相关的库，这里使用的是 [preact-render-to-string](https://github.com/preactjs/preact-render-to-string)，[preact](https://preactjs.com/)是一个跟 React 实现很接近的库，你可以理解为 mini React。\r\n\r\n> 这里其实并不会使用 hooks 之类的功能，使用的只是 jsx 语法本身，所以选用什么框架并不关键。\r\n\r\n```jsx\r\nimport { render } from 'preact-render-to-string';\r\nconst html = render(<App {...props}></App>);\r\n```\r\n\r\n如果结合 TypeScript 使用，还需要做一些额外的配置\r\n\r\n- 安装 preact\r\n\r\n- 修改 tsconfig.json\r\n\r\n```json\r\n{\r\n  \"compilerOptions\": {\r\n    \"jsx\": \"react-jsx\",\r\n    \"jsxImportSource\": \"preact\"\r\n  }\r\n}\r\n```\r\n\r\n### node 环境使用\r\n\r\n这里并没有万事大吉，在 node 环境使用模板引擎也是一个很正常的事情，但是 tsx 或者 jsx 文件都是属于需要编译来进行处理的，否则 node 并不认识。\r\n\r\n1. [tsx](https://github.com/esbuild-kit/tsx)，使用 tsx 这个库，它通过 esbuild 来运行 TypeScript 和 ESM 文件；\r\n2. webpack\r\n\r\n下面是一个完整的 webpack 示例\r\n\r\n```js\r\nconst path = require('path');\r\nconst nodeExternals = require('webpack-node-externals');\r\nconst RunNodeWebpackPlugin = require('run-node-webpack-plugin');\r\n\r\nmodule.exports = {\r\n  entry: {\r\n    index: './src/index.ts',\r\n  },\r\n  target: 'node',\r\n  devtool: 'source-map',\r\n  externalsPresets: { node: true },\r\n  output: {\r\n    path: path.resolve(__dirname, 'dist'),\r\n    filename: '[name].cjs',\r\n    clean: true,\r\n  },\r\n  resolve: {\r\n    extensions: ['.js', '.jsx', '.ts', '.tsx'],\r\n  },\r\n  module: {\r\n    rules: [\r\n      {\r\n        test: /\\.(js|jsx|ts|tsx)$/,\r\n        exclude: /node_modules/,\r\n        use: [\r\n          {\r\n            loader: 'esbuild-loader',\r\n            options: {\r\n              target: 'es2022',\r\n            },\r\n          },\r\n        ],\r\n      },\r\n    ],\r\n  },\r\n};\r\n```\r\n\r\n## 最后\r\n\r\n如果文章有错误欢迎留言指出。\r\n",
          "reactions": {
            "url": "https://api.github.com/repos/bosens-China/blog/issues/97/reactions",
            "total_count": 0,
            "+1": 0,
            "-1": 0,
            "laugh": 0,
            "hooray": 0,
            "confused": 0,
            "heart": 0,
            "rocket": 0,
            "eyes": 0
          },
          "timeline_url": "https://api.github.com/repos/bosens-China/blog/issues/97/timeline",
          "performed_via_github_app": null,
          "state_reason": null
        },
        {
          "url": "https://api.github.com/repos/bosens-China/blog/issues/83",
          "repository_url": "https://api.github.com/repos/bosens-China/blog",
          "labels_url": "https://api.github.com/repos/bosens-China/blog/issues/83/labels{/name}",
          "comments_url": "https://api.github.com/repos/bosens-China/blog/issues/83/comments",
          "events_url": "https://api.github.com/repos/bosens-China/blog/issues/83/events",
          "html_url": "https://github.com/bosens-China/blog/issues/83",
          "id": 1085661652,
          "node_id": "I_kwDOCzPAy85AteHU",
          "number": 83,
          "title": "漫谈程序初始化",
          "user": {
            "login": "bosens-China",
            "id": 39508895,
            "node_id": "MDQ6VXNlcjM5NTA4ODk1",
            "avatar_url": "https://avatars.githubusercontent.com/u/39508895?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/bosens-China",
            "html_url": "https://github.com/bosens-China",
            "followers_url": "https://api.github.com/users/bosens-China/followers",
            "following_url": "https://api.github.com/users/bosens-China/following{/other_user}",
            "gists_url": "https://api.github.com/users/bosens-China/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/bosens-China/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/bosens-China/subscriptions",
            "organizations_url": "https://api.github.com/users/bosens-China/orgs",
            "repos_url": "https://api.github.com/users/bosens-China/repos",
            "events_url": "https://api.github.com/users/bosens-China/events{/privacy}",
            "received_events_url": "https://api.github.com/users/bosens-China/received_events",
            "type": "User",
            "site_admin": false
          },
          "labels": [
            {
              "id": 1371686608,
              "node_id": "MDU6TGFiZWwxMzcxNjg2NjA4",
              "url": "https://api.github.com/repos/bosens-China/blog/labels/%E6%BC%AB%E8%B0%88%E7%B3%BB%E5%88%97",
              "name": "漫谈系列",
              "color": "e7f3ee",
              "default": false,
              "description": "浅谈类文章"
            }
          ],
          "state": "open",
          "locked": false,
          "assignee": null,
          "assignees": [],
          "milestone": null,
          "comments": 0,
          "created_at": "2021-12-21T10:13:42Z",
          "updated_at": "2021-12-24T05:45:59Z",
          "closed_at": null,
          "author_association": "OWNER",
          "active_lock_reason": null,
          "body": "## 前言\r\n\r\n在软件工程的开发中有生命周期这个概念，它的作用就是定义各个阶段需要处理的事情跟 `tcp/ip` 协议分层一个意思，今天重点聊一聊初始化这个阶段。\r\n\r\n- 在日常使用的 `webpack`、`vite` 等工具会有一个配置收集的过程，这个过程就是初始化；\r\n- 在使用 `react`、`vue` 等框架时也会有 `created` 等生命周期函数暴露，在此阶段执行一些请求 api 等操作，这也是初始化；\r\n- 在使用 `koa` 等 `node` 框架启动服务之前进行 `use` 装载也是初始化；\r\n- 甚至，一段代码在执行之前通常会经历以下三个阶段，也可以概括为初始化\r\n  - 分词/词法分析\r\n  - 解析/语法分析\r\n  - 生成代码\r\n\r\n下面，我把任务分为两部分：\r\n\r\n- 可以前置化处理\r\n- 不能前置化处理\r\n\r\n## 前置初始化\r\n\r\n上面举例的一大堆，你会发现很多任务我们可以很自然完成，例如：\r\n\r\n- `webpack`、`vite` 读取配置，如果让你写大概就是根据 `npm script` 填写 config 的路径进行解析，然后通过 node 的 `fs` 模块进行读取\r\n- `koa` 在装载插件之前可能还需要自动导入所有符合要求的文件，这里可以通过 `glob` 模块来查找所有符合规则的文件进行批量导入\r\n\r\n上面的任务都可以通过 node 提供的同步 api 进行完成，且他们只会运行一次并不会影响到主体的功能。\r\n\r\n但是有一些操作，例如请求网络，异步加载模块后续的操作都需要等待加载完成之后才能执行，这种情况下没有同步的语法供使用，没办法完成前置依赖的处理。\r\n\r\n下面就抛砖引玉聊聊这种情况如何处理\r\n\r\n## 非前置化处理\r\n\r\n下面的例子都以 db 模块为例，它负责连接数据库之后进行读取数据，可能有一个 connect 的方法和 queue 的查询方法。\r\n\r\n```js\r\nclass Db {\r\n  constructor() {\r\n    this.signIn = false;\r\n  }\r\n  connect() {\r\n    if (this.signIn) {\r\n      return Promise.resolve(true);\r\n    }\r\n    return new Promise((resolve) => {\r\n      setTimeout(() => {\r\n        this.signIn = true;\r\n        resolve(true);\r\n      }, 3000);\r\n    });\r\n  }\r\n  async queue(str) {\r\n    if (!this.signIn) {\r\n      throw new Error(`必须连接数据库才能使用queue！`);\r\n    }\r\n    console.log(str);\r\n  }\r\n}\r\nconst db = new Db();\r\n\r\nconst app = async () => {\r\n  await db.connect();\r\n  await db.queue(`xx`);\r\n};\r\napp();\r\n```\r\n\r\n> 为了演示，后面代码全部为简化版本，不执行具体操作\r\n\r\n我们在程序中调用这个 db 模块，你会发现发现 `await db.connect()` 这段代码省略不了，我们的程序依赖 connect 这一步。\r\n\r\n且因为只是演示没有传递具体的密码和账号，但想象一下每次调用 db 都需要手动传递一次账号和密码也太糟心了。\r\n\r\n有什么办法可以简化这个过程呢？可以对 connect 进行一次封装，最后暴露 db 模块出去。\r\n\r\n### 封装 connect\r\n\r\n```js\r\nclass Db {\r\n  constructor() {\r\n    this.signIn = false;\r\n  }\r\n  connect() {\r\n    if (this.signIn) {\r\n      return Promise.resolve(true);\r\n    }\r\n    return new Promise((resolve) => {\r\n      setTimeout(() => {\r\n        this.signIn = true;\r\n        resolve(true);\r\n      }, 3000);\r\n    });\r\n  }\r\n  async queue(str) {\r\n    if (!this.signIn) {\r\n      throw new Error(`必须连接数据库才能使用queue！`);\r\n    }\r\n    console.log(str);\r\n  }\r\n}\r\nconst proxyDb = (() => {\r\n  const db = new Db();\r\n  let sign = false;\r\n  return async () => {\r\n    if (!sign) {\r\n      sign = await db.connect();\r\n    }\r\n    return db;\r\n  };\r\n})();\r\nconst app = async () => {\r\n  const db = await proxyDb();\r\n  await db.queue('xxx');\r\n};\r\napp();\r\n```\r\n\r\n使用一个代理将 `connect` 进行缓存起来，确保执行一次，后续使用直接 await 调用。\r\n\r\n不过这种方法虽然实现简单，但是体验只能说一般，有没有更加优雅的方法呢？\r\n\r\n### 预先队列\r\n\r\n观察上面 db 的操作，可以看到两部分\r\n\r\n- 登录操作\r\n- 依赖登录操作的后续\r\n\r\n我们可以把需要依赖登录的操作进行一个封装，如果没有登录就 push 到队列中，等到登录的时候进行一个整体的执行。\r\n\r\n```js\r\nclass Db {\r\n  constructor() {\r\n    this.signIn = false;\r\n    this.list = [];\r\n  }\r\n  connect() {\r\n    if (this.signIn) {\r\n      return Promise.resolve(true);\r\n    }\r\n    return new Promise((resolve) => {\r\n      setTimeout(() => {\r\n        this.signIn = true;\r\n        this.list.forEach((fn) => fn());\r\n        this.list = [];\r\n        resolve(true);\r\n      }, 3000);\r\n    });\r\n  }\r\n  queue(str) {\r\n    return new Promise((resolve) => {\r\n      const fn = () => {\r\n        console.log(str);\r\n        resolve(undefined);\r\n      };\r\n      if (this.signIn) {\r\n        return fn();\r\n      }\r\n      this.list.push(fn);\r\n    });\r\n  }\r\n}\r\nconst db = new Db();\r\ndb.connect();\r\nconst app = async () => {\r\n  await db.queue('xxx');\r\n};\r\napp();\r\n```\r\n\r\n- 在直接执行 `queue` 的时候状态还没有登录，添加到 `list` 中；\r\n- `connect` 执行成功，释放队列的值\r\n\r\n### 预先队列状态分离\r\n\r\n上述的要求我们实现了，但是后面如果还有其他的方法，例如 `toArray`、`findOne` 等方法，一个个写重复的步骤太繁琐了。\r\n\r\n按照设计模式单一原则，我们尝试进行分离一下\r\n\r\n- 执行 db 相关的操作只执行这部分\r\n- 对未登录状态的操作进行一个统一拦截\r\n\r\n这部分拦截可以基于 ES6 的 `proxy`，也可以是 class 的 `extends`，这里采用 extends 的方式来进行。\r\n\r\n```js\r\nclass Db {\r\n  constructor() {\r\n    this.signIn = false;\r\n  }\r\n  connect() {\r\n    if (this.signIn) {\r\n      return Promise.resolve(true);\r\n    }\r\n    return new Promise((resolve) => {\r\n      setTimeout(() => {\r\n        this.signIn = true;\r\n        resolve(true);\r\n      }, 3000);\r\n    });\r\n  }\r\n  async queue(str) {\r\n    console.log(str);\r\n  }\r\n}\r\nclass ProxyDb extends Db {\r\n  constructor() {\r\n    super();\r\n    this.list = [];\r\n    ['queue'].forEach((item) => {\r\n      this[item] = (...rest) => {\r\n        return new Promise((resolve) => {\r\n          const fn = () => {\r\n            const result = super[item].apply(this, rest);\r\n            return resolve(result);\r\n          };\r\n          if (!super.signIn) {\r\n            this.list.push(fn);\r\n            return;\r\n          }\r\n          fn();\r\n        });\r\n      };\r\n    });\r\n  }\r\n  async connect() {\r\n    await super.connect();\r\n    this.list.forEach((fn) => fn());\r\n  }\r\n}\r\nconst db = new ProxyDb();\r\ndb.connect();\r\ndb.queue('xxx');\r\n```\r\n\r\n通过继承重写 `connect` 操作，在 `constructor` 阶段把需要代理的方法手写到子类中，最后利用 Promise 的特性，等待 `connect `完成之后 `resolve`。\r\n\r\n### 顶层 await\r\n\r\n除了上述的两种方法，ES6 的最新 `顶层 await` 也可以帮助实现效果，顶层 await 是为了解决模块异步加载问题，对于本文刚好可以用到。\r\n\r\n我们之所以要对 `db` 模块 进行缓存和队列等一系列操作，就是因为初始化这部分我们没办法完成前置，不能像读取配置文件一样通过同步 api 语法完成。\r\n\r\n但是顶层 await 的出现，让其有一种同步的语法完成这部分工作。\r\n\r\n```js\r\nclass Db {\r\n  constructor() {\r\n    this.signIn = false;\r\n  }\r\n  connect() {\r\n    if (this.signIn) {\r\n      return Promise.resolve(true);\r\n    }\r\n    return new Promise((resolve) => {\r\n      setTimeout(() => {\r\n        this.signIn = true;\r\n        resolve(true);\r\n      }, 3000);\r\n    });\r\n  }\r\n  async queue(str) {\r\n    if (!this.signIn) {\r\n      throw new Error(`必须连接数据库才能使用queue！`);\r\n    }\r\n    console.log(str);\r\n  }\r\n}\r\n```\r\n\r\n这是最初我们的 db 模块，使用顶层 await 只需要，直接 `import` 后\r\n\r\n```js\r\nconst db = new Db();\r\nawait db.connect();\r\nawait db.queue('xxx');\r\n```\r\n\r\n## 最后\r\n\r\n抛砖引玉聊了初始化加载可能遇到的情况，受限于聊天的方向，很多异常情况没有给予考虑，例如数据库如果连接操作，需要手动对队列的操作进行 `reject` 的错误抛出。\r\n\r\n最后如果文章有什么错误或者错别字欢迎指出。\r\n\r\n> 参考：\r\n>\r\n> - [顶层 await](https://es6.ruanyifeng.com/#docs/async#%E9%A1%B6%E5%B1%82-await)\r\n> - [ECMAScript proposal: Top-level `await`](https://github.com/tc39/proposal-top-level-await)\r\n",
          "reactions": {
            "url": "https://api.github.com/repos/bosens-China/blog/issues/83/reactions",
            "total_count": 0,
            "+1": 0,
            "-1": 0,
            "laugh": 0,
            "hooray": 0,
            "confused": 0,
            "heart": 0,
            "rocket": 0,
            "eyes": 0
          },
          "timeline_url": "https://api.github.com/repos/bosens-China/blog/issues/83/timeline",
          "performed_via_github_app": null,
          "state_reason": null
        },
        {
          "url": "https://api.github.com/repos/bosens-China/blog/issues/86",
          "repository_url": "https://api.github.com/repos/bosens-China/blog",
          "labels_url": "https://api.github.com/repos/bosens-China/blog/issues/86/labels{/name}",
          "comments_url": "https://api.github.com/repos/bosens-China/blog/issues/86/comments",
          "events_url": "https://api.github.com/repos/bosens-China/blog/issues/86/events",
          "html_url": "https://github.com/bosens-China/blog/issues/86",
          "id": 1085665053,
          "node_id": "I_kwDOCzPAy85Ate8d",
          "number": 86,
          "title": "漫谈异步函数执行的前世今生",
          "user": {
            "login": "bosens-China",
            "id": 39508895,
            "node_id": "MDQ6VXNlcjM5NTA4ODk1",
            "avatar_url": "https://avatars.githubusercontent.com/u/39508895?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/bosens-China",
            "html_url": "https://github.com/bosens-China",
            "followers_url": "https://api.github.com/users/bosens-China/followers",
            "following_url": "https://api.github.com/users/bosens-China/following{/other_user}",
            "gists_url": "https://api.github.com/users/bosens-China/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/bosens-China/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/bosens-China/subscriptions",
            "organizations_url": "https://api.github.com/users/bosens-China/orgs",
            "repos_url": "https://api.github.com/users/bosens-China/repos",
            "events_url": "https://api.github.com/users/bosens-China/events{/privacy}",
            "received_events_url": "https://api.github.com/users/bosens-China/received_events",
            "type": "User",
            "site_admin": false
          },
          "labels": [
            {
              "id": 1371686608,
              "node_id": "MDU6TGFiZWwxMzcxNjg2NjA4",
              "url": "https://api.github.com/repos/bosens-China/blog/labels/%E6%BC%AB%E8%B0%88%E7%B3%BB%E5%88%97",
              "name": "漫谈系列",
              "color": "e7f3ee",
              "default": false,
              "description": "浅谈类文章"
            }
          ],
          "state": "open",
          "locked": false,
          "assignee": null,
          "assignees": [],
          "milestone": null,
          "comments": 0,
          "created_at": "2021-12-21T10:17:10Z",
          "updated_at": "2021-12-23T05:42:51Z",
          "closed_at": null,
          "author_association": "OWNER",
          "active_lock_reason": null,
          "body": "今天简单聊聊异步函数的演变史，不着重讲解语法本身，而是借此窥探一下演变过程，以及是基于什么原因一步步推进。\r\n\r\n## 回调函数\r\n\r\n回调函数是最简单处理异步的方式，之所以会有回调函数原因在于 `JavaScript` 是单线程的语言，如果遇到 io 输入就会阻塞在这里，体验感受较差，为了不影响性能刻意设计。\r\n\r\n当然回调函数本身不是问题，例如我们点击提交按钮，在 `jQuery` 可能会这样写\r\n\r\n```js\r\n$(\".btn\").on(\"click\", () => {\r\n  // 验证通过，执行发送\r\n  $.ajax({\r\n    url: url,\r\n    data: data,\r\n    success: success,\r\n    dataType: dataType,\r\n  });\r\n});\r\n```\r\n\r\n可以看到，在功能简单的情况下使用回调函数是最简洁的写法。\r\n\r\n回调函数的问题在于需求的不断扩充，使得我们在回调函数不停的嵌套，且还要在每层考虑抛出异常的情况，想想就让人头大。\r\n\r\n```js\r\nfn1(fn2(fn3(fn4())));\r\n```\r\n\r\n下面通过一个爬虫例子举例，我们需要获取某网站列表字段还有每个列表对应的详情字段。\r\n\r\n```js\r\nconst request = require(\"request\");\r\n\r\nconst reptile = (fn) => {\r\n  request(\"xxx/list\", function (error, response, body) {\r\n    if (error) {\r\n      return fn(error);\r\n    }\r\n    request(\"xxx/details\", function (err, res, data) {\r\n      if (error) {\r\n        return fn(error);\r\n      }\r\n      fn(body, data);\r\n    });\r\n  });\r\n};\r\n```\r\n\r\n首先我们看上面这段代码，因为是只请求两次所以看起来不算混乱，不过也可以发现两处问题：\r\n\r\n- 回调函数内的命名，按照好的做法不应当存在遮蔽现象，内部的代码覆盖外层的变量，这样会导致引用和歧义\r\n- 代码在朝这 `>>>` 的形式拓展\r\n\r\n当然也可以通过职责分离来进行一定程度的缓解，例如上面代码我们把爬取列表和爬取详情分离开，通过一个主函数来进行组装，不过这样的作法也只是缓解，当程序越来越庞大维护和调试的成本也会越来越高。\r\n\r\n## Promise\r\n\r\n`Promise` 是社区为了解决回调问题而出现的提案，`ES6` 的时候将其吸收到规范内，变成了语言内置的特性。\r\n为了保持跟之前代码兼容，现在 Promise 的检测都是基于`.then`方法。\r\n\r\n在说 Promise 之前，我们来回忆一下它的特性\r\n\r\n- Promise 创建之后不可取消\r\n- Promise 只有三种状态：进行、完成和失败，状态变更后不会改变\r\n- Promise 可以随时 `.then`，每次 then 都返回一个新的 Promise 实例\r\n\r\n上面的特性总结下来就是给我们一个统一的处理机制，可以随时调用不用担心错过，这个在回调函数是可能发生的，例如一个事件没有初始监听，在发生之后监听是不会监听到的。\r\n\r\n还是拿上面的爬虫例子，看基于 Promise 写是不是更优雅一些\r\n\r\n```js\r\nconst rp = require(\"request-promise\");\r\n// 这里Promise原本的库不支持，所以改用一下Promise版本\r\nconst reptile = () => {\r\n  return rp(\"xxx/list\").then((listData) => {\r\n    return rp(\"xxx/details\").then((detailsData) => {\r\n      return {\r\n        listData,\r\n        detailsData,\r\n      };\r\n    });\r\n  });\r\n};\r\nreptile()\r\n  .then((res) => {\r\n    console.log(res);\r\n  })\r\n  .catch((err) => {\r\n    console.log(err);\r\n  });\r\n```\r\n\r\n观察上面代码，可以明显看到\r\n\r\n- 改善了`>>>`之前横向代码的发展，结构更加清晰\r\n- 拥有了统一的错误处理，在请求列表如果失败，后续的.then 也不会执行\r\n\r\n而且 Promise 包装起来也十分简单，下面以 wait 函数为例\r\n\r\n```js\r\nconst wait = (time) => new Promise((resolve) => setTimeout(resolve, time));\r\n```\r\n\r\n不过 Promise 也不完全都是优点，例如它只是把代码的书写结构从`>>>`变成往下的延伸，代码结构多起来也是挺糟心。\r\n\r\n## Generator\r\n\r\n`Generator` 是 ES6 新出现的 API，它的出现解决了两个问题：\r\n\r\n- 给 Symbol.iterator 提供了简单的实现\r\n- 给异步变成提供了新的思路\r\n\r\n我们重点聊一聊第二点，还是上面的爬虫例子，看下用 Generator 应当如何书写，为了省去一些写执行器的过程，这里直接结合`co`模块进行书写。\r\n\r\n> 如果对这部分感兴趣，可以点击了解[Generator 函数的异步应用](https://es6.ruanyifeng.com/#docs/generator-async)，里面会一步步包含如何实现一个简单执行器。\r\n\r\n```js\r\nconst rp = require(\"request-promise\");\r\n// 这里Promise原本的库不支持，所以改用一下Promise版本\r\nconst co = require(\"co\");\r\nfunction* getList() {\r\n  return rp(\"xxx/list\");\r\n}\r\nfunction* getDetails() {\r\n  return rp(\"xxx/details\");\r\n}\r\nfunction* peptile() {\r\n  const listData = yield getList();\r\n  const detailsData = yield getDetails();\r\n  return {\r\n    listData,\r\n    detailsData,\r\n  };\r\n}\r\nco(peptile);\r\n```\r\n\r\n再来观察一下上面代码，是不是感觉已经接近同步函数的写法了，这就是 Generator 带来的影响。\r\n\r\n不过它的缺点也很明显，没有内置执行器，需要额外自己编写。\r\n\r\n## async\r\n\r\n`ES2017` 引用了 `async` 函数，它本身是 Generator 的语法糖，我们上面说 Generator 最大缺点就是没有自带执行器，async 函数出现弥补了这一缺陷。\r\n\r\n- 它本身自带执行器，await 执行的可以是任何表达式，不需要一定基于 Promise\r\n- 语法更加简洁，返回值是基于 Promise\r\n\r\n还是爬虫的例子，这次我们改用 async 函数书写\r\n\r\n```js\r\nconst rp = require(\"request-promise\");\r\n// 这里Promise原本的库不支持，所以改用一下Promise版本\r\nfunction getList() {\r\n  return rp(\"xxx/list\");\r\n}\r\nfunction getDetails() {\r\n  return rp(\"xxx/details\");\r\n}\r\nconst peptile = async () => {\r\n  const listData = await getList();\r\n  const detailsData = await getDetails();\r\n  return {\r\n    listData,\r\n    detailsData,\r\n  };\r\n};\r\n```\r\n\r\n从上面的代码不难看出 async 函数的出现，标志异步编程解决方案的最终成熟，结合 `babel` 现在就可以在低版本浏览器运行起来。\r\n\r\n不过 async 虽然很好，但是也有一些实现不了的点，例如讲 Promise 的时候 wait 函数，用 async 函数就是实现不了，在解决问题一定要零和组合。\r\n\r\n## 最后\r\n\r\n简单回顾了一下 js 的异步史：`回调 > Promise > Generator > async`。受限于篇幅并没有讲解太多，但是从异步的解决可以看到 JavaScript 正在走向成熟。\r\n\r\n最后如果这篇文章有什么错误欢迎指点，如果对你有帮助也可以`start`下。\r\n",
          "reactions": {
            "url": "https://api.github.com/repos/bosens-China/blog/issues/86/reactions",
            "total_count": 0,
            "+1": 0,
            "-1": 0,
            "laugh": 0,
            "hooray": 0,
            "confused": 0,
            "heart": 0,
            "rocket": 0,
            "eyes": 0
          },
          "timeline_url": "https://api.github.com/repos/bosens-China/blog/issues/86/timeline",
          "performed_via_github_app": null,
          "state_reason": null
        },
        {
          "url": "https://api.github.com/repos/bosens-China/blog/issues/36",
          "repository_url": "https://api.github.com/repos/bosens-China/blog",
          "labels_url": "https://api.github.com/repos/bosens-China/blog/issues/36/labels{/name}",
          "comments_url": "https://api.github.com/repos/bosens-China/blog/issues/36/comments",
          "events_url": "https://api.github.com/repos/bosens-China/blog/issues/36/events",
          "html_url": "https://github.com/bosens-China/blog/issues/36",
          "id": 522570348,
          "node_id": "MDU6SXNzdWU1MjI1NzAzNDg=",
          "number": 36,
          "title": "漫谈系统权限设计",
          "user": {
            "login": "bosens-China",
            "id": 39508895,
            "node_id": "MDQ6VXNlcjM5NTA4ODk1",
            "avatar_url": "https://avatars.githubusercontent.com/u/39508895?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/bosens-China",
            "html_url": "https://github.com/bosens-China",
            "followers_url": "https://api.github.com/users/bosens-China/followers",
            "following_url": "https://api.github.com/users/bosens-China/following{/other_user}",
            "gists_url": "https://api.github.com/users/bosens-China/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/bosens-China/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/bosens-China/subscriptions",
            "organizations_url": "https://api.github.com/users/bosens-China/orgs",
            "repos_url": "https://api.github.com/users/bosens-China/repos",
            "events_url": "https://api.github.com/users/bosens-China/events{/privacy}",
            "received_events_url": "https://api.github.com/users/bosens-China/received_events",
            "type": "User",
            "site_admin": false
          },
          "labels": [
            {
              "id": 1371686608,
              "node_id": "MDU6TGFiZWwxMzcxNjg2NjA4",
              "url": "https://api.github.com/repos/bosens-China/blog/labels/%E6%BC%AB%E8%B0%88%E7%B3%BB%E5%88%97",
              "name": "漫谈系列",
              "color": "e7f3ee",
              "default": false,
              "description": "浅谈类文章"
            }
          ],
          "state": "open",
          "locked": false,
          "assignee": null,
          "assignees": [],
          "milestone": null,
          "comments": 0,
          "created_at": "2019-11-14T01:35:53Z",
          "updated_at": "2021-12-21T09:48:35Z",
          "closed_at": null,
          "author_association": "OWNER",
          "active_lock_reason": null,
          "body": "> 这里不会介绍具体实现的方式，要根据公司的业务来进行调整，下面就聊一聊基本设计的思路。\r\n\r\n权限的设计对于一个后台来说至关重要，不过也要根据情况来选择，比如我们不会在一个博客或者个人网站的后台中写上权限控制，因为这是没有必要的，但是对于面向不同用户的产品来说就很有必要了，举个例子来说，滴滴打车的乘客和车主肯定是两个不同的用户产品，如何管理里面的数据就需要引用权限设计的功能了。\r\n\r\n权限设计可以帮助我们增加信息安全、保证页面的简洁不至于出现误操作的事情，下面就来说下基本的组成\r\n\r\n## 组成\r\n\r\n- 权限\r\n  ![](https://user-gold-cdn.xitu.io/2019/11/14/16e6786c0af135b6?w=1080&h=638&f=webp&s=9744)\r\n  权限这块可以分为页面权限、功能权限和数据权限，页面权限就是指是否能访问当前页面，功能权限对应的则是（增加、删除、修改等），而数据权限则是可以访问的数据范围。\r\n\r\n- 角色\r\n\r\n  在一个成熟的后台设计中必然要出现角色，这是为了避免每新增一个用户就还要重新为他勾选一遍权限，由角色赋值给用户权限，角色这层就相当于一个中间层，同时也方便维护。\r\n\r\n- 用户\r\n\r\n  每个用户对应一个账号，在默认状态下会给予用户一个最小的操作权限，权限的赋值由角色给予，多个角色的权限是可以叠加的。\r\n\r\n## 延伸\r\n\r\n上面介绍的其实就是`RBAC`模型的简单概念，在实际开发中觉得至少有以下几点需要注意：\r\n\r\n- admin\r\n\r\n在开发完成后需要在角色预留一个 admin 或者超级管理员，方便开发人员的维护\r\n\r\n- 权限的优先级\r\n\r\n上面介绍了权限的组成，但是页面的权限应当是大于操作的权限，只有页面的权限可见，功能的权限才是有意义的\r\n\r\n- tips\r\n\r\n无权限访问页面、页面不存在、服务器发生错误等方面的提示\r\n\r\n## 最后\r\n\r\n最后说一下前端对`tips`这块的处理\r\n403、404、500 的处理思路\r\n\r\n##### 500\r\n\r\n500 的处理可以通过`axions`的拦截器来实现，现在后端默认返回的基本格式都是\r\n\r\n```js\r\n{\r\n  // 状态码\r\n  status: 200,\r\n  data: {},\r\n  // ...\r\n  }\r\n```\r\n\r\n所以判断服务器发生错误，我们可以直接通过\r\n\r\n```js\r\n// 添加请求拦截器\r\naxios.interceptors.request.use(\r\n  function(config) {\r\n    // 在发送请求之前做些什么\r\n    return config;\r\n  },\r\n  function(error) {\r\n    // 对请求错误做些什么，这一步可以直接返回服务器发生错误，方便提示信息的定制\r\n    return Promise.reject(`服务器发生错误`);\r\n  }\r\n);\r\n```\r\n\r\n##### 404\r\n\r\n404 的实现可以通过`router`来实现，这里我用的是`vue router`就以这个举例，假设有一组路由为\r\n\r\n```js\r\nconst router = new VueRouter({\r\n  routes: [\r\n    {\r\n      path: \"/user\",\r\n      component: User,\r\n      children: [\r\n        {\r\n          path: \"profile\",\r\n          component: UserProfile\r\n        },\r\n        {\r\n          path: \"posts\",\r\n          component: UserPosts\r\n        }\r\n      ]\r\n    },\r\n    {\r\n      path: \"/sign\",\r\n      component: sign\r\n    }\r\n  ]\r\n});\r\n```\r\n\r\n那我们就通过递归将所有路由拼成一维数组（注意对比的条件，这里我对比的是 path 所以在递归过程中要将父 path 相加），具体的递归实现取决于你的常见，这里不做演示，之后对比访问的路径存不存在路由信息中，不存在则说明页面不存在返回`404`\r\n\r\n##### 403\r\n\r\n403 的实现需要配合后端来实现，一般情况下会请求用户的操作权限会返回当前用户权限所能操作的菜单，之后将能访问的菜单和路由信息对比，如果访问的路径在路由信息中但是不在用户返回的菜单说明没有页面访问的权限。\r\n\r\n最后说下为什么没有用`*`的原因，因为不太好定制，在默认状态下以`'/'`的形式访问我们要给予一个用户菜单的第一项，但是如果`'/'`不存在路由中我们还要写额外的判断，不如全部自己来自行处理了。\r\n\r\n## 参考\r\n\r\n1. [角色权限设计的 100 种解法](<https://mp.weixin.qq.com/s?__biz=MzI1ODY0NTg0MA==&mid=2247484799&idx=1&sn=5467e1452356e36607d938752805eb7d&chksm=ea044f40dd73c6563e72b1f34d0c27a23d06d5bcd80255568a9caa359ef2d03cd89713f0449b&scene=0&key=7fa4b6bcf3a05ff6a03f1d892329a3a1fcb4a9dd572857d0b82f72ec1386dfb5bd66a733158b657f4524063e1b5b4ade5442b1f23c89adbc9cfa818a68f64fbb4e725cc4baa55d048efe25d963e9e391&ascene=0&uin=MTAyMzI5NDA0Mw%3D%3D&devicetype=iMac+MacBookPro11%2C4+OSX+OSX+10.11.6+build(15G22010)&version=12020010&nettype=WIFI&lang=en&fontScale=100&pass_ticket=GR%2BJaO%2FEpgB4z%2BZuVHJsrM8QYhyiZAEBCQll6nnnN5CpbcQ%2FhZ5WoCr%2Fxr5QWiOL>)\r\n",
          "reactions": {
            "url": "https://api.github.com/repos/bosens-China/blog/issues/36/reactions",
            "total_count": 0,
            "+1": 0,
            "-1": 0,
            "laugh": 0,
            "hooray": 0,
            "confused": 0,
            "heart": 0,
            "rocket": 0,
            "eyes": 0
          },
          "timeline_url": "https://api.github.com/repos/bosens-China/blog/issues/36/timeline",
          "performed_via_github_app": null,
          "state_reason": null
        },
        {
          "url": "https://api.github.com/repos/bosens-China/blog/issues/2",
          "repository_url": "https://api.github.com/repos/bosens-China/blog",
          "labels_url": "https://api.github.com/repos/bosens-China/blog/issues/2/labels{/name}",
          "comments_url": "https://api.github.com/repos/bosens-China/blog/issues/2/comments",
          "events_url": "https://api.github.com/repos/bosens-China/blog/issues/2/events",
          "html_url": "https://github.com/bosens-China/blog/issues/2",
          "id": 473943664,
          "node_id": "MDU6SXNzdWU0NzM5NDM2NjQ=",
          "number": 2,
          "title": "漫谈ECMAScript有意思的设计",
          "user": {
            "login": "bosens-China",
            "id": 39508895,
            "node_id": "MDQ6VXNlcjM5NTA4ODk1",
            "avatar_url": "https://avatars.githubusercontent.com/u/39508895?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/bosens-China",
            "html_url": "https://github.com/bosens-China",
            "followers_url": "https://api.github.com/users/bosens-China/followers",
            "following_url": "https://api.github.com/users/bosens-China/following{/other_user}",
            "gists_url": "https://api.github.com/users/bosens-China/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/bosens-China/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/bosens-China/subscriptions",
            "organizations_url": "https://api.github.com/users/bosens-China/orgs",
            "repos_url": "https://api.github.com/users/bosens-China/repos",
            "events_url": "https://api.github.com/users/bosens-China/events{/privacy}",
            "received_events_url": "https://api.github.com/users/bosens-China/received_events",
            "type": "User",
            "site_admin": false
          },
          "labels": [
            {
              "id": 1371686608,
              "node_id": "MDU6TGFiZWwxMzcxNjg2NjA4",
              "url": "https://api.github.com/repos/bosens-China/blog/labels/%E6%BC%AB%E8%B0%88%E7%B3%BB%E5%88%97",
              "name": "漫谈系列",
              "color": "e7f3ee",
              "default": false,
              "description": "浅谈类文章"
            }
          ],
          "state": "open",
          "locked": false,
          "assignee": null,
          "assignees": [],
          "milestone": null,
          "comments": 0,
          "created_at": "2019-07-29T09:23:22Z",
          "updated_at": "2021-12-21T09:33:52Z",
          "closed_at": null,
          "author_association": "OWNER",
          "active_lock_reason": null,
          "body": "最近重读《你所不知道的 JavaScript》发现一些有趣的点，想分享下。\r\n\r\n## 块级作用域\r\n\r\nES6 引用了 let 和 const，这实际上带来了块级作用域，在 ES6 之前只存在全局作用域和函数作用域，相信小伙伴对这句话应当不陌生，下面就来聊聊一个 ES6 之前如果实现块级作用域。\r\n\r\n思考下面一个例子代码输出值为多少\r\n\r\n```js\r\nfor (var i = 0; i < 10; i++) {\r\n  setTimeout(function () {\r\n    console.log(i);\r\n  }, 100);\r\n}\r\n```\r\n\r\n这里会输出 10 个 10，因为只存在一个全局变量`i`，我们可以通过立即执行函数来解决这个问题\r\n\r\n```js\r\nfor (var i = 0; i < 10; i++) {\r\n  (function (i) {\r\n    setTimeout(function () {\r\n      console.log(i);\r\n    }, 100);\r\n  })(i);\r\n}\r\n```\r\n\r\n如果在 ES6 环境下还可以使用 let 命令解决，它会在每次循环的时候创建一个作用域，至于为什么能记住上一次的值，那是因为 js 引擎会记住上一次循环的值。\r\n\r\n```js\r\nfor (let i = 0; i < 10; i++) {\r\n  setTimeout(() => {\r\n    console.log(i);\r\n  }, 100);\r\n}\r\n```\r\n\r\n上面的例子帮我们回顾一下没有块级作用域的痛苦之一，实际上我们写项目的时候可能早早的就使用了`babel`，它会通过怎么样的形式将`let`和`const`转化为支持 ES5 的环境呢？\r\n\r\n先看下面一个例子\r\n\r\n```js\r\ntry {\r\n  throw 5;\r\n} catch (e) {\r\n  console.log(e);\r\n}\r\nconsole.log(e); //error e is not defined\r\n```\r\n\r\n这里 try 会创建一个块级作用域，在全局环境下 a 不存在，所以报错了。\r\n聪明的小伙伴可能已经想到了，可以使用 try 来创建块级作用域，理论上是可行的，不过实际上有两点问题\r\n\r\n1. 性能太慢\r\n2. 语法丑陋，要显示的报错\r\n\r\n我们来看下`babel`怎么处理上面的例子\r\n\r\n```js\r\n'use strict';\r\n\r\nvar _loop = function _loop(i) {\r\n  setTimeout(function () {\r\n    console.log(i);\r\n  }, 100);\r\n};\r\n\r\nfor (var i = 0; i < 10; i++) {\r\n  _loop(i);\r\n}\r\n```\r\n\r\n可以看到与立即执行函数基本相同，不过使用立即执行函数创建块级作用域需要注意一点`this`的指向。\r\n\r\n例如这个例子\r\n\r\n```js\r\nconst obj = {\r\n  foo() {\r\n    for (let i = 0; i < 5; i += 1) {\r\n      setTimeout(() => {\r\n        console.log(this.arr[i]);\r\n      }, 1000);\r\n    }\r\n  },\r\n  arr: [1, 2, 3, 4, 5],\r\n};\r\n```\r\n\r\n箭头函数没有自己的 this 对象，是定义时的对象而不是运行时的对象，在这个例子中指向的是 obj；\r\n如果要把上面的代码转化为 ES5 环境支持的代码，我们可以通过作用域的规则来实现\r\n\r\n```js\r\n(function () {\r\n  var _this = this;\r\n  setTimeout(function () {\r\n    console.log(_this.arr[i]);\r\n  }, 1000);\r\n})();\r\n```\r\n\r\n上面就实现了所需的功能\r\n\r\n## 隐藏的 global 对象\r\n\r\n下面代码假设环境为浏览器环境，JavaScript 有许多设计缺陷，其中不使用声明声明变量，会自动将变量创建在`global`上就是其一，不过下面就来漫谈特殊的`global`对象\r\n\r\n```js\r\nvar a = 10;\r\nb = 20;\r\nwindow.a; //10\r\nwindow.b; //20\r\n```\r\n\r\n### index.html\r\n\r\n创建一个带有 id 的 DOM 元素，html 内的 id 元素也会自动反映在`global`对象上，例如下面\r\n\r\n```html\r\n<div id=\"div\"></div>\r\n<script>\r\n  console.log(typeof div); //object\r\n</script>\r\n```\r\n\r\n通过`id`的 DOM 元素，可以直接使用 DOM 上的一些方法，算是一个奇淫巧技\r\n\r\n```js\r\nconsole.log(div.nodeType); //1\r\nconsole.log(div.nodeName); //DIV\r\n//...\r\n```\r\n\r\n不过应该避免使用 id 的 DOM 元素，不易于代码的可读性，更推荐使用标准获取 dom 的方法。\r\n最后提示一点，如果存在相同的`id`dom，css 代码会作用两个相同的元素\r\n",
          "reactions": {
            "url": "https://api.github.com/repos/bosens-China/blog/issues/2/reactions",
            "total_count": 0,
            "+1": 0,
            "-1": 0,
            "laugh": 0,
            "hooray": 0,
            "confused": 0,
            "heart": 0,
            "rocket": 0,
            "eyes": 0
          },
          "timeline_url": "https://api.github.com/repos/bosens-China/blog/issues/2/timeline",
          "performed_via_github_app": null,
          "state_reason": null
        }
      ]
    ],
    [
      "1740577858",
      [
        {
          "url": "https://api.github.com/repos/bosens-China/blog/issues/95",
          "repository_url": "https://api.github.com/repos/bosens-China/blog",
          "labels_url": "https://api.github.com/repos/bosens-China/blog/issues/95/labels{/name}",
          "comments_url": "https://api.github.com/repos/bosens-China/blog/issues/95/comments",
          "events_url": "https://api.github.com/repos/bosens-China/blog/issues/95/events",
          "html_url": "https://github.com/bosens-China/blog/issues/95",
          "id": 1520334523,
          "node_id": "I_kwDOCzPAy85anna7",
          "number": 95,
          "title": "monorepo 如何解决别名问题",
          "user": {
            "login": "bosens-China",
            "id": 39508895,
            "node_id": "MDQ6VXNlcjM5NTA4ODk1",
            "avatar_url": "https://avatars.githubusercontent.com/u/39508895?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/bosens-China",
            "html_url": "https://github.com/bosens-China",
            "followers_url": "https://api.github.com/users/bosens-China/followers",
            "following_url": "https://api.github.com/users/bosens-China/following{/other_user}",
            "gists_url": "https://api.github.com/users/bosens-China/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/bosens-China/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/bosens-China/subscriptions",
            "organizations_url": "https://api.github.com/users/bosens-China/orgs",
            "repos_url": "https://api.github.com/users/bosens-China/repos",
            "events_url": "https://api.github.com/users/bosens-China/events{/privacy}",
            "received_events_url": "https://api.github.com/users/bosens-China/received_events",
            "type": "User",
            "site_admin": false
          },
          "labels": [
            {
              "id": 1740577858,
              "node_id": "MDU6TGFiZWwxNzQwNTc3ODU4",
              "url": "https://api.github.com/repos/bosens-China/blog/labels/%E5%B7%A5%E5%85%B7%E7%9B%B8%E5%85%B3",
              "name": "工具相关",
              "color": "f73d62",
              "default": false,
              "description": "工程化相关的东西"
            }
          ],
          "state": "open",
          "locked": false,
          "assignee": null,
          "assignees": [],
          "milestone": null,
          "comments": 0,
          "created_at": "2023-01-05T08:43:30Z",
          "updated_at": "2023-01-05T08:43:30Z",
          "closed_at": null,
          "author_association": "OWNER",
          "active_lock_reason": null,
          "body": "得益于 pnpm 软链接实现现在 monorepo 项目已经十分成熟了，不过在写项目时候还是遇到很多痛点，例如：\r\n\r\n1. 如果我有多个 packages 项目并且使用 TypeScript，那么我肯定希望是写的都是 ts，在需要调用的时候通过工具来完成这一过程的转译，不过在实际开发中可能使用了 vite 这样的工具，导致遇到问题只能通过其它方式来绕过去；\r\n2. 如果写一个后端项目，那么数据库定义的模型描述肯定希望在 web 项目也可以复用，不过在多入口中可能还需要通过 `@new-house/src/xxxx.ts` 来引用，这个 `src/xxx` 也太不简洁了。\r\n\r\n所以这篇文章重点就是解决问题 2 ，问题 1 如果有机会再单独开一个篇幅来说，在正式讲解之前需要介绍一下 `exports` 这个属性\r\n\r\n## exports\r\n\r\n这个属性添加于 v12.7.0，最简单的使用方式如下\r\n\r\n```js\r\n{\r\n  // package.json\r\n  \"exports\": \"./index.js\"\r\n}\r\n```\r\n\r\n它的优先级高于 `main`，除此之外更多是作为不同环境导入文件来使用，例如开发了一个 utils 的包希望它可以在 node 的 cjs 和 ems 环境下工作，那么它就可以发挥作用了。\r\n\r\n```js\r\n{\r\n  \"exports\": {\r\n    \".\": {\r\n      \"import\": \"./feature-node.mjs\",\r\n      \"require\": \"./feature-node.cjs\"\r\n    },\r\n  }\r\n}\r\n```\r\n\r\n除此之外还可以解决目录别名问题，这也是为什么介绍它的原因\r\n\r\n```js\r\n{\r\n  \"name\": \"my-package\",\r\n  \"exports\": {\r\n    \".\": \"./lib/index.js\",\r\n    \"./lib\": \"./lib/index.js\",\r\n    \"./lib/*\": \"./lib/*.js\",\r\n    \"./lib/*.js\": \"./lib/*.js\",\r\n    \"./feature\": \"./feature/index.js\",\r\n    \"./feature/*\": \"./feature/*.js\",\r\n    \"./feature/*.js\": \"./feature/*.js\",\r\n    \"./package.json\": \"./package.json\"\r\n  }\r\n}\r\n```\r\n\r\n上面的 ` \"./feature/*\": \"./feature/*.js\",` 以及 `\"./feature/*.js\": \"./feature/*.js\",` 等都可以通过 `my-package/feature/xxx.js` 来完成调用\r\n\r\nexports 就介绍到这里，了解到它可以适配不同环境以及用于解决目录别名，下面就是项目实战。\r\n\r\n## TypeScript 下使用\r\n\r\n为了方便，这里我已经搭建好了一个 pnpm monorepo 项目，它的文件结构如下\r\n\r\n```sh\r\ntest\r\n├─ node_modules\r\n├─ package.json\r\n├─ packages\r\n│    ├─ utils\r\n│    │    ├─ package.json\r\n│    │    ├─ src\r\n│    │    │    ├─ addition.ts\r\n│    │    │    └─ subtraction.ts\r\n│    │    └─ tsconfig.json\r\n│    └─ web\r\n│           ├─ babel.config.js\r\n│           ├─ dist\r\n│           │    └─ index.js\r\n│           ├─ node_modules\r\n│           ├─ package.json\r\n│           ├─ src\r\n│           │    └─ index.ts\r\n│           ├─ tsconfig.json\r\n│           └─ webpack.config.js\r\n├─ pnpm-lock.yaml\r\n├─ pnpm-workspace.yaml\r\n└─ tsconfig.json\r\n```\r\n\r\nutils 这个项目用于给 web 项目使用，它的 package.json 内容如下\r\n\r\n```js\r\n{\r\n  \"name\": \"@test/utils\",\r\n  \"version\": \"1.0.0\",\r\n  \"exports\": {\r\n    \"./*\": \"./src/*.ts\"\r\n  }\r\n}\r\n```\r\n\r\n这里设置 `\"./*\"` 是提示这个为一个子目录别名，同理你也可以设置 `\"test/*\"` 表示以 test 为开头，因为 utils 这个项目都是 ts 我并不想花时间每次都 build 一遍成 js 所以只能写成 `./src/*.ts`\r\n\r\n> 这里提示一下，如果是 ts 项目必须这个结尾，否则会提示找不到类型文件\r\n\r\n第二步就是在 web 项目中引用\r\n\r\n```js\r\n// web/src/index.ts\r\nimport addition from '@test/utils/addition';\r\nimport subtraction from '@test/utils/subtraction';\r\n\r\nconsole.log(addition(1, 1));\r\nconsole.log(subtraction(1, 1));\r\n```\r\n\r\n> 如果 TypeScript 提示说不到模块之类的错误，那么你需要调整一下 tsconfig.json 的配置\r\n>\r\n> ```json\r\n> {\r\n>   \"compilerOptions\": {\r\n>     \"moduleResolution\": \"NodeNext\" // node 16也可以\r\n>   }\r\n> }\r\n> ```\r\n\r\n这样就消除了闹心的 src 目录\r\n\r\n## 其它问题\r\n\r\n### TypeScript 使用别名如何定义类型文件\r\n\r\n这个可以参考官方文档的实现\r\n\r\n```json\r\n// package.json\r\n{\r\n  \"name\": \"my-package\",\r\n  \"type\": \"module\",\r\n  \"exports\": {\r\n    \".\": {\r\n      // Entry-point for TypeScript resolution - must occur first!\r\n      \"types\": \"./types/index.d.ts\",\r\n      // Entry-point for `import \"my-package\"` in ESM\r\n      \"import\": \"./esm/index.js\",\r\n      // Entry-point for `require(\"my-package\") in CJS\r\n      \"require\": \"./commonjs/index.cjs\"\r\n    }\r\n  },\r\n  // CJS fall-back for older versions of Node.js\r\n  \"main\": \"./commonjs/index.cjs\",\r\n  // Fall-back for older versions of TypeScript\r\n  \"types\": \"./types/index.d.ts\"\r\n}\r\n```\r\n\r\n额外在 exports 中添加 types 属性，相关讨论链接 https://github.com/microsoft/TypeScript/issues/33079#issuecomment-598961442\r\n\r\n### 设置了 moduleResolution 导致导入其它模块必须以.js 结尾\r\n\r\n以.js 结尾是规范的规定，如果你使用 webpack5 来打包项目可以在配置文件中添加以下内容\r\n\r\n```js\r\n{\r\n  resolve: {\r\n    extensionAlias: {\r\n      \".js\": [\".ts\", \".js\"],\r\n      \".cjs\": [\".cts\", \".cjs\"],\r\n      \".mjs\": [\".mts\", \".mjs\"],\r\n    }\r\n    // ...\r\n  }\r\n  // ...\r\n}\r\n```\r\n\r\n相关问题链接 [Support TypeScript module resolution `node16` · Issue #12625 · facebook/create-react-app (github.com)](https://github.com/facebook/create-react-app/issues/12625)\r\n\r\n## 参考链接\r\n\r\n- [模块：包|节点.js v19.3.0 文档 (nodejs.org)](https://nodejs.org/api/packages.html#subpath-imports)\r\n- [TypeScript： Documentation - ECMAScript Modules in Node.js (typescriptlang.org)](https://www.typescriptlang.org/docs/handbook/esm-node.html)\r\n- [Module 的加载实现 - ECMAScript 6 入门 (ruanyifeng.com)](https://es6.ruanyifeng.com/#docs/module-loader)\r\n",
          "reactions": {
            "url": "https://api.github.com/repos/bosens-China/blog/issues/95/reactions",
            "total_count": 1,
            "+1": 1,
            "-1": 0,
            "laugh": 0,
            "hooray": 0,
            "confused": 0,
            "heart": 0,
            "rocket": 0,
            "eyes": 0
          },
          "timeline_url": "https://api.github.com/repos/bosens-China/blog/issues/95/timeline",
          "performed_via_github_app": null,
          "state_reason": null
        },
        {
          "url": "https://api.github.com/repos/bosens-China/blog/issues/93",
          "repository_url": "https://api.github.com/repos/bosens-China/blog",
          "labels_url": "https://api.github.com/repos/bosens-China/blog/issues/93/labels{/name}",
          "comments_url": "https://api.github.com/repos/bosens-China/blog/issues/93/comments",
          "events_url": "https://api.github.com/repos/bosens-China/blog/issues/93/events",
          "html_url": "https://github.com/bosens-China/blog/issues/93",
          "id": 1254826397,
          "node_id": "I_kwDOCzPAy85KyyGd",
          "number": 93,
          "title": "nginx 极简入门",
          "user": {
            "login": "bosens-China",
            "id": 39508895,
            "node_id": "MDQ6VXNlcjM5NTA4ODk1",
            "avatar_url": "https://avatars.githubusercontent.com/u/39508895?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/bosens-China",
            "html_url": "https://github.com/bosens-China",
            "followers_url": "https://api.github.com/users/bosens-China/followers",
            "following_url": "https://api.github.com/users/bosens-China/following{/other_user}",
            "gists_url": "https://api.github.com/users/bosens-China/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/bosens-China/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/bosens-China/subscriptions",
            "organizations_url": "https://api.github.com/users/bosens-China/orgs",
            "repos_url": "https://api.github.com/users/bosens-China/repos",
            "events_url": "https://api.github.com/users/bosens-China/events{/privacy}",
            "received_events_url": "https://api.github.com/users/bosens-China/received_events",
            "type": "User",
            "site_admin": false
          },
          "labels": [
            {
              "id": 1740577858,
              "node_id": "MDU6TGFiZWwxNzQwNTc3ODU4",
              "url": "https://api.github.com/repos/bosens-China/blog/labels/%E5%B7%A5%E5%85%B7%E7%9B%B8%E5%85%B3",
              "name": "工具相关",
              "color": "f73d62",
              "default": false,
              "description": "工程化相关的东西"
            }
          ],
          "state": "open",
          "locked": false,
          "assignee": null,
          "assignees": [],
          "milestone": null,
          "comments": 0,
          "created_at": "2022-06-01T03:35:30Z",
          "updated_at": "2022-06-01T03:35:30Z",
          "closed_at": null,
          "author_association": "OWNER",
          "active_lock_reason": null,
          "body": "nginx（读音：engine-x，音标：[ˈendʒɪnks']）是 HTTP 和反向代理服务器、邮件代理服务器和通用 TCP/UDP 代理服务器。\r\n\r\n日常中最经常听到用到的就是反向代理以及负载均衡，那么什么是反向代理呢？\r\n\r\n## 什么是反向代理？\r\n\r\n![reverse-proxy](https://user-images.githubusercontent.com/39508895/171322376-dc12836e-435a-44c1-b3c8-cfdc3f8c4293.png)\r\n\r\n\r\n反向代理（Reverse Proxy）是指以代理服务器来接受 internet（ˈɪntəˌnɛt） 上的连接请求，然后将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给 internet 上请求连接的客户端，此时代理服务器对外就表现为一个反向代理服务器。\r\n\r\n简单概括就是有一个中转服务器来转发你的请求，那么使用反向代理有什么好处呢？\r\n\r\n- 隐藏真实的服务地址\r\n- 节省 ip 资源，公共的 ip 地址是有限的，反向代理可以解决此问题\r\n\r\n### nginx 中如何配置反向代理？\r\n\r\n在 nginx 中通过指定 proxy_pass（ˈprɒksi pɑːs） 即可完成请求转发到指定服务器\r\n\r\n```nginx\r\n# 省略其他配置\r\n\r\nserver {\r\n  listen       80;\r\n  server_name  www.helloworld.com;\r\n\r\n  location /app1/ {\r\n    proxy_pass http://api_server;\r\n    rewrite \"^/app1/(.*)$\" /$1 break;\r\n  }\r\n\r\n  location /app2/ {\r\n    proxy_pass http://api_server;\r\n  }\r\n}\r\n```\r\n\r\n上面的两种形式是最长使用的场景。\r\n\r\n假设访问 `www.helloworld.com/api1/user/1`，那么真实请求的是 `http://api_server/user/1`；\r\n\r\n而如果访问` www.helloworld.com/api2/user/2`，真实请求地址为 `http://api_server/app2/user/2`。\r\n\r\n上面的 `rewrite（ˈriːraɪt）` 是重写请求地址，而 `(.*)` 代表正则的组匹配，$1 是获取 `()` 的内容，同理如果存在多个 `()` 还可以通过$2,$3 的形式来简写。\r\n\r\n### 与 dev 开发对比\r\n\r\n而在真实的开发中（可能是通过 webpack 或者 vite 这样的工具），为了解决跨域问题，我们也会引入反向代理，例如如下配置：\r\n\r\n```js\r\nexport default defineConfig({\r\n  server: {\r\n    proxy: {\r\n      // 字符串简写写法\r\n      '/foo': 'http://localhost:4567',\r\n      // 选项写法\r\n      '/api': {\r\n        target: 'http://jsonplaceholder.typicode.com',\r\n        changeOrigin: true,\r\n        rewrite: (path) => path.replace(/^\\/api/, ''),\r\n      },\r\n    },\r\n  },\r\n});\r\n```\r\n\r\n所以综上所述，反向代理我们一直在使用可能你并没有觉察到。\r\n\r\n## 什么是负载均衡？\r\n\r\n负载均衡（Load Balance）这个词经常会听到，它的作用就是分摊到多个操作单元上进行执行。\r\n\r\n概念还是不太明显，举一个例子，如果有一个网站 `www.helloworld.com`，正常情况下它的 web 架构如下\r\n![demo1](https://pic3.zhimg.com/80/v2-6a7f624cd5e776a6b0b05a051e65666e_720w.jpg)\r\n这里如果服务器宕机了或者达到访问上限就会出现没办法访问情况。\r\n\r\n那么负载均衡如何解决如上问题呢？\r\n\r\n### 负载均衡如何解决\r\n\r\n\r\n\r\n在后端引入一个负载均衡器和一台额外的 web 服务器就可以缓解这种情况（注意，这里的 web 服务会提供一致的服务）。\r\n\r\n所以负载均衡的作用就是在于分流，而像上面部署两台或者以上的 web 服务，我们称为集群。\r\n\r\n下面看一个 nginx 的负载均衡例子，作为额外知识点补充\r\n\r\n### nginx 负载均衡示例\r\n\r\n```nginx\r\nhttp {\r\n     #设定mime类型,类型由mime.type文件定义\r\n    include       /etc/nginx/mime.types;\r\n    default_type  application/octet-stream;\r\n    #设定日志格式\r\n    access_log    /var/log/nginx/access.log;\r\n\r\n    #设定负载均衡的服务器列表\r\n    upstream load_balance_server {\r\n        #weigth参数表示权值，权值越高被分配到的几率越大\r\n        server 192.168.1.11:80   weight=5;\r\n        server 192.168.1.12:80   weight=1;\r\n        server 192.168.1.13:80   weight=6;\r\n    }\r\n\r\n   #HTTP服务器\r\n   server {\r\n        #侦听80端口\r\n        listen       80;\r\n\r\n        #定义使用www.xx.com访问\r\n        server_name  www.helloworld.com;\r\n\r\n        #对所有请求进行负载均衡请求\r\n        location / {\r\n            root        /root;                 #定义服务器的默认网站根目录位置\r\n            index       index.html index.htm;  #定义首页索引文件的名称\r\n            proxy_pass  http://load_balance_server ;#请求转向load_balance_server 定义的服务器列表\r\n\r\n            #以下是一些反向代理的配置(可选择性配置)\r\n            #proxy_redirect off;\r\n            proxy_set_header Host $host;\r\n            proxy_set_header X-Real-IP $remote_addr;\r\n            #后端的Web服务器可以通过X-Forwarded-For获取用户真实IP\r\n            proxy_set_header X-Forwarded-For $remote_addr;\r\n            proxy_connect_timeout 90;          #nginx跟后端服务器连接超时时间(代理连接超时)\r\n            proxy_send_timeout 90;             #后端服务器数据回传时间(代理发送超时)\r\n            proxy_read_timeout 90;             #连接成功后，后端服务器响应时间(代理接收超时)\r\n            proxy_buffer_size 4k;              #设置代理服务器（nginx）保存用户头信息的缓冲区大小\r\n            proxy_buffers 4 32k;               #proxy_buffers缓冲区，网页平均在32k以下的话，这样设置\r\n            proxy_busy_buffers_size 64k;       #高负荷下缓冲大小（proxy_buffers*2）\r\n            proxy_temp_file_write_size 64k;    #设定缓存文件夹大小，大于这个值，将从upstream服务器传\r\n\r\n            client_max_body_size 10m;          #允许客户端请求的最大单文件字节数\r\n            client_body_buffer_size 128k;      #缓冲区代理缓冲用户端请求的最大字节数\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n这里在访问 www.helloworld.com 会按照以下权重访问\r\n\r\n- 192.168.1.13:80\r\n- 192.168.1.11:80\r\n- 192.168.1.12:80\r\n\r\n## nginx 常见命令\r\n\r\n| 命令                         | 描述                                                                                               |\r\n| ---------------------------- | -------------------------------------------------------------------------------------------------- |\r\n| <kbd>nginx -s stop</kbd>     | 快速关闭 Nginx，可能不保存相关信息，并迅速终止 web 服务。                                          |\r\n| <kbd>nginx -s quit</kbd>     | 平稳关闭 Nginx，保存相关信息，有安排的结束 web 服务。                                              |\r\n| <kbd>nginx -s reload</kbd>   | 因改变了 Nginx 相关配置，需要重新加载配置而重载。                                                  |\r\n| <kbd>nginx -s reopen</kbd>   | 重新打开日志文件。                                                                                 |\r\n| <kbd>nginx -c filename</kbd> | 为 Nginx 指定一个配置文件，来代替缺省的。                                                          |\r\n| <kbd>nginx -t</kbd>          | 不运行，仅仅测试配置文件。nginx 将检查配置文件的语法的正确性，并尝试打开配置文件中所引用到的文件。 |\r\n| <kbd>nginx -v</kbd>          | 显示 nginx 的版本。                                                                                |\r\n| <kbd>nginx -V</kbd>          | 显示 nginx 的版本，编译器版本和配置参数。                                                          |\r\n\r\n这里的 nginx -t 还有一个额外作用，在不指定-c 的情况下会测试默认的配置文件，且会输出一句额外信息\r\n\r\n```sh\r\nginx: the configuration file /etc/nginx/nginx.conf syntax is ok\r\nnginx: configuration file /etc/nginx/nginx.conf test is successful\r\n```\r\n\r\n可以从上面信息获取到默认的配置文件路径\r\n\r\n## location 匹配规则\r\n\r\n| 名称           | 描述                                                               |\r\n| -------------- | ------------------------------------------------------------------ |\r\n| <kbd>=</kbd>   | 表示精确匹配                                                       |\r\n| <kbd>~</kbd>   | 表示该规则是使用正则定义的，区分大小写                             |\r\n| <kbd>~\\*</kbd> | 表示该规则是使用正则定义的，不区分大小写                           |\r\n| <kbd>^~</kbd>  | 表示如果该符号后面的字符是最佳匹配，采用该规则，不再进行后续的查找 |\r\n| <kbd>/</kbd>   | 通用匹配                                                           |\r\n\r\n它们之前优先级如下\r\n\r\n1. 如果匹配到 `=` 不再寻找；\r\n2. 如果匹配到 `^~` 不再寻找；\r\n3. 如果匹配到正则规则（存在多条取第一条匹配），不再查找；\r\n4. 匹配不带任何前缀的规则，例如 `location /user/`\r\n5. 如果都不存在，匹配 `/`;\r\n\r\n### location 实战\r\n\r\n下面看一个例子，假设 nginx 配置如下\r\n\r\n```nginx\r\nlocation = / {\r\n    [ configuration A ]\r\n}\r\n\r\nlocation / {\r\n    [ configuration B ]\r\n}\r\n\r\nlocation /user/ {\r\n    [ configuration C ]\r\n}\r\n\r\nlocation ^~ /images/ {\r\n    [ configuration D ]\r\n}\r\n\r\nlocation ~* \\.(gif|jpg|jpeg)$ {\r\n    [ configuration E ]\r\n}\r\n```\r\n\r\n分别请求以下内容会匹配到那条规则呢？\r\n\r\n- /\r\n- /index.html\r\n- /user/index.html\r\n- /images/1.jpg\r\n- /documents/about.html\r\n\r\n## alias 与 root 区别\r\n\r\nalias 与 root 有着细微的差异，以下面 nginx 配置为例\r\n\r\n```nginx\r\nserver {\r\n  # 省略其他\r\n  # 自定义一些变量\r\n  set $path /usr/share/nginx/html/icare/dist;\r\n\r\n  charset utf-8;\r\n\r\n  location / {\r\n    root $path;\r\n    index index.html;\r\n    try_files $uri $uri/ /index.html;\r\n  }\r\n\r\n  location /media/ {\r\n    expires 1h;\r\n    alias /usr/share/nginx/html/icare/static/download/;\r\n  }\r\n\r\n  location ^~ /app/center/assets {\r\n    alias $path/assets/;\r\n    gzip on;\r\n    gzip_http_version 1.1;\r\n    gzip_min_length 1k;\r\n    gzip_comp_level 5;\r\n    gzip_types *;\r\n    expires 30d;\r\n  }\r\n\r\n}\r\n\r\n```\r\n\r\n静态资源的存放路径为： `/usr/share/nginx/html/icare/dist`\r\n\r\n静态资源的公共前缀为/app/center/，此前缀是通过 vite 设置 base 来完成的\r\n\r\n```js\r\nbase: command === 'build' ? '/app/center/' : '/';\r\n```\r\n\r\n而假定我们请求一个资源 `http://10.0.40.33:8000/app/center/assets/index.d1eb2512.js`\r\n\r\n如果上面的 alias 为 `root` 就会请求 `/usr/share/nginx/html/icare/dist/app/center/assets/index.d1eb2512.js` 这条资源\r\n\r\n而实际上 app/center 这个目录是不存在，如果使用 root 指令就会导致资源无法正常加载。\r\n\r\n对此使用 aliasa 指令来指定目录，还是以上面资源为例，指定 alias 情况下，真正请求的资源地址为 `/usr/share/nginx/html/icare/dist/assets/index.d1eb2512.js`\r\n\r\n所以概括一下：\r\n\r\n- root 请求的资源路径为 root + location 匹配规则 + 资源后缀（index.d1eb2512.js）\r\n- alias 请求资源路径为 alias + 资源后缀（index.d1eb2512.js）\r\n\r\n## 实战\r\n\r\n上面简短的介绍了一下 nginx 的一些知识点，下面看几种常见的场景\r\n\r\n- 部署静态站点\r\n- 部署 spa 单页面\r\n\r\n### 部署静态站点\r\n\r\n不需要任何后端服务的项目，可能是一个纯展示信息，假设静态资源放置到了/app/dist 下\r\n\r\n```nginx\r\nworker_processes  1;\r\n\r\nevents {\r\n\tworker_connections  1024;\r\n}\r\n\r\nhttp {\r\n    include       mime.types;\r\n    default_type  application/octet-stream;\r\n    sendfile        on;\r\n    keepalive_timeout  65;\r\n\r\n    gzip on;\r\n    gzip_types text/plain application/x-javascript text/css application/xml text/javascript application/javascript image/jpeg image/gif image/png;\r\n    gzip_vary on;\r\n\r\n    server {\r\n\t\tlisten       80;\r\n\t\tserver_name  static.zp.cn;\r\n\r\n\t\tlocation / {\r\n\t\t\troot /app/dist;\r\n\t\t\tindex index.html;\r\n\t\t\t#转发任何请求到 index.html\r\n\t\t}\r\n\t}\r\n}\r\n```\r\n\r\n运行 nginx 就可以看到展示的信息了。\r\n\r\n### 部署 spa 单页面\r\n\r\nspa 单页面部署可以根据路由分为 history 和 hash 模式，即(/hello or #hello)区别。\r\n\r\n- hash 路由\r\n\r\n![hash](https://user-images.githubusercontent.com/39508895/171322500-143846c6-7d38-4909-99e0-c2d7c9dc0927.jpg)\r\n\r\n- history 路由\r\n\r\n![history](https://user-images.githubusercontent.com/39508895/171322578-5d9dc8a3-841b-417b-9995-b74d1e5e5286.jpg)\r\n\r\n\r\n对于 hash 只需要前端这边路由处理即可不涉及到服务端，所以只需要确保指向正确的 index.html 即可。\r\n\r\n而 history 模式需要则保证在刷新页面之后，用户请求的页面地址依然可以正确返回内容，后面会详细介绍，下面看一下 hash 模式 nginx 如何配置？\r\n\r\n#### hash nginx 配置\r\n\r\n```nginx\r\nworker_processes 1;\r\n\r\nevents {\r\n  worker_connections 1024;\r\n}\r\n\r\nhttp {\r\n  include mime.types;\r\n  default_type application/octet-stream;\r\n  sendfile on;\r\n  keepalive_timeout 65;\r\n\r\n  gzip on;\r\n  gzip_types text/plain application/x-javascript text/css application/xml text/javascript application/javascript image/jpeg image/gif image/png;\r\n  gzip_vary on;\r\n\r\n  root /app/dist;\r\n\r\n  server {\r\n    listen 80;\r\n    server_name static.zp.cn;\r\n\r\n    location / {\r\n      index index.html index.htm;\r\n    }\r\n    location ^~ /assets/ {\r\n      add_header Cache-Control \"public,max-age=31536000\";\r\n      # Allow cross origin access\r\n      add_header Access-Control-Expose-Headers \"Access-Control-Allow-Origin\";\r\n      add_header Access-Control-Allow-Origin \"*\";\r\n    }\r\n\r\n  }\r\n}\r\n```\r\n\r\n这里新增了 `^~ /assets/`它的意思是如果请求 url 包含/assets/内容就采用该匹配规则。\r\n\r\n#### history nginx 配置\r\n\r\n```nginx\r\nworker_processes 1;\r\n\r\nevents {\r\n  worker_connections 1024;\r\n}\r\n\r\nhttp {\r\n  include mime.types;\r\n  default_type application/octet-stream;\r\n  sendfile on;\r\n  keepalive_timeout 65;\r\n\r\n  gzip on;\r\n  gzip_types text/plain application/x-javascript text/css application/xml text/javascript application/javascript image/jpeg image/gif image/png;\r\n  gzip_vary on;\r\n\r\n  root /app/dist;\r\n\r\n  server {\r\n    listen 80;\r\n    server_name static.zp.cn;\r\n\r\n    location / {\r\n      try_files $uri /index.html;\r\n      index index.html index.htm;\r\n    }\r\n    location ^~ /assets/ {\r\n      add_header Cache-Control \"public,max-age=31536000\";\r\n      # Allow cross origin access\r\n      add_header Access-Control-Expose-Headers \"Access-Control-Allow-Origin\";\r\n      add_header Access-Control-Allow-Origin \"*\";\r\n    }\r\n\r\n  }\r\n}\r\n```\r\n\r\n对比之下 history 模式则多了一个 try_files。\r\n\r\ntry_files 的作用是检查文件是否存在，如果存在返回该文件，否则返回后置文件。\r\n\r\n举个例子 访问 static.zp.cn/a 的时候$uri 为/a，此时按照顺序会检查如下文件\r\n\r\n- 检查 /$root/a 文件是否存在\r\n- 检查 /$root/a/ 目录是否存在\r\n- 都不存在返回 index.html 内容\r\n\r\n> 为了演示方便没有包含接口请求，生产环境中一般会出现 proxy_pass 指定。\r\n\r\n# 最后\r\n\r\n到此分享就结束了，下面是一些工具链接，如果有需要可以收藏。\r\n\r\n如果文章有错误的地方也欢迎指出。\r\n\r\n- [NGINX 配置生成](https://www.digitalocean.com/community/tools/nginx?global.app.lang=zhCN)\r\n- [正则可视化工具](https://regexper.com/#)\r\n",
          "reactions": {
            "url": "https://api.github.com/repos/bosens-China/blog/issues/93/reactions",
            "total_count": 0,
            "+1": 0,
            "-1": 0,
            "laugh": 0,
            "hooray": 0,
            "confused": 0,
            "heart": 0,
            "rocket": 0,
            "eyes": 0
          },
          "timeline_url": "https://api.github.com/repos/bosens-China/blog/issues/93/timeline",
          "performed_via_github_app": null,
          "state_reason": null
        },
        {
          "url": "https://api.github.com/repos/bosens-China/blog/issues/69",
          "repository_url": "https://api.github.com/repos/bosens-China/blog",
          "labels_url": "https://api.github.com/repos/bosens-China/blog/issues/69/labels{/name}",
          "comments_url": "https://api.github.com/repos/bosens-China/blog/issues/69/comments",
          "events_url": "https://api.github.com/repos/bosens-China/blog/issues/69/events",
          "html_url": "https://github.com/bosens-China/blog/issues/69",
          "id": 911281718,
          "node_id": "MDU6SXNzdWU5MTEyODE3MTg=",
          "number": 69,
          "title": "Webpack 插件入门",
          "user": {
            "login": "bosens-China",
            "id": 39508895,
            "node_id": "MDQ6VXNlcjM5NTA4ODk1",
            "avatar_url": "https://avatars.githubusercontent.com/u/39508895?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/bosens-China",
            "html_url": "https://github.com/bosens-China",
            "followers_url": "https://api.github.com/users/bosens-China/followers",
            "following_url": "https://api.github.com/users/bosens-China/following{/other_user}",
            "gists_url": "https://api.github.com/users/bosens-China/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/bosens-China/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/bosens-China/subscriptions",
            "organizations_url": "https://api.github.com/users/bosens-China/orgs",
            "repos_url": "https://api.github.com/users/bosens-China/repos",
            "events_url": "https://api.github.com/users/bosens-China/events{/privacy}",
            "received_events_url": "https://api.github.com/users/bosens-China/received_events",
            "type": "User",
            "site_admin": false
          },
          "labels": [
            {
              "id": 1740577858,
              "node_id": "MDU6TGFiZWwxNzQwNTc3ODU4",
              "url": "https://api.github.com/repos/bosens-China/blog/labels/%E5%B7%A5%E5%85%B7%E7%9B%B8%E5%85%B3",
              "name": "工具相关",
              "color": "f73d62",
              "default": false,
              "description": "工程化相关的东西"
            }
          ],
          "state": "open",
          "locked": false,
          "assignee": null,
          "assignees": [],
          "milestone": null,
          "comments": 0,
          "created_at": "2021-06-04T08:53:06Z",
          "updated_at": "2021-12-21T10:04:02Z",
          "closed_at": null,
          "author_association": "OWNER",
          "active_lock_reason": null,
          "body": "# webpack 插件入门\r\n\r\n![bg](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/69547c8c2fe9429faf29c425de792cb3~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n最近写了一个移动端项目，不过每次 build 的时候还需要手动上传服务器感觉很不方便，毕竟每次删除文件夹然后拖拽上传的过程太重复了，本着不重复造轮子的原则去 Github 翻了一下，发现 `Upload`上传插件还是蛮多的，不过距离自己的要求还是有些差异，很多插件只是只是单一职责，只负责上传这件事情。\r\n\r\n而如果只负责上传文件不做删除会导致服务器文件越来越多，占用额外的储存成本，WebPack 在 build 过程中会检测相关依赖是否变更，如果变更相关文件的 `hash` 也是发生变更，这样就会导致新的文件上传到服务器，而旧资源却不会被覆盖替换掉。\r\n\r\n## 基本概念\r\n\r\nWebPack 的插件是基于 `Tapable` 实现的，它是一种发布订阅的实现，作用就是将插件的各个生命周期钩子广播出去，然后在合适的时机执行。同时只让插件关注自身的订阅，保证插件组合起来有序进行。\r\n\r\n`Tapable`暴露了三个方法：\r\n\r\n- tap： 可以注册同步钩子和异步钩子\r\n- tapAsync： 回调形式注册异步钩子\r\n- tapPromise： Promise 形式注册异步钩子\r\n\r\n在编写插件时 WebPack 显示要求我们有 `apply` 方法，这样做的原因是 WebPack 执行期间会执行 apply 方法，并且注入`compiler`，之后在`compiler`上订阅钩子事件，在合适时间触发已订阅的 apply 方法\r\n\r\n再看一下官方给出的示例代码\r\n\r\n```js\r\n// A JavaScript class.\r\nclass MyExampleWebpackPlugin {\r\n  // Define `apply` as its prototype method which is supplied with compiler as its argument\r\n  apply(compiler) {\r\n    // Specify the event hook to attach to\r\n    compiler.hooks.emit.tapAsync('MyExampleWebpackPlugin', (compilation, callback) => {\r\n      console.log('This is an example plugin!');\r\n      console.log(\r\n        'Here’s the `compilation` object which represents a single build of assets:',\r\n        compilation\r\n      );\r\n\r\n      // Manipulate the build using the plugin API provided by webpack\r\n      compilation.addModule(/* ... */);\r\n\r\n      callback();\r\n    });\r\n  }\r\n}\r\n```\r\n\r\n上面插件在`compiler`中订阅了 `emit` 的异步钩子，然后做了一些操作之后，执行 `callback()` 回调\r\n\r\n> 这里稍微说下，对于 `tapAsync` 的钩子，`callback` 必须执行，否则程序会一致在等待，而 callback 左侧的 `compilation` 是用来访问这一次的资源构建信息，例如一些输出的资源，相互依赖的关系等。\r\n\r\n了解了上面的信息，我们找一下 [compiler 钩子 ](https://webpack.docschina.org/api/compiler-hooks/)有没有我们需要的，文档中列举的钩子很多：\r\n\r\n- environment\r\n- afterEnvironment\r\n- entryOption\r\n- ...\r\n\r\n翻到最后会看到一个 `done` 的钩子，它在 `compilation` 完成时执行。\r\n\r\n这里我们需要的前置基本准备齐全了，下面要做的就是在 `done` 触发时\r\n\r\n- 连接 ssh 服务器，执行`rm-rf xx`的操作\r\n- 上传 build 后的资源到 xx 目录下\r\n\r\n## 插件开发准备\r\n\r\n> 之后的内容采用 `TypeScript` 作为开发，如果你没有相关经验直接跳过类型注释即可\r\n\r\n为了方便解耦和复用文件，我们创建了一个 utils.ts 文件\r\n\r\n```ts\r\n// utils.ts\r\nimport { NodeSSH } from 'node-ssh';\r\n\r\nimport { Option } from './typings';\r\n\r\nexport const isObject = (obj: any): obj is Object => typeof obj === 'object' && obj;\r\n\r\n// 删除文件夹\r\nexport const removeDir = async (option: Option) => {\r\n  const ssh = new NodeSSH();\r\n  await ssh.connect(option);\r\n  await ssh.execCommand(`rm -rf ${option.to}`);\r\n  await ssh.dispose();\r\n};\r\n\r\n// 上传文件夹\r\nexport const uploadDir = async (option: Option) => {\r\n  const ssh = new NodeSSH();\r\n  await ssh.connect(option);\r\n  await ssh.putDirectory(option.src!, option.to, {\r\n    recursive: true,\r\n  });\r\n  await ssh.dispose();\r\n};\r\n```\r\n\r\n它暴露三个方法，删除文件夹和上传文件夹还有一个判断 object 的方法，上面的删除和上传文件夹基于 [node-ssh](https://github.com/steelbrain/node-ssh) 封装而来，如果你有兴趣了解可以去阅读一下文档\r\n\r\n## 插件开发\r\n\r\n剩下的插件开发，就是获取用户填写一些必要字段，例如密码、上传的服务器路径、host 等信息，结合上面的 `utils` 和钩子，完成这个上传过程\r\n\r\n```ts\r\n// upload-plugin.ts\r\nimport { Compiler, Stats } from 'webpack';\r\nimport { isObject, uploadDir, removeDir } from './utils';\r\nimport { Option } from './typings';\r\n\r\nclass UploadPlugin {\r\n  public stats: Stats;\r\n\r\n  public option: Option & Record<string, any>;\r\n\r\n  public removeDir: boolean;\r\n\r\n  constructor(option: Option, remove = true) {\r\n    this.stats = null as unknown as Stats;\r\n    this.option = option;\r\n    this.removeDir = remove;\r\n    this.init();\r\n  }\r\n\r\n  init() {\r\n    this.checkOption();\r\n    this.setOption();\r\n  }\r\n\r\n  // 检验参数\r\n  checkOption(option = this.option) {\r\n    if (!isObject(option)) {\r\n      throw new Error('option Must be an object!');\r\n    }\r\n    const result = ['to', 'host'].filter((f) => !option[f]);\r\n    if (result.length) {\r\n      throw new Error(`The ${result.join(',')} parameter is required!`);\r\n    }\r\n    if (!option.password && !option.privateKey) {\r\n      throw new Error('password and privateKey must have one entry!');\r\n    }\r\n  }\r\n\r\n  // 初始化默认值\r\n  setOption() {\r\n    const option = {\r\n      port: 22,\r\n      username: 'root',\r\n    };\r\n    this.option = {\r\n      ...option,\r\n      ...this.option,\r\n    };\r\n  }\r\n\r\n  apply(compiler: Compiler) {\r\n    compiler.hooks.done.tap('upload-plugin', async (stats) => {\r\n      console.time('time');\r\n      // 获取默认的信息，如果src不存在直接使用webpack的配置\r\n      const src = stats.compilation.outputOptions.path;\r\n      this.option.src = this.option.src ?? src;\r\n      if (this.removeDir) {\r\n        await removeDir(this.option);\r\n      }\r\n      await uploadDir(this.option);\r\n      console.timeEnd('time');\r\n    });\r\n  }\r\n}\r\n\r\nexport default UploadPlugin;\r\n```\r\n\r\n整体代码还是很简洁的，去除参数校验部分还有赋值默认值参数，剩下的就是根据参数来是否删除远程文件夹，之后执行上传方法。\r\n\r\n你可能很好奇 `Option` 的定义是啥，这个是结合 `node-ssh` 的连接信息加上自定义扩展的一些字段而来的\r\n\r\n```ts\r\n// typings.d.ts\r\nexport interface Option {\r\n  src?: string;\r\n  to: string;\r\n  port?: number;\r\n  host: string;\r\n  username?: string;\r\n  password?: string;\r\n  privateKey?: string;\r\n}\r\n```\r\n\r\n## 最后\r\n\r\n完整代码已经上传了[Github 仓库](https://github.com/bosens-China/upload-plugin)，如果你有兴趣可以具体看下更具体的一些信息，如果对你有帮助也欢迎 `star`。\r\n",
          "reactions": {
            "url": "https://api.github.com/repos/bosens-China/blog/issues/69/reactions",
            "total_count": 0,
            "+1": 0,
            "-1": 0,
            "laugh": 0,
            "hooray": 0,
            "confused": 0,
            "heart": 0,
            "rocket": 0,
            "eyes": 0
          },
          "timeline_url": "https://api.github.com/repos/bosens-China/blog/issues/69/timeline",
          "performed_via_github_app": null,
          "state_reason": null
        },
        {
          "url": "https://api.github.com/repos/bosens-China/blog/issues/49",
          "repository_url": "https://api.github.com/repos/bosens-China/blog",
          "labels_url": "https://api.github.com/repos/bosens-China/blog/issues/49/labels{/name}",
          "comments_url": "https://api.github.com/repos/bosens-China/blog/issues/49/comments",
          "events_url": "https://api.github.com/repos/bosens-China/blog/issues/49/events",
          "html_url": "https://github.com/bosens-China/blog/issues/49",
          "id": 548743305,
          "node_id": "MDU6SXNzdWU1NDg3NDMzMDU=",
          "number": 49,
          "title": "GitHubActions构建定时任务",
          "user": {
            "login": "bosens-China",
            "id": 39508895,
            "node_id": "MDQ6VXNlcjM5NTA4ODk1",
            "avatar_url": "https://avatars.githubusercontent.com/u/39508895?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/bosens-China",
            "html_url": "https://github.com/bosens-China",
            "followers_url": "https://api.github.com/users/bosens-China/followers",
            "following_url": "https://api.github.com/users/bosens-China/following{/other_user}",
            "gists_url": "https://api.github.com/users/bosens-China/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/bosens-China/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/bosens-China/subscriptions",
            "organizations_url": "https://api.github.com/users/bosens-China/orgs",
            "repos_url": "https://api.github.com/users/bosens-China/repos",
            "events_url": "https://api.github.com/users/bosens-China/events{/privacy}",
            "received_events_url": "https://api.github.com/users/bosens-China/received_events",
            "type": "User",
            "site_admin": false
          },
          "labels": [
            {
              "id": 1740577858,
              "node_id": "MDU6TGFiZWwxNzQwNTc3ODU4",
              "url": "https://api.github.com/repos/bosens-China/blog/labels/%E5%B7%A5%E5%85%B7%E7%9B%B8%E5%85%B3",
              "name": "工具相关",
              "color": "f73d62",
              "default": false,
              "description": "工程化相关的东西"
            }
          ],
          "state": "open",
          "locked": false,
          "assignee": null,
          "assignees": [],
          "milestone": null,
          "comments": 0,
          "created_at": "2020-01-13T07:07:52Z",
          "updated_at": "2021-12-21T09:53:13Z",
          "closed_at": null,
          "author_association": "OWNER",
          "active_lock_reason": null,
          "body": "写这篇文章是无意之间看到阮一峰老师发布的[GitHub Actions 入门教程](http://www.ruanyifeng.com/blog/2019/09/getting-started-with-github-actions.html)里面介绍了 GitHub Actions 的一些概念，碰巧我之前用爬虫 + vuePress 构件了一个[typescript 的中文手册](https://bosens-china.github.io/Typescript-manual/)，下面就以每天定时构建这个应用为背景介绍如何使用 GitHub Actions 完成下面工作。\r\n\r\n下面内容主要以实践为主。\r\n\r\n## 思路\r\n\r\n1. 编写 bash 上传脚本\r\n2. 执行爬虫命令构建应用；\r\n3. 定时执行脚本，完成上传\r\n4. 出现错误发送邮件通知我；\r\n\r\n### deploy.sh\r\n\r\n```sh\r\n#!/usr/bin/env sh\r\n\r\n# 确保脚本抛出遇到的错误\r\nset -e\r\n# 下面是脚本命令，根据你的需求来选取。\r\nnpm run xxxx\r\n# 进入生成的文件夹\r\ncd docs/.vuepress/dist\r\ngit init\r\ngit add -A\r\ngit commit -m 'deploy'\r\n# 强制推送到指定分支\r\ngit push -f git@github.com:bosens-China/Typescript-manual.git master:gh-pages\r\ncd -\r\n```\r\n\r\n脚本执行的功能很简单，执行构建命令，之后进入构建的文件夹创建 git 仓库之后推送，这里需要注意一点的就是我们会将任务放置在`GitHub Actions`上，**而 git 推送是需要权限的**，下面就来解决和这个问题。\r\n\r\n###  ssh-keygen\r\n\r\n运行\r\n\r\n```sh\r\nssh-keygen\r\n```\r\n\r\n创建`id_rsa`和`id_rsa.pub`两个文件，分别对应私钥文件和公钥文件。\r\n\r\n之后将`id_rsa.pub`中的公钥添加到 Github 对应仓库的 Deploye keys 中\r\n![xx](https://user-gold-cdn.xitu.io/2020/1/13/16f9deb5aa175f0f?w=800&h=439&f=png&s=121430)\r\n再将`id_rsa`的私钥文件添加到 Github 对应仓库的 Secrets 中，这里将名称定义为`ACTION_DEPLOY_KEY`，你可以自行定义，目的就是为了让虚拟机拥有 git 仓库的权限\r\n![xx](https://user-gold-cdn.xitu.io/2020/1/13/16f9deb52f7e5467?w=800&h=389&f=png&s=121131)\r\n\r\nOK，到这一步我们得准备工作就基本上完成了，下面就是对 yml 配置文件的编写了。\r\n\r\n### deploy.yml\r\n\r\n我们在根目录新建一个`.github`的文件夹在文件夹内新建一个文件`deploy.yml`\r\n\r\n```sh\r\n# 触发的事件\r\non:\r\n  push:\r\n    branches:\r\n      - master\r\n# 定时任务在utc的9点执行，换算北京时间需要 + 8也就是凌晨五点\r\n  schedule:\r\n    - cron: \"0 21 * * *\"\r\n\r\njobs:\r\n  build:\r\n    runs-on: ubuntu-18.04\r\n\r\n    strategy:\r\n      matrix:\r\n        node-version: [12.x]\r\n\r\n    steps:\r\n      - uses: actions/checkout@v1\r\n      - name: Use Node.js ${{ matrix.node-version }}\r\n        uses: actions/setup-node@v1\r\n        with:\r\n          node-version: ${{ matrix.node-version }}\r\n      - name: git Actions\r\n        uses: srt32/git-actions@v0.0.3\r\n      - name: Setup\r\n        env:\r\n          ACTION_DEPLOY_KEY: ${{ secrets.ACTION_DEPLOY_KEY }}\r\n        run: |\r\n          mkdir -p ~/.ssh/\r\n          echo \"$ACTION_DEPLOY_KEY\" > ~/.ssh/id_rsa\r\n          chmod 600 ~/.ssh/id_rsa\r\n          ssh-keyscan github.com >> ~/.ssh/known_hosts\r\n          git config --global user.email \"你的邮箱\"\r\n          git config --global user.name \"你的名字\"\r\n          npm install\r\n          npm run updata\r\n```\r\n\r\n简单说下上面脚本干了什么事情。\r\n\r\n1. 拉取源码（actions/checkout@v1）\r\n2. 安装 node 和 git（actions/setup-node@v1 和 srt32/git-actions@v0.0.3）\r\n3. 将我们的私匙放置在.ssh 目录下（Setup）\r\n4. 执行`deploy.sh`脚本，上述的最后指定的 npm run updata 值就是`bash deploy.sh`\r\n\r\n在上面我指定了 on 它是触发的事件，我在这里指定了每天定时和`master`分支提交的时候执行这段脚本；\r\n\r\n`jobs`则是动作，动作可以有很多 build 就是一个动作，需要特别注意一点**runs-on: ubuntu-18.04**的值是指定虚拟机这个字段是必填的，不建议使用`windows`虚拟机。\r\n\r\n至于上面的`uses`字段，这个是官方提供的模块，你可以这样理解，它可以方便我们的操作，你也可以自己编写脚本之后上传到 github 的市场上，更多的内容我推荐到[官方文档上查阅](https://github.com/features/actions)\r\n\r\n### 执行错误邮件通知\r\n\r\n因为上面说这个是爬虫的应用，为了知道错误我需要邮件及时通知我，这里就使用第三方`nodemailer`的模块为例。\r\n\r\n```js\r\nfunction sendMail(e) {\r\n  const mailTransport = nodemailer.createTransport({\r\n    host: \"smtp.qq.com\",\r\n    secureConnection: true,\r\n    auth: {\r\n      user: \"xxx@qq.com\",\r\n      pass: \"vbwjzecplhehibed\"\r\n    }\r\n  });\r\n  const options = {\r\n    from: \"xxxx@qq.com\",\r\n    to: \"xxx@qq.com\",\r\n    subject: \"typescript-book出现错误\",\r\n    text: e instanceof Error ? e.message : e\r\n  };\r\n  mailTransport.sendMail(options);\r\n}\r\n```\r\n\r\n稍微注意一下`auth`字段，有一个 pass 这个本来是密码不过如果直接把密码暴露出来可能会造成不安全，所以也支持授权码，如果你想了解更多可以[什么是授权码，它又是如何设置？](https://link.jianshu.com/?t=http%3A%2F%2Fservice.mail.qq.com%2Fcgi-bin%2Fhelp%3Fsubtype%3D1%26%26no%3D1001256%26%26id%3D28)点击了解。\r\n\r\n最后你需要为邮箱开通`SMTP服务`，qq 邮箱直接点开设置查找就行了，其他邮箱也类似。\r\n之后再调用这个函数就 OK 了。\r\n\r\n### 查看效果\r\n\r\n上面写完后我们的定时发布脚本就完成了，剩下的就是提交代码触发钩子来执行我们的任务，这里我 push`master`分支代码，打开 actions\r\n![xx](https://user-gold-cdn.xitu.io/2020/1/13/16f9ded560ff8454?w=1920&h=937&f=png&s=62950)\r\n\r\n右侧就是我们脚本的执行次数和状态了，√ 表示成功，你可以详细点开查看更多的细节，例如下面的错误，你可以展开查看报错的原因是什么，方便对错误定位和调试，这里不做展开了。\r\n\r\n## 最后\r\n\r\n这篇文章写完发现更多是分享我怎么完成的，希望对你有所帮助，如果喜欢请给一下 Star\r\n",
          "reactions": {
            "url": "https://api.github.com/repos/bosens-China/blog/issues/49/reactions",
            "total_count": 0,
            "+1": 0,
            "-1": 0,
            "laugh": 0,
            "hooray": 0,
            "confused": 0,
            "heart": 0,
            "rocket": 0,
            "eyes": 0
          },
          "timeline_url": "https://api.github.com/repos/bosens-China/blog/issues/49/timeline",
          "performed_via_github_app": null,
          "state_reason": null
        },
        {
          "url": "https://api.github.com/repos/bosens-China/blog/issues/7",
          "repository_url": "https://api.github.com/repos/bosens-China/blog",
          "labels_url": "https://api.github.com/repos/bosens-China/blog/issues/7/labels{/name}",
          "comments_url": "https://api.github.com/repos/bosens-China/blog/issues/7/comments",
          "events_url": "https://api.github.com/repos/bosens-China/blog/issues/7/events",
          "html_url": "https://github.com/bosens-China/blog/issues/7",
          "id": 479646858,
          "node_id": "MDU6SXNzdWU0Nzk2NDY4NTg=",
          "number": 7,
          "title": "使用rollup编写现代化模块",
          "user": {
            "login": "bosens-China",
            "id": 39508895,
            "node_id": "MDQ6VXNlcjM5NTA4ODk1",
            "avatar_url": "https://avatars.githubusercontent.com/u/39508895?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/bosens-China",
            "html_url": "https://github.com/bosens-China",
            "followers_url": "https://api.github.com/users/bosens-China/followers",
            "following_url": "https://api.github.com/users/bosens-China/following{/other_user}",
            "gists_url": "https://api.github.com/users/bosens-China/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/bosens-China/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/bosens-China/subscriptions",
            "organizations_url": "https://api.github.com/users/bosens-China/orgs",
            "repos_url": "https://api.github.com/users/bosens-China/repos",
            "events_url": "https://api.github.com/users/bosens-China/events{/privacy}",
            "received_events_url": "https://api.github.com/users/bosens-China/received_events",
            "type": "User",
            "site_admin": false
          },
          "labels": [
            {
              "id": 1740577858,
              "node_id": "MDU6TGFiZWwxNzQwNTc3ODU4",
              "url": "https://api.github.com/repos/bosens-China/blog/labels/%E5%B7%A5%E5%85%B7%E7%9B%B8%E5%85%B3",
              "name": "工具相关",
              "color": "f73d62",
              "default": false,
              "description": "工程化相关的东西"
            }
          ],
          "state": "open",
          "locked": false,
          "assignee": null,
          "assignees": [],
          "milestone": null,
          "comments": 0,
          "created_at": "2019-08-12T13:30:02Z",
          "updated_at": "2021-12-21T09:34:35Z",
          "closed_at": null,
          "author_association": "OWNER",
          "active_lock_reason": null,
          "body": "> 之所有选用 rollup 是因为它可以减少打包体积和提高构建速度，下面介绍不会详细讲解配置，你可以自行查阅官方文档\r\n\r\nES6 已经出现很久了，但是为了兼容以前的浏览器，我们还是需要使用各种构建工具，例如 webpack，在使用的时候很方便，可以通过 babel 转换 es6 的语法，比如下面导入一个模块\r\n\r\n`import moduleName from 'module';`\r\n\r\n不过编写一个现代化模块呢，预定目标应该有三点\r\n\r\n1.  支持 typescript，将 ES6 代码转化为 ES5 环境使用\r\n2.  支持构建工具和`script type=\"module\"`的导入\r\n3.  支持 umd 格式引用\r\n\r\n就以下面这段代码为演示，实现上述的目标\r\n\r\n```js\r\nexport default (arr = []) => {\r\n  return Array.from(arr).length;\r\n};\r\n```\r\n\r\n## 准备\r\n\r\n```sh\r\nnpm init -y\r\nnpm i rollup -D\r\ncd.>rollup.config.js\r\nmd src\r\ncd.>src/index.js\r\n```\r\n\r\n这样就创建好我们想要的基本结构了，将上面例子复制到 `index.js` 文件下。\r\n\r\n`rollup`可以通过命令行也可以通过脚本来调用，这里在`package.json`的`scripts`字段，通过脚本调用\r\n\r\n```json\r\n  \"scripts\": {\r\n    \"build\": \"rollup -c\"\r\n  }\r\n```\r\n\r\n`-c`是指配置文件，默认就是`rollup.config.js`所以不需要额外配置了\r\n\r\n## 编写第一个例子\r\n\r\nrollup.config.js\r\n\r\n```js\r\nexport default {\r\n  input: \"./src/index.js\",\r\n  output: [\r\n    {\r\n      file: \"dist/index.esm.browser.js\",\r\n      format: \"es\",\r\n      sourcemap: true\r\n    }\r\n  ]\r\n};\r\n```\r\n\r\n上面配置信息`input`指的是入口文件，`output` 是出口文件，`file`是输出的文件路径，`sourcemap`是是否输出 map 文件，他可以方便调试错误，在开发模块中应该是必须的，`format`是指输出的格式\r\n\r\n- amd\r\n  异步模块定义，用于像 RequireJS 这样的模块加载器\r\n- cjs\r\n  CommonJS，适用于 Node 和 Browserify/Webpack\r\n- es\r\n  将软件包保存为 ES 模块文件\r\n- iife\r\n  一个自动执行的功能，适合作为<\\script>标签。（如果要为应用程序创建一个捆绑包，您可能想要使用它，因为它会使文件大小变小。）\r\n- umd\r\n  通用模块定义，以 amd，cjs 和 iife 为一体\r\n\r\n执行`npm run build`\r\n\r\ndist/index.esm.browser.js\r\n\r\n```js\r\nvar index = (arr = []) => {\r\n  return Array.from(arr).length;\r\n};\r\n\r\nexport default index;\r\n//# sourceMappingURL=index.esm.browser.js.map\r\n```\r\n\r\n可以看到生成的信息十分简洁，上面说到要同时支持`umd` 格式和 `import` 导入，`import`可以通过`es`的形式来供构建工具和`script type=\"module\"`使用，下面就来定义一下 umd 格式\r\n\r\n```js\r\nexport default {\r\n  input: \"./src/index.js\",\r\n  output: [\r\n    {\r\n      file: \"dist/index.esm.browser.js\",\r\n      format: \"es\",\r\n      sourcemap: true\r\n    },\r\n    {\r\n      file: \"dist/index.js\",\r\n      format: \"umd\",\r\n      sourcemap: true,\r\n      name: \"index\"\r\n    }\r\n  ]\r\n};\r\n```\r\n\r\n**注意**使用`umd`或者`iife`必须指定 name 字段，他决定了暴露在全局作用下的变量名，再次执行可以看到`index.js`的信息了。\r\n\r\n## babel\r\n\r\n上面完成了需求的第一步，不过对于 es6 的代码，并没有转化为 es5 的形式，只是将语法转换了，`Array.from`依旧存在，下面使用`babel`来完成需求\r\n\r\n```sh\r\nnpm i @babel/core @babel/preset-env  core-js rollup-plugin-babel rollup-plugin-node-resolve rollup-plugin-commonjs -D\r\n```\r\n\r\nbabel.config.js\r\n\r\n```js\r\nmodule.exports = {\r\n  presets: [\r\n    [\r\n      \"@babel/preset-env\",\r\n      {\r\n        useBuiltIns: \"usage\",\r\n        corejs: 3,\r\n        modules: false\r\n      }\r\n    ]\r\n  ]\r\n};\r\n```\r\n\r\n上面代码的`useBuiltIns`的`usage`是 babel7 的实验性特性，他支持按需加载\r\n\r\nrollup.config.js\r\n\r\n```js\r\nimport babel from \"rollup-plugin-babel\";\r\nimport resolve from \"rollup-plugin-node-resolve\";\r\nimport commonjs from \"rollup-plugin-commonjs\";\r\nexport default {\r\n  input: \"./src/index.js\",\r\n  output: [\r\n    {\r\n      file: \"dist/index.esm.browser.js\",\r\n      format: \"es\",\r\n      sourcemap: true\r\n    },\r\n    {\r\n      file: \"dist/index.js\",\r\n      format: \"umd\",\r\n      sourcemap: true,\r\n      name: \"index\"\r\n    }\r\n  ],\r\n  plugins: [\r\n    commonjs(),\r\n    resolve(),\r\n    babel({\r\n      exclude: [/\\/core-js\\//],\r\n      runtimeHelpers: true,\r\n      sourceMap: true,\r\n      extensions: [\".js\", \".jsx\", \".es6\", \".es\", \".mjs\", \".ts\"]\r\n    })\r\n  ]\r\n};\r\n```\r\n\r\n再次执行可以看到`Arrar.from`已经被`babel`转换为 ES5 的环境了\r\n\r\n## typescript\r\n\r\n这个我们用`babel`提供给我们的`@babel/preset-typescript`即可完成，不过为了支持`typescript`一些其他扩展语法，我们还需要安装一些插件\r\n\r\n```sh\r\nnpm i @babel/preset-typescript @babel/plugin-transform-typescript @babel/plugin-syntax-dynamic-import @babel/plugin-proposal-class-properties -D\r\n```\r\n\r\nbabel.config.js\r\n\r\n```js\r\nmodule.exports = {\r\n  presets: [\r\n    [\r\n      \"@babel/preset-env\",\r\n      {\r\n        useBuiltIns: \"usage\",\r\n        corejs: 3,\r\n        modules: false\r\n      }\r\n    ],\r\n    [\"@babel/preset-typescript\"]\r\n  ],\r\n  plugins: [\r\n    \"@babel/plugin-transform-typescript\",\r\n    \"@babel/plugin-syntax-dynamic-import\",\r\n    \"@babel/plugin-proposal-class-properties\"\r\n  ]\r\n};\r\n```\r\n\r\n修改一下 `src/index.js` 为 `index.ts`，`rollup.config.js` 下`input`字段\r\n\r\n```js\r\nexport default (arr: Array<any> = []): number => {\r\n  return Array.from(arr).length;\r\n};\r\n```\r\n\r\n再次执行`npm run build`，成功输出\r\n\r\n## 优化\r\n\r\n1. 输出代码没有被压缩\r\n2. 每次输出的时候文件夹没有被删除\r\n\r\n上面两个问题，可以通过插件来解决\r\n\r\n```sh\r\nnpm i rollup-plugin-terser rollup-plugin-clear -D\r\n```\r\n\r\nrollup.config.js\r\n\r\n```js\r\nimport babel from \"rollup-plugin-babel\";\r\nimport clear from \"rollup-plugin-clear\";\r\nimport resolve from \"rollup-plugin-node-resolve\";\r\nimport commonjs from \"rollup-plugin-commonjs\";\r\nimport { terser } from \"rollup-plugin-terser\";\r\nexport default {\r\n  input: \"./src/index.ts\",\r\n  output: [\r\n    {\r\n      file: \"dist/index.esm.browser.js\",\r\n      format: \"es\",\r\n      sourcemap: true\r\n    },\r\n    {\r\n      file: \"dist/index.js\",\r\n      format: \"umd\",\r\n      sourcemap: true,\r\n      name: \"index\"\r\n    }\r\n  ],\r\n  plugins: [\r\n    clear({\r\n      targets: [\"dist\"]\r\n    }),\r\n    resolve(),\r\n    commonjs(),\r\n    terser(),\r\n    babel({\r\n      exclude: [/\\/core-js\\//],\r\n      runtimeHelpers: true,\r\n      sourceMap: true,\r\n      extensions: [\".js\", \".jsx\", \".es6\", \".es\", \".mjs\", \".ts\"]\r\n    })\r\n  ]\r\n};\r\n```\r\n这样基本的模块的基本功能就编写完成了",
          "reactions": {
            "url": "https://api.github.com/repos/bosens-China/blog/issues/7/reactions",
            "total_count": 0,
            "+1": 0,
            "-1": 0,
            "laugh": 0,
            "hooray": 0,
            "confused": 0,
            "heart": 0,
            "rocket": 0,
            "eyes": 0
          },
          "timeline_url": "https://api.github.com/repos/bosens-China/blog/issues/7/timeline",
          "performed_via_github_app": null,
          "state_reason": null
        }
      ]
    ],
    [
      "1371686611",
      [
        {
          "url": "https://api.github.com/repos/bosens-China/blog/issues/94",
          "repository_url": "https://api.github.com/repos/bosens-China/blog",
          "labels_url": "https://api.github.com/repos/bosens-China/blog/issues/94/labels{/name}",
          "comments_url": "https://api.github.com/repos/bosens-China/blog/issues/94/comments",
          "events_url": "https://api.github.com/repos/bosens-China/blog/issues/94/events",
          "html_url": "https://github.com/bosens-China/blog/issues/94",
          "id": 1361066184,
          "node_id": "I_kwDOCzPAy85RIDjI",
          "number": 94,
          "title": "TypeScript 类型收窄",
          "user": {
            "login": "bosens-China",
            "id": 39508895,
            "node_id": "MDQ6VXNlcjM5NTA4ODk1",
            "avatar_url": "https://avatars.githubusercontent.com/u/39508895?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/bosens-China",
            "html_url": "https://github.com/bosens-China",
            "followers_url": "https://api.github.com/users/bosens-China/followers",
            "following_url": "https://api.github.com/users/bosens-China/following{/other_user}",
            "gists_url": "https://api.github.com/users/bosens-China/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/bosens-China/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/bosens-China/subscriptions",
            "organizations_url": "https://api.github.com/users/bosens-China/orgs",
            "repos_url": "https://api.github.com/users/bosens-China/repos",
            "events_url": "https://api.github.com/users/bosens-China/events{/privacy}",
            "received_events_url": "https://api.github.com/users/bosens-China/received_events",
            "type": "User",
            "site_admin": false
          },
          "labels": [
            {
              "id": 1371686611,
              "node_id": "MDU6TGFiZWwxMzcxNjg2NjEx",
              "url": "https://api.github.com/repos/bosens-China/blog/labels/%E5%85%B6%E4%BB%96",
              "name": "其他",
              "color": "f6ecbf",
              "default": false,
              "description": "未找到分类，暂定的文章"
            }
          ],
          "state": "open",
          "locked": false,
          "assignee": null,
          "assignees": [],
          "milestone": null,
          "comments": 0,
          "created_at": "2022-09-04T07:17:35Z",
          "updated_at": "2022-09-04T07:17:35Z",
          "closed_at": null,
          "author_association": "OWNER",
          "active_lock_reason": null,
          "body": "![image-20220904141910530](https://user-images.githubusercontent.com/39508895/188302110-a54f0cf4-ec09-4b1b-bcf0-2caf181351da.png)\r\n\r\n\r\n写这篇文章是因为最近在写一个[管理异步队列的库](https://github.com/bosens-China/async-queue)，但是有一些类型推导不太好写，例如上面的期待是\r\n\r\n```js\r\nif (values.stauts === 'error') {\r\n  // values.data to Error\r\n}\r\n```\r\n\r\n后面查询了一些文档和资料就有了这篇文章。\r\n\r\n## 收窄方式\r\n\r\n在具体讲解上面如何实现之前，先介绍一下几种收窄对象的方式。\r\n\r\n### typeof 类型守卫\r\n\r\n```js\r\nfunction padLeft(padding: number | string, input: string): string {\r\n  throw new Error('Not implemented yet!');\r\n}\r\n```\r\n\r\n如果在 padLeft 函数内调用不是 stirng 和 number 相同的方法，例如 toString、valueOf 会提示方法不存在。\r\n\r\n之所以出现这样问题是因为 Typescript 并不知道 padding 到底是 number 还是 string，但是你可以通过 typeof 的显式告诉它的类型。\r\n\r\n```js\r\nfunction padLeft(padding: number | string, input: string): string {\r\n  if (typeof padding === 'string') {\r\n    return padding.charAt(0);\r\n  }\r\n  // 排除了string，剩下就是number\r\n  return padding.toFixed(2);\r\n}\r\n```\r\n\r\n### 条件语句\r\n\r\n在使用条件语句，例如 `if`、`&&`、`||` 、`!` 等条件语句的时候也会缩小类型。\r\n\r\n看一个例子\r\n\r\n```js\r\nfunction printAll(strs: string | string[] | null) {\r\n  //\r\n}\r\n```\r\n\r\n按照上面 typeof 语句很自然就想到判断是不是 object 来完成数组区分\r\n\r\n```js\r\nfunction printAll(strs: string | string[] | null) {\r\n  if (typeof strs === 'object') {\r\n    strs.forEach((item) => {});\r\n    // Object is possibly 'null'.\r\n    //'item' is declared but its value is never read.\r\n  }\r\n}\r\n```\r\n\r\n不过写到一半就会发现提示报错了，strs 在 object 的判断下依然可能为 null，回忆一下 typeof 的运算符可以得知这个是正常现象，null 的 typeof 返回值也是 object，这个是 JavaScript 语言设计的一个缺陷。\r\n\r\n不过要怎么消除这个影响呢？这就用到这条件语句，可以通过判断 strs 是否存在显式排除 null 的存在\r\n\r\n```js\r\nfunction printAll(strs: string | string[] | null) {\r\n  if (typeof strs === 'object' && strs) {\r\n    // object\r\n    return strs;\r\n    // 这里strs类型已经被排除object了\r\n  } else if (typeof strs === 'string') {\r\n    return strs;\r\n  }\r\n  // null\r\n  return strs;\r\n}\r\n```\r\n\r\n### 相等运算符和 switch 收窄\r\n\r\n还可以使用 `===`、`==`、`!=`、`!==` 运算符来完成收窄\r\n\r\n```js\r\ninterface Container {\r\n  value: number | null | undefined;\r\n}\r\n\r\nfunction multiplyValue(container: Container, factor: number) {}\r\n```\r\n\r\n例如上面，如果想让 container 排除 null 和 undefined 就可以使用 `===` 来完成，下面是示例\r\n\r\n```js\r\ninterface Container {\r\n  value: number | null | undefined;\r\n}\r\n\r\nfunction multiplyValue(container: Container, factor: number) {\r\n  if (container.value === undefined) {\r\n    return 0;\r\n  }\r\n  if (container.value === null) {\r\n    return 1;\r\n  }\r\n  return container.value === factor;\r\n}\r\n```\r\n\r\n通过 === 完成了 undefined 和 null 的收窄过程，这里顺便说下其实上面的写法可以简写成 `==` ，== 在判断 undefined 跟 null 之间时返回 true。\r\n\r\n```js\r\ninterface Container {\r\n  value: number | null | undefined;\r\n}\r\n\r\nfunction multiplyValue(container: Container, factor: number) {\r\n  if (container.value == undefined) {\r\n    return 0;\r\n  }\r\n\r\n  return container.value === factor;\r\n}\r\n```\r\n\r\n### in 运算符\r\n\r\nin 运算符用于判断一个属性是否存在对象上，在 TypeScript 同样可以使用 in 来完成收窄。\r\n\r\n```js\r\ntype Fish = { swim: () => void };\r\ntype Bird = { fly: () => void };\r\n\r\nfunction move(animal: Fish | Bird) {\r\n  if ('swim' in animal) {\r\n    return animal.swim();\r\n  }\r\n\r\n  return animal.fly();\r\n}\r\n```\r\n\r\n上面 move 通过指定 `swim in animal` 告诉 TypeScript，在 if 中类型就是 Fish，因为 Bird 中不存在这个属性。\r\n\r\n> 使用 in 运算符收窄时，使用其他联合类型不存在的属性来完成对某一类型的收窄\r\n\r\n### instanceof\r\n\r\n与 JavaScript 中一样，instanceof 也可以判断某个属性是否匹配对象。\r\n\r\n```js\r\nfunction logValue(x: Date | string) {\r\n  if (x instanceof Date) {\r\n    console.log(x.toUTCString());\r\n  } else {\r\n    console.log(x.toUpperCase());\r\n  }\r\n}\r\n```\r\n\r\n### 赋值\r\n\r\n这里直接看例子\r\n\r\n```js\r\nlet x = Math.random() < 0.5 ? 10 : 'hello world!';\r\n// let x: string | number\r\nx = 1;\r\n\r\nconsole.log(x);\r\n// let x: number\r\nx = 'goodbye!';\r\n\r\nconsole.log(x);\r\n// let x: string\r\n```\r\n\r\n不过注意，分配给上面的 x 一定要符合 x 最初的联合类型，也就是说给定 boolean 会报错。\r\n\r\n### 类型谓词\r\n\r\n在使用 lodash 类型的函数库，通常都会有 isObject，你可能很好奇怎么实现。\r\n\r\n其实它们就是使用了类型谓词，下面动手实现一个 isObject\r\n\r\n```js\r\nfunction isObject (value:any) : value is object {\r\n    return value && typeof value === 'object'\r\n}\r\n```\r\n\r\n之后在配合使用就可以完成类型收窄\r\n\r\n```js\r\nfunction test(pet: object | null) {\r\n  if (isObject(pet)) {\r\n    return pet;\r\n  } else {\r\n    return {};\r\n  }\r\n}\r\n```\r\n\r\n### interface 收窄\r\n\r\n上面将收窄的方式列举了一番，下面就看下在 interface 中如何实现收窄，最开始已经说了，我们期待使用 if 条件语句可以通过 status 的不同来完成 data 的变化。\r\n\r\n在 TypeScript 我们可以使用联合类型将两者通用部分区分\r\n\r\n```js\r\nexport interface ChangeError {\r\n  status: 'error';\r\n  data: Error;\r\n}\r\n\r\nexport interface ChangeData<T> {\r\n  status: 'success';\r\n  data: T;\r\n}\r\n```\r\n\r\n之后拼接一起\r\n\r\n```js\r\nexport type Change<T = any> = {\r\n  index: number,\r\n  progress: number,\r\n  total: number,\r\n} & (ChangeError | ChangeData<T>);\r\n```\r\n\r\n之后通过 TypeScript 的条件收窄就自动完成这一过程。\r\n\r\n### 收窄类型的实用示例\r\n\r\n收窄 + never 结合可以完成一个联合类型添加新对象不处理报错。\r\n\r\n```js\r\ninterface A {\r\n  name: 'a';\r\n}\r\ninterface B {\r\n  name: 'b';\r\n}\r\n\r\ntype Types = A | B;\r\n\r\nfunction check(values: Types) {\r\n  switch (values.name) {\r\n    case 'a':\r\n      return '';\r\n    case 'b':\r\n      return '';\r\n    default:\r\n      const _never: never = values;\r\n      return _never;\r\n  }\r\n}\r\n```\r\n\r\nnever 表示永远为空的类型，结合 switch 可以将对象类型收窄尽，这时对象的类型就是 never。\r\n\r\n现在如果给 Types 添加新的联合类型 default 就会抛出错误\r\n\r\n```js\r\ninterface A {\r\n  name: 'a';\r\n}\r\ninterface B {\r\n  name: 'b';\r\n}\r\n\r\ntype Types = A | B | { name: 'c' };\r\n\r\nfunction check(values: Types) {\r\n  switch (values.name) {\r\n    case 'a':\r\n      return '';\r\n    case 'b':\r\n      return '';\r\n    default:\r\n      const _never: never = values;\r\n      return _never;\r\n  }\r\n}\r\n```\r\n",
          "reactions": {
            "url": "https://api.github.com/repos/bosens-China/blog/issues/94/reactions",
            "total_count": 0,
            "+1": 0,
            "-1": 0,
            "laugh": 0,
            "hooray": 0,
            "confused": 0,
            "heart": 0,
            "rocket": 0,
            "eyes": 0
          },
          "timeline_url": "https://api.github.com/repos/bosens-China/blog/issues/94/timeline",
          "performed_via_github_app": null,
          "state_reason": null
        }
      ]
    ],
    [
      "3661376441",
      [
        {
          "url": "https://api.github.com/repos/bosens-China/blog/issues/92",
          "repository_url": "https://api.github.com/repos/bosens-China/blog",
          "labels_url": "https://api.github.com/repos/bosens-China/blog/issues/92/labels{/name}",
          "comments_url": "https://api.github.com/repos/bosens-China/blog/issues/92/comments",
          "events_url": "https://api.github.com/repos/bosens-China/blog/issues/92/events",
          "html_url": "https://github.com/bosens-China/blog/issues/92",
          "id": 1187971933,
          "node_id": "I_kwDOCzPAy85GzwNd",
          "number": 92,
          "title": ".gitattributes 正确使用姿势",
          "user": {
            "login": "bosens-China",
            "id": 39508895,
            "node_id": "MDQ6VXNlcjM5NTA4ODk1",
            "avatar_url": "https://avatars.githubusercontent.com/u/39508895?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/bosens-China",
            "html_url": "https://github.com/bosens-China",
            "followers_url": "https://api.github.com/users/bosens-China/followers",
            "following_url": "https://api.github.com/users/bosens-China/following{/other_user}",
            "gists_url": "https://api.github.com/users/bosens-China/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/bosens-China/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/bosens-China/subscriptions",
            "organizations_url": "https://api.github.com/users/bosens-China/orgs",
            "repos_url": "https://api.github.com/users/bosens-China/repos",
            "events_url": "https://api.github.com/users/bosens-China/events{/privacy}",
            "received_events_url": "https://api.github.com/users/bosens-China/received_events",
            "type": "User",
            "site_admin": false
          },
          "labels": [
            {
              "id": 3661376441,
              "node_id": "LA_kwDOCzPAy87aPCu5",
              "url": "https://api.github.com/repos/bosens-China/blog/labels/%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83",
              "name": "代码规范",
              "color": "5319e7",
              "default": false,
              "description": "团队规范、代码规范、技术选型等相关内容"
            }
          ],
          "state": "open",
          "locked": false,
          "assignee": null,
          "assignees": [],
          "milestone": null,
          "comments": 0,
          "created_at": "2022-03-31T12:00:40Z",
          "updated_at": "2022-04-16T03:28:38Z",
          "closed_at": null,
          "author_association": "OWNER",
          "active_lock_reason": null,
          "body": "这篇文章的由来是因为项目上的一个神奇问题，之前觉得写重复的创建项目太繁琐就封装了一个[创建模板文件 CLI](https://github.com/bosens-China/template-create) ，当时心想自己真是一个上进的小伙子。\r\n\r\n后来某天 xx 领导对我说有一个新项目交给我做，当时心想终于可以大展拳脚试试新的工具了，一顿操作后项目完成了，不过在推送 GitLab 时发现图片竟然无法预览。why？后面根据 git log 记录一个个回滚和但是这也无法复现 entire，后面又对项目文件屏蔽检查终于发现原来是 .gitattributes 文件填写问题。\r\n\r\n> 之前.gitattributes 写法\r\n>\r\n> ```sh\r\n> * text eol=lf\r\n> ```\r\n\r\n那是不是直接删除 .gitattributes 文件就可以了呢？如果只考虑解决图片提交格式损坏当时是没问题。\r\n\r\n## .gitattributes 作用\r\n\r\n不过回到标题，当时之所以在模板文件中添加 .gitattributes 主要是有两个目的：\r\n\r\n- 确保文件行尾序列符合一致，在 windows 下行尾序列为 CRLF 而在 mac 和 linux 则是 LF。行尾序列不同在某些 Eslint 规则下会显示报错，这是为了规范你的代码。\r\n\r\n![Code File With Prettier Linting Errors - .gitattributes](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/2/11/17033a0f5ed87f6c~tplv-t2oaga2asx-zoom-in-crop-mark:1304:0:0:0.awebp)\r\n\r\n- 避免 git 提交记录莫名差异，例如从仓库下拉取了一个项目，更改了一个某一个文件的内容发现不对又撤销了，但是因为系统不同行尾序列已经发生了变更，git 会显示这个文件的差异。\r\n\r\n![image-20220410152753128.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4843f675b9cd448eaafa3e944cc5d7ec~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n> 以上操作是假设仓库的文件是 LF 格式，且你是 windows 电脑下操作\r\n\r\n## 如何编写.gitattributes 文件\r\n\r\n按照开头我最初的写法肯定是错误的\r\n\r\n```sh\r\n* text eol=lf\r\n```\r\n\r\n这里会把代码的所有文件都 LF 化，对于文本文件是没问题的，但是对于一些图片文件、pdf 等二进制文件就会导致额外的问题。\r\n\r\n这里参考两个库的写法 [v8 .gitattributes](https://github.com/v8/v8/blob/main/.gitattributes)\r\n\r\n```sh\r\n# Automatically normalize line endings (to LF) for all text-based files.\r\n* text=auto eol=lf\r\n# Do not modify line endings for binary files (which are sometimes auto\r\n# detected as text files by git).\r\n*.png binary\r\n# Don't include minified JS in git grep/diff output\r\ntest/mjsunit/asm/sqlite3/*.js -diff\r\n```\r\n\r\n上面会把所有的文件都 LF 化，不同的是单独为需要的资源添加了 binary，而翻阅 git 官方 [gitattributes 文档](https://git-scm.com/docs/gitattributes) 可以看到\r\n\r\n> 如果你不希望产生文本差异，以及行尾转换应用到任何二进制文件。可以使用系统内置的 binary，它会取消 text 和 diff 属性。\r\n\r\n而第三行 `test/mjsunit/asm/sqlite3/*.js -diff` 则是说不要跟踪 diff 差异。\r\n\r\n再来看一个 [pdf .gitattributes](https://github.com/mozilla/pdf.js/blob/master/.gitattributes)\r\n\r\n```sh\r\n# Force Unix line endings for most file formats (except binary files)\r\n*.js         text eol=lf\r\n*.jsm        text eol=lf\r\n*.css        text eol=lf\r\n*.html       text eol=lf\r\n*.md         text eol=lf\r\n*.properties text eol=lf\r\n*.yml        text eol=lf\r\n*.json       text eol=lf\r\n*.config     text eol=lf\r\n*.inc        text eol=lf\r\n*.manifest   text eol=lf\r\n*.rdf        text eol=lf\r\n*.jade       text eol=lf\r\n*.coffee     text eol=lf\r\n\r\n# PDF files shall not modify CRLF line endings\r\n*.pdf -crlf\r\n\r\n# Linguist language overrides\r\n*.js linguist-language=JavaScript\r\n*.jsm linguist-language=JavaScript\r\n*.inc linguist-language=XML\r\n```\r\n\r\n它将资源前置化处理，需要的文件全部 LF 处理，而 `*.pdf -crlf` 则是说强制 crlf 处理，下面的 `linguist-language` 是 [Linguist](https://github.com/github/linguist) 库的属性，它用于生成我们常见的语言分布\r\n\r\n![image-20220410155340149.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f64c46b840a84381bfcea21d0fe87235~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n综合上面两个库来看，有两种编写 .gitattributes 的方式\r\n\r\n### 前置后添加\r\n\r\n这就是 [pdf.js](https://github.com/mozilla/pdf.js) 所采用的，将需要用的序列化，例如如果你是 React 项目，只可能只需要这样指定\r\n\r\n```sh\r\n*.js        text eol=lf\r\n*.jsm       text eol=lf\r\n*.jsx     \ttext eol=lf\r\n*.ts        text eol=lf\r\n*.tsx   \ttext eol=lf\r\n*.json      text eol=lf\r\n*.css       text eol=lf\r\n*.html      text eol=lf\r\n```\r\n\r\n后面如果还有新的需要行尾序列的后缀可以继续添加\r\n\r\n### 全局后添加\r\n\r\n这是 [V8](https://github.com/v8/v8) 的做法，假定所有资源都是文本相关，如果后续有新的二进制文件再对 .gitattributes 文件进行编辑。\r\n\r\n```sh\r\n* text eol=lf\r\n# 如果有新的二进制文件\r\n* png eol=binary\r\n```\r\n\r\n## 迁移指南\r\n\r\n如果你的项目已经存在很久，但是也想添加 .gitattributes 文件来统一行尾序列，下面就介绍一下相关方法。\r\n\r\n1. 添加相关的 .gitattributes 文件到项目（详情见如何编写.gitattributes 文件\r\n2. 运行 `git add .` 添加所有文件\r\n3. 运行 `git commit -m \"Saving files before refreshing line endings\"` 来保存本次更改\r\n4. 删除所有文件，不包括 .git 目录，`git rm -rf --cached .`\r\n5. 运行 `git reset --hard HEAD`，恢复上一次的提交，这里会得到正确的行尾序列\r\n\r\n## 兼容指南\r\n\r\n如果你发现 monorepo 项目中还是没有得到正确的行尾序列，可以参考一下下面 [ .gitattributes 的写法](https://gist.github.com/dpalomar/ebc64d6f56cfc25a3e5c20fe7cdfbd4f)\r\n\r\n```sh\r\n* text=auto\r\n\r\n# Force the following filetypes to have unix eols, so Windows does not break them\r\n*.* text eol=lf\r\n\r\n# Windows forced line-endings\r\n/.idea/* text eol=crlf\r\n\r\n#\r\n## These files are binary and should be left untouched\r\n#\r\n\r\n# (binary is a macro for -text -diff)\r\n*.png binary\r\n```\r\n\r\n添加了兼容性的写法，强制在 window 下 lf 化\r\n\r\n## 最后\r\n\r\n如果文章有相关错误欢迎指出\r\n\r\n> 参考了\r\n>\r\n> - [配置 Git 处理行结束符](https://docs.github.com/cn/get-started/getting-started-with-git/configuring-git-to-handle-line-endings)\r\n",
          "reactions": {
            "url": "https://api.github.com/repos/bosens-China/blog/issues/92/reactions",
            "total_count": 0,
            "+1": 0,
            "-1": 0,
            "laugh": 0,
            "hooray": 0,
            "confused": 0,
            "heart": 0,
            "rocket": 0,
            "eyes": 0
          },
          "timeline_url": "https://api.github.com/repos/bosens-China/blog/issues/92/timeline",
          "performed_via_github_app": null,
          "state_reason": null
        },
        {
          "url": "https://api.github.com/repos/bosens-China/blog/issues/70",
          "repository_url": "https://api.github.com/repos/bosens-China/blog",
          "labels_url": "https://api.github.com/repos/bosens-China/blog/issues/70/labels{/name}",
          "comments_url": "https://api.github.com/repos/bosens-China/blog/issues/70/comments",
          "events_url": "https://api.github.com/repos/bosens-China/blog/issues/70/events",
          "html_url": "https://github.com/bosens-China/blog/issues/70",
          "id": 913346542,
          "node_id": "MDU6SXNzdWU5MTMzNDY1NDI=",
          "number": 70,
          "title": "团队规范系列之 git 规范",
          "user": {
            "login": "bosens-China",
            "id": 39508895,
            "node_id": "MDQ6VXNlcjM5NTA4ODk1",
            "avatar_url": "https://avatars.githubusercontent.com/u/39508895?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/bosens-China",
            "html_url": "https://github.com/bosens-China",
            "followers_url": "https://api.github.com/users/bosens-China/followers",
            "following_url": "https://api.github.com/users/bosens-China/following{/other_user}",
            "gists_url": "https://api.github.com/users/bosens-China/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/bosens-China/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/bosens-China/subscriptions",
            "organizations_url": "https://api.github.com/users/bosens-China/orgs",
            "repos_url": "https://api.github.com/users/bosens-China/repos",
            "events_url": "https://api.github.com/users/bosens-China/events{/privacy}",
            "received_events_url": "https://api.github.com/users/bosens-China/received_events",
            "type": "User",
            "site_admin": false
          },
          "labels": [
            {
              "id": 3661376441,
              "node_id": "LA_kwDOCzPAy87aPCu5",
              "url": "https://api.github.com/repos/bosens-China/blog/labels/%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83",
              "name": "代码规范",
              "color": "5319e7",
              "default": false,
              "description": "团队规范、代码规范、技术选型等相关内容"
            }
          ],
          "state": "open",
          "locked": false,
          "assignee": null,
          "assignees": [],
          "milestone": null,
          "comments": 0,
          "created_at": "2021-06-07T09:37:17Z",
          "updated_at": "2021-12-21T10:03:46Z",
          "closed_at": null,
          "author_association": "OWNER",
          "active_lock_reason": null,
          "body": "最近一周的工作重心就是在梳理团队规范，在写的过程也查缺补漏了不少知识，剔除掉关于公司场景的部分就有了这一系列的文章，预计写四部分：\r\n1. git规范\r\n2. [工程规范](https://github.com/bosens-China/blog/issues/71)\r\n3. [用户体验规范](https://github.com/bosens-China/blog/issues/72)\r\n4. [命名规范](https://github.com/bosens-China/blog/issues/73)\r\n\r\n\r\n# Git 规范\r\n\r\nGit 作为现在最流行的分布式管理工具，基本上是每个团队的必备，下面就从分支和提交这两部分展开\r\n\r\n## 什么是分支\r\n\r\n分支就是把你的工作从开发主线上分离开来，以免影响开发主线，假设你准备开发一个新功能，但是需要两周才能完成，第一周你写了 50%的代码，如果立刻提交，由于代码还没写完，不完整的代码库会导致别人不能干活了。如果等代码全部写完再一次提交，又存在丢失每天进度的巨大风险。\r\n\r\n现在有了分支，就不用怕了。你创建了一个属于你自己的分支，别人看不到，还继续在原来的分支上正常工作，而你在自己的分支上干活，想提交就提交，直到开发完毕后，再一次性合并到原来的分支上，这样，既安全，又不影响别人工作。\r\n\r\n![1.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/305ee83c688b49ae859b493fbf7d7218~tplv-k3u1fbpfcp-watermark.image)\r\n\r\n## 分支如何命名\r\n\r\n分支按照类型可以分为以下几种\r\n\r\n| 分支名称         |       命名        |                                                       说明 |\r\n| ---------------- | :---------------: | ---------------------------------------------------------: |\r\n| 主分支           |      master       | 主分支，所有提供给用户使用的正式版本，都在这个主分支上发布 |\r\n| 开发主分支       |      develop      |                         开发分支，永远是功能最新最全的分支 |\r\n| 功能分支         |    feature-\\*     |                         新功能分支，某个功能点正在开发阶段 |\r\n| 发布版本         |    release-\\*     |                                       发布定期要上线的功能 |\r\n| 修复发布版本分支 | bugfix-release-\\* |                                               修复测试 bug |\r\n| 紧急修复分支     | bugfix-master-\\*  |                                     紧急修复线上代码的 bug |\r\n\r\n## 开发流程示例\r\n\r\n下面就以一个产品从最初到发布上线为例子，讲解 git 流程\r\n\r\n### 初始化\r\n\r\n第一步，初始仓库的信息，同时创建`develop`分支\r\n\r\n![2.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cf641e319fd14f93a08b9ee748b0706b~tplv-k3u1fbpfcp-watermark.image)\r\n\r\n### 开发新功能\r\n\r\n开发人员在`develop`分支开发新的功能，包括:新特性与 Bug 修复\r\n\r\n![3.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2656d065a3714906a8a503b318698841~tplv-k3u1fbpfcp-watermark.image)\r\n\r\n如果并行开发多个需求，可以创建 `feature 分支`，命名规则为`feature-分支创建日期-新特性关键字`，例如:`feature-20190919-i18n`\r\n\r\n![4.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/dba19d9f51714f7caa6f8e45ebd1e120~tplv-k3u1fbpfcp-watermark.image)\r\n\r\n开发完成之后将 feature 分支合并到 develop 分支，最后删除 feature 分支\r\n\r\n> 什么时候使用 feature\r\n>\r\n> - 开发一个独立的新特性(完成时，需合并到 develop 分支)\r\n> - 技术研究与尝试(若失败，可随时删除 feature 分支)\r\n> - 提前实现下一个版本需要开发的特性(可不在本次迭代中发布)\r\n\r\n### 准备发布版本\r\n\r\n如果 develop 分支上的功开发完毕\r\n\r\n1. 建 release 分支(发布分支)命名规则:release-分支创建日期-待发布版本号，例如：`release-20190919-v1.0.0`\r\n2. 对 release 分支的版本号进行修改（之后提交一次）\r\n3. 通知测试人员测试\r\n\r\n![5.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f639127d864f404b9cd12d85cc8e5547~tplv-k3u1fbpfcp-watermark.image)\r\n\r\n### 修复问题\r\n\r\n开发人员在 release 修复问题，此时禁止开发新功能，只对 bug 进行修复\r\n\r\n![6.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5566fa0226ee43b78f8daf7d4ed14950~tplv-k3u1fbpfcp-watermark.image)\r\n\r\n### 最终发布\r\n\r\n经过测试没有发现问题，或者问题已经全部修复，这个时候\r\n\r\n1. 将 release 分支同时合并到 master 分支与 develop 分支\r\n\r\n   - 通知测试，进行主分支测试\r\n   - 如果没问题，进行下一步，如果有问题回到 release\r\n\r\n1. 删除 release 分支\r\n1. 构建应用到服务器\r\n\r\n![7.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ad87a01a2eb845a99dfc4ff489e6b4e9~tplv-k3u1fbpfcp-watermark.image)\r\n\r\n## commit 规范\r\n\r\n目前开源社区主要应用是规范是[Angular Git Commit Guidelines](https://github.com/angular/angular.js/blob/master/DEVELOPERS.md#-git-commit-guidelines)\r\n\r\n它由下面几部分组成:\r\n\r\n```sh\r\n<type>: <subject>\r\n<BLANK LINE>\r\n<body>\r\n<BLANK LINE>\r\n<footer>\r\n```\r\n\r\n### type\r\n\r\n本次 commit 的类型，诸如 bugfix、docs、style 等\r\n\r\n完整的类型如下：\r\n\r\n| 名称     |                        描述                        |\r\n| -------- | :------------------------------------------------: |\r\n| feat     |                     添加新特性                     |\r\n| fix      |                      修复 bug                      |\r\n| docs     |                   仅仅修改了文档                   |\r\n| style    | 仅仅修改了空格、格式缩进、都好等等，不改变代码逻辑 |\r\n| refactor |         代码重构，没有加新功能或者修复 bug         |\r\n| perf     |                增加代码进行性能测试                |\r\n| test     |                    增加测试用例                    |\r\n| chore    |        改变构建流程、或者增加依赖库、工具等        |\r\n\r\n### scope\r\n\r\n本次 commit 波及的范围\r\n\r\n### subject\r\n\r\n简明扼要的阐述下本次 commit 的主旨\r\n\r\n有几点需要注意：\r\n\r\n1. 首字母不要大写\r\n2. 结尾无需添加标点\r\n\r\n### body\r\n\r\n主体内容，我们需要把本次 commit 详细的描述一下，比如此次变更的动机等，不能超出 72 个字符\r\n\r\n> 为什么需要\r\n>\r\n> - 它可能是用来修复一个 bug，增加一个 feature，提升性能、可靠性、稳定性等等\r\n> - 它如何解决这个问题? 具体描述解决问题的步骤\r\n> - 是否存在副作用、风险?\r\n\r\n### footer\r\n\r\n描述下与之关联的 issue 或 break change，在公司项目中基本忽略即可\r\n\r\n## 参考文章\r\n\r\n- [Git 分支管理规范](https://juejin.cn/post/6844903945245048846#heading-1)\r\n",
          "reactions": {
            "url": "https://api.github.com/repos/bosens-China/blog/issues/70/reactions",
            "total_count": 0,
            "+1": 0,
            "-1": 0,
            "laugh": 0,
            "hooray": 0,
            "confused": 0,
            "heart": 0,
            "rocket": 0,
            "eyes": 0
          },
          "timeline_url": "https://api.github.com/repos/bosens-China/blog/issues/70/timeline",
          "performed_via_github_app": null,
          "state_reason": null
        },
        {
          "url": "https://api.github.com/repos/bosens-China/blog/issues/71",
          "repository_url": "https://api.github.com/repos/bosens-China/blog",
          "labels_url": "https://api.github.com/repos/bosens-China/blog/issues/71/labels{/name}",
          "comments_url": "https://api.github.com/repos/bosens-China/blog/issues/71/comments",
          "events_url": "https://api.github.com/repos/bosens-China/blog/issues/71/events",
          "html_url": "https://github.com/bosens-China/blog/issues/71",
          "id": 914142576,
          "node_id": "MDU6SXNzdWU5MTQxNDI1NzY=",
          "number": 71,
          "title": "团队规范系列之工程规范",
          "user": {
            "login": "bosens-China",
            "id": 39508895,
            "node_id": "MDQ6VXNlcjM5NTA4ODk1",
            "avatar_url": "https://avatars.githubusercontent.com/u/39508895?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/bosens-China",
            "html_url": "https://github.com/bosens-China",
            "followers_url": "https://api.github.com/users/bosens-China/followers",
            "following_url": "https://api.github.com/users/bosens-China/following{/other_user}",
            "gists_url": "https://api.github.com/users/bosens-China/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/bosens-China/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/bosens-China/subscriptions",
            "organizations_url": "https://api.github.com/users/bosens-China/orgs",
            "repos_url": "https://api.github.com/users/bosens-China/repos",
            "events_url": "https://api.github.com/users/bosens-China/events{/privacy}",
            "received_events_url": "https://api.github.com/users/bosens-China/received_events",
            "type": "User",
            "site_admin": false
          },
          "labels": [
            {
              "id": 3661376441,
              "node_id": "LA_kwDOCzPAy87aPCu5",
              "url": "https://api.github.com/repos/bosens-China/blog/labels/%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83",
              "name": "代码规范",
              "color": "5319e7",
              "default": false,
              "description": "团队规范、代码规范、技术选型等相关内容"
            }
          ],
          "state": "open",
          "locked": false,
          "assignee": null,
          "assignees": [],
          "milestone": null,
          "comments": 0,
          "created_at": "2021-06-08T01:42:17Z",
          "updated_at": "2021-12-21T10:00:23Z",
          "closed_at": null,
          "author_association": "OWNER",
          "active_lock_reason": null,
          "body": "![bg](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7235b285206d49f5bb8f0cc2e43771c9~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n最近一周的工作重心就是在梳理团队规范，在写的过程也查缺补漏了不少知识，剔除掉关于公司场景的部分就有了这一系列的文章，预计写四部分：\r\n\r\n1. [git 规范](https://github.com/bosens-China/blog/issues/70)\r\n2. 工程规范\r\n3. [用户体验规范](https://github.com/bosens-China/blog/issues/72)\r\n4. [命名规范](https://github.com/bosens-China/blog/issues/73)\r\n\r\n# 工程规范\r\n\r\n## 项目目录\r\n\r\n项目目录定义的名称应当做到清晰易读，对于每个文件夹可以放置一个`README.md`的文件，对重要部分和职责进行描述，下面给一份常用的示例：\r\n\r\n```sh\r\n├── public                          // 静态页面\r\n├── scripts                         // 相关脚本配置\r\n├── src                             // 主目录\r\n    ├── assets                      // 静态资源\r\n    ├── components                  // 全局组件\r\n    ├── lib                         // 全局插件\r\n    ├── router                      // 路由配置\r\n    ├── store                       // vuex 配置\r\n    ├── styles                      // 样式\r\n    ├── utils                       // 工具方法(axios封装，全局方法等)\r\n    ├── views                       // 页面\r\n    ├── App.vue                     // 页面主入口\r\n    ├── main.js                     // 脚本主入口\r\n```\r\n\r\n下面再说几条建议：\r\n\r\n- 如果存在嵌套路由的页面，可以在 src 定义一个 `layout` 当做基础的视图组件使用\r\n- `components` 文件内的组件请保持通用性\r\n- 如果 views 存在业务组件，可以在当前目录下新建 components 使用，或者基于全局 components 进行二次封装\r\n- views 下的页面使用文件夹的形式来定义，例如有一个统计页面，如果只写一个`.vue`文件会导致文件内容过多，而如果直接在 views 下进行抽离多个`.vue`会导致结构不统一\r\n\r\n## utils\r\n\r\n对于 utils 下的文件，请保持按照文件类型进行划分，下面截取[ant-design-pro](https://github.com/ant-design/ant-design-pro/tree/master/src/utils)的 utils 文件为例\r\n\r\n| 名称          |                            提交信息                             |\r\n| ------------- | :-------------------------------------------------------------: |\r\n| Authorized.ts |                     use @umijs/fabric@2.5.0                     |\r\n| authority.ts  |       🌎 localization: docs translated to english (#7938)       |\r\n| request.ts    |       🌎 localization: docs translated to english (#7938)       |\r\n| utils.less    |                clean: remove unuse less (#6214)                 |\r\n| utils.test.ts | feat: @umijs/route-utils replace getAuthorityFromRouter (#7319) |\r\n| utils.ts      |       🌎 localization: docs translated to english (#7938)       |\r\n\r\n> 在开发项目中，请优先使用 [lodash](https://www.lodashjs.com/) 这样的工具库，并在此基础上封装自己的方法，如果真的不存再在考虑手动实现从 0 到 1 实现\r\n\r\n## VueX\r\n\r\n在大型项目中，对 VueX 的拆分通常根据业务，请不要直接使用 VueX 下的`State`、`Getter`、`Mutation`等，而是改用`Module`将相关依赖聚合在一起，最后通过`import`整合在一起，下面以 home 文件夹为例：\r\n\r\n```sh\r\n├── home                            // 主目录\r\n    ├── index.js                    // VueX state getters mutations action 管理\r\n    ├── ...                         // 可能存在的其它文件\r\n└── index.js                        // VueX 主入口\r\n```\r\n\r\nhome/index.js\r\n\r\n```js\r\nexport default {\r\n  namespaced: true,\r\n  state: () => ({ ... }),\r\n  mutations: { ... },\r\n  actions: { ... },\r\n  getters: { ... }\r\n}\r\n```\r\n\r\nindex.js\r\n\r\n```js\r\nimport { createStore } from 'vuex';\r\nimport home from './home';\r\n\r\nconst store = createStore({\r\n  modules: {\r\n    home,\r\n  },\r\n});\r\n\r\nexport default store;\r\n```\r\n\r\n## Router\r\n\r\n### 路由层级\r\n\r\n路由层级十分重要，在 Router4 之前，会根据路由定义的顺序来决定路由的先后顺序，如果层级很不清晰会导致两个问题：\r\n\r\n- 维护或者定义新路由需要查找半天\r\n- 遍历 routes 信息十分困难，做权限之类的的很麻烦\r\n\r\n![1.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8312de118fe34964afb919655f2f7292~tplv-k3u1fbpfcp-watermark.image)\r\n\r\n举个例子，对于上面的一个设计图，包含：`head、content、footer`三个部分，观察他们剩余设计图顶部和底部基本相同，只是 content 区域的内容有所不同。\r\n\r\n而对这样一个设计图进行开发，可以定义一个`layout`组件当做基础公共结构，之后书写`routers`的具体信息\r\n\r\n```sh\r\n├── routes                            // routes的定义目录\r\n    ├── home.js                       // 首页\r\n    ├── type.js                       // 分类\r\n    ├── food.js                       // 东家菜\r\n    ├── brand.js                       // 大牌\r\n└── index.js                          // vue router 主入口\r\n└── routes.js                         // 将routers目录下的文件分发成最终vue router使用结构\r\n```\r\n\r\nroutes.js\r\n\r\n```js\r\nimport layout from '@/layout';\r\nimport home from './routes/home';\r\nimport type from './routes/type';\r\nimport food from './routes/food';\r\nimport brand from './routes/brand';\r\n\r\nconst routes = [\r\n  {\r\n    path: '/',\r\n    component: layout,\r\n    children: home,\r\n  },\r\n  {\r\n    path: '/',\r\n    component: layout,\r\n    children: type,\r\n  },\r\n  {\r\n    path: '/',\r\n    component: layout,\r\n    children: food,\r\n  },\r\n  {\r\n    path: '/',\r\n    component: layout,\r\n    children: brand,\r\n  },\r\n];\r\n\r\nexport default routes;\r\n```\r\n\r\nindex.js\r\n\r\n```js\r\nimport { createRouter, createWebHistory, createWebHashHistory } from 'vue-router';\r\n\r\nimport routes from './routes';\r\n\r\nconst router = createRouter({\r\n  routes,\r\n});\r\n\r\n// 全局导航守卫\r\nrouter.beforeEach(async (to) => {\r\n  // ...\r\n});\r\n\r\nexport default router;\r\n```\r\n\r\n### 捕获未知路由\r\n\r\n无论在做中台还是移动端的产品，都需要正确处理未知的路由，一般而言有二种处理方式，具体参考项目的类型进行选择：\r\n\r\n1. 直接给出 404 之类的提示，提示页面不存在等信息；\r\n2. 帮助其重定向到首页或者其它页面；\r\n\r\n```js\r\n// vue router4\r\n{ path: '/:pathMatch(._)_', name: 'NotFound', redirect: { name: 'home' } };\r\n\r\n// vue router3\r\n{ path: '*', name: 'NotFound', redirect: { name: 'home' } };\r\n```\r\n\r\n### 路由懒加载\r\n\r\n使用懒加载可以节省白屏时间，懒加载的机制利用了 webpack 代码分割 + import()，只在进入当前路由的时候加载所依赖的 js 文件。\r\n\r\n```js\r\n  { path: '/', name: 'home', component: () => import(/* webpackChunkName: \"home\" */ 'views/home/index.vue') }\r\n```\r\n\r\n> 除了需要`children`的父级页面，所有其它页面统一使用懒加载\r\n>\r\n> `/* webpackChunkName: \"home\" */`这样的注释语法，是 webpack 独有的，它负责 build 打包之后的文件名称\r\n\r\n## 组件拆分建议\r\n\r\n![2.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/620871b1cb374af4a5995db475119ba6~tplv-k3u1fbpfcp-watermark.image)\r\n\r\n一个大型项目由无数子组件组合而成，有点像乐高积木一样，直接开发一个大型项目肯定很难，但是如果给无数子组件让你拼接则相对简单。\r\n\r\n组件的拆分，应该遵循两个原则：\r\n\r\n### 颗粒度细分\r\n\r\n在学习设计模式中有很重要的一句话就是**单一职责**，在组件开发也是同理，原则上让一个组件只负责一件事情，可以最大程度的复用组件，方便测试和定位问题。\r\n\r\n但是过度的单一职责组件也会导致一个问题就是颗粒度太细造成组件的碎片化，举一个例子来说，自动完成组件，它是搜索框 + select 组合而成，因此我们可以直接复用，因为前两个组件的颗粒度刚刚好。\r\n\r\n![3.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0e6da1bee9e44e9a9059520b8555a99b~tplv-k3u1fbpfcp-watermark.image)\r\n\r\n还有一个例子就是徽章数组件(Badge)，它的右上角会有红点提示，可能是数字也可能是 icon，它的职责当然也很单一，这个红点提示也理所当然也可以被单独抽象为一个独立组件，但是我们通常不会将它作为独立组件，因为在其它场景中这个组件是无法被复用的，因为没有类似的场景再需要小红点这个小组件了\r\n\r\n![4.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/517274f4b3744cd9acd35e15c091425f~tplv-k3u1fbpfcp-watermark.image)\r\n\r\n### 通用性考虑\r\n\r\n组件分为基础组件和业务组件，当存在业务常见重复使用的时候通常会对通用组件进行二次封装，例如有一个搜索部门的组件，这个组件在很多 view 都有复用而且也对这个组件集成了自动搜索 + 初始 loading + 自动加载下一页，最后使用效果用起来也很方便。\r\n\r\n但是现在突然来一个需求，说对搜索的组件进行底部提示，那难道直接更改源码吗？但是如果直接更改组件，这样也违背了`开放、关闭原则`\r\n\r\n其实说这个例子就是希望思考组件广的适配性，在使用第三方的组件，会看到它们暴露了很多插槽、jsx 的渲染函数，最终的目的也就是应对各种各样的场景\r\n\r\n> 组件的形态(DOM 结构)永远是千变万化的，但是其行为(逻辑)是固定的，因此通用组件的秘诀之一就是将 DOM 结构的控制权交给开发者,组件只负责行为和最基本的 DOM 结构\r\n\r\n## 工程优化\r\n\r\n优化是一个很庞大的命题，根据项目的不同所采取的方式也不尽相同，下面只总结一些常用的方式\r\n\r\n### 项目优化\r\n\r\n- CND\r\n- gzip，让后端支持 gzip 压缩，前端也生成 gzip 文件\r\n- 使用 webp 格式，生产环境下压缩图片\r\n- 路由懒加载\r\n- 第三方组件按需加载\r\n- 抽离第三方库，避免和业务组件耦合一起打包\r\n- ...\r\n\r\n### code 优化\r\n\r\n- 减少对 dom 操作，如果操作将所有 dom 聚合在一起修改\r\n- 不直接修改 style 改用 class 修改；\r\n- 尽量不适用 table，绑定事件采用事件委托形式\r\n- 对动画元素，让其脱离文档流，减少重绘和重排\r\n- ...\r\n\r\n### 构建过程优化\r\n\r\n- 删除 eslint-loader，改用编辑器自带的 eslint\r\n- 使用 catch-loader，对资源进行加速\r\n- 生产环境下删除`.map`文件，缩短`import`查找后缀\r\n- ...\r\n",
          "reactions": {
            "url": "https://api.github.com/repos/bosens-China/blog/issues/71/reactions",
            "total_count": 0,
            "+1": 0,
            "-1": 0,
            "laugh": 0,
            "hooray": 0,
            "confused": 0,
            "heart": 0,
            "rocket": 0,
            "eyes": 0
          },
          "timeline_url": "https://api.github.com/repos/bosens-China/blog/issues/71/timeline",
          "performed_via_github_app": null,
          "state_reason": null
        },
        {
          "url": "https://api.github.com/repos/bosens-China/blog/issues/72",
          "repository_url": "https://api.github.com/repos/bosens-China/blog",
          "labels_url": "https://api.github.com/repos/bosens-China/blog/issues/72/labels{/name}",
          "comments_url": "https://api.github.com/repos/bosens-China/blog/issues/72/comments",
          "events_url": "https://api.github.com/repos/bosens-China/blog/issues/72/events",
          "html_url": "https://github.com/bosens-China/blog/issues/72",
          "id": 914175625,
          "node_id": "MDU6SXNzdWU5MTQxNzU2MjU=",
          "number": 72,
          "title": "团队规范系列之用户体验规范",
          "user": {
            "login": "bosens-China",
            "id": 39508895,
            "node_id": "MDQ6VXNlcjM5NTA4ODk1",
            "avatar_url": "https://avatars.githubusercontent.com/u/39508895?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/bosens-China",
            "html_url": "https://github.com/bosens-China",
            "followers_url": "https://api.github.com/users/bosens-China/followers",
            "following_url": "https://api.github.com/users/bosens-China/following{/other_user}",
            "gists_url": "https://api.github.com/users/bosens-China/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/bosens-China/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/bosens-China/subscriptions",
            "organizations_url": "https://api.github.com/users/bosens-China/orgs",
            "repos_url": "https://api.github.com/users/bosens-China/repos",
            "events_url": "https://api.github.com/users/bosens-China/events{/privacy}",
            "received_events_url": "https://api.github.com/users/bosens-China/received_events",
            "type": "User",
            "site_admin": false
          },
          "labels": [
            {
              "id": 3661376441,
              "node_id": "LA_kwDOCzPAy87aPCu5",
              "url": "https://api.github.com/repos/bosens-China/blog/labels/%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83",
              "name": "代码规范",
              "color": "5319e7",
              "default": false,
              "description": "团队规范、代码规范、技术选型等相关内容"
            }
          ],
          "state": "open",
          "locked": false,
          "assignee": null,
          "assignees": [],
          "milestone": null,
          "comments": 0,
          "created_at": "2021-06-08T02:22:11Z",
          "updated_at": "2021-12-21T10:00:18Z",
          "closed_at": null,
          "author_association": "OWNER",
          "active_lock_reason": null,
          "body": "![bg](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b9625a50c497462ab14fb45ab08d21d6~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n最近一周的工作重心就是在梳理团队规范，在写的过程也查缺补漏了不少知识，剔除掉关于公司场景的部分就有了这一系列的文章，预计写四部分：\r\n\r\n1. [git 规范](https://github.com/bosens-China/blog/issues/70)\r\n2. [工程规范](https://github.com/bosens-China/blog/issues/71)\r\n3. 用户体验规范\r\n4. [命名规范](https://github.com/bosens-China/blog/issues/73)\r\n\r\n# 用户体验规范\r\n\r\n关于用户体验是一个很庞大的命题并且每个人对于体验的理解也各不相同，同时伴随着时效性，随着新技术的出现可能之前的体验就很快落伍了，所以下面内容只能简短概括下。\r\n\r\n## 通用准则\r\n\r\n### 增加可点击区域大小\r\n\r\n![1.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a2fb47391323406d90d3cc8a350bdf0b~tplv-k3u1fbpfcp-watermark.image)\r\n\r\n以上图为例，如果必须点击到`checkbox`区域才能点击生效，必然会导致体验不佳\r\n\r\n组件的考虑一致性同时也包含了页面结构，对于上图所示 label 和 checkbox 就是一个整体，这里抛砖引玉说一些常见适用该准则的元素：\r\n\r\n- header 区域右上角头像和姓名部分；\r\n- Label、li 等整体一行元素；\r\n- 自定义图标\r\n- ...\r\n\r\n在对上面元素进行交互的时候，尽量避免用户的点击成本，下面说两个常见的做法\r\n\r\n#### 增大整体区域点击，例如有下面一个头像区域\r\n\r\n```html\r\n<p class=\"portrait\">\r\n  <img class=\"portrait-img\" src=\"xxx\" />\r\n  <span class=\"portrait-name\">xxxx</span>\r\n</p>\r\n```\r\n\r\n如果原本是点击事件绑定在`.portrait-img`，那么请考虑增加到`.portrait`\r\n\r\n#### 增大元素本身的点击区域\r\n\r\n```html\r\n<i class=\"i-con\"></i>\r\n```\r\n\r\n对于上面的 i 元素，通常用来设置自定义图标，但是在实际操作中，用户的鼠标或者手势可能存在偏差所以需要增加这个元素的本身范围。\r\n\r\n回归`css box`的概念，我们可以增加`border`来完成增加区域的效果\r\n\r\n```css\r\n.i-con {\r\n  /* 省略其它代码 */\r\n  border: 5px solid transparent;\r\n}\r\n```\r\n\r\n> 注意：pc 上还需要考虑光标的一致性，以及 hover 等一系列整体的效果\r\n\r\n### 图片相关优化\r\n\r\n对于很多项目而言，图片是常见的优化点，毕竟多方面的优化远没有压缩一张图片来的直观，而对于用户体验来说也同样是\r\n\r\n#### 预加载\r\n\r\n不同于懒加载，预加载的目的就是提前输出图片，避免用户等待。\r\n\r\n举一个常见的例子：轮播图就很适合使用预加载，否则用户看到下一张图片的时候还继续等待加载就会感觉很突兀。\r\n\r\n预加载的原理就是提前请求，之后重复请求相同资源时会返回缓存文件，我们可以封装一个方法，利用`Image`对 src 赋值即可\r\n\r\n```js\r\nconst preloading = (src) => {\r\n  return new Promise((resolve, reject) => {\r\n    const img = new Image();\r\n    img.src = src;\r\n    img.onload = resolve;\r\n    img.onerror = reject;\r\n  });\r\n};\r\n```\r\n\r\n#### 错误图片\r\n\r\n各个浏览器对错误图片的处理方式各不相同，虽然存在`alt`提示信息，但是不够统一和美观\r\n\r\n![2.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/eb2385e0dcf34915b0ada7050405f3a5~tplv-k3u1fbpfcp-watermark.image)\r\n\r\n例如上面这种错误信息看起来就不够美观，更好的做法给出默认的错误图片，监听图片的`onerror`事件来重新赋值，如果不想一个个写，可以监听`window.addEventListener error`来完成全局监听\r\n\r\n```js\r\nwindow.addEventListener(\r\n  'error',\r\n  function (event) {\r\n    var dom = event.target;\r\n    if (/img/i.test(dom.nodeName)) {\r\n      dom.src = 'xxxx.png';\r\n    }\r\n  },\r\n  true\r\n);\r\n```\r\n\r\n> 如果想增加对错误图片进行重试，或者对 JSP 动态渲染内容进行拦截，可以参考这篇文章[如何优雅处理图片异常](https://juejin.cn/post/6844904046705246216#heading-2)\r\n\r\n### 空数据默认处理\r\n\r\n对空数据放任不管，可能会导致用户认为系统出现了问题，通常情况下我们要尽量避免空数据的出现，一般而言有两种处理方式\r\n\r\n#### 使用 empty（空状态）进行填充\r\n\r\n![3.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1a378691e6c94997ad9cbf2578f3d310~tplv-k3u1fbpfcp-watermark.image)\r\n\r\n一般 UI 框架现在都内置 empty 组件，可以跟产品和设计沟通无误后，对于常见的 table 或者 list 无数据的进行默认的提示\r\n\r\n```vue\r\n<template>\r\n  <template v-if=\"list.length\"> /* ... */ </template>\r\n  <template v-else>\r\n    <empty />\r\n  </template>\r\n</template>\r\n```\r\n\r\n#### 隐藏整体区域\r\n\r\n![1.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2945ac9ba5ed4a8d83341bf1815157fe~tplv-k3u1fbpfcp-watermark.image)\r\n\r\n对于上面的作者帮当，如果当前子项不存在数据，只展示一个标题和完整榜单的信息可能会很奇怪那不妨考虑删除整体区域\r\n\r\n### 优先使用语义化标签\r\n\r\n尽量避免无语义的`div、span`滥用，因为搜索引擎抓录不友好，维护起来不够直观，而且使用语义化标签可以节省很多代码性工作，下面举一个例子\r\n\r\n![5.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/942b4d168d254463801b2938ee7c8cbe~tplv-k3u1fbpfcp-watermark.image)\r\n\r\n例如上面的按钮，假设它的功能是跳转到一个新的页面，如果在 spa 页面中，我们可以直接使用`vue-router`自带的`router-link`跳转即可完成，而在传统开发中可以在`button`外部嵌套一个`a`标签完成跳转\r\n\r\n```html\r\n<a href=\"xxx\">\r\n  <button>xxx</button>\r\n</a>\r\n<!-- 或者 -->\r\n<router-link to=\"xxx\">\r\n  <button>xxx</button>\r\n</router-link>\r\n```\r\n\r\n而且这样做很容易配合浏览器的一些其它行为，比如右击打开在新标签页\r\n\r\n### 操作反馈\r\n\r\n操作反馈是提升用户体验的一个重要指标，具体可以展开为三部分来说\r\n\r\n#### Require 反馈\r\n\r\n在与后端进行通信的过程中，如果成功或者失败，都请告知用户，而且提示的消息必须友好。\r\n\r\n这里有一个准则\r\n\r\n- 成功消息可以由前端来定义，可以结合各种操作场景做到更细致的提示\r\n- 对于错误消息，则返回后端返回的 message 等信息\r\n- 对于 500 等错误，请在拦截器统一改成`网络连接错误，请稍后重试`，而不是提示一串超时等英文信息\r\n\r\n#### 元素反馈\r\n\r\n在衡量一个 ui 框架的时候就有两点很重要：\r\n\r\n1. 组件本身的交互是否友好，比如动画是否流畅，有没有 hover、active 等效果\r\n2. 对于无障碍阅读是否友好\r\n\r\n可见交互的重要性，要让用户感觉自己在点击一个真实存在的元素，而不是像图片一样的静止\r\n\r\n![6.gif](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f7548ccd492147eb989ca42b2057e0d6~tplv-k3u1fbpfcp-watermark.image)\r\n\r\n例如上图中，最少要存在`hover`、`active`等效果\r\n\r\n#### 等待反馈\r\n\r\n![7.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6af4503f4f9c425583118b98b1f3b57e~tplv-k3u1fbpfcp-watermark.image)\r\n\r\n因为与后端的通信是异步的，而且用户的网络好坏也不是固定不变的，所以给元素添加`loading`就很有必要，这里说两个常见的场景\r\n\r\n#### 表单提交\r\n\r\n![7.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6af4503f4f9c425583118b98b1f3b57e~tplv-k3u1fbpfcp-watermark.image)\r\n\r\n需要操作交互的常见都可以考虑使用`loading`，这样可以防止用户重复点击和避免用户不知道有没有点击成功\r\n\r\n#### 重新获取数据\r\n\r\n![8.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/17d967b2947344f5815e114084df2ad8~tplv-k3u1fbpfcp-watermark.image)\r\n\r\n#### 获取前置信息\r\n\r\n在 pc 上，整体进入页面的时候为了掩盖获取一些前置的信息的场景，可以选择使用 loading 元素减少用户等待的焦虑感\r\n\r\n### 缓存\r\n\r\n缓存本质上就是拿空间换时间，对于客户端而言，更多的瓶颈是在时间上，下面就说两种常见的缓存场景\r\n\r\n#### 组件信息缓存\r\n\r\n![9.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2dbabc0b5fb8449297b174ca267ef2f2~tplv-k3u1fbpfcp-watermark.image)\r\n\r\n例如上面表单，如果用户误操作关闭网页，从头开始填写体验就不是特别好，可以在未提交成功的状态下结合本地做持久化缓存\r\n\r\n下面给一个简单示例（没有给出完成清除本地储存）\r\n\r\n```vue\r\n<script>\r\nimport { reactive, watchEffect } from 'vue';\r\n\r\nexport default {\r\n  setUp() {\r\n    const key = 'form';\r\n    const form = reactive({\r\n      name: '',\r\n      password: '',\r\n    });\r\n    const set = (key, value) => {\r\n      localStorage.setItem(key, JSON.stringify(value));\r\n    };\r\n    const get = () => {\r\n      const value = localStorage.getItem(key);\r\n      try {\r\n        return JSON.parse(value);\r\n      } catch {\r\n        return undefined;\r\n      }\r\n    };\r\n    watchEffect(() => {\r\n      set(key, form);\r\n    });\r\n    Object.assign(form, get('form'));\r\n  },\r\n};\r\n</script>\r\n```\r\n\r\n#### 接口缓存\r\n\r\n如果存在频繁请求且很耗时，接口本身基本不会变更的情况，可以考虑接口缓存，下面给出一段简单的代码示例\r\n\r\n生产环境可以考虑使用一些库 [axios-request-cache](https://github.com/ZhengXiaowei/axios-request-cache)\r\n\r\n```js\r\nimport axios from 'axios';\r\nconst { toString } = Object.prototype;\r\n\r\n// 数据存储\r\nexport const cache = {\r\n  data: {},\r\n  set(key, data) {\r\n    this.data[key] = data;\r\n  },\r\n  get(key) {\r\n    return this.data[key];\r\n  },\r\n  clear(key) {\r\n    delete this.data[key];\r\n  },\r\n};\r\n\r\n// 建立唯一的key值\r\nexport const buildUniqueUrl = (url, method, params = {}, data = {}) => {\r\n  const paramStr = (obj) => {\r\n    if (toString.call(obj) === '[object Object]') {\r\n      return JSON.stringify(\r\n        Object.keys(obj)\r\n          .sort()\r\n          .reduce((result, key) => {\r\n            result[key] = obj[key];\r\n            return result;\r\n          }, {})\r\n      );\r\n    } else {\r\n      return JSON.stringify(obj);\r\n    }\r\n  };\r\n  url += `?${paramStr(params)}&${paramStr(data)}&${method}`;\r\n  return url;\r\n};\r\n\r\n// 防止重复请求\r\nexport default (options = {}) =>\r\n  async (config) => {\r\n    const defaultOptions = {\r\n      // 设置为0，不清除缓存\r\n      time: 0,\r\n      ...options,\r\n    };\r\n    const index = buildUniqueUrl(config.url, config.method, config.params, config.data);\r\n    let responsePromise = cache.get(index);\r\n    if (!responsePromise) {\r\n      responsePromise = (async () => {\r\n        try {\r\n          const response = await axios.defaults.adapter(config);\r\n          return Promise.resolve(response);\r\n        } catch (reason) {\r\n          cache.clear(index);\r\n          return Promise.reject(reason);\r\n        }\r\n      })();\r\n      cache.set(index, responsePromise);\r\n      if (defaultOptions.time !== 0) {\r\n        setTimeout(() => {\r\n          cache.clear(index);\r\n        }, defaultOptions.time);\r\n      }\r\n    }\r\n    // 为防止数据源污染\r\n    return responsePromise.then((data) => JSON.parse(JSON.stringify(data)));\r\n  };\r\n```\r\n\r\n### 风格一致性\r\n\r\n风格一致性包含很多部分，这里不太好全部列举，就说两个常见的\r\n\r\n#### 视觉颜色一致\r\n\r\n每个页面都有一个主色号，对于设计图或者原型图没有给到的部分，自己动手或者引用组件时需要考虑是否跟主色号存在冲突，这里推荐阅读一下`视觉规范`，下面给出一个示例\r\n\r\n![2.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2efab79f3bf4429c852e5f7e4182a8ae~tplv-k3u1fbpfcp-watermark.image)\r\n\r\n![3.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4f0aabbe895d42f0b18b0bdd5b9a7698~tplv-k3u1fbpfcp-watermark.image)\r\n\r\n在默认的 vant 组件中，tab 默认的颜色是`#ee0a24`，如果直接放上去就会导致页面风格不统一，因为页面整体风格是蓝色\r\n\r\n#### 组件交互一致性\r\n\r\n这里在自定义扩展或者二次封装比较常见，还是以表单为例\r\n\r\n![9.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/56f9f210d65e4ae9b23516548a1056e1~tplv-k3u1fbpfcp-watermark.image)\r\n\r\n如果我们想自定义根据业务进行一个文件上传的组件，除了考虑功能本身的实现，还要考虑一致性的问题，例如校验的问题\r\n\r\n这里`Ant Design `在不符合条件的`form-item`下面出现一个红字提示，而如果我们使用`message`或者其他提示就会造成提示信息的不一致性，那更好的做法就是根据官方文档提供的自定义插件做法进行组件开发。\r\n\r\n## pc\r\n\r\n### 考虑最小布局\r\n\r\n请设置`min-width`，防止因为宽度不够导致元素挤在一起\r\n\r\n```css\r\nbody {\r\n  /* 省略其它 */\r\n  min-width: 1200px;\r\n  overflow: auto;\r\n}\r\n```\r\n\r\n### 表格宽度\r\n\r\n对于表格，根据字段的权值不同分配的宽度也应该不同，尽量不要使用`auto`避免二次表格宽度计算造成视觉上的浮动\r\n\r\n![13.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d295a4f0c4544388b1190c62b862bd3c~tplv-k3u1fbpfcp-watermark.image)\r\n\r\n对于不可省略的信息可以让其换行展示，否则请考虑`ellipsis`\r\n\r\n```css\r\n.ellipsis {\r\n  overflow: hidden;\r\n  white-space: nowrap;\r\n  text-overflow: ellipsis;\r\n}\r\n```\r\n\r\n### 指标卡片添加 tip\r\n\r\n在一些中台产品中，很容易遇到一些专业名词，比如`pv`和`uv`等，对于这种专业名词，建议添加一个问号的提示图标，鼠标移动上去给与提示\r\n\r\n![14.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fc35ab89bc294f45b7c0c070d527ec9e~tplv-k3u1fbpfcp-watermark.image)\r\n\r\n上面效果仅供参考\r\n\r\n### 支持键盘快捷键\r\n\r\n![9.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6a0349131f50469e85f9efbeb0934b2f~tplv-k3u1fbpfcp-watermark.image)\r\n\r\n如上图所示，在我们使用`form`或者`input`时，如果按下`enter`时请确保可以进行正常的搜索或者提交操作，不仅局限于表单提交，对于一些常见的搜索场景都需要考虑\r\n\r\n一个好的建议，对于需要 submit 的子元素，都绑定`.enter`修饰符\r\n\r\n```vue\r\n<input @keyup.enter=\"submit\" />\r\n```\r\n\r\n### SPA 路由导航\r\n\r\n对于单页面导航请考虑使用[nprogress](https://github.com/rstacruz/nprogress)这样的进度条，为你的页面添加进度通知\r\n\r\n![15.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7b2a1bf70cab4c279339f2e11ef5e5e0~tplv-k3u1fbpfcp-watermark.image)\r\n\r\n## 移动端\r\n\r\n### 左右滑动监听\r\n\r\n浏览了许多 H5 的页面，对于手势左右滑动基本上都没做支持，而在很多 App 上，例如知乎，从首页进去问题左滑就可以返回\r\n\r\n![微信图片_20210608100923.jpg](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5e1ef02488054521999304fe663d9867~tplv-k3u1fbpfcp-watermark.image)\r\n\r\n这里稍微建议一下，对于下面两种情况可以考虑引入左滑返回\r\n\r\n- 跟上面图片一致的 tab 页比较多，可以考虑做成 tab 下的元素滑动监听\r\n- 对于一些列表和详情页\r\n\r\n推荐一个库源码也很简洁可以基于这个库进行二次封装，提高用户的体验 [swipy](https://github.com/whitecube/swipy)\r\n\r\n### 尽量使用 SVG\r\n\r\nSVG 是一种图像文件格式，它的英文全称为 Scalable Vector Graphics，意思为可缩放的矢量图形。基于 XML 的标记语言\r\n\r\nSVG 是矢量图，它有很多优点\r\n\r\n- SVG 是可伸缩的，在任何的分辨率下被高质量地打印\r\n- SVG 可在图像质量不下降的情况下被放大\r\n- 修改方便，可以在记事本之类的软件中被打开\r\n\r\n而在开发移动端，面对的用户手机的屏幕也各不相同，之前的做法是对不同 ratio 的手机选择不同的图片，但是根据上面 SVG 的优点，我们可以直接选用 SVG 当做图片\r\n\r\n而在 SVG 不适用的场景，我们可以利用媒体查询，选择合适的高倍图\r\n\r\n```js\r\nexport const getMultipleImg = (img1, img2) => {\r\n  const mql = window.matchMedia('@media only screen and (-webkit-min-device-pixel-ratio:3)');\r\n  if (mql.matches) {\r\n    return img2;\r\n  }\r\n  return img1;\r\n};\r\n```\r\n",
          "reactions": {
            "url": "https://api.github.com/repos/bosens-China/blog/issues/72/reactions",
            "total_count": 0,
            "+1": 0,
            "-1": 0,
            "laugh": 0,
            "hooray": 0,
            "confused": 0,
            "heart": 0,
            "rocket": 0,
            "eyes": 0
          },
          "timeline_url": "https://api.github.com/repos/bosens-China/blog/issues/72/timeline",
          "performed_via_github_app": null,
          "state_reason": null
        },
        {
          "url": "https://api.github.com/repos/bosens-China/blog/issues/73",
          "repository_url": "https://api.github.com/repos/bosens-China/blog",
          "labels_url": "https://api.github.com/repos/bosens-China/blog/issues/73/labels{/name}",
          "comments_url": "https://api.github.com/repos/bosens-China/blog/issues/73/comments",
          "events_url": "https://api.github.com/repos/bosens-China/blog/issues/73/events",
          "html_url": "https://github.com/bosens-China/blog/issues/73",
          "id": 914211223,
          "node_id": "MDU6SXNzdWU5MTQyMTEyMjM=",
          "number": 73,
          "title": "团队规范系列之命名规范",
          "user": {
            "login": "bosens-China",
            "id": 39508895,
            "node_id": "MDQ6VXNlcjM5NTA4ODk1",
            "avatar_url": "https://avatars.githubusercontent.com/u/39508895?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/bosens-China",
            "html_url": "https://github.com/bosens-China",
            "followers_url": "https://api.github.com/users/bosens-China/followers",
            "following_url": "https://api.github.com/users/bosens-China/following{/other_user}",
            "gists_url": "https://api.github.com/users/bosens-China/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/bosens-China/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/bosens-China/subscriptions",
            "organizations_url": "https://api.github.com/users/bosens-China/orgs",
            "repos_url": "https://api.github.com/users/bosens-China/repos",
            "events_url": "https://api.github.com/users/bosens-China/events{/privacy}",
            "received_events_url": "https://api.github.com/users/bosens-China/received_events",
            "type": "User",
            "site_admin": false
          },
          "labels": [
            {
              "id": 3661376441,
              "node_id": "LA_kwDOCzPAy87aPCu5",
              "url": "https://api.github.com/repos/bosens-China/blog/labels/%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83",
              "name": "代码规范",
              "color": "5319e7",
              "default": false,
              "description": "团队规范、代码规范、技术选型等相关内容"
            }
          ],
          "state": "open",
          "locked": false,
          "assignee": null,
          "assignees": [],
          "milestone": null,
          "comments": 0,
          "created_at": "2021-06-08T02:53:40Z",
          "updated_at": "2021-12-21T10:00:13Z",
          "closed_at": null,
          "author_association": "OWNER",
          "active_lock_reason": null,
          "body": "![bg](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4b7b48b9a67c44eab564bf46e99f1ee0~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n最近一周的工作重心就是在梳理团队规范，在写的过程也查缺补漏了不少知识，剔除掉关于公司场景的部分就有了这一系列的文章，预计写四部分：\r\n\r\n1. [git 规范](https://github.com/bosens-China/blog/issues/70)\r\n2. [工程规范](https://github.com/bosens-China/blog/issues/71)\r\n3. [用户体验规范](https://github.com/bosens-China/blog/issues/72)\r\n4. 命名规范\r\n\r\n# 命名规范\r\n\r\n命名规范请结合团队情况来进行制定，如果想更进阶一些可以配合 git 钩子写校验工具，配合规范食用\r\n\r\n## 代码命名规范\r\n\r\n### 避免用一个字母命名\r\n\r\n```js\r\n// bad\r\nfunction q() {\r\n  // ...\r\n}\r\n\r\n// good\r\nfunction query() {\r\n  // ...\r\n}\r\n```\r\n\r\n### 用小驼峰命名法来命名你的对象、函数、实例\r\n\r\n```js\r\n// bad\r\nconst OBJEcttsssss = {};\r\nconst this_is_my_object = {};\r\nfunction c() {}\r\n\r\n// good\r\nconst thisIsMyObject = {};\r\nfunction thisIsMyFunction() {}\r\n```\r\n\r\n### 用大驼峰命名法来命名类\r\n\r\n```js\r\n// bad\r\nfunction user(options) {\r\n  this.name = options.name;\r\n}\r\n\r\nconst bad = new user({\r\n  name: 'nope',\r\n});\r\n\r\n// good\r\nclass User {\r\n  constructor(options) {\r\n    this.name = options.name;\r\n  }\r\n}\r\n\r\nconst good = new User({\r\n  name: 'yup',\r\n});\r\n```\r\n\r\n### 不要用前置或后置下划线\r\n\r\nJavaScript 没有私有属性或私有方法的概念。尽管前置下划线通常的概念上意味着私有，事实上，这些属性是完全公有的，因此这部分也是你的 API 的内容。这一概念可能会导致开发者误以为更改这个不会导致崩溃或者不需要测试。如果你想要什么东西变成私有，那就不要让它在这里出现。\r\n\r\n```js\r\n// bad\r\nthis.__firstName__ = 'Panda';\r\nthis.firstName_ = 'Panda';\r\nthis._firstName = 'Panda';\r\n\r\n// good\r\nthis.firstName = 'Panda';\r\n```\r\n\r\n### export\r\n\r\n#### export-default 导出名称与 import 引用名称保持一致\r\n\r\n例如：`export-default 模块 A`，则这个文件名也叫 `A`， import 时候的参数也叫 `A`。 大小写完全一致。\r\n\r\n```js\r\n// file 1 contents\r\nclass CheckBox {\r\n  // ...\r\n}\r\nexport default CheckBox;\r\n\r\n// file 2 contents\r\nexport default function fortyTwo() { return 42; }\r\n\r\n// file 3 contents\r\nexport default function insideDirectory() {}\r\n\r\n// in some other file\r\n// bad\r\nimport CheckBox from './checkBox'; // PascalCase import/export, camelCase filename\r\nimport FortyTwo from './FortyTwo'; // PascalCase import/filename, camelCase export\r\nimport InsideDirectory from './InsideDirectory'; // PascalCase import/filename, camelCase export\r\n\r\n// bad\r\nimport CheckBox from './check_box'; // PascalCase import/export, snake_case filename\r\nimport forty_two from './forty_two'; // snake_case import/filename, camelCase export\r\nimport inside_directory from './inside_directory'; // snake_case import, camelCase export\r\nimport index from './inside_directory/index'; // requiring the index file explicitly\r\nimport insideDirectory from './insideDirectory/index'; // requiring the index file explicitly\r\n\r\n// good\r\nimport CheckBox from './CheckBox'; // PascalCase export/import/filename\r\nimport fortyTwo from './fortyTwo'; // camelCase export/import/filename\r\nimport insideDirectory from './insideDirectory'; // camelCase export/import/directory name/implicit \"index\"\r\n// ^ supports both insideDirectory.js and insideDirectory/index.js\r\n```\r\n\r\n#### export-default 一个函数时，函数名用小驼峰，文件名需要和函数名一致\r\n\r\n```js\r\nfunction makeStyleGuide() {\r\n  // ...\r\n}\r\n\r\nexport default makeStyleGuide;\r\n```\r\n\r\n#### export 一个结构体/类/单例/函数库/对象 时用大驼峰\r\n\r\n```js\r\nconst AirbnbStyleGuide = {\r\n  es6: {},\r\n};\r\n\r\nexport default AirbnbStyleGuide;\r\n```\r\n\r\n### 简称和缩写应该全部大写或全部小写\r\n\r\n```js\r\n// bad\r\nimport SmsContainer from './containers/SmsContainer';\r\n\r\n// bad\r\nconst HttpRequests = [\r\n  // ...\r\n];\r\n\r\n// good\r\nimport SMSContainer from './containers/SMSContainer';\r\n\r\n// good\r\nconst HTTPRequests = [\r\n  // ...\r\n];\r\n\r\n// also good\r\nconst httpRequests = [\r\n  // ...\r\n];\r\n\r\n// best\r\nimport TextMessageContainer from './containers/TextMessageContainer';\r\n\r\n// best\r\nconst requests = [\r\n  // ...\r\n];\r\n```\r\n\r\n### 导出静态变量\r\n\r\n如果导出静态变量，它需要以下条件：\r\n\r\n- 确保被导出\r\n- 尽量全部大写\r\n- const 定义的，保证不能被改变\r\n- 如果导出对象，这个变量是可信的，他的子属性都是不能被改变的\r\n\r\n```js\r\n// bad\r\nconst PRIVATE_VARIABLE = 'should not be unnecessarily uppercased within a file';\r\n// bad\r\nexport const THING_TO_BE_CHANGED = 'should obviously not be uppercased';\r\n// bad\r\nexport let REASSIGNABLE_VARIABLE = 'do not use let with uppercase variables';\r\n// 允许但不够语义化\r\nexport const apiKey = 'SOMEKEY';\r\n// 更好的\r\nexport const API_KEY = 'SOMEKEY';\r\n\r\n// bad 不必要的大写键，没有增加任何语义\r\nexport const MAPPING = {\r\n  KEY: 'value',\r\n};\r\n// good\r\nexport const MAPPING = {\r\n  key: 'value',\r\n};\r\n```\r\n\r\n## CSS 命名规范\r\n\r\ncss 命名规范有很多方案，这里采用`BEM`作为规范，之所以采用 `BEM` 是因为它让你的前端代码更容易阅读和理解，更容易协作，更容易控制，更加健壮和明确，而且更加严密。\r\n\r\n下面介绍一些相关的概念，以及如何书写\r\n\r\n### 什么是 BEM 命名规范\r\n\r\nBem 是块（block）、元素（element）、修饰符（modifier）的简写，由 Yandex 团队提出的一种前端 CSS 命名方法论。\r\n\r\n- 中划线 ：仅作为连字符使用，表示某个块或者某个子元素的多单词之间的连接记号。\r\n\r\n- 双下划线：双下划线用来连接块和块的子元素\r\n\r\n- 单下划线：单下划线用来描述一个块或者块的子元素的一种状态\r\n\r\n### BEM 命名模式\r\n\r\n根据上面条件，下面写一个示例\r\n\r\n```css\r\n.block {\r\n}\r\n\r\n.block__element {\r\n}\r\n\r\n.block--modifier {\r\n}\r\n```\r\n\r\n仔细观察上面结构可以得到三个信息：\r\n\r\n- 每一个块(block)名应该有一个命名空间（前缀）\r\n- `block__element` 代表 `.block` 的后代，用于形成一个完整的 `.block` 的整体\r\n- `block--modifier` 代表 `.block` 的不同状态或不同版本\r\n\r\n使用两个连字符和下划线而不是一个，是为了让你自己的块可以用单个连字符来界定。如：\r\n\r\n```css\r\n.sub-block__element {\r\n}\r\n\r\n.sub-block--modifier {\r\n}\r\n```\r\n\r\n### 什么时候使用 BEM 命名\r\n\r\n- 你要知道什么时候哪些东西是应该写成 BEM 格式的\r\n\r\n或者说你要事先知道效果图或者 dom 结构应当是一个什么样子的\r\n\r\n- 只有模块或者组件有关联的时候才使用 BEM 格式\r\n\r\n- 单独的样式，没有必要使用 BEM 命名\r\n\r\n```css\r\n.hide {\r\n  display: none !important;\r\n}\r\n```\r\n\r\n### 与预处理器结合\r\n\r\nBEM 写起来可能会存在命名很长，但是如果有 less 之类的预处理器就能节省我们很多时间，下面以 less 为例\r\n\r\n```less\r\n.article {\r\n  max-width: 1200px;\r\n  &__body {\r\n    padding: 20px;\r\n  }\r\n  &__button {\r\n    padding: 5px 8px;\r\n    &--primary {\r\n      background: blue;\r\n    }\r\n    &--success {\r\n      background: green;\r\n    }\r\n  }\r\n}\r\n```\r\n\r\n### 在 Vue 中使用\r\n\r\nVue 为了简便开发提供了 `scope` 的 css 语法糖，但是在 BEM 中并不推荐，因为使用`scope`的目的就是避免样式冲突，而 BEM 本身就已经可以做到了。\r\n\r\n```vue\r\n<template>\r\n  <form class=\"form form--theme-xmas form--simple\">\r\n    <input class=\"form__input\" type=\"text\" />\r\n    <input class=\"form__submit form__submit--disabled\" type=\"submit\" />\r\n  </form>\r\n</template>\r\n\r\n<script lang=\"css\">\r\n.form { }\r\n.form--theme-xmas { }\r\n.form--simple { }\r\n.form__input { }\r\n.form__submit { }\r\n.form__submit--disabled { }\r\n</script>\r\n```\r\n\r\n## 组件命名规范\r\n\r\n### 文件名应始终单词大写开头或横线连接\r\n\r\n单词大写开头对于代码编辑器的自动补全最为友好，因为这使得我们在 `JS(X)` 和模板中引用组件的方式尽可能的一致。然而，混用文件命名方式有的时候会导致大小写不敏感的文件系统的问题，这也是横线连接命名同样完全可取的原因。\r\n\r\n```sh\r\n# bad\r\ncomponents/\r\n|- mycomponent.vue\r\n```\r\n\r\n```sh\r\ncomponents/\r\n|- myComponent.vue\r\n```\r\n\r\n```sh\r\n# good\r\ncomponents/\r\n|- TodoList.js\r\n|- TodoItem.js\r\n```\r\n\r\n```sh\r\n# good\r\ncomponents/\r\n|- TodoList.vue\r\n|- TodoItem.vue\r\n```\r\n\r\n### 基础组件以一个特定的前缀开头\r\n\r\n应用特定样式和约定的基础组件 (也就是展示类的、无逻辑的或无状态的组件) 应该全部以一个特定的前缀开头，比如 `Base`、`App` 或 `V`。\r\n\r\n```sh\r\n# bad\r\ncomponents/\r\n|- MyButton.vue\r\n|- VueTable.vue\r\n|- Icon.vue\r\n```\r\n\r\n```sh\r\n# good\r\ncomponents/\r\n|- BaseButton.vue\r\n|- BaseTable.vue\r\n|- BaseIcon.vue\r\n# or\r\ncomponents/\r\n|- AppButton.vue\r\n|- AppTable.vue\r\n|- AppIcon.vue\r\n# or\r\ncomponents/\r\n|- VButton.vue\r\n|- VTable.vue\r\n|- VIcon.vue\r\n```\r\n\r\n### 一次性组件命名\r\n\r\n单个活跃实例的组件应该以 `The` 前缀命名，以示其唯一性。\r\n\r\n这不意味着组件只可用于一个单页面，而是每个页面只使用一次。这些组件永远不接受任何 `prop`，因为它们是为你的应用定制的，而不是它们在你的应用中的上下文。如果你发现有必要添加 `prop`，那就表明这实际上是一个可复用的组件，只是目前在每个页面里只使用一次。\r\n\r\n```sh\r\n# bad\r\ncomponents/\r\n|- Heading.vue\r\n|- MySidebar.vue\r\n```\r\n\r\n```sh\r\n# good\r\ncomponents/\r\n|- TheHeading.vue\r\n|- TheSidebar.vue\r\n```\r\n\r\n### 组件命名请保持关联\r\n\r\n和父组件紧密耦合的子组件应该以父组件名作为前缀命名。\r\n\r\n如果一个组件只在某个父组件的场景下有意义，这层关系应该体现在其名字上。因为编辑器通常会按字母顺序组织文件，所以这样做可以把相关联的文件排在一起。\r\n\r\n```sh\r\n# bad\r\ncomponents/\r\n|- TodoList.vue\r\n|- TodoItem.vue\r\n|- TodoButton.vue\r\n```\r\n\r\n```sh\r\n# good\r\ncomponents/\r\n|- TodoList.vue\r\n|- TodoListItem.vue\r\n|- TodoListItemButton.vue\r\n```\r\n",
          "reactions": {
            "url": "https://api.github.com/repos/bosens-China/blog/issues/73/reactions",
            "total_count": 0,
            "+1": 0,
            "-1": 0,
            "laugh": 0,
            "hooray": 0,
            "confused": 0,
            "heart": 0,
            "rocket": 0,
            "eyes": 0
          },
          "timeline_url": "https://api.github.com/repos/bosens-China/blog/issues/73/timeline",
          "performed_via_github_app": null,
          "state_reason": null
        }
      ]
    ],
    [
      "1371686609",
      [
        {
          "url": "https://api.github.com/repos/bosens-China/blog/issues/91",
          "repository_url": "https://api.github.com/repos/bosens-China/blog",
          "labels_url": "https://api.github.com/repos/bosens-China/blog/issues/91/labels{/name}",
          "comments_url": "https://api.github.com/repos/bosens-China/blog/issues/91/comments",
          "events_url": "https://api.github.com/repos/bosens-China/blog/issues/91/events",
          "html_url": "https://github.com/bosens-China/blog/issues/91",
          "id": 1187970892,
          "node_id": "I_kwDOCzPAy85Gzv9M",
          "number": 91,
          "title": "yarn.lock 引发的血案",
          "user": {
            "login": "bosens-China",
            "id": 39508895,
            "node_id": "MDQ6VXNlcjM5NTA4ODk1",
            "avatar_url": "https://avatars.githubusercontent.com/u/39508895?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/bosens-China",
            "html_url": "https://github.com/bosens-China",
            "followers_url": "https://api.github.com/users/bosens-China/followers",
            "following_url": "https://api.github.com/users/bosens-China/following{/other_user}",
            "gists_url": "https://api.github.com/users/bosens-China/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/bosens-China/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/bosens-China/subscriptions",
            "organizations_url": "https://api.github.com/users/bosens-China/orgs",
            "repos_url": "https://api.github.com/users/bosens-China/repos",
            "events_url": "https://api.github.com/users/bosens-China/events{/privacy}",
            "received_events_url": "https://api.github.com/users/bosens-China/received_events",
            "type": "User",
            "site_admin": false
          },
          "labels": [
            {
              "id": 1371686609,
              "node_id": "MDU6TGFiZWwxMzcxNjg2NjA5",
              "url": "https://api.github.com/repos/bosens-China/blog/labels/JavaScript",
              "name": "JavaScript",
              "color": "F7DF1E",
              "default": false,
              "description": "JavaScript系列的文章"
            }
          ],
          "state": "open",
          "locked": false,
          "assignee": null,
          "assignees": [],
          "milestone": null,
          "comments": 0,
          "created_at": "2022-03-31T11:59:44Z",
          "updated_at": "2022-04-08T11:14:47Z",
          "closed_at": null,
          "author_association": "OWNER",
          "active_lock_reason": null,
          "body": "最近开发项目的时候遇到一个神奇的 bug，在回滚了无数次之后终于定位到了问题，就是 yarn.lock 引起的，当时升级相关依赖版本不小心把 yanr.lock 文件给干掉了，导致依赖引用的模块有问题。\r\n\r\n不过这也引起了我的思考为什么 yarn 要有一个 `yarn.lock` 文件呢？或者说为什么现代的包安装都需要有 lock 文件呢？例如 npm 的叫做 [package-lock.json](http://nodejs.cn/learn/the-package-lock-json-file)，pnpm 的叫做 `pnpm-lock.yaml`。\r\n\r\n后面调查了一下发现其实是为了确认依赖关系，这里以 npm 的发展历史进行讲解。\r\n\r\n## 扁平化依赖安装\r\n\r\n下面的例子都以这张依赖图为例\r\n\r\n![relyon.jpeg](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a70906a65fcb4dab971ee37e894c1e15~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n在 npm5 之前也就是还没有 package-lock.json 之前，会将所有的依赖都下载到 `node_modules` 目录下，如果依赖还依赖其他依赖就会继续下载到依赖本身下的 `node_modules`下，例如上图所示最终会生成如下依赖关系。\r\n\r\n```sh\r\nnode_modules\r\n  modules1\r\n    a:1.0\r\n    b:1.0\r\n  modules2\r\n    a:1.0\r\n    b:2.0\r\n```\r\n\r\n这样做虽然不会遇到依赖管理问题，但是很明显占用磁盘空间太大了。\r\n例如上面有一个共同模块是 `a:1.0`，如果能把相同的依赖提取出来不就是可以大大节省安装时长嘛？\r\n\r\n而且最关键的时因为包的文件体积很小，依赖一旦多起来反复读写反而成为性能的瓶颈。\r\n\r\nnpm5 之后就尝试了扁平化安装，它的思想很简单就是安装的时候如果有子依赖就安装到根目录下的 `node_modules` ，如果还有依赖跟根目录下的依赖冲突就和 npm5 之前的处理方式一样，在子依赖的目录下新建 `node_modules` 然后重复。\r\n以上面的例子演示\r\n\r\n```sh\r\nnpm i modules1 modules2\r\n```\r\n\r\n会得到这样一个依赖\r\n\r\n```sh\r\nnode_modules\r\n  modules1\r\n  a:1.0\r\n  b:1.0\r\n  modules2\r\n    b:2.0\r\n```\r\n\r\n这样做很明显改善了安装时长和节省了磁盘空间，但是带来了一个安装顺序的问题，就是上面是安装 module1 为开始，但是假设安装 module2 为开始呢？\r\n\r\n```sh\r\nnpm i modules2 modules1\r\n```\r\n\r\n会得到这样一个依赖\r\n\r\n```sh\r\nnode_modules\r\n  modules1\r\n  a:1.0\r\n  b:2.0\r\n  modules2\r\n    b:1.0\r\n```\r\n\r\n> 注意，上面不考虑网速等额外情况\r\n\r\n会发现结构已经发生了改变。\r\n\r\n温习一下查找模块的方式：如果在当前 `node_modules` 找不到时会怎么查找？会继续向上查找，直到最顶层为止。\r\n\r\n而 module1 import 的很明显是期待 `b:1.0` 这个依赖，最终却得到了 `b:2.0` 依赖。这就给代码新增了不确定性，我最开始遇到的问题就是这个原因得来的。\r\n\r\n## 解决方式\r\n\r\n上面演示了扁平化依赖可能遇到的依赖不确定问题，那能不能通过新增一个文件来记录模块之间的依赖关系呢，之后安装的时候复用？这就是 yanr.lock、package-lock.lock 和 pnpm-lock.yml 的由来。\r\n\r\n不过除了锁定 lock 文件的这种方式还有什么新的办法呢？pnpm 给出了答案，可以继续采用 npm5 之前的安装方式 + 软连接来解决。\r\n\r\n上面说到因为安装重复的模块导致安装效率很低，才被迫采用提取公共模块的扁平化安装，但是如果把当前项目的模块放到最顶的磁盘文件内，每次安装新的模块先搜寻有没有对应的，如果有给一个软链接而不生成真正文件，这样不就是大大节省了安装效率嘛？虽然 lock 文件还是存在但是已经改善重复磁盘的读写问题。\r\n\r\n## 新的展望\r\n\r\n最近在知乎看到了 [如何看待蚂蚁在 SEEConf 分享的 NPM 安装优化，提速 3 倍之多？](https://www.zhihu.com/question/511006062) 我觉得这可能是后面的网速不断提升但是包安装依然很慢的解决方案，但是目前还未开源所以暂未能体验。\r\n\r\n## 最后\r\n\r\n如果有什么错误欢迎指出。\r\n\r\n> 参考了一些文章：\r\n>\r\n> - [深入浅出 tnpm rapid 模式 - 如何比 pnpm 快 10 秒](https://zhuanlan.zhihu.com/p/455809528)\r\n> - [关于现代包管理器的深度思考——为什么现在我更推荐 pnpm 而不是 npm/yarn?](https://juejin.cn/post/6932046455733485575#heading-7)\r\n",
          "reactions": {
            "url": "https://api.github.com/repos/bosens-China/blog/issues/91/reactions",
            "total_count": 0,
            "+1": 0,
            "-1": 0,
            "laugh": 0,
            "hooray": 0,
            "confused": 0,
            "heart": 0,
            "rocket": 0,
            "eyes": 0
          },
          "timeline_url": "https://api.github.com/repos/bosens-China/blog/issues/91/timeline",
          "performed_via_github_app": null,
          "state_reason": null
        },
        {
          "url": "https://api.github.com/repos/bosens-China/blog/issues/48",
          "repository_url": "https://api.github.com/repos/bosens-China/blog",
          "labels_url": "https://api.github.com/repos/bosens-China/blog/issues/48/labels{/name}",
          "comments_url": "https://api.github.com/repos/bosens-China/blog/issues/48/comments",
          "events_url": "https://api.github.com/repos/bosens-China/blog/issues/48/events",
          "html_url": "https://github.com/bosens-China/blog/issues/48",
          "id": 548738832,
          "node_id": "MDU6SXNzdWU1NDg3Mzg4MzI=",
          "number": 48,
          "title": "优雅处理图片异常",
          "user": {
            "login": "bosens-China",
            "id": 39508895,
            "node_id": "MDQ6VXNlcjM5NTA4ODk1",
            "avatar_url": "https://avatars.githubusercontent.com/u/39508895?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/bosens-China",
            "html_url": "https://github.com/bosens-China",
            "followers_url": "https://api.github.com/users/bosens-China/followers",
            "following_url": "https://api.github.com/users/bosens-China/following{/other_user}",
            "gists_url": "https://api.github.com/users/bosens-China/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/bosens-China/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/bosens-China/subscriptions",
            "organizations_url": "https://api.github.com/users/bosens-China/orgs",
            "repos_url": "https://api.github.com/users/bosens-China/repos",
            "events_url": "https://api.github.com/users/bosens-China/events{/privacy}",
            "received_events_url": "https://api.github.com/users/bosens-China/received_events",
            "type": "User",
            "site_admin": false
          },
          "labels": [
            {
              "id": 1371686609,
              "node_id": "MDU6TGFiZWwxMzcxNjg2NjA5",
              "url": "https://api.github.com/repos/bosens-China/blog/labels/JavaScript",
              "name": "JavaScript",
              "color": "F7DF1E",
              "default": false,
              "description": "JavaScript系列的文章"
            }
          ],
          "state": "open",
          "locked": false,
          "assignee": null,
          "assignees": [],
          "milestone": null,
          "comments": 0,
          "created_at": "2020-01-13T06:54:18Z",
          "updated_at": "2021-12-21T09:47:37Z",
          "closed_at": null,
          "author_association": "OWNER",
          "active_lock_reason": null,
          "body": "## 前言\r\n\r\n不同浏览器对加载失败图片的图标展示不统一，所以给定一个默认的失败图片就尤为重要。\r\n\r\n正好前几天处理了一下公司首页图片 error 默认图片的问题，就趁着记忆没有消失分享一下这篇文章。\r\n\r\n## error\r\n\r\nimg 标签有一个 error 事件，通过它我们可以捕捉到异常，使用起来也很简单\r\n\r\n```html\r\n<img src=\"abc.xxx\" alt=\"xxx\" class=\"cs-img\" />\r\n```\r\n\r\n```js\r\n<img src=\"abc.xxx\" alt=\"xxx\" class=\"cs-img\" onerror=\"this.src = 'xxxx.png'\" />;\r\n// 或者\r\nvar img = document.querySelector(\".cs-img\");\r\nimg.addEventListener(\"error\", function(e) {\r\n  e.target.src = \"xxxx.png\";\r\n});\r\n```\r\n\r\n## 全局\r\n\r\n上面的方法没有问题，不过需要我们手动管理图片这样写的话维护成本可能很高，有可能你只是想为图片失败统一处理。\r\n\r\n我们希望可以统一监听到`error`的事件来完成，不过图片的`error`处于事件模型的第二阶段也就是目标阶段，是不会向上冒泡的，但是也是可以通过`window.addEventListener.error`来完成监听。\r\n\r\n> 顺便说下`window.addEventListener.error`不仅可以监听到图片的失败也可以监听到 `css,js` 之类加载错误，注意区分`window.onerror`和`window.addEventListener.error`之间的区别，前者是 js 运行错误，后者是资源错误，对于事件模型网上的例子很多，这里不做展开来说了。\r\n\r\n来看下如何用\r\n\r\n```js\r\nwindow.addEventListener(\r\n  \"error\",\r\n  function(event) {\r\n    var dom = event.target;\r\n    if (/img/i.test(dom.nodeName)) {\r\n      dom.src = \"xxxx.png\";\r\n    }\r\n  },\r\n  true\r\n);\r\n```\r\n\r\n注意 `addEventListener` 第二个参数必须是 `true`，默认为 `false`，表示只在冒泡阶段出发，但是上面我们说过图片的 error 事件并不会向上冒泡所以是不会捕捉到的。\r\n\r\n## 重试次数\r\n\r\n上面的代码没有考虑到备选`src`也会失效的问题，如果备选`src`失效就会导致图片无限重试，下面就抛砖引玉写一种方法。\r\n\r\n```js\r\nwindow.addEventListener(\r\n  \"error\",\r\n  function(event) {\r\n    var dom = event.target;\r\n    if (!/img/i.test(dom.nodeName)) {\r\n      return;\r\n    }\r\n    // 不存在返回null\r\n    var retry = +dom.getAttribute(\"data-retry\");\r\n    if (retry >= 3) {\r\n      // 绝对安全的图片\r\n      dom.src =\r\n        \"data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7\";\r\n    } else {\r\n      dom.src = \"xxxx.png\";\r\n      dom.setAttribute(\"data-retry\", (retry += 1));\r\n    }\r\n  },\r\n  true\r\n);\r\n```\r\n\r\n## 动态填充\r\n\r\n最后分享一个动态模板渲染出来的网页(例如，网页的内容是从后台的编辑器 html 直接插入的)如何监听`error`，如果不考虑兼容问题可以在`head`使用`window.addEventListener.error`方法，但是如果需要兼容性很高不妨试试下面这种。\r\n\r\n```js\r\nconst img = Array.prototype.slice.call(document.images);\r\nfor (let i = 0; i < img.length; i++) {\r\n  var dom = img[i];\r\n  const image = document.createElement(\"img\");\r\n  image.src = dom.src;\r\n  image.style.display = \"none\";\r\n  document.body.appendChild(image);\r\n  image.onerror = function(event) {\r\n    dom.src = \"xxxx.png\";\r\n    document.body.removeChild(image);\r\n  };\r\n  image.onload = function() {\r\n    document.body.removeChild(image);\r\n  };\r\n}\r\n```\r\n\r\n上面我们说了假设内容是直接通过 html 代码插入的，我们可能监听不到图片的默认错误事件，那么我们可以在网页加载完成之后重试一遍所有的 img，在为 img 指定一次错误事件就 OK 了。\r\n\r\n## 最后\r\n\r\n为了方便演示，上面的代码我都没有做兼容性的补充，但是在实际生产中上面代码需要`polyfill`尤其是 dom 的一些语法，推荐简单一些的做法可以把上面的例子转化为 jquery 的语法。\r\n",
          "reactions": {
            "url": "https://api.github.com/repos/bosens-China/blog/issues/48/reactions",
            "total_count": 0,
            "+1": 0,
            "-1": 0,
            "laugh": 0,
            "hooray": 0,
            "confused": 0,
            "heart": 0,
            "rocket": 0,
            "eyes": 0
          },
          "timeline_url": "https://api.github.com/repos/bosens-China/blog/issues/48/timeline",
          "performed_via_github_app": null,
          "state_reason": null
        },
        {
          "url": "https://api.github.com/repos/bosens-China/blog/issues/29",
          "repository_url": "https://api.github.com/repos/bosens-China/blog",
          "labels_url": "https://api.github.com/repos/bosens-China/blog/issues/29/labels{/name}",
          "comments_url": "https://api.github.com/repos/bosens-China/blog/issues/29/comments",
          "events_url": "https://api.github.com/repos/bosens-China/blog/issues/29/events",
          "html_url": "https://github.com/bosens-China/blog/issues/29",
          "id": 499886565,
          "node_id": "MDU6SXNzdWU0OTk4ODY1NjU=",
          "number": 29,
          "title": "jsonp实现原理",
          "user": {
            "login": "bosens-China",
            "id": 39508895,
            "node_id": "MDQ6VXNlcjM5NTA4ODk1",
            "avatar_url": "https://avatars.githubusercontent.com/u/39508895?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/bosens-China",
            "html_url": "https://github.com/bosens-China",
            "followers_url": "https://api.github.com/users/bosens-China/followers",
            "following_url": "https://api.github.com/users/bosens-China/following{/other_user}",
            "gists_url": "https://api.github.com/users/bosens-China/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/bosens-China/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/bosens-China/subscriptions",
            "organizations_url": "https://api.github.com/users/bosens-China/orgs",
            "repos_url": "https://api.github.com/users/bosens-China/repos",
            "events_url": "https://api.github.com/users/bosens-China/events{/privacy}",
            "received_events_url": "https://api.github.com/users/bosens-China/received_events",
            "type": "User",
            "site_admin": false
          },
          "labels": [
            {
              "id": 1371686609,
              "node_id": "MDU6TGFiZWwxMzcxNjg2NjA5",
              "url": "https://api.github.com/repos/bosens-China/blog/labels/JavaScript",
              "name": "JavaScript",
              "color": "F7DF1E",
              "default": false,
              "description": "JavaScript系列的文章"
            }
          ],
          "state": "open",
          "locked": false,
          "assignee": null,
          "assignees": [],
          "milestone": null,
          "comments": 0,
          "created_at": "2019-09-29T09:16:55Z",
          "updated_at": "2021-12-21T09:46:25Z",
          "closed_at": null,
          "author_association": "OWNER",
          "active_lock_reason": null,
          "body": "简单说一下存在的历史，浏览器存在同源政策，即域名+端口+协议必须一致，很多时候我们需要跨域访问，当然在现在我们可以借助 webpack 的反向代理配合服务器设置 cors 实现访问，但是在之前工程化还没出现的时候就需要有一种方法可以访问所以 jsonp 就出现了。\r\njsonp 的原理就是浏览器的 `script` 标签可以加载不同源的资源，配合后端通过执行函数传递参数，这也是 **jsonp 只支持 get** 的原因，同理的标签还有`img`，我们可以用它来实现访问站点次数的统计，根据上面的原理我们来实现一个模拟的版本\r\n\r\n## 第一版\r\n\r\n```html\r\n<script>\r\n  function callback(v) {\r\n    console.log(\"参数是：\");\r\n    console.log(v);\r\n  }\r\n</script>\r\n<script>\r\n  callback({\r\n    name: \"zhangsan\",\r\n    age: 18\r\n  });\r\n</script>\r\n```\r\n\r\n可以看到就是这个思路，后面的脚本调用这个参数即可。\r\n\r\n## 简单实现一个 jsonp 的函数\r\n\r\n```js\r\ninterface Iparams {\r\n  [propName: string]: any;\r\n}\r\ninterface Ioptions {\r\n  params?: Iparams;\r\n  timeout?: number;\r\n  name?: string;\r\n}\r\nlet uid = 0;\r\nconst jsonp = function jsonp(this: any, url: string, option: Ioptions = {}) {\r\n  return new Promise((resolve, reject) => {\r\n    // 注意，这个id不能重复\r\n    const id = `__uid${uid++}`;\r\n    Reflect.set(window, id, (...rest: any[]) => {\r\n      clear();\r\n      return resolve.call(this, ...rest);\r\n    });\r\n    const { name = \"callback\", params = {}, timeout = 6000 } = option;\r\n    // 清理\r\n    const clear = () => {\r\n      Reflect.set(window, id, () => {});\r\n      script.parentNode.removeChild(script);\r\n      if (timer) {\r\n        clearTimeout(timer);\r\n      }\r\n    };\r\n    // 创建超时任务\r\n    let timer: NodeJS.Timeout;\r\n    if (typeof timeout === \"number\") {\r\n      timer = setTimeout(() => {\r\n        clear();\r\n        return reject(new Error(`Task timeout`));\r\n      }, timeout);\r\n    }\r\n    const script: HTMLScriptElement = document.createElement(\"script\");\r\n    // 处理一下参数最终合并\r\n    const par = new URLSearchParams(params);\r\n    par.append(name, id);\r\n    const href = `${url}?${par}`;\r\n    // 编码一下防止出现中文之类的\r\n    script.src = encodeURI(href);\r\n    document.body.appendChild(script);\r\n    script.addEventListener(\"error\", () => {\r\n      clear();\r\n      return reject(\r\n        new Error(`Failed to create jsonp, request target address is:${url}`)\r\n      );\r\n    });\r\n  });\r\n};\r\nexport default jsonp;\r\n```\r\n\r\n这里为了方便演示使用了`URLSearchParams`对象，它是浏览器的原生对象，用来构造、解析和处理 URL 的查询字符串，当然在生产中还需要`polyfill`，如果不满足兼容性建议手写一个工具处理。\r\n\r\n## 最后\r\n\r\n代码我已经放置到了仓库，欢迎来 [Star](https://github.com/bosens-China/promise-jsonp)\r\n\r\n参考：\r\n\r\n- https://github.com/webmodules/jsonp\r\n",
          "reactions": {
            "url": "https://api.github.com/repos/bosens-China/blog/issues/29/reactions",
            "total_count": 0,
            "+1": 0,
            "-1": 0,
            "laugh": 0,
            "hooray": 0,
            "confused": 0,
            "heart": 0,
            "rocket": 0,
            "eyes": 0
          },
          "timeline_url": "https://api.github.com/repos/bosens-China/blog/issues/29/timeline",
          "performed_via_github_app": null,
          "state_reason": null
        },
        {
          "url": "https://api.github.com/repos/bosens-China/blog/issues/23",
          "repository_url": "https://api.github.com/repos/bosens-China/blog",
          "labels_url": "https://api.github.com/repos/bosens-China/blog/issues/23/labels{/name}",
          "comments_url": "https://api.github.com/repos/bosens-China/blog/issues/23/comments",
          "events_url": "https://api.github.com/repos/bosens-China/blog/issues/23/events",
          "html_url": "https://github.com/bosens-China/blog/issues/23",
          "id": 489595663,
          "node_id": "MDU6SXNzdWU0ODk1OTU2NjM=",
          "number": 23,
          "title": "长列表优化",
          "user": {
            "login": "bosens-China",
            "id": 39508895,
            "node_id": "MDQ6VXNlcjM5NTA4ODk1",
            "avatar_url": "https://avatars.githubusercontent.com/u/39508895?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/bosens-China",
            "html_url": "https://github.com/bosens-China",
            "followers_url": "https://api.github.com/users/bosens-China/followers",
            "following_url": "https://api.github.com/users/bosens-China/following{/other_user}",
            "gists_url": "https://api.github.com/users/bosens-China/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/bosens-China/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/bosens-China/subscriptions",
            "organizations_url": "https://api.github.com/users/bosens-China/orgs",
            "repos_url": "https://api.github.com/users/bosens-China/repos",
            "events_url": "https://api.github.com/users/bosens-China/events{/privacy}",
            "received_events_url": "https://api.github.com/users/bosens-China/received_events",
            "type": "User",
            "site_admin": false
          },
          "labels": [
            {
              "id": 1371686609,
              "node_id": "MDU6TGFiZWwxMzcxNjg2NjA5",
              "url": "https://api.github.com/repos/bosens-China/blog/labels/JavaScript",
              "name": "JavaScript",
              "color": "F7DF1E",
              "default": false,
              "description": "JavaScript系列的文章"
            }
          ],
          "state": "open",
          "locked": false,
          "assignee": null,
          "assignees": [],
          "milestone": null,
          "comments": 0,
          "created_at": "2019-09-05T08:10:06Z",
          "updated_at": "2021-12-21T09:45:48Z",
          "closed_at": null,
          "author_association": "OWNER",
          "active_lock_reason": null,
          "body": "## 前言\r\n\r\n在项目中如果能分页实现那最好不过了，不过很多时候长列表不可避免，这里又分两种情况\r\n\r\n1. 第一次不用全部加载完成，这种可以使用懒加载或者说无限滚动的方式来实现\r\n2. 另外一种则是一次要渲染全部数据出现\r\n\r\n下面就来讨论这两种情况如何进行优化，可以对比[列表优化具体实现](https://github.com/bosens-China/VirtualList)的源码来看\r\n(注：下面是用 Vue 实现的，使用其他框架并不影响)\r\n\r\n## 无限滚动\r\n\r\n实现的思路很简单就是根据滚动条是否滚动到底部（总高度 - 可见高度 - 滚动条高度），滚动到底部就添加新的数据\r\n\r\n```js\r\nfunction scroll({ target }) {\r\n  const DISTANCE = 40;\r\n  const h = target.scrollHeight - (target.clientHeight + target.scrollTop);\r\n  if (h < DISTANCE) {\r\n    for (let i = 0, j = this.list.length, l = this.list.length; i < l; i++) {\r\n      this.list.push(j + i);\r\n    }\r\n  }\r\n}\r\n```\r\n\r\n## 虚拟列表\r\n\r\n![v2-f00bb3f5d9815d660d7bcbd87236af86_hd](https://user-images.githubusercontent.com/39508895/64329195-6cc67180-d001-11e9-8104-1256738a1cc2.jpg)\r\n\r\n引用一张图，可以看见我们实现的思路就是只渲染可见部分的列表，每次滚动条变化的时候更改展示的列表，在下面的演示中，我们都会用到一个基础的 html 结构，这里先贴一下\r\n\r\n```html\r\n<div class=\"root\">\r\n  <div class=\"container\"></div>\r\n  <ul class=\"content\">\r\n    <li class=\"item\" v-for=\"item of nowList\" :key=\"item.value\">\r\n      {{ item.value }}\r\n    </li>\r\n  </ul>\r\n</div>\r\n```\r\n\r\n```less\r\n.root {\r\n  border: 1px solid #999;\r\n  list-style: none;\r\n  overflow: auto;\r\n  height: 400px;\r\n  position: relative;\r\n  .container {\r\n    position: absolute;\r\n    left: 0;\r\n    top: 0;\r\n    right: 0;\r\n    z-index: -1;\r\n  }\r\n  .content {\r\n    .container();\r\n    z-index: 1;\r\n    margin: 0;\r\n    padding: 0;\r\n    list-style: none;\r\n  }\r\n  .item {\r\n    border-bottom: 1px solid #ccc;\r\n    padding-left: 40px;\r\n  }\r\n}\r\n```\r\n\r\n上面结构做了两件事情\r\n\r\n1. 固定总列表的高度，让其出现滚动条\r\n2. 用一个遮罩 div 撑起整个列表的高度\r\n\r\n### 固定\r\n\r\n这里假设每个列表的高度为 30px，剩下的部分就是计算出列表的`总体高度`以及`开始索引`和`结束索引`，核心代码只有不到 10 行\r\n\r\n```js\r\nscroll() {\r\n  const dom = this.$refs.root;\r\n  const total = Math.ceil(dom.clientHeight / this.height);\r\n  const start = Math.floor(dom.scrollTop / this.height);\r\n  const end = start + total;\r\n  this.start = start;\r\n  this.end = end;\r\n}\r\n```\r\n\r\n总索引: 当前视图的高度 / 子项的高度，不过注意需要向上取整；\r\n开始索引: 滚动的距离 / 子项的高度\r\n结束索: 总索引 + 开始索引\r\n下面是完整的代码\r\n\r\n```html\r\n<template>\r\n  <div>\r\n    <div class=\"root\" ref=\"root\" @scroll=\"scroll\">\r\n      <div class=\"container\" :style=\"{ height: totalHeight }\"></div>\r\n      <ul class=\"content\" :style=\"{ transform: getTransform }\">\r\n        <li\r\n          class=\"item\"\r\n          :style=\"{ height: height + 'px', lineHeight: height + 'px' }\"\r\n          v-for=\"(item, i) of nowList\"\r\n          :key=\"i\"\r\n        >\r\n          {{ item }}\r\n        </li>\r\n      </ul>\r\n    </div>\r\n  </div>\r\n</template>\r\n\r\n<script>\r\n  export default {\r\n    data() {\r\n      return {\r\n        list: Array(10000)\r\n          .fill(1)\r\n          .map((f, i) => i),\r\n        height: 30,\r\n        start: 0,\r\n        end: 0\r\n      };\r\n    },\r\n    computed: {\r\n      totalHeight() {\r\n        return this.height * this.list.length + \"px\";\r\n      },\r\n      nowList() {\r\n        return this.list.slice(this.start, this.end);\r\n      },\r\n      getTransform() {\r\n        return `translate3d(0,${this.start * this.height}px,0)`;\r\n      }\r\n    },\r\n    mounted() {\r\n      this.scroll();\r\n    },\r\n    methods: {\r\n      scroll() {\r\n        const dom = this.$refs.root;\r\n        const total = Math.ceil(dom.clientHeight / this.height);\r\n        const start = Math.floor(dom.scrollTop / this.height);\r\n        const end = start + total;\r\n        this.start = start;\r\n        this.end = end;\r\n      }\r\n    }\r\n  };\r\n</script>\r\n\r\n<style lang=\"less\" scoped>\r\n  .root {\r\n    border: 1px solid #999;\r\n    list-style: none;\r\n    overflow: auto;\r\n    height: 400px;\r\n    position: relative;\r\n    .container {\r\n      position: absolute;\r\n      left: 0;\r\n      top: 0;\r\n      right: 0;\r\n      z-index: -1;\r\n    }\r\n    .content {\r\n      .container();\r\n      z-index: 1;\r\n      margin: 0;\r\n      padding: 0;\r\n      list-style: none;\r\n    }\r\n    .item {\r\n      border-bottom: 1px solid #ccc;\r\n      padding-left: 40px;\r\n    }\r\n  }\r\n</style>\r\n```\r\n\r\n### 非固定\r\n\r\n非固定需要考虑的更多则是性能的问题，下面先贴一个完整的代码，在需要说明部分已经注释了\r\n\r\n```html\r\n<template>\r\n  <div>\r\n    <div class=\"root\" ref=\"root\" @scroll=\"scroll\">\r\n      <div class=\"container\" :style=\"{ height: totalHeight }\"></div>\r\n      <ul class=\"content\" :style=\"{ transform: getTransform }\">\r\n        <li\r\n          class=\"item\"\r\n          v-for=\"item of nowList\"\r\n          :style=\"{\r\n            height: item.height + 'px',\r\n            lineHeight: item.height + 'px'\r\n          }\"\r\n          :key=\"item.value\"\r\n        >\r\n          {{ item.value }}\r\n        </li>\r\n      </ul>\r\n    </div>\r\n  </div>\r\n</template>\r\n\r\n<script>\r\n  export default {\r\n    data() {\r\n      return {\r\n        list: Array(10000)\r\n          .fill(1)\r\n          .map((f, i) => {\r\n            return {\r\n              value: i,\r\n              height: this.getRandom(10, 100)\r\n            };\r\n          }),\r\n        start: 0,\r\n        end: 0,\r\n        // 指针\r\n        pointer: -1,\r\n        // 缓存\r\n        cache: {},\r\n        // 初始总数\r\n        initialHeight: 50\r\n      };\r\n    },\r\n    computed: {\r\n      totalHeight() {\r\n        // 这里是获取总体高度，判断了两种情况，第一种是给定初始总数，另外一种则是没有，如果没有的话，高度就是已缓存的 + 未缓存的部分\r\n        if (this.initialtotal >= 0) {\r\n          const { top, height } =\r\n            this.pointer >= 0\r\n              ? this.getIndexOffset(this.pointer)\r\n              : { top: 0, height: 0 };\r\n          return `${top +\r\n            height +\r\n            (this.list.length - 1 - this.pointer) * this.initialHeight}px`;\r\n        }\r\n        const { height } = this.list.reduce(function(x, y) {\r\n          return {\r\n            height: x.height + y.height\r\n          };\r\n        });\r\n        return height + \"px\";\r\n      },\r\n      // 可视数据\r\n      nowList() {\r\n        return this.list.slice(\r\n          this.start,\r\n          Math.min(this.end + 1, this.list.length)\r\n        );\r\n      },\r\n      getTransform() {\r\n        return `translate3d(0,${this.getIndexOffset(this.start).top}px,0)`;\r\n      }\r\n    },\r\n    mounted() {\r\n      this.scroll();\r\n    },\r\n    methods: {\r\n      // 滚动事件\r\n      scroll() {\r\n        const dom = this.$refs.root;\r\n        // 获取索引\r\n        const start = this.getIndex(dom.scrollTop);\r\n        // 把当前可视的高度 + 滚动条的高度，再去取索引\r\n        const end = this.getIndex(dom.scrollTop + dom.clientHeight);\r\n        this.start = start;\r\n        this.end = end;\r\n      },\r\n      // 取出指定范围随机数\r\n      getRandom(min, max) {\r\n        return Math.floor(Math.random() * (max - min + 1)) + min;\r\n      },\r\n      // 根据滚动条y获取指定坐标\r\n      getIndex(scrollTop) {\r\n        // 判断思路很简单，如果高度大于滚动条肯定就出现了，另外一种则是判断了边界问题\r\n        let total = 0;\r\n        for (let i = 0, j = this.list.length; i < j; i++) {\r\n          if (total >= scrollTop || j - 1 === i) {\r\n            return i;\r\n          }\r\n          // 这里主要是起缓存作用的\r\n          total += this.getIndexOffset(i).height;\r\n        }\r\n        return 0;\r\n      },\r\n      // 获取指定坐标的位置和高度\r\n      getIndexOffset(index) {\r\n        // 如果存在缓存中直接返回\r\n        if (this.pointer >= index) {\r\n          return this.cache[index];\r\n        }\r\n        let total = 0;\r\n        // 这里是为了比较没有取到的情况\r\n        if (this.pointer >= 0) {\r\n          const li = this.cache[this.pointer];\r\n          total = li.top + li.height;\r\n        }\r\n        // 注意上面因为取的值是li.top + li.height，所以i从 + 1开始\r\n        for (let i = this.pointer + 1; i <= index; i++) {\r\n          const size = this.list[i].height;\r\n          this.cache[i] = {\r\n            top: total,\r\n            height: size\r\n          };\r\n          total += size;\r\n        }\r\n        if (index > this.pointer) {\r\n          this.pointer = index;\r\n        }\r\n\r\n        return this.cache[index];\r\n      }\r\n    }\r\n  };\r\n</script>\r\n\r\n<style lang=\"less\" scoped>\r\n  .root {\r\n    border: 1px solid #999;\r\n    list-style: none;\r\n    overflow: auto;\r\n    height: 400px;\r\n    position: relative;\r\n    .container {\r\n      position: absolute;\r\n      left: 0;\r\n      top: 0;\r\n      right: 0;\r\n      z-index: -1;\r\n    }\r\n    .content {\r\n      .container();\r\n      z-index: 1;\r\n      margin: 0;\r\n      padding: 0;\r\n      list-style: none;\r\n    }\r\n    .item {\r\n      border-bottom: 1px solid #ccc;\r\n      padding-left: 40px;\r\n    }\r\n  }\r\n</style>\r\n```\r\n\r\n上面只最终的实现，实际上跟固定高度相比就是增加了获取索引的方法，固定高度我们是知道对应子项的高度，所以可以通过可视高度来计算，而这里我用了随机数来设置高度，所以需要获取到对应的索引。\r\n上面代码同时也做了两点优化，一是缓存，二是总高度优化\r\n\r\n总高度的实现有两种思路：\r\n\r\n1. 计算所有的高度，这种实际上有点浪费性能；\r\n2. 给定一个大概的值，拿缓存的值 + 没有缓存的值，没有缓存的值就是对应数据的长度 - 已缓存的坐标，之后每次缓存变化的时候再计算；\r\n\r\n缓存则比较简单了，每次计算的时候把指针移动到计算的位置，同时将值添加上\r\n\r\n## 参考文章\r\n\r\n1. https://zhuanlan.zhihu.com/p/34585166\r\n",
          "reactions": {
            "url": "https://api.github.com/repos/bosens-China/blog/issues/23/reactions",
            "total_count": 0,
            "+1": 0,
            "-1": 0,
            "laugh": 0,
            "hooray": 0,
            "confused": 0,
            "heart": 0,
            "rocket": 0,
            "eyes": 0
          },
          "timeline_url": "https://api.github.com/repos/bosens-China/blog/issues/23/timeline",
          "performed_via_github_app": null,
          "state_reason": null
        },
        {
          "url": "https://api.github.com/repos/bosens-China/blog/issues/65",
          "repository_url": "https://api.github.com/repos/bosens-China/blog",
          "labels_url": "https://api.github.com/repos/bosens-China/blog/issues/65/labels{/name}",
          "comments_url": "https://api.github.com/repos/bosens-China/blog/issues/65/comments",
          "events_url": "https://api.github.com/repos/bosens-China/blog/issues/65/events",
          "html_url": "https://github.com/bosens-China/blog/issues/65",
          "id": 770754319,
          "node_id": "MDU6SXNzdWU3NzA3NTQzMTk=",
          "number": 65,
          "title": "初探 node 接口开发",
          "user": {
            "login": "bosens-China",
            "id": 39508895,
            "node_id": "MDQ6VXNlcjM5NTA4ODk1",
            "avatar_url": "https://avatars.githubusercontent.com/u/39508895?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/bosens-China",
            "html_url": "https://github.com/bosens-China",
            "followers_url": "https://api.github.com/users/bosens-China/followers",
            "following_url": "https://api.github.com/users/bosens-China/following{/other_user}",
            "gists_url": "https://api.github.com/users/bosens-China/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/bosens-China/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/bosens-China/subscriptions",
            "organizations_url": "https://api.github.com/users/bosens-China/orgs",
            "repos_url": "https://api.github.com/users/bosens-China/repos",
            "events_url": "https://api.github.com/users/bosens-China/events{/privacy}",
            "received_events_url": "https://api.github.com/users/bosens-China/received_events",
            "type": "User",
            "site_admin": false
          },
          "labels": [
            {
              "id": 1371686609,
              "node_id": "MDU6TGFiZWwxMzcxNjg2NjA5",
              "url": "https://api.github.com/repos/bosens-China/blog/labels/JavaScript",
              "name": "JavaScript",
              "color": "F7DF1E",
              "default": false,
              "description": "JavaScript系列的文章"
            }
          ],
          "state": "open",
          "locked": false,
          "assignee": null,
          "assignees": [],
          "milestone": null,
          "comments": 0,
          "created_at": "2020-12-18T10:03:26Z",
          "updated_at": "2021-12-21T03:35:11Z",
          "closed_at": null,
          "author_association": "OWNER",
          "active_lock_reason": null,
          "body": "接口请求与其它资源请求没有什么不同，都是借助 `http` 协议返回对应的资源，这篇文章简单介绍一下 `node` 开发接口以及如何管理多个接口情况和接口风格。\r\n\r\n标题关联了 node，主要因为 node 开启一个服务器是很简单，而且语法基本相同没有太多负担，这篇文章主要讲解思路，换算到其它语言也是可以的。\r\n\r\n先看一个官网的例子，稍微改造一下让它返回一个固定的`json`数据\r\n\r\n```js\r\nconst http = require('http');\r\n\r\nconst hostname = '127.0.0.1';\r\nconst port = 3000;\r\n\r\nconst server = http.createServer((req, res) => {\r\n  res.statusCode = 200;\r\n  res.writeHead(200, { 'Content-Type': 'application/json' });\r\n  res.write(JSON.stringify({ name: 'hello wrold' }));\r\n  res.end();\r\n});\r\n\r\nserver.listen(port, hostname, () => {\r\n  console.log(`服务器运行在 http://${hostname}:${port}/`);\r\n});\r\n```\r\n\r\n将上面代码复制到文件中，之后借助 `node xxx.js` 的形式就可以预览到效果了。\r\n\r\n## koa\r\n\r\n上面是借助 node 的 `http` 原生模块实现的，当然这种实现没有什么问题，不过追求可扩展和简化开发的目的，这里选择了 koa 作为下面使用的的框架。\r\n\r\nkoa 号称是下一代的 web 开发框架，同样以上面的例子安装一下 koa ，看它怎么实现上面的功能\r\n\r\n```sh\r\nyarn add koa\r\n```\r\n\r\n```js\r\nconst Koa = require('koa');\r\n\r\nconst hostname = '127.0.0.1';\r\nconst port = 3000;\r\n\r\nconst app = new Koa();\r\n\r\napp.use(async (ctx) => {\r\n  ctx.type = 'application/json';\r\n  ctx.body = { name: 'hello wrold' };\r\n});\r\napp.listen(port, hostname, () => {\r\n  console.log(`服务器运行在 http://${hostname}:${port}/`);\r\n});\r\n```\r\n\r\n代码方面还是十分简洁的，这里主要介绍实现思路不过多介绍 koa 的语法，而且实际上 koa 只是对 http 模块进行了封装，文档也没多少推荐看一下官网的介绍即可。\r\n\r\n说到`koa`这里还是聊一下 `koa` 的中间件，下面的代码会经常使用到，`koa` 借助中间件来实现各种拓展，就是类似于插件的功能，它本身非常像洋葱结构\r\n![洋葱](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fada01c271eb43c19fa026d988e30642~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n例如上面的`app.use`就是中间件，中间件的执行顺序以`next`为分割，先执行`next`的前半部分，之后按照倒叙的结构执行后半部分的`next`代码，看一下例子\r\n\r\n```js\r\napp.use(async (ctx, next) => {\r\n  console.log(1);\r\n  await next();\r\n  console.log(2);\r\n});\r\n\r\napp.use(async (ctx, next) => {\r\n  console.log(3);\r\n  await next();\r\n  console.log(4);\r\n});\r\n\r\napp.use(async (ctx, next) => {\r\n  console.log(5);\r\n  await next();\r\n  console.log(6);\r\n});\r\n```\r\n\r\n上面代码的打印结果是`1,3,5,6,4,2`，这块有点绕可以多想一下。\r\n\r\n接口开发中一般都是通过`json`来传递消息，`koa`本身的语法已经很简洁了，但是每次都需要返回想重复的部分，时间长了肯定也会有失误或者漏写拼错的情况，还有抛出错误也需要有一个公共的方法，下面是一个返回信息和抛出错误的设想。\r\n\r\n```js\r\napp.use(async (ctx) => {\r\n  ctx.sendData({ name: 'hello wrold' });\r\n  // 如果发生错误\r\n  ctx.throwError('不满足xxx');\r\n});\r\n```\r\n\r\n如果代码都通过这种形式返回就简单多了，而且实际写在中间件部分的也是可能出现问题的，这里可以通过 `koa` 自带的监听错误来处理，或者通过一个`try`来包裹，可以预料的是一个个手动管理`try`一定会让人抓狂。\r\n\r\n借助中间件的机制很容易编写出一个带有`sendData`和`throwError`的功能，只需要在 ctx 中返回，之后调用 next 让后面的实例执行\r\n\r\n```js\r\napp.use(async (ctx, next) => {\r\n  ctx.sendData = () => {};\r\n  ctx.throwError = () => {};\r\n  await next();\r\n});\r\n```\r\n\r\n上面的例子是简化过的，这里稍微错开一下具体实现之后再详细讲解\r\n\r\n> 中间件的顺序非常重要\r\n\r\n## 接口结构\r\n\r\n上面说了要有一个`sendData`和`throwError`的方法来统一返回信息和抛出错误，这里就说下这两个方法的具体参数以及实现。\r\n\r\n首先接口的返回信息，期待它是固定成下面这种结构\r\n\r\n```json\r\n{\r\n  \"data\": {},\r\n  \"message\": \"ok\",\r\n  \"code\": 200\r\n}\r\n```\r\n\r\n这里 `data` 部分是需要手动返回的，`message` 是可选的，默认的时候可以给一个 ok 以及 200 的 code，这里`code`值是固定死的，方法不允许修改，这样做是因为成功返回一般不需要额外的 code 值\r\n\r\n而错误信息，期待它是这种结构\r\n\r\n```json\r\n{\r\n  \"message\": \"\",\r\n  \"code\": \"400\"\r\n}\r\n```\r\n\r\n这里 message 是必填，而 code 则是可选的。\r\n\r\n这里稍微说一下错误到底使用 `code` 来做区分？还是通过`message`来做区分？\r\n如果通过`code`来做不同状态的区分，那么必然要维护一个 code 列表，其实这是很繁琐的而且单纯的数字记忆也不符合人的记忆，而通过`message`来做提示则基本上可以做到大概可以猜到错误情况，例如可以这样返回\r\n\r\n```json\r\n{\r\n  \"message\": \"error_用户名不能为空\"\r\n}\r\n```\r\n\r\n前面类型后面提示，是不是简洁很多，这两种错误提示自己选择一种即可。\r\n\r\n说了需要实现的功能，方法的实现就很简单了，下面代码是`code`值风格的实现\r\n\r\n```js\r\n// 忽略顶层语法问题，这里是把实现提取出来了\r\nasync (ctx, next) => {\r\n  const content = {\r\n    ...ctx,\r\n    sendData: (data, message = 'ok') => {\r\n      ctx.body = {\r\n        data,\r\n        message,\r\n        code: 200,\r\n      };\r\n      ctx.type = 'application/json';\r\n    },\r\n    throwError: (message = '错误', code = 400) => {\r\n      ctx.body = {\r\n        code,\r\n        message,\r\n      };\r\n      ctx.type = 'application/json';\r\n    },\r\n  };\r\n  try {\r\n    await callback(content);\r\n  } catch (e) {\r\n    ctx.body = {\r\n      code: 400,\r\n      message: (e instanceof Error ? e.message : e) || '系统出现错误',\r\n    };\r\n    ctx.status = 400;\r\n  }\r\n  await next();\r\n};\r\n```\r\n\r\n## REST 风格\r\n\r\nrest 是一种接口风格，简单可以概括成以下几种\r\n\r\n- 使用`get`来获取资源\r\n- 使用`post`来发送请求\r\n- 使用`put`来更新资源\r\n- 使用`delete`来删除资源\r\n\r\n说了这么多使用`rest`的好处有哪些呢？\r\n\r\n首先 rest 只是一种规范，定义这种规范更方便理解和阅读，和代码规范是一个性质\r\n\r\n## 自动导入\r\n\r\n在项目开发中必然存在不同的接口，如何管理这些接口就很有必要的，一个个手动导入管理固然可以，不过当项目足够大的时候，业务变更的时候一个个调整一定让人抓狂。\r\n\r\n下面借助`koa-router`和中间件就编写一个自动导入接口的功能，先看一下`koar-router`的简单使用\r\n\r\n```sh\r\nyarn add @koa/router\r\n```\r\n\r\n```js\r\nconst Koa = require('koa');\r\nconst Router = require('@koa/router');\r\n\r\nconst hostname = '127.0.0.1';\r\nconst port = 3000;\r\nconst app = new Koa();\r\nconst router = new Router();\r\n\r\nrouter.get('/', (ctx, next) => {\r\n  ctx.type = 'application/json';\r\n  ctx.body = { name: 'hello wrold' };\r\n});\r\n\r\napp.use(router.routes()).use(router.allowedMethods());\r\n\r\napp.listen(port, hostname, () => {\r\n  console.log(`服务器运行在 http://${hostname}:${port}/`);\r\n});\r\n```\r\n\r\n要实现这个功能先定义一下规则\r\n\r\n- 只导入`src`目录下`index.js`结尾的接口文件\r\n\r\n  搜索所有符合要求的`index.js`文件，可以借助`glob`模块来实现，借助通配符`'src/**/index.js'`即可。\r\n\r\n- 导入文件，把对应模板返回的字段添加到`router`上\r\n\r\n  这里可以通过 node 原生`require`来读取文件，在具体实现的时候需要稍微注意，必须满足格式的模块才能被导入，而且要添加`try`来捕捉不是`modules`的文件\r\n\r\n在动手实现这个函数之前，还要约定一下`index.js`文件的内的模块格式是什么样的\r\n\r\n```js\r\nconst api = {\r\n  url: '',\r\n  methods: 'get' || ['post'],\r\n  async callback(ctx) {},\r\n};\r\n```\r\n\r\n上面是约定的格式，只有满足这样的结构才会被导入进来，因为开发用的是`ts`这里就不做转换`js`的操作了，如果不想使用 ts 直接忽略掉类型标注看大概实现即可。\r\n\r\nutils.ts\r\n\r\n```js\r\nimport glob from 'glob';\r\nimport path from 'path';\r\nimport _ from 'lodash';\r\nimport { Iobj, Istructure } from '../../typings/structure';\r\n\r\nexport const globFile = (pattern: string): Promise<Array<string>> => {\r\n  return new Promise((resolve, reject) => {\r\n    glob(pattern, (err, files) => {\r\n      if (err) {\r\n        return reject(err);\r\n      }\r\n      return resolve(files);\r\n    });\r\n  });\r\n};\r\n\r\nexport const importModule = async () => {\r\n  const pattern = 'src/**/index.ts';\r\n  const list = await globFile(pattern);\r\n  const listMap = list.map((item) => {\r\n    const f = path.resolve(process.cwd(), item);\r\n    return import(f)\r\n      .then((res) => {\r\n        // 过滤掉default的属性，其它的返回\r\n        return _.omit(res, ['default']);\r\n      })\r\n      .catch(() => null);\r\n  });\r\n  return (await Promise.all(listMap)).filter((f) => f) as Array<Iobj<Istructure>>;\r\n};\r\n\r\n```\r\n\r\n> 这里注意一下，因为用的 ts 所以用了 `import()`如果只是用 node 语法直接 `require` 即可\r\n\r\nindex.ts\r\n\r\n```js\r\nimport Router from '@koa/router';\r\nimport _ from 'lodash';\r\nimport { Ictx, Iobj } from '../../typings/structure';\r\n\r\nimport { importModule } from './utils';\r\nimport Koa from 'koa';\r\n\r\nconst route = async (koa: Koa) => {\r\n  const router = new Router();\r\n  const list = await importModule();\r\n\r\n  for (const fileAll of list) {\r\n    // 将数据解构，这里返回的是{xxx: {url,methods,callback}}这样解构\r\n\r\n    // 过滤不符合条件的模块\r\n    for (const file of Object.values(fileAll)) {\r\n      if (\r\n        !_.isObjectLike(file) ||\r\n        !['url', 'methods', 'callback'].every((f) =>\r\n          Object.keys(file).includes(f)\r\n        )\r\n      ) {\r\n        continue;\r\n      }\r\n      const { url, methods, callback } = file;\r\n      const methodsArr = _.isArray(methods) ? methods : [methods];\r\n      for (const met of methodsArr) {\r\n        router[met](url, async (ctx, next) => {\r\n          const content: Ictx = {\r\n            ...ctx,\r\n            sendData: (data: Iobj, message = 'ok') => {\r\n              ctx.body = {\r\n                data,\r\n                message,\r\n                code: 200,\r\n              };\r\n              ctx.type = 'application/json';\r\n            },\r\n            throwError: (message = '错误', code = 400) => {\r\n              ctx.body = {\r\n                code,\r\n                message,\r\n              };\r\n              ctx.type = 'application/json';\r\n            },\r\n          };\r\n          try {\r\n            await callback(content);\r\n          } catch (e) {\r\n            ctx.body = {\r\n              code: 400,\r\n              message: (e instanceof Error ? e.message : e) || '系统出现错误',\r\n            };\r\n            ctx.status = 400;\r\n          }\r\n          await next();\r\n        });\r\n      }\r\n    }\r\n  }\r\n  koa.use(router.routes()).use(router.allowedMethods());\r\n};\r\n\r\nexport default route;\r\n```\r\n\r\n## 日志\r\n\r\n借助 koa 的中间件也很容易实现日志的功能，这里以[winston](https://github.com/winstonjs/winston)为例\r\n\r\n日志主要记录系统运行时的错误，还记的上面通过`try`来捕捉错误的例子么，现在让他继续抛出错误，直接通过中间件 try 捕捉错误写入到文件。\r\n\r\n```js\r\nimport winston from 'winston';\r\nimport Koa from 'koa';\r\n\r\nimport 'winston-daily-rotate-file';\r\nconst transport = new winston.transports.DailyRotateFile({\r\n  filename: 'log/%DATE%.log',\r\n  datePattern: 'YYYY-MM-DD-HH',\r\n  zippedArchive: true,\r\n  maxSize: '20m',\r\n  maxFiles: '14d',\r\n});\r\n\r\nconst logger = winston.createLogger({\r\n  transports: [transport],\r\n});\r\n\r\nconst asyncwinston = async (\r\n  _ctx: Koa.ParameterizedContext<Koa.DefaultState, Koa.DefaultContext>,\r\n  next: Koa.Next\r\n) => {\r\n  try {\r\n    await next();\r\n  } catch (err) {\r\n    const data = {\r\n      data: err,\r\n      time: new Date().valueOf(),\r\n    };\r\n    if (err instanceof Error) {\r\n      data.data = {\r\n        content: err.message,\r\n        name: err.name,\r\n        stack: err.stack,\r\n      };\r\n    }\r\n    logger.error(JSON.stringify(data));\r\n  }\r\n};\r\n\r\nexport default asyncwinston;\r\n```\r\n\r\n## 启动\r\n\r\n启动就很简单了，把上面暴露的 index.js 通过`koa`的 use 引入\r\n\r\nApp.js\r\n\r\n```js\r\nconst Koa = require('koa');\r\nconst bodyParser = require('koa-bodyparser');\r\nconst route = require('./middleware/route');\r\nconst winston = require('./middleware/winston');\r\n\r\nconst App = async () => {\r\n  const app = new Koa();\r\n  app.use(winston);\r\n  app.use(bodyParser());\r\n  await route(app);\r\n  return app;\r\n};\r\n\r\nmodule.exports = App;\r\n```\r\n\r\nstart.js\r\n\r\n```js\r\nconst Koa = require('koa');\r\nconst ip = require('ip');\r\nconst App = require('./App');\r\n\r\nconst start = async () => {\r\n  const app = await App();\r\n  notice(app);\r\n};\r\n\r\nconst notice = (koa: Koa) => {\r\n  const port = 3000;\r\n  const ipStr = ip.address();\r\n  const str = `http://${ipStr}:${port}`;\r\n  koa.listen(port, () => {\r\n    console.log(`服务器运行在\\n${str}`);\r\n  });\r\n};\r\n\r\nstart();\r\n```\r\n\r\n**这里稍微说明一下为什么分成两个文件，这是因为方便接口测试特意分层的，`start`只做启动的用途**\r\n\r\n最后添加一个`node-dev`的模块，就大功告成了\r\n\r\n10/21 补充\r\n\r\n> 上面的 node-dev，是开发环境下使用的，方便代码的快速重启，在生产环境下可以使用 [pm2](https://github.com/Unitech/pm2)\r\n\r\n```js\r\n// 安装\r\nyarn add node-dev\r\n// 启动\r\nnode-dev start.js\r\n```\r\n\r\n通过`node-dev`启动主要是可以方便修改接口可以直接重载以及通知的方式更明显\r\n\r\n## 接口测试\r\n\r\n12/21 补上\r\n\r\n首先在 src 目录下 新建一个 `index.ts` 文件，用于测试的接口\r\n\r\n```js\r\nimport { Istructure } from '../typings/structure';\r\n\r\nconst testGet: Istructure = {\r\n  url: '/api/:id',\r\n  methods: 'get',\r\n  async callback(ctx) {\r\n    const { id } = ctx?.params;\r\n    ctx?.sendData({ name: 'hello', id });\r\n  },\r\n};\r\nconst testPost: Istructure = {\r\n  url: '/api',\r\n  methods: 'post',\r\n  async callback(ctx) {\r\n    const body = ctx?.request.body;\r\n    ctx?.sendData(body || {});\r\n  },\r\n};\r\n\r\nexport { testGet, testPost };\r\n```\r\n\r\n上面是一个很简单的 post 和 get 请求，之后我们新建一个`__test__`目录，在里面新建一个`index.test.js`文件\r\n\r\n```sh\r\nyarn add @babel/core @babel/preset-env @babel/preset-typescript babel-jest jest supertest\r\n```\r\n\r\n在根目录新建`babel.config.js`文件\r\n\r\n```js\r\n// babel.config.js\r\nmodule.exports = {\r\n  presets: [\r\n    ['@babel/preset-env', { targets: { node: 'current' } }],\r\n    '@babel/preset-typescript',\r\n  ],\r\n};\r\n```\r\n\r\n简单说下，这个 babel 的作用是让我们可以在 js 里面使用 `es6 module` 的语法，同时将 ts 文件转成 js，否则我们这个测试用例是 ts 的根本跑不起来，测试框架方面选用了`jest`测试 http 库使用了`supertest`，其实这块都是可以调整的，单元测试的目的就是对比数据是否符合预期\r\n\r\n`__test__ index.test.js`\r\n\r\n```js\r\nimport App from '../App';\r\n\r\nimport supertest from 'supertest';\r\n\r\ntest('get请求测试', async () => {\r\n  const app = await App();\r\n  const request = supertest(app.listen());\r\n  const id = 6;\r\n  const data = { name: 'hello', id: `${id}` };\r\n  const res = await request.get(`/api/${id}`).expect(200);\r\n  const body = res.body.data;\r\n  expect(body).toEqual(data);\r\n});\r\n\r\ntest('post请求测试', async () => {\r\n  const app = await App();\r\n  const request = supertest(app.listen());\r\n  const data = { name: 'hello', id: 8 };\r\n  const res = await request.post(`/api/`).send(data).expect(200);\r\n  const body = res.body.data;\r\n  expect(body).toEqual(data);\r\n});\r\n```\r\n\r\n运行 `npx jest `，命令行如果没有抛出异常说明我们的代码符合预期，关于更多的 jest 内容可以查看文档\r\n\r\n## 最后\r\n\r\n如果对你有帮助欢迎 `stat`，如果有什么错误之处欢迎指出，关于代码本来全部想用 ts 举例的，但是 ts 并不是一定要上的，所以某些场景我就手动转了一下，看起来有点风格不统一还望谅解\r\n",
          "reactions": {
            "url": "https://api.github.com/repos/bosens-China/blog/issues/65/reactions",
            "total_count": 0,
            "+1": 0,
            "-1": 0,
            "laugh": 0,
            "hooray": 0,
            "confused": 0,
            "heart": 0,
            "rocket": 0,
            "eyes": 0
          },
          "timeline_url": "https://api.github.com/repos/bosens-China/blog/issues/65/timeline",
          "performed_via_github_app": null,
          "state_reason": null
        },
        {
          "url": "https://api.github.com/repos/bosens-China/blog/issues/61",
          "repository_url": "https://api.github.com/repos/bosens-China/blog",
          "labels_url": "https://api.github.com/repos/bosens-China/blog/issues/61/labels{/name}",
          "comments_url": "https://api.github.com/repos/bosens-China/blog/issues/61/comments",
          "events_url": "https://api.github.com/repos/bosens-China/blog/issues/61/events",
          "html_url": "https://github.com/bosens-China/blog/issues/61",
          "id": 680636174,
          "node_id": "MDU6SXNzdWU2ODA2MzYxNzQ=",
          "number": 61,
          "title": "文字高亮",
          "user": {
            "login": "bosens-China",
            "id": 39508895,
            "node_id": "MDQ6VXNlcjM5NTA4ODk1",
            "avatar_url": "https://avatars.githubusercontent.com/u/39508895?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/bosens-China",
            "html_url": "https://github.com/bosens-China",
            "followers_url": "https://api.github.com/users/bosens-China/followers",
            "following_url": "https://api.github.com/users/bosens-China/following{/other_user}",
            "gists_url": "https://api.github.com/users/bosens-China/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/bosens-China/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/bosens-China/subscriptions",
            "organizations_url": "https://api.github.com/users/bosens-China/orgs",
            "repos_url": "https://api.github.com/users/bosens-China/repos",
            "events_url": "https://api.github.com/users/bosens-China/events{/privacy}",
            "received_events_url": "https://api.github.com/users/bosens-China/received_events",
            "type": "User",
            "site_admin": false
          },
          "labels": [
            {
              "id": 1371686609,
              "node_id": "MDU6TGFiZWwxMzcxNjg2NjA5",
              "url": "https://api.github.com/repos/bosens-China/blog/labels/JavaScript",
              "name": "JavaScript",
              "color": "F7DF1E",
              "default": false,
              "description": "JavaScript系列的文章"
            }
          ],
          "state": "open",
          "locked": false,
          "assignee": null,
          "assignees": [],
          "milestone": null,
          "comments": 0,
          "created_at": "2020-08-18T02:15:53Z",
          "updated_at": "2021-12-21T03:30:00Z",
          "closed_at": null,
          "author_association": "OWNER",
          "active_lock_reason": null,
          "body": "![bg](https://user-images.githubusercontent.com/39508895/90462493-935eb900-e13b-11ea-902c-dce1e576fbb4.png)\r\n\r\n如上图，可能在搜索之类的时候需要将搜索内容进行高亮，下面聊聊小程序和 web 上如何实现。\r\n\r\n## web 上做法\r\n\r\n可以通过正则表达式`/(高亮的文字)/`来实现\r\n\r\n```js\r\nfunction highlight(str, sep, color) {\r\n  const reg = new RegExp(`\\(${sep}\\)`, 'g');\r\n  return str.replace(reg, `<i style=\"color:${color};\">$1</i>`);\r\n}\r\nhighlight('安徽省合肥市', '安徽', 'reg');\r\n// <i style=\"color:reg;\">安徽</i>省合肥市\r\n```\r\n\r\n这里实现比较简单，稍微注意一下`replace`api 即可，它还可以接收一个函数作为参数，具体内容这里不做讲解了只简单实现一下。\r\n\r\n## 小程序做法\r\n\r\n不同于 web，因为小程序无法手动管理 `dom` 样式，所以思路是将`高亮文字`和普通文字区分开来，例如：\r\n\r\n```js\r\nvar str = '安徽省合肥市蜀山区';\r\n// 如果高亮合肥市，那么我们把他转化为下面这种形式的数组\r\n['安徽省', '合肥市', '蜀山区'];\r\n```\r\n\r\n将普通文字和高亮文字通过数组的形式区分开来，之后再通过`<text>`标签将转换后的数组`for`循环，每次循环的结果与高亮文字对比，如果符合就添加高亮样式。\r\n\r\n```html\r\n<view>\r\n  <text\r\n    style=\"{{item === keyWord ? 'color:' + color + ';' : ''}}\"\r\n    wx:for=\"{{arr}}\"\r\n    wx:key=\"item\"\r\n  >\r\n    {{item}}\r\n  </text>\r\n</view>\r\n```\r\n\r\n整体的思路就是这样，下面说一下实现的细节。\r\n\r\n- 怎么将一段文字转化为上面数组的形式\r\n  其实这块要分为两步，将文字转化为数组我们可以用`split`的方法，之后通过一个变异的`join`将他们拼成数组。\r\n\r\n```js\r\nfunction join(array, str) {\r\n  const arr = [];\r\n  const len = array.length;\r\n  for (let i = 0; i < len - 1; i++) {\r\n    const value = array[i];\r\n    if (!value) {\r\n      arr.push(str);\r\n    } else {\r\n      arr.push(value, str);\r\n    }\r\n  }\r\n  if (array[len - 1]) {\r\n    arr.push(array[len - 1]);\r\n  }\r\n  return arr;\r\n}\r\n```\r\n\r\n把上面的`wxml`代码片段和`join`相关组合一起就可以实现一个文字高亮的效果了。\r\n\r\n为了方便使用，我这里已经封装成一个库了[highlight](https://github.com/bosens-China/highlight)\r\n\r\n## 最后\r\n\r\n相关代码整合到了[Github](https://github.com/bosens-China/highlight)\r\n\r\n如果对你有帮助可以`star`支持作者一下。\r\n",
          "reactions": {
            "url": "https://api.github.com/repos/bosens-China/blog/issues/61/reactions",
            "total_count": 0,
            "+1": 0,
            "-1": 0,
            "laugh": 0,
            "hooray": 0,
            "confused": 0,
            "heart": 0,
            "rocket": 0,
            "eyes": 0
          },
          "timeline_url": "https://api.github.com/repos/bosens-China/blog/issues/61/timeline",
          "performed_via_github_app": null,
          "state_reason": null
        },
        {
          "url": "https://api.github.com/repos/bosens-China/blog/issues/44",
          "repository_url": "https://api.github.com/repos/bosens-China/blog",
          "labels_url": "https://api.github.com/repos/bosens-China/blog/issues/44/labels{/name}",
          "comments_url": "https://api.github.com/repos/bosens-China/blog/issues/44/comments",
          "events_url": "https://api.github.com/repos/bosens-China/blog/issues/44/events",
          "html_url": "https://github.com/bosens-China/blog/issues/44",
          "id": 547208786,
          "node_id": "MDU6SXNzdWU1NDcyMDg3ODY=",
          "number": 44,
          "title": "global对象获取",
          "user": {
            "login": "bosens-China",
            "id": 39508895,
            "node_id": "MDQ6VXNlcjM5NTA4ODk1",
            "avatar_url": "https://avatars.githubusercontent.com/u/39508895?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/bosens-China",
            "html_url": "https://github.com/bosens-China",
            "followers_url": "https://api.github.com/users/bosens-China/followers",
            "following_url": "https://api.github.com/users/bosens-China/following{/other_user}",
            "gists_url": "https://api.github.com/users/bosens-China/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/bosens-China/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/bosens-China/subscriptions",
            "organizations_url": "https://api.github.com/users/bosens-China/orgs",
            "repos_url": "https://api.github.com/users/bosens-China/repos",
            "events_url": "https://api.github.com/users/bosens-China/events{/privacy}",
            "received_events_url": "https://api.github.com/users/bosens-China/received_events",
            "type": "User",
            "site_admin": false
          },
          "labels": [
            {
              "id": 1371686609,
              "node_id": "MDU6TGFiZWwxMzcxNjg2NjA5",
              "url": "https://api.github.com/repos/bosens-China/blog/labels/JavaScript",
              "name": "JavaScript",
              "color": "F7DF1E",
              "default": false,
              "description": "JavaScript系列的文章"
            }
          ],
          "state": "open",
          "locked": false,
          "assignee": null,
          "assignees": [],
          "milestone": null,
          "comments": 0,
          "created_at": "2020-01-09T02:19:18Z",
          "updated_at": "2021-12-21T03:03:16Z",
          "closed_at": null,
          "author_association": "OWNER",
          "active_lock_reason": null,
          "body": "global 在开发中经常经常使用，例如下面一段代码调用的就是 global 内置的对象\r\n\r\n```js\r\nconst min = Math.min(...[1, 11, 22, 55, -2, -1]);\r\n```\r\n\r\n这里的 Math 对象就是 global 内置的，在浏览器环境下我们可以通过`window.Math.min`显示调用，而在 node 环境下我们则要通过`global.Math.min`来调用，在实际中我们不会通过`window.Math.min`这种方式来调用，不过却也能看到不同环境下获取 global 对象各不相同。\r\n\r\n下面就以编写一个现代的工具库为假设，这个库要支持全局引用也是很科学的，但是如何让其挂载在全局属性上呢？\r\n\r\n## 第一版\r\n\r\n```js\r\n(function() {\r\n  var _global = this;\r\n  var _ = {};\r\n  _.debounce = function() {};\r\n  // ...一些其他的方法\r\n  return (_global._ = _);\r\n})();\r\n```\r\n\r\n这里的想法是通过全局环境下运行 this 来返回一个全局对象，在全局对象上挂载我们的工具函数，不通过 `window` 显示挂载是因为我们不仅要让这个工具库运行在浏览器环境下,同时也让他运行在 `node` 环境中。\r\n\r\n## 严格模式\r\n\r\n上面的写法是假设在非严格模式下运行，而在严格模式下运行，this 会返回一个`undefined`\r\n\r\n```js\r\n(function() {\r\n  \"use strict\";\r\n  console.log(this === undefined); // true\r\n})();\r\n```\r\n\r\n下面我们来尝试修订一下严格模式下的错误\r\n\r\n```js\r\n(function() {\r\n  // 防止null出现\r\n  function isObjectLike(par) {\r\n    return par && typeof par == \"object\";\r\n  }\r\n  var _global;\r\n  if (isObjectLike(global) && global.global === global) {\r\n    _global = global;\r\n  } else {\r\n    _global = window;\r\n  }\r\n  var _ = {};\r\n  _.debounce = function() {};\r\n  // ...一些其他的方法\r\n  return (_global._ = _);\r\n})();\r\n```\r\n\r\n这里我们通过判断 global 是否存在，如果存在就是 `node` 环境如果不存在就是浏览器环境。\r\n\r\n> `global.global`和`window.window`都是指向自身，可以理解为无限嵌套的属性\r\n\r\n## Web Worker\r\n\r\nWeb Worker 是为 JavaScript 创造多线程环境出现的，不过使用它是有一些限制无法使用 `document、window、parent`等这些对象，所以在上面的例子中如果我们在 Web Worker 环境中一定会报错，因为不存在 `global` 和 `window` 对象\r\n\r\n不过 Worker 可以通过`self`来拿到子线程的全局对象，而且 self 在浏览器环境下也指向 window\r\n\r\n```js\r\n(function() {\r\n  // 防止null出现\r\n  function isObjectLike(par) {\r\n    return par && typeof par == \"object\";\r\n  }\r\n  var _global;\r\n  if (isObjectLike(global) && global.global === global) {\r\n    _global = global;\r\n  } else if (isObjectLike(self) && self === self) {\r\n    _global = self;\r\n  }\r\n  var _ = {};\r\n  _.debounce = function() {};\r\n  // ...一些其他的方法\r\n  return (_global._ = _);\r\n})();\r\n```\r\n\r\n## node 虚拟机\r\n\r\nnode vm（沙盒） 环境下不存在 global 和 window 对象，所以上面代码还是会出现问题，不过我们可以通过\r\n`new Function('return this')()`或者`this`的形式来解决\r\n\r\n```js\r\n(function() {\r\n  // 防止null出现\r\n  function isObjectLike(par) {\r\n    return par && typeof par == \"object\";\r\n  }\r\n  var _global;\r\n  if (isObjectLike(global) && global.global === global) {\r\n    _global = global;\r\n  } else if (isObjectLike(self) && self === self) {\r\n    _global = self;\r\n  } else {\r\n    _global = new Function(\"return this\")();\r\n    // 或者\r\n    // _global = this;\r\n  }\r\n  var _ = {};\r\n  _.debounce = function() {};\r\n  // ...一些其他的方法\r\n  return (_global._ = _);\r\n})();\r\n```\r\n\r\n## Content Security Policy\r\n\r\n上面你可能注意到了，我在上一版提到了两个方法来最后获取 `global` 的值\r\n\r\n- \\_global = new Function(\"return this\")();\r\n- \\_global = this;\r\n\r\n不过在网页安全政策（Content Security Policy）下只会加载信任的白名单，`eval、new Function`这些方法都可能无法使用，只能使用`\\_global = this`来获取 global\r\n\r\n```js\r\n(function() {\r\n  // 防止null出现\r\n  function isObjectLike(par) {\r\n    return par && typeof par == \"object\";\r\n  }\r\n  var _global;\r\n  if (isObjectLike(global) && global.global === global) {\r\n    _global = global;\r\n  } else if (isObjectLike(self) && self === self) {\r\n    _global = self;\r\n  } else {\r\n    // 或者\r\n    _global = this;\r\n  }\r\n  var _ = {};\r\n  _.debounce = function() {};\r\n  // ...一些其他的方法\r\n  return (_global._ = _);\r\n})();\r\n```\r\n\r\n## 微信小程序\r\n\r\n在微信小程序中`global`和`window`都不存在再加上使用的是严格模式，this 会返回`undefined`所以我们还需要在加一个判断\r\n\r\n```js\r\n(function() {\r\n  // 防止null出现\r\n  function isObjectLike(par) {\r\n    return par && typeof par == \"object\";\r\n  }\r\n  var _global;\r\n  if (isObjectLike(global) && global.global === global) {\r\n    _global = global;\r\n  } else if (isObjectLike(self) && self === self) {\r\n    _global = self;\r\n  } else {\r\n    // 或者\r\n    _global = this || {};\r\n  }\r\n  var _ = {};\r\n  _.debounce = function() {};\r\n  // ...一些其他的方法\r\n  return (_global._ = _);\r\n})();\r\n```\r\n\r\n## globalThis\r\n\r\n上面的判断方式是现在社区主流做法，不过在 tc39 的提案中`globalThis`可以获取全局对象，使用方法也很简单\r\n\r\n```js\r\n// 浏览器环境\r\nglobalThis === window; // true\r\n// node\r\nglobalThis === global; // true\r\n```\r\n\r\n目前是`Stage 3`使用的话还是需要做一些兼容性的处理，下面就来写最后一版\r\n\r\n```js\r\n(function() {\r\n  // 防止null出现\r\n  function isObjectLike(par) {\r\n    return par && typeof par == \"object\";\r\n  }\r\n  function getGlobal() {\r\n    if (isObjectLike(globalThis) && globalThis.Object === Object) {\r\n      return globalThis;\r\n    }\r\n    if (isObjectLike(global) && global.global === global) {\r\n      return global;\r\n    }\r\n\r\n    if (isObjectLike(self) && self === self) {\r\n      return self;\r\n    }\r\n    return this || {};\r\n  }\r\n\r\n  var _global = getGlobal();\r\n  var _ = {};\r\n  _.debounce = function() {};\r\n  // ...一些其他的方法\r\n  return (_global._ = _);\r\n})();\r\n```\r\n\r\n## 最后\r\n\r\n本来可以一次写完，不过还是希望循循而进了解写了这么多判断究竟是为什么，最后如果有不正确的地方希望有小伙伴指出来，欢迎 star，对作者也是一种鼓励。\r\n\r\n## 参考链接\r\n\r\n- https://developer.mozilla.org/zh-CN/docs/Web/HTTP/CSP\r\n- https://github.com/mqyqingfeng/Blog/issues/56\r\n- https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/globalThis\r\n- https://github.com/lodash/lodash/blob/master/.internal/root.js\r\n",
          "reactions": {
            "url": "https://api.github.com/repos/bosens-China/blog/issues/44/reactions",
            "total_count": 0,
            "+1": 0,
            "-1": 0,
            "laugh": 0,
            "hooray": 0,
            "confused": 0,
            "heart": 0,
            "rocket": 0,
            "eyes": 0
          },
          "timeline_url": "https://api.github.com/repos/bosens-China/blog/issues/44/timeline",
          "performed_via_github_app": null,
          "state_reason": null
        },
        {
          "url": "https://api.github.com/repos/bosens-China/blog/issues/54",
          "repository_url": "https://api.github.com/repos/bosens-China/blog",
          "labels_url": "https://api.github.com/repos/bosens-China/blog/issues/54/labels{/name}",
          "comments_url": "https://api.github.com/repos/bosens-China/blog/issues/54/comments",
          "events_url": "https://api.github.com/repos/bosens-China/blog/issues/54/events",
          "html_url": "https://github.com/bosens-China/blog/issues/54",
          "id": 588233327,
          "node_id": "MDU6SXNzdWU1ODgyMzMzMjc=",
          "number": 54,
          "title": "使用 canvas 实现贪吃蛇",
          "user": {
            "login": "bosens-China",
            "id": 39508895,
            "node_id": "MDQ6VXNlcjM5NTA4ODk1",
            "avatar_url": "https://avatars.githubusercontent.com/u/39508895?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/bosens-China",
            "html_url": "https://github.com/bosens-China",
            "followers_url": "https://api.github.com/users/bosens-China/followers",
            "following_url": "https://api.github.com/users/bosens-China/following{/other_user}",
            "gists_url": "https://api.github.com/users/bosens-China/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/bosens-China/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/bosens-China/subscriptions",
            "organizations_url": "https://api.github.com/users/bosens-China/orgs",
            "repos_url": "https://api.github.com/users/bosens-China/repos",
            "events_url": "https://api.github.com/users/bosens-China/events{/privacy}",
            "received_events_url": "https://api.github.com/users/bosens-China/received_events",
            "type": "User",
            "site_admin": false
          },
          "labels": [
            {
              "id": 1371686609,
              "node_id": "MDU6TGFiZWwxMzcxNjg2NjA5",
              "url": "https://api.github.com/repos/bosens-China/blog/labels/JavaScript",
              "name": "JavaScript",
              "color": "F7DF1E",
              "default": false,
              "description": "JavaScript系列的文章"
            }
          ],
          "state": "open",
          "locked": false,
          "assignee": null,
          "assignees": [],
          "milestone": null,
          "comments": 0,
          "created_at": "2020-03-26T08:13:17Z",
          "updated_at": "2021-12-21T02:57:58Z",
          "closed_at": null,
          "author_association": "OWNER",
          "active_lock_reason": null,
          "body": "<div align=center><img src=\"https://user-images.githubusercontent.com/39508895/139045104-f01d3705-928a-478a-8859-ae6e3cf20c98.png\" alt=\"贪吃蛇\"></div>\r\n\r\n\r\n童年使用的诺基亚基本上都会搭载这款小游戏，最近心血来潮想用 canvas 来实现这个游戏就有了这篇文章，下面讲解一下实现的思路，本文的最终代码已经放到了[codesandbox](https://codesandbox.io/s/peaceful-firefly-c1i43?file=/src/index.js)上。\r\n\r\n当然实现的方式并不止 `canvas` 这一种，还可以使用 `html` + `css` 的形式，这里不讨论优劣取舍，让我们快速开始吧。\r\n\r\n## 游戏规则\r\n\r\n在开发之前先要设计游戏的具体规则是怎么样的，就像是实现`polyfill`也要对照规范一样，贪吃蛇游戏规则还是蛮简单下面概括一下：\r\n\r\n- 初始的时候会被四周墙体包围着，贪吃蛇这时候很虚弱只有一节，墙的周围随机分布着一个鸡蛋（奖励品）\r\n- 按下方向键游戏开始，吃到鸡蛋身体会边长，同时会生成新的鸡蛋\r\n- 撞到墙体和撞到身体会结束游戏\r\n\r\n上面规则概括成代码就是我们需要给一个界面范围、绘制蛇和鸡蛋、让蛇动起来。\r\n\r\n## 基本概念\r\n\r\n`canvas` 是 `html5` 出现的元素，它可以用于数据可视化、动画、游戏、图像操作、视频等方面，它以 `JavaScript` 的方式来进行交互。\r\n\r\n为了方便下面的理解介绍几个基本概念\r\n\r\n- `var ctx = canvas.getContext(contextType);`\r\n\r\n`getContext` 返回 `canvas` 的上下文，`contextType` 指定了何种上下文，它有 `2d`、`webgl`、`webgl2`、`bitmaprenderer`这几种选项，这里只需要 2d 界面，所以填写 2d 即可。\r\n\r\n> 可以根据 `canvas.getContext` 存在判断浏览器支不支持 `canvas` 元素\r\n\r\n- `CanvasRenderingContext2D.clearRect`\r\n\r\n指定矩形区域的像素都变成透明，**注意这个方法不等于完全清除画布，对于一些 `path` 的方法记得手动 `closePath()`**\r\n\r\n- 动画的组成原理\r\n\r\n后续我们需要让贪吃蛇动起来，但是动这个概念是一个伪命题，想一下电视和电影是怎么让我们感觉到动的呢？就是通过一帧帧的画面快速播放得到的视觉效果。\r\n\r\n后面让蛇动起来也是通过定时器来让 `canvas` 不断重绘达到动画的效果。\r\n\r\n## 实现思路\r\n\r\n![坐标](https://user-images.githubusercontent.com/39508895/139045144-fb2d7562-20a8-4c52-a76b-30a1eca7031c.png)\r\n\r\n\r\n如文章首页的示例图片，贪吃蛇可以想象成一个坐标，根据这个坐标很容易得到下面启示：\r\n\r\n- 蛇和鸡蛋都会在坐标中出现，但不会超出\r\n- 撞到坐标的边界即是撞墙\r\n- 每次贪吃蛇移动都需要擦拭移动的路径\r\n- 判断有没有撞到身体和吃不是吃到鸡蛋，判断移动的坐标值是什么即可\r\n\r\n也就是说，贪吃蛇这个游戏最核心的就是坐标这个概念，为了快速得到坐标的信息，我们期待以下面的形式来储存数据。\r\n\r\n```js\r\ninterface CoordinateAll {\r\n  [x: number]: {\r\n    [y: number]: 'block' | 'egg' | 'sanke';\r\n  };\r\n}\r\n// 转化成JavaScript表示\r\n{\r\n  1: {1: 'block', 2: 'egg', 'block'},\r\n  2: {1: 'block', 2: 'block', 'block'},\r\n  // ...\r\n}\r\n```\r\n\r\n为了后续的使用方便，提前定义两个文件\r\n\r\n```js\r\n// utils.js\r\n// 传递一个整数，来循环它\r\nexport const eachNumber = (n, fn) => {\r\n  for (let i = 0; i < n; i++) {\r\n    fn(i);\r\n  }\r\n};\r\n// 返回随机整数\r\nexport const randomNumber = (min, max) => {\r\n  return Math.floor(Math.random() * (max - min + 1)) + min;\r\n};\r\n```\r\n\r\n```js\r\n// const.js\r\n// canvas宽度\r\nexport const WIDTH = 400;\r\n// 高度\r\nexport const HEIGHT = 400;\r\n// 像素x\r\nexport const PIXEL_X = 20;\r\n// 像素y\r\nexport const PIXEL_Y = 20;\r\n// 行\r\nexport const ROW = HEIGHT / PIXEL_Y;\r\n// 列\r\nexport const COLUMN = WIDTH / PIXEL_X;\r\n// 半径\r\nexport const RADIUS = 10;\r\n// 定时器间隔\r\nexport const INTERVAL = 150;\r\n// 鸡蛋颜色\r\nexport const EGG_COLOR = '#767803';\r\n// 蛇颜色\r\nexport const SANKE_COLOR = '#6f5f06';\r\n// 边框颜色\r\nexport const BORDER_COLOR = '#796e09';\r\n```\r\n\r\n后面就开始绘制初始的界面。\r\n\r\n## 初始化界面\r\n\r\n```js\r\nclass Sanke {\r\n  constructor() {\r\n    const canvas = document.createElement('canvas');\r\n    canvas.width = WIDTH;\r\n    canvas.height = HEIGHT;\r\n    this.canvas = canvas;\r\n    document.body.appendChild(canvas);\r\n    const ctx = canvas.getContext('2d');\r\n    this.ctx = ctx;\r\n\r\n    // 蛇身\r\n    this.currentSanke = [];\r\n    // 出现的egg位置\r\n    this.currentEgg = null;\r\n    // 坐标系\r\n    this.coordinateAll = {};\r\n    this.init();\r\n  }\r\n  init() {\r\n    // 创建坐标系\r\n    this.coordinateAll = {};\r\n    eachNumber(ROW, (x) => {\r\n      this.coordinateAll[x] = {};\r\n      eachNumber(COLUMN, (y) => {\r\n        this.coordinateAll[x][y] = 'block';\r\n      });\r\n    });\r\n    const sanke = this.randomCoordinate();\r\n    this.setCoordinate(sanke, 'sanke');\r\n    this.currentSanke = [sanke];\r\n    this.currentEgg = this.randomCoordinate();\r\n    this.setCoordinate(this.currentEgg, 'egg');\r\n    this.repaint();\r\n  }\r\n  repaint() {\r\n    const { ctx, canvas, currentSanke } = this;\r\n    // 绘制egg和绘制sanke\r\n    ctx.clearRect(0, 0, canvas.width, canvas.height);\r\n    ctx.strokeStyle = BORDER_COLOR;\r\n    ctx.strokeRect(0, 0, canvas.width, canvas.height);\r\n    ctx.fillStyle = SANKE_COLOR;\r\n    currentSanke.forEach((item) => {\r\n      ctx.fillRect(item.x * PIXEL_X, item.y * PIXEL_Y, PIXEL_X, PIXEL_Y);\r\n    });\r\n    // 绘制egg\r\n    ctx.beginPath();\r\n    ctx.fillStyle = EGG_COLOR;\r\n    if (!this.currentEgg) {\r\n      this.currentEgg = this.randomCoordinate();\r\n      this.setCoordinate(this.currentEgg, 'egg');\r\n    }\r\n    const { currentEgg } = this;\r\n    ctx.arc(\r\n      0 + RADIUS + currentEgg.x * PIXEL_X,\r\n      0 + RADIUS + currentEgg.y * PIXEL_Y,\r\n      RADIUS,\r\n      0,\r\n      Math.PI * 2,\r\n      true\r\n    );\r\n    ctx.fill();\r\n    ctx.closePath();\r\n  }\r\n\r\n  randomCoordinate() {\r\n    const arr = [];\r\n    eachNumber(ROW, (x) => {\r\n      eachNumber(COLUMN, (y) => {\r\n        const value = this.coordinateAll[x][y];\r\n        if (value === 'block') {\r\n          arr.push({ x, y });\r\n        }\r\n      });\r\n    });\r\n    // 说明无坐标可取\r\n    if (!arr.length) {\r\n      return null;\r\n    }\r\n    return arr[randomNumber(0, arr.length)];\r\n  }\r\n  setCoordinate({ x, y }, value) {\r\n    this.coordinateAll[x][y] = value;\r\n  }\r\n  getCoordinate({ x, y }) {\r\n    if (x < 0 || y < 0 || x > ROW - 1 || y > COLUMN - 1) {\r\n      return null;\r\n    }\r\n    return this.coordinateAll[x][y];\r\n  }\r\n}\r\n```\r\n\r\n代码看起来还是蛮多的，不过之前已经介绍过实现的思路了，接下来一步步分析执行：\r\n\r\n- `constructor`\r\n\r\n这里主要是创建 `canvas` 对象，在 `this` 上绑定一些必要的属性，例如`坐标系`、`egg 位置`和 `sanke 位置`，这里 `currentSanke` ` array` 是因为蛇存在多节，用数组管理比较方便的。\r\n\r\n- `init`\r\n\r\n用 `init` 来完成组装，第一步是创建坐标系，这里给所有的初始元素打上 `block`，它一共三个值：`'block' | 'egg' | 'sanke'`。\r\n后面随机获取蛋的位置和蛇的位置，储存到` coordinateAll` 中，最后调用 `repaint` 完成绘制\r\n\r\n- `repaint`\r\n\r\n这一步就是调用 `canvas` 完成界面绘制，主要用到了两个 `api`\r\n\r\n[ctx.arc](https://developer.mozilla.org/zh-CN/docs/Web/API/CanvasRenderingContext2D/arc) 和 [ctx.fillRect](https://developer.mozilla.org/zh-CN/docs/Web/API/CanvasRenderingContext2D/fillRect)，前者绘制弧形后者填充矩形，先 `clearRect` 后绘制是因为这个方法后续会被重复调用，后面的一些`randomCoordinate`、`setCoordinate`、`getCoordinate`都是跟坐标方法有关，比较简单看一下即可。\r\n\r\n![静态效果](https://user-images.githubusercontent.com/39508895/139045166-b0b27e8d-3517-4e16-a0e7-c8b3cbdb01a3.png)\r\n\r\n\r\n到这里我们就可以得到静态的效果，后面就是让其动起来。\r\n\r\n## 动起来\r\n\r\n想让贪吃蛇动起来，我们需要做两步：\r\n\r\n- 监听方向键，也就是动的方向（也充当启动游戏作用）\r\n- 使用定时器不断的重绘蛇和鸡蛋的位置来造成视觉的移动\r\n\r\n监听方向键很简单，我们直接在 `body` 上监听 `keydown` 即可，这个事件在键盘按下的时候触发\r\n\r\n```js\r\nthis.keydownFn = (e) => {\r\n  const code = e.code;\r\n  const result = ['ArrowDown', 'ArrowUp', 'ArrowLeft', 'ArrowRight'].indexOf(\r\n    code\r\n  );\r\n  if (result <= -1) {\r\n    return;\r\n  }\r\n  this.direction = code;\r\n};\r\nmonitor() {\r\n  document.body.addEventListener('keydown', this.keydownFn);\r\n};\r\n```\r\n\r\n```js\r\nmove() {\r\n  if (this.timeId) {\r\n    clearInterval(this.timeId);\r\n  }\r\n  this.timeId = setInterval(() => {\r\n    const { direction, currentSanke, currentEgg } = this;\r\n    // 如果方向键不存在就返回\r\n    if (!direction) {\r\n      return;\r\n    }\r\n    let nextCoordinate;\r\n    // 蛇头始终是0\r\n    const { x, y } = currentSanke[0];\r\n    switch (direction) {\r\n      case 'ArrowDown':\r\n      case 'ArrowUp':\r\n        nextCoordinate = { x, y: direction === 'ArrowUp' ? y - 1 : y + 1 };\r\n        break;\r\n      case 'ArrowLeft':\r\n      case 'ArrowRight':\r\n        nextCoordinate = { y, x: direction === 'ArrowLeft' ? x - 1 : x + 1 };\r\n        break;\r\n      default:\r\n        break;\r\n    }\r\n    // nextCoordinate的作用是确认下一步是什么类型\r\n    const value = this.getCoordinate(nextCoordinate);\r\n    switch (value) {\r\n      case 'block':\r\n        this.setCoordinate(currentSanke.pop(), 'block');\r\n        currentSanke.unshift(nextCoordinate);\r\n        this.setCoordinate(nextCoordinate, 'sanke');\r\n        break;\r\n      case 'egg':\r\n        this.setCoordinate(currentEgg, 'sanke');\r\n        this.currentEgg = null;\r\n        currentSanke.unshift(nextCoordinate);\r\n        break;\r\n      case 'sanke':\r\n      case null:\r\n        // 游戏结束\r\n        break;\r\n      default:\r\n        break;\r\n    }\r\n    this.repaint();\r\n  }, INTERVAL);\r\n};\r\n```\r\n\r\n之后在 init 中插入这这两个方法\r\n\r\n```js\r\ninit() {\r\n  // ...\r\n  this.monitor();\r\n  this.move();\r\n}\r\n```\r\n\r\n![示例](https://user-images.githubusercontent.com/39508895/139045193-71ae885b-bb3d-4613-82b9-9c7b4d9f6e38.png)\r\n\r\n\r\n到这一步，贪吃蛇也实现了动起来的要求，在 `swtich` 中判断 `value` 的类型来决定坐标值如何变化，之后继续执行 `repaint` 重绘界面\r\n\r\n## 结束游戏\r\n\r\n上面 `move` 对游戏结束只进行了注释，下面就把` case null:`下面语句替换成`this.end`\r\n\r\n```js\r\nend() {\r\n  if (this.timeId) {\r\n    clearInterval(this.timeId);\r\n  }\r\n  this.timeId = null;\r\n  document.body.removeEventListener('keydown', this.keydownFn);\r\n  alert(`游戏结束，当前分数：${(this.currentSanke.length - 1) * 10}`);\r\n};\r\n```\r\n\r\n## 最后\r\n\r\n如果有什么错误请不吝指点，对你有帮助也可以 `start` 一下。\r\n",
          "reactions": {
            "url": "https://api.github.com/repos/bosens-China/blog/issues/54/reactions",
            "total_count": 1,
            "+1": 1,
            "-1": 0,
            "laugh": 0,
            "hooray": 0,
            "confused": 0,
            "heart": 0,
            "rocket": 0,
            "eyes": 0
          },
          "timeline_url": "https://api.github.com/repos/bosens-China/blog/issues/54/timeline",
          "performed_via_github_app": null,
          "state_reason": null
        },
        {
          "url": "https://api.github.com/repos/bosens-China/blog/issues/51",
          "repository_url": "https://api.github.com/repos/bosens-China/blog",
          "labels_url": "https://api.github.com/repos/bosens-China/blog/issues/51/labels{/name}",
          "comments_url": "https://api.github.com/repos/bosens-China/blog/issues/51/comments",
          "events_url": "https://api.github.com/repos/bosens-China/blog/issues/51/events",
          "html_url": "https://github.com/bosens-China/blog/issues/51",
          "id": 566103021,
          "node_id": "MDU6SXNzdWU1NjYxMDMwMjE=",
          "number": 51,
          "title": "基于History实现前端路由",
          "user": {
            "login": "bosens-China",
            "id": 39508895,
            "node_id": "MDQ6VXNlcjM5NTA4ODk1",
            "avatar_url": "https://avatars.githubusercontent.com/u/39508895?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/bosens-China",
            "html_url": "https://github.com/bosens-China",
            "followers_url": "https://api.github.com/users/bosens-China/followers",
            "following_url": "https://api.github.com/users/bosens-China/following{/other_user}",
            "gists_url": "https://api.github.com/users/bosens-China/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/bosens-China/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/bosens-China/subscriptions",
            "organizations_url": "https://api.github.com/users/bosens-China/orgs",
            "repos_url": "https://api.github.com/users/bosens-China/repos",
            "events_url": "https://api.github.com/users/bosens-China/events{/privacy}",
            "received_events_url": "https://api.github.com/users/bosens-China/received_events",
            "type": "User",
            "site_admin": false
          },
          "labels": [
            {
              "id": 1371686609,
              "node_id": "MDU6TGFiZWwxMzcxNjg2NjA5",
              "url": "https://api.github.com/repos/bosens-China/blog/labels/JavaScript",
              "name": "JavaScript",
              "color": "F7DF1E",
              "default": false,
              "description": "JavaScript系列的文章"
            }
          ],
          "state": "open",
          "locked": false,
          "assignee": null,
          "assignees": [],
          "milestone": null,
          "comments": 0,
          "created_at": "2020-02-17T07:21:46Z",
          "updated_at": "2020-02-17T07:21:46Z",
          "closed_at": null,
          "author_association": "OWNER",
          "active_lock_reason": null,
          "body": "`History`是 HTML5 新增的标准，对比`hash`它的展示更加优雅，但低版本 ie 还有兼容问题。\r\n\r\n首先`History`表示窗口浏览历史，可以通过`pushState`方法添加历史记录，以及通过`go`方法来实现跳转，还有`popstate`事件可以监听到记录变更。\r\n\r\n下面就来分析实现一个`History路由`的基础是什么\r\n\r\n1. 它需要在变更地址的时候，不会导致文档直接跳转，例如`hash路由`的出现是因为 url 的`hash`变更不会导致文档变化；\r\n2. 需要有事件可以辅助我们监听到这个变化;\r\n\r\n这两个要求`History`都能很好满足，当使用`pushState`方法添加一条记录的时候，只会导致浏览器的地址栏发生变化，但是不会跳转到这个地址，并且浏览器也不会检查这个地址，利用这个特性我们可以实现比较优雅的路由地址，例如`https://xxx.com/a`，`a`就是这个路由地址。\r\n\r\n为了方便理解下面实现的代码，简短介绍一下`pushState`\r\n\r\n#### pushState\r\n\r\n`pushState`方法，它有三个参数\r\n\r\n- 第一个是`state`，表示发生`popstate`事件的时候传递的对象；\r\n- title，当前浏览器已经忽略了，传递`''`就好了；\r\n- 网址，要更改的地址，注意要符合同源政策；\r\n\r\n举个例子，当前网站的根路径是`https://xxx.com`，我们使用`pushState`添加一条记录\r\n\r\n```js\r\nhistory.pushState({ path: \"/abc\" }, \"\", \"/abc\");\r\n```\r\n\r\n当前的网址就是`https://xxx.com/abc`。\r\n\r\n#### popstate\r\n\r\n`pushState`事件触发的条件是用户点击`前进`、`后退`按钮或者调用 `History.back()`、`History.forward()`、`History.go()`方法时才会触发。\r\n\r\n触发事件后有一个`event`对象，它有一个`state`属性，就是对应`pushState`方法的第一个参数。\r\n\r\n更多关于`history`的信息可以查阅[MDN](https://developer.mozilla.org/zh-CN/docs/Web/API/History)\r\n\r\n### history 路由实现\r\n\r\n```js\r\nclass Router {\r\n  constructor() {\r\n    this.routes = new Map();\r\n    this.init();\r\n  }\r\n  change(e) {\r\n    // 防止为null\r\n    const { path } = e.state || {};\r\n    this.implement(path);\r\n  }\r\n  init() {\r\n    window.addEventListener(\"popstate\", this.change.bind(this));\r\n    window.addEventListener(\"load\", () => {\r\n      const { pathname } = location;\r\n      history.replaceState({ path: pathname }, \"\", pathname);\r\n      this.implement(pathname);\r\n    });\r\n  }\r\n  implement(path) {\r\n    if (!this.routes.has(path)) {\r\n      return;\r\n    }\r\n    const fn = this.routes.get(path);\r\n    typeof fn == \"function\" && fn.call(this, path);\r\n  }\r\n  go(num) {\r\n    history.go(num);\r\n  }\r\n  route(state, fn) {\r\n    this.routes.set(state, fn);\r\n  }\r\n  push(state) {\r\n    history.pushState({ path: state }, \"\", state);\r\n    this.implement(state);\r\n  }\r\n  replace(state) {\r\n    history.replaceState({ path: state }, \"\", state);\r\n    this.implement(state);\r\n  }\r\n}\r\n```\r\n\r\n这一块比较简单就不做更多赘述了，唯一一点需要注意的就是页面加载完毕也需要监听一次，这里用了`load事件`。\r\n\r\n### 使用方法\r\n\r\n```html\r\n<ul>\r\n  <li><a href=\"/\">hash1</a></li>\r\n  <li><a href=\"/hash2\">hash2</a></li>\r\n  <li><a href=\"/hash3\">hash3</a></li>\r\n</ul>\r\n<div><button class=\"f\">前进</button> <button class=\"b\">后退</button></div>\r\n```\r\n\r\n```js\r\nconst color = {\r\n  \"/\": \"yellow\",\r\n  \"/hash2\": \"#333\",\r\n  \"/hash3\": \"#DDD\"\r\n};\r\nconst route = new Router();\r\nroute.route(\"/\", function(e) {\r\n  document.body.style.background = color[e];\r\n});\r\nroute.route(\"/hash2\", function(e) {\r\n  document.body.style.background = color[e];\r\n});\r\nroute.route(\"/hash3\", function(e) {\r\n  document.body.style.background = color[e];\r\n});\r\nArray.from(document.links).forEach(fn => {\r\n  fn.addEventListener(\"click\", e => {\r\n    e.preventDefault();\r\n    const href = fn.href;\r\n    const { pathname } = new URL(href);\r\n    route.push(pathname);\r\n  });\r\n});\r\nconst backOff = document.querySelector(\".b\");\r\nconst forward = document.querySelector(\".f\");\r\nbackOff.addEventListener(\"click\", () => route.go(-1));\r\nforward.addEventListener(\"click\", () => route.go(1));\r\n```\r\n\r\n这里注意，我直接屏蔽了`a`链接的默认跳转，这个是防止它直接到其他文档。\r\n\r\n### 最后\r\n\r\n关于前端路由的两种实现，这里就抛砖引玉的讲解完成了，剩下的就是在这个原理上更加完善，例如对 404 页面的处理。\r\n\r\n如果有帮助可以 **star** 一下。\r\n",
          "reactions": {
            "url": "https://api.github.com/repos/bosens-China/blog/issues/51/reactions",
            "total_count": 0,
            "+1": 0,
            "-1": 0,
            "laugh": 0,
            "hooray": 0,
            "confused": 0,
            "heart": 0,
            "rocket": 0,
            "eyes": 0
          },
          "timeline_url": "https://api.github.com/repos/bosens-China/blog/issues/51/timeline",
          "performed_via_github_app": null,
          "state_reason": null
        },
        {
          "url": "https://api.github.com/repos/bosens-China/blog/issues/50",
          "repository_url": "https://api.github.com/repos/bosens-China/blog",
          "labels_url": "https://api.github.com/repos/bosens-China/blog/issues/50/labels{/name}",
          "comments_url": "https://api.github.com/repos/bosens-China/blog/issues/50/comments",
          "events_url": "https://api.github.com/repos/bosens-China/blog/issues/50/events",
          "html_url": "https://github.com/bosens-China/blog/issues/50",
          "id": 566035569,
          "node_id": "MDU6SXNzdWU1NjYwMzU1Njk=",
          "number": 50,
          "title": "基于hash实现前端路由",
          "user": {
            "login": "bosens-China",
            "id": 39508895,
            "node_id": "MDQ6VXNlcjM5NTA4ODk1",
            "avatar_url": "https://avatars.githubusercontent.com/u/39508895?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/bosens-China",
            "html_url": "https://github.com/bosens-China",
            "followers_url": "https://api.github.com/users/bosens-China/followers",
            "following_url": "https://api.github.com/users/bosens-China/following{/other_user}",
            "gists_url": "https://api.github.com/users/bosens-China/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/bosens-China/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/bosens-China/subscriptions",
            "organizations_url": "https://api.github.com/users/bosens-China/orgs",
            "repos_url": "https://api.github.com/users/bosens-China/repos",
            "events_url": "https://api.github.com/users/bosens-China/events{/privacy}",
            "received_events_url": "https://api.github.com/users/bosens-China/received_events",
            "type": "User",
            "site_admin": false
          },
          "labels": [
            {
              "id": 1371686609,
              "node_id": "MDU6TGFiZWwxMzcxNjg2NjA5",
              "url": "https://api.github.com/repos/bosens-China/blog/labels/JavaScript",
              "name": "JavaScript",
              "color": "F7DF1E",
              "default": false,
              "description": "JavaScript系列的文章"
            }
          ],
          "state": "open",
          "locked": false,
          "assignee": null,
          "assignees": [],
          "milestone": null,
          "comments": 0,
          "created_at": "2020-02-17T03:34:23Z",
          "updated_at": "2020-02-17T03:34:23Z",
          "closed_at": null,
          "author_association": "OWNER",
          "active_lock_reason": null,
          "body": "> 前端路由分为两部分，hash 路由和 History 路由，例如我们常用的 vue-roter 就包含这两部分，这里并不探讨框架是如何进行封装的，而是使用原生的 api 来实现这样一个功能。\r\n\r\n> 预计分为两部分，这里先介绍 hash 路由，实现基本的接受响应和前进后退（为了方便，下面代码不做任何兼容处理）\r\n\r\nhash 指的就是 url 标识符后面`#`号部分的内容（包含#），例如：`https://xxx#abc`这个 url 的 hash 就是`#abc`。\r\n\r\n而 hash 路由就是指接收 hash 的变化更新对应的路由视图，它的优点就是兼容性很好，在 ie 下也能正常工作，不足之处就是`#`这个符号很丑陋。\r\n\r\n### 监听 hash 变化\r\n\r\nwindow 对象上有`hashchange`事件可以监听到 hash 的变化，我们先拿来用用，看看好不好用。\r\n\r\n```js\r\nclass Router {\r\n  constructor() {\r\n    this.hash = new Map();\r\n    this.change = () => {\r\n      const href = this.getHash();\r\n      this.move(href);\r\n    };\r\n    window.addEventListener(\"hashchange\", this.change);\r\n  }\r\n  route(href, fn) {\r\n    this.hash.set(href, fn);\r\n  }\r\n  move(href) {\r\n    if (!this.hash.has(href)) {\r\n      return false;\r\n    }\r\n    const fn = this.hash.get(href);\r\n    if (typeof fn == \"function\") {\r\n      fn.call(this, href);\r\n    }\r\n    return true;\r\n  }\r\n  getHash() {\r\n    return location.hash ? location.hash.slice(1) : \"/\";\r\n  }\r\n}\r\n```\r\n\r\n#### 使用方法\r\n\r\n```js\r\nconst color = {\r\n  hash1: \"#333\",\r\n  hash2: \"#666\",\r\n  hash3: \"#DDD\"\r\n};\r\nconst route = new Router();\r\nroute.route(\"hash1\", function(e) {\r\n  document.body.style.background = color[e];\r\n});\r\nroute.route(\"hash2\", function(e) {\r\n  document.body.style.background = color[e];\r\n});\r\nroute.route(\"hash3\", function(e) {\r\n  document.body.style.background = color[e];\r\n});\r\n```\r\n\r\n这里已经实现了 hash 响应了，不过还是有一个问题就是如果点击 hash 之后刷新浏览器，对应的回调函数并不会执行，所以我们还需要浏览器加载完成后响应对应的回调函数，修订这个问题很简单监听 load 事件即可。\r\n\r\n```js\r\n// 省略其他代码\r\nconstructor() {\r\n    window.addEventListener('load', this.change);\r\n    window.addEventListener(\"hashchange\", this.change);\r\n  }\r\n```\r\n\r\n### 后退功能\r\n\r\n上面完成了基础功能，下面对这个代码进行改造，首先新增一个后退处理。\r\n\r\n实现的思路是新增一个`history`数组来储存变化的 hash，并且创建一个指针，在后退的时候移动指针变化，同时触发对应的函数。\r\n\r\n```js\r\nclass Router {\r\n  constructor() {\r\n    this.hash = new Map();\r\n    // 储存hash变化的数组\r\n    this.history = [];\r\n    // 指针\r\n    this.pointer = this.history.length - 1;\r\n    this.change = () => {\r\n      const href = this.getHash();\r\n      if (!this.move(href)) {\r\n        return console.error(`hash路由${href}无对应处理函数`);\r\n      }\r\n      // 在路由发生变化的时候，同时对history添加，和移动指针\r\n      this.history.push(href);\r\n      this.pointer++;\r\n    };\r\n    // 后退\r\n    this.backOff = () => {\r\n      // 数组下表不能负\r\n      if (this.pointer <= 0) {\r\n        this.pointer = 0;\r\n      } else {\r\n        // 移动下标\r\n        this.pointer -= 1;\r\n      }\r\n      // 读取对应的值，移动hash\r\n      const href = this.history[this.pointer];\r\n      console.log(href, this.pointer, this.history);\r\n      this.setHash(href);\r\n      this.move(href);\r\n    };\r\n    window.addEventListener(\"load\", this.change);\r\n    window.addEventListener(\"hashchange\", this.change);\r\n  }\r\n  route(href, fn) {\r\n    this.hash.set(href, fn);\r\n  }\r\n  move(href) {\r\n    if (!this.hash.has(href)) {\r\n      return false;\r\n    }\r\n    const fn = this.hash.get(href);\r\n    if (typeof fn == \"function\") {\r\n      fn.call(this, href);\r\n    }\r\n    return true;\r\n  }\r\n  getHash() {\r\n    // 过滤掉'#'\r\n    return location.hash ? location.hash.slice(1) : \"/\";\r\n  }\r\n  setHash(href) {\r\n    if (!href) {\r\n      return;\r\n    }\r\n    if (!/^/.test(href)) {\r\n      href = `#${href}`;\r\n    }\r\n    location.hash = href;\r\n  }\r\n}\r\n```\r\n\r\n上面看似实现了后退功能，不过仔细观察上面的代码，我们会发现这样实现是有问题的\r\n\r\n1. 回调函数被执行两次；\r\n2. `history`数组记录的 hash 不对，因为后退是不需要记录的；\r\n\r\n下面来修正这两个问题。\r\n\r\n```js\r\nclass Router {\r\n  constructor() {\r\n    this.hash = new Map();\r\n    // 储存hash变化的数组\r\n    this.history = [];\r\n    // 指针\r\n    this.pointer = this.history.length - 1;\r\n    // 是否后退，默认给false\r\n    this.isBackOff = false;\r\n    this.change = () => {\r\n      const href = this.getHash();\r\n      if (!this.hash.has(href)) {\r\n        return console.error(`hash路由${href}无对应处理函数`);\r\n      }\r\n      if (!this.isBackOff) {\r\n        // 看一下指针长度对不对，如果多余就截取掉\r\n        if (this.pointer < this.history.length - 1) {\r\n          this.history = this.history.slice(0, this.pointer + 1);\r\n        }\r\n        // 在路由发生变化的时候，同时对history添加，和移动指针\r\n        this.history.push(href);\r\n        this.pointer++;\r\n      }\r\n      this.move(href);\r\n      this.isBackOff = false;\r\n    };\r\n    // 后退\r\n    this.backOff = () => {\r\n      this.isBackOff = true;\r\n      // 数组下表不能负\r\n      if (this.pointer <= 0) {\r\n        this.pointer = 0;\r\n      } else {\r\n        // 移动下标\r\n        this.pointer -= 1;\r\n      }\r\n      // 读取对应的值，移动hash\r\n      const href = this.history[this.pointer];\r\n      console.log(href, this.pointer, this.history);\r\n      this.setHash(href);\r\n    };\r\n    window.addEventListener(\"load\", this.change);\r\n    window.addEventListener(\"hashchange\", this.change);\r\n  }\r\n  route(href, fn) {\r\n    this.hash.set(href, fn);\r\n  }\r\n  move(href) {\r\n    const fn = this.hash.get(href);\r\n    if (typeof fn == \"function\") {\r\n      fn.call(this, href);\r\n    }\r\n  }\r\n  getHash() {\r\n    // 过滤掉'#'\r\n    return location.hash ? location.hash.slice(1) : \"/\";\r\n  }\r\n  setHash(href) {\r\n    if (!href) {\r\n      return;\r\n    }\r\n    if (!/^/.test(href)) {\r\n      href = `#${href}`;\r\n    }\r\n    location.hash = href;\r\n  }\r\n}\r\n```\r\n\r\n借助变量`isBackOff`来控制，如果是后退只执行回调函数，当正常操作的时候新增`history`数据，同时清楚多余数组，前进跟后退类似，下面就来实现它。\r\n\r\n### 前进\r\n\r\n思路跟后退的一致，借助变量来进行控制，定义一个前进方法。\r\n\r\n```js\r\nclass Router {\r\n  constructor() {\r\n    this.hash = new Map();\r\n    // 储存hash变化的数组\r\n    this.history = [];\r\n    // 指针\r\n    this.pointer = this.history.length - 1;\r\n    // 是否后退，默认给false\r\n    this.isBackOff = false;\r\n    // 前进标识\r\n    this.isForward = false;\r\n    this.change = () => {\r\n      const href = this.getHash();\r\n      if (!this.hash.has(href)) {\r\n        return console.error(`hash路由${href}无对应处理函数`);\r\n      }\r\n      if (!this.isBackOff && !this.isForward) {\r\n        // 看一下指针长度对不对，如果多余就截取掉\r\n        if (this.pointer < this.history.length - 1) {\r\n          this.history = this.history.slice(0, this.pointer + 1);\r\n        }\r\n        // 在路由发生变化的时候，同时对history添加，和移动指针\r\n        this.history.push(href);\r\n        this.pointer++;\r\n      }\r\n      this.move(href);\r\n      this.isBackOff = false;\r\n      this.isForward = false;\r\n    };\r\n    // 后退\r\n    this.backOff = () => {\r\n      this.isBackOff = true;\r\n      // 数组下表不能负\r\n      if (this.pointer <= 0) {\r\n        this.pointer = 0;\r\n      } else {\r\n        // 移动下标\r\n        this.pointer -= 1;\r\n      }\r\n      // 读取对应的值，移动hash\r\n      const href = this.history[this.pointer];\r\n      console.log(href, this.pointer, this.history);\r\n      this.setHash(href);\r\n    };\r\n    // 前进\r\n    this.forward = () => {\r\n      this.isForward = true;\r\n      // 数组下表不能负\r\n      if (this.pointer >= this.history.length - 1) {\r\n        this.pointer = this.history.length - 1;\r\n      } else {\r\n        // 移动下标\r\n        this.pointer += 1;\r\n      }\r\n      // 读取对应的值，移动hash\r\n      const href = this.history[this.pointer];\r\n      console.log(`前进${href}`, this.pointer, this.history);\r\n      this.setHash(href);\r\n    };\r\n    window.addEventListener(\"load\", this.change);\r\n    window.addEventListener(\"hashchange\", this.change);\r\n  }\r\n  route(href, fn) {\r\n    this.hash.set(href, fn);\r\n  }\r\n  move(href) {\r\n    const fn = this.hash.get(href);\r\n    if (typeof fn == \"function\") {\r\n      fn.call(this, href);\r\n    }\r\n  }\r\n  getHash() {\r\n    // 过滤掉'#'\r\n    return location.hash ? location.hash.slice(1) : \"/\";\r\n  }\r\n  setHash(href) {\r\n    if (!href) {\r\n      return;\r\n    }\r\n    if (!/^/.test(href)) {\r\n      href = `#${href}`;\r\n    }\r\n    location.hash = href;\r\n  }\r\n}\r\n```\r\n\r\n跟后退对比，实质上也只是把后退指针改成前进了，如果想要实现`go`跳转的功能也跟前进、后退思路一样。\r\n\r\n### 使用方法\r\n\r\n```html\r\n<ul>\r\n  <li><a href=\"#hash1\">hash1</a></li>\r\n  <li><a href=\"#hash2\">hash2</a></li>\r\n  <li><a href=\"#hash3\">hash3</a></li>\r\n</ul>\r\n<div><button class=\"f\">前进</button> <button class=\"b\">后退</button></div>\r\n1\r\n```\r\n\r\n```js\r\nconst color = {\r\n  hash1: \"#333\",\r\n  hash2: \"#666\",\r\n  hash3: \"#DDD\"\r\n};\r\nconst route = new Router();\r\nroute.route(\"hash1\", function(e) {\r\n  document.body.style.background = color[e];\r\n});\r\nroute.route(\"hash2\", function(e) {\r\n  document.body.style.background = color[e];\r\n});\r\nroute.route(\"hash3\", function(e) {\r\n  document.body.style.background = color[e];\r\n});\r\nconst backOff = document.querySelector(\".b\");\r\nconst forward = document.querySelector(\".f\");\r\nbackOff.addEventListener(\"click\", route.backOff);\r\nforward.addEventListener(\"click\", route.forward);\r\n```\r\n\r\n### 最后\r\n\r\n这里实现了 hash 路由的`响应变化`和`前进`、`后退`、`404` 的功能，但是还有很多地方需要完善，比如`go`跳转。\r\n\r\n下一节将介绍 `History 路由的实现`，如果喜欢请点击一下 **star**\r\n",
          "reactions": {
            "url": "https://api.github.com/repos/bosens-China/blog/issues/50/reactions",
            "total_count": 0,
            "+1": 0,
            "-1": 0,
            "laugh": 0,
            "hooray": 0,
            "confused": 0,
            "heart": 0,
            "rocket": 0,
            "eyes": 0
          },
          "timeline_url": "https://api.github.com/repos/bosens-China/blog/issues/50/timeline",
          "performed_via_github_app": null,
          "state_reason": null
        }
      ]
    ],
    [
      "1935755992",
      [
        {
          "url": "https://api.github.com/repos/bosens-China/blog/issues/88",
          "repository_url": "https://api.github.com/repos/bosens-China/blog",
          "labels_url": "https://api.github.com/repos/bosens-China/blog/issues/88/labels{/name}",
          "comments_url": "https://api.github.com/repos/bosens-China/blog/issues/88/comments",
          "events_url": "https://api.github.com/repos/bosens-China/blog/issues/88/events",
          "html_url": "https://github.com/bosens-China/blog/issues/88",
          "id": 1089747064,
          "node_id": "I_kwDOCzPAy85A9Dh4",
          "number": 88,
          "title": "Babel to Class之原生构造函数继承（4）",
          "user": {
            "login": "bosens-China",
            "id": 39508895,
            "node_id": "MDQ6VXNlcjM5NTA4ODk1",
            "avatar_url": "https://avatars.githubusercontent.com/u/39508895?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/bosens-China",
            "html_url": "https://github.com/bosens-China",
            "followers_url": "https://api.github.com/users/bosens-China/followers",
            "following_url": "https://api.github.com/users/bosens-China/following{/other_user}",
            "gists_url": "https://api.github.com/users/bosens-China/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/bosens-China/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/bosens-China/subscriptions",
            "organizations_url": "https://api.github.com/users/bosens-China/orgs",
            "repos_url": "https://api.github.com/users/bosens-China/repos",
            "events_url": "https://api.github.com/users/bosens-China/events{/privacy}",
            "received_events_url": "https://api.github.com/users/bosens-China/received_events",
            "type": "User",
            "site_admin": false
          },
          "labels": [
            {
              "id": 1935755992,
              "node_id": "MDU6TGFiZWwxOTM1NzU1OTky",
              "url": "https://api.github.com/repos/bosens-China/blog/labels/%E5%BE%85%E5%AE%8C%E6%88%90%E7%B3%BB%E5%88%97",
              "name": "待完成系列",
              "color": "cc6e43",
              "default": false,
              "description": "等待完成的文章..."
            }
          ],
          "state": "open",
          "locked": false,
          "assignee": null,
          "assignees": [],
          "milestone": null,
          "comments": 0,
          "created_at": "2021-12-28T09:44:09Z",
          "updated_at": "2021-12-28T09:44:09Z",
          "closed_at": null,
          "author_association": "OWNER",
          "active_lock_reason": null,
          "body": null,
          "reactions": {
            "url": "https://api.github.com/repos/bosens-China/blog/issues/88/reactions",
            "total_count": 0,
            "+1": 0,
            "-1": 0,
            "laugh": 0,
            "hooray": 0,
            "confused": 0,
            "heart": 0,
            "rocket": 0,
            "eyes": 0
          },
          "timeline_url": "https://api.github.com/repos/bosens-China/blog/issues/88/timeline",
          "performed_via_github_app": null,
          "state_reason": null
        },
        {
          "url": "https://api.github.com/repos/bosens-China/blog/issues/87",
          "repository_url": "https://api.github.com/repos/bosens-China/blog",
          "labels_url": "https://api.github.com/repos/bosens-China/blog/issues/87/labels{/name}",
          "comments_url": "https://api.github.com/repos/bosens-China/blog/issues/87/comments",
          "events_url": "https://api.github.com/repos/bosens-China/blog/issues/87/events",
          "html_url": "https://github.com/bosens-China/blog/issues/87",
          "id": 1085665660,
          "node_id": "I_kwDOCzPAy85AtfF8",
          "number": 87,
          "title": "函数组合",
          "user": {
            "login": "bosens-China",
            "id": 39508895,
            "node_id": "MDQ6VXNlcjM5NTA4ODk1",
            "avatar_url": "https://avatars.githubusercontent.com/u/39508895?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/bosens-China",
            "html_url": "https://github.com/bosens-China",
            "followers_url": "https://api.github.com/users/bosens-China/followers",
            "following_url": "https://api.github.com/users/bosens-China/following{/other_user}",
            "gists_url": "https://api.github.com/users/bosens-China/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/bosens-China/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/bosens-China/subscriptions",
            "organizations_url": "https://api.github.com/users/bosens-China/orgs",
            "repos_url": "https://api.github.com/users/bosens-China/repos",
            "events_url": "https://api.github.com/users/bosens-China/events{/privacy}",
            "received_events_url": "https://api.github.com/users/bosens-China/received_events",
            "type": "User",
            "site_admin": false
          },
          "labels": [
            {
              "id": 1935755992,
              "node_id": "MDU6TGFiZWwxOTM1NzU1OTky",
              "url": "https://api.github.com/repos/bosens-China/blog/labels/%E5%BE%85%E5%AE%8C%E6%88%90%E7%B3%BB%E5%88%97",
              "name": "待完成系列",
              "color": "cc6e43",
              "default": false,
              "description": "等待完成的文章..."
            }
          ],
          "state": "open",
          "locked": false,
          "assignee": null,
          "assignees": [],
          "milestone": null,
          "comments": 0,
          "created_at": "2021-12-21T10:17:50Z",
          "updated_at": "2021-12-21T10:17:50Z",
          "closed_at": null,
          "author_association": "OWNER",
          "active_lock_reason": null,
          "body": null,
          "reactions": {
            "url": "https://api.github.com/repos/bosens-China/blog/issues/87/reactions",
            "total_count": 0,
            "+1": 0,
            "-1": 0,
            "laugh": 0,
            "hooray": 0,
            "confused": 0,
            "heart": 0,
            "rocket": 0,
            "eyes": 0
          },
          "timeline_url": "https://api.github.com/repos/bosens-China/blog/issues/87/timeline",
          "performed_via_github_app": null,
          "state_reason": null
        },
        {
          "url": "https://api.github.com/repos/bosens-China/blog/issues/85",
          "repository_url": "https://api.github.com/repos/bosens-China/blog",
          "labels_url": "https://api.github.com/repos/bosens-China/blog/issues/85/labels{/name}",
          "comments_url": "https://api.github.com/repos/bosens-China/blog/issues/85/comments",
          "events_url": "https://api.github.com/repos/bosens-China/blog/issues/85/events",
          "html_url": "https://github.com/bosens-China/blog/issues/85",
          "id": 1085663742,
          "node_id": "I_kwDOCzPAy85Aten-",
          "number": 85,
          "title": "手写PromiseA+规范",
          "user": {
            "login": "bosens-China",
            "id": 39508895,
            "node_id": "MDQ6VXNlcjM5NTA4ODk1",
            "avatar_url": "https://avatars.githubusercontent.com/u/39508895?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/bosens-China",
            "html_url": "https://github.com/bosens-China",
            "followers_url": "https://api.github.com/users/bosens-China/followers",
            "following_url": "https://api.github.com/users/bosens-China/following{/other_user}",
            "gists_url": "https://api.github.com/users/bosens-China/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/bosens-China/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/bosens-China/subscriptions",
            "organizations_url": "https://api.github.com/users/bosens-China/orgs",
            "repos_url": "https://api.github.com/users/bosens-China/repos",
            "events_url": "https://api.github.com/users/bosens-China/events{/privacy}",
            "received_events_url": "https://api.github.com/users/bosens-China/received_events",
            "type": "User",
            "site_admin": false
          },
          "labels": [
            {
              "id": 1935755992,
              "node_id": "MDU6TGFiZWwxOTM1NzU1OTky",
              "url": "https://api.github.com/repos/bosens-China/blog/labels/%E5%BE%85%E5%AE%8C%E6%88%90%E7%B3%BB%E5%88%97",
              "name": "待完成系列",
              "color": "cc6e43",
              "default": false,
              "description": "等待完成的文章..."
            }
          ],
          "state": "open",
          "locked": false,
          "assignee": null,
          "assignees": [],
          "milestone": null,
          "comments": 0,
          "created_at": "2021-12-21T10:15:52Z",
          "updated_at": "2021-12-21T10:15:52Z",
          "closed_at": null,
          "author_association": "OWNER",
          "active_lock_reason": null,
          "body": null,
          "reactions": {
            "url": "https://api.github.com/repos/bosens-China/blog/issues/85/reactions",
            "total_count": 0,
            "+1": 0,
            "-1": 0,
            "laugh": 0,
            "hooray": 0,
            "confused": 0,
            "heart": 0,
            "rocket": 0,
            "eyes": 0
          },
          "timeline_url": "https://api.github.com/repos/bosens-China/blog/issues/85/timeline",
          "performed_via_github_app": null,
          "state_reason": null
        }
      ]
    ],
    [
      "1602397157",
      [
        {
          "url": "https://api.github.com/repos/bosens-China/blog/issues/77",
          "repository_url": "https://api.github.com/repos/bosens-China/blog",
          "labels_url": "https://api.github.com/repos/bosens-China/blog/issues/77/labels{/name}",
          "comments_url": "https://api.github.com/repos/bosens-China/blog/issues/77/comments",
          "events_url": "https://api.github.com/repos/bosens-China/blog/issues/77/events",
          "html_url": "https://github.com/bosens-China/blog/issues/77",
          "id": 1041025871,
          "node_id": "I_kwDOCzPAy84-DMtP",
          "number": 77,
          "title": "判断对象全等",
          "user": {
            "login": "bosens-China",
            "id": 39508895,
            "node_id": "MDQ6VXNlcjM5NTA4ODk1",
            "avatar_url": "https://avatars.githubusercontent.com/u/39508895?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/bosens-China",
            "html_url": "https://github.com/bosens-China",
            "followers_url": "https://api.github.com/users/bosens-China/followers",
            "following_url": "https://api.github.com/users/bosens-China/following{/other_user}",
            "gists_url": "https://api.github.com/users/bosens-China/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/bosens-China/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/bosens-China/subscriptions",
            "organizations_url": "https://api.github.com/users/bosens-China/orgs",
            "repos_url": "https://api.github.com/users/bosens-China/repos",
            "events_url": "https://api.github.com/users/bosens-China/events{/privacy}",
            "received_events_url": "https://api.github.com/users/bosens-China/received_events",
            "type": "User",
            "site_admin": false
          },
          "labels": [
            {
              "id": 1602397157,
              "node_id": "MDU6TGFiZWwxNjAyMzk3MTU3",
              "url": "https://api.github.com/repos/bosens-China/blog/labels/%E6%B7%B1%E5%85%A5%E7%B3%BB%E5%88%97",
              "name": "深入系列",
              "color": "719192",
              "default": false,
              "description": "主要介绍实现的思路"
            }
          ],
          "state": "open",
          "locked": false,
          "assignee": null,
          "assignees": [],
          "milestone": null,
          "comments": 0,
          "created_at": "2021-11-01T10:38:09Z",
          "updated_at": "2021-12-21T09:58:45Z",
          "closed_at": null,
          "author_association": "OWNER",
          "active_lock_reason": null,
          "body": "JavaScript 自带了`==`和`===`两种判断方式，前者会隐式转换类型导致代码出现问题，而后者则是根据指针地址进行判断。\r\n\r\n在绝大多数情况这两种已经足够使用了，不过延伸下想判断两个对象或数组元素是否相同，则会显得不太友好，而且在 JavaScript 中有一些特殊的规则：`NaN`和`NaN`不相同、`+0`和`-0`相同，这就导致有的场景使用起来不便，下面动手实现一个`equal`函数，它具备以下功能：\r\n\r\n- `+0`和`-0`不相同\r\n- `NaN`和`NaN`相同\r\n- `{}`和`{}`相同\r\n- `[]`和`[]`相同\r\n- `new Set()`和`new Set()`相同\r\n- `new Map()`和`new Map()`相同\r\n- `new Date(111)`和`new Date(111)`相同\r\n- `new String(1)`和`new String(1)`之类的包装对象相同\r\n- `/a/`和`/a/`相同 -`() => {}`和`() => {}`不相同\r\n- 其他情况一律`===`判断\r\n\r\n## 第一版\r\n\r\n在这一版中，我们先实现`+0`和`-0`、`NaN`的判断\r\n\r\n```js\r\nfunction equal(a, b) {\r\n  // 判断NaN\r\n  if (a === b) {\r\n    return 1 / a === 1 / b;\r\n  }\r\n  // 判断对象\r\n  if (a && b && typeof a === 'object' && typeof b === 'object') {\r\n    //... 留空\r\n  }\r\n  // 判断NaN\r\n  return a !== a && b !== b;\r\n}\r\n```\r\n\r\n上面判断`NaN`的思路为`1 / 0`为`Infinity`，而`1/-0`为`-Infinity`\r\n\r\n## 第二版\r\n\r\n第一版中我们已经实现了基础的功能，下面就来实现一下怎么深层次判断对象和数组是否相同\r\n\r\n```js\r\nfunction equal(a, b) {\r\n  // 判断NaN\r\n  if (a === b) {\r\n    return 1 / a === 1 / b;\r\n  }\r\n  // 判断对象\r\n  if (a && b && typeof a === 'object' && typeof b === 'object') {\r\n    if (a.constructor !== b.constructor) {\r\n      return false;\r\n    }\r\n    // 判断array\r\n    if (Array.isArray(a) && Array.isArray(b)) {\r\n      const len = a.length;\r\n      if (len !== b.length) {\r\n        return false;\r\n      }\r\n      for (let i = 0; i < len; i++) {\r\n        if (!equal(a[i], b[i])) {\r\n          return false;\r\n        }\r\n      }\r\n      return true;\r\n    }\r\n    // 默认为对象，进行key和长度对比\r\n    const keys = Object.keys(a);\r\n    const len = keys.length;\r\n    if (Object.keys(b).length !== len) {\r\n      return false;\r\n    }\r\n    for (let i = 0; i < len; i++) {\r\n      const key = keys[i];\r\n      if (!Object.prototype.hasOwnProperty.call(b, key)) {\r\n        return false;\r\n      }\r\n      if (!equal(a[key], b[key])) {\r\n        return false;\r\n      }\r\n    }\r\n    return true;\r\n  }\r\n}\r\n```\r\n\r\n上面代码中首先判断`constructor`是否相同，`constructor`可以从实例指向原型的构造函数，上面代码首先的意思是首先判断构造函数是否相同，如果不相同直接返回。\r\n\r\n后面的话判断数组的成员数量、每个子属性是否相同，而判断对象也是判断`length`之后判断`b`下是否存在`name`，之后统一对比值是否相同。\r\n\r\n至于执行`Object.prototype.hasOwnProperty`的原因则是`hasOwnProperty`有可能被改写，例如：\r\n\r\n```js\r\nvar foo = {\r\n  hasOwnProperty: function () {\r\n    return false;\r\n  },\r\n  bar: 'Here be dragons',\r\n};\r\n\r\nfoo.hasOwnProperty('bar'); // 始终返回 false\r\n```\r\n\r\n## 第三版\r\n\r\n上面的代码基本实现了一个雏形，下面加入`Set`、`Map`的对比，`Set`和`Map`是 es6 是引入的新的数据结构，`Set`是一组不重复的成员，`Map`则是`object`的升级版：重点解决了键名循环不稳定以及只能插入 string 键名的问题。\r\n\r\n它们两者都是有序的，且都遵循`Symbol.iterator`，所以我们不仅要对比`name`、`value`也要对比所在的位置是否相同，这里为了简化后面的工作提前写了一个函数\r\n\r\n```js\r\nconst iteration = (value, j) => {\r\n  let i = 0;\r\n  for (const iterator of value) {\r\n    if (j === i++) {\r\n      return iterator;\r\n    }\r\n  }\r\n  return undefined;\r\n};\r\n```\r\n\r\n它的作用就是根据`j`指定下标来运行迭代器的`next`方法，例如：\r\n\r\n```js\r\niteration(new Set([1, 2, 3]), 1); // 2\r\n```\r\n\r\n```js\r\n// 判断set\r\nif (a instanceof Set && b instanceof Set) {\r\n  const len = a.size;\r\n  if (len !== b.size) {\r\n    return false;\r\n  }\r\n  for (let i = 0; i < len; i++) {\r\n    if (!equal(iteration(a, i), iteration(b, i))) {\r\n      return false;\r\n    }\r\n  }\r\n  return true;\r\n}\r\n// 判断Map\r\nif (a instanceof Map && b instanceof Map) {\r\n  const len = a.size;\r\n  if (len !== b.size) {\r\n    return false;\r\n  }\r\n  for (let i = 0; i < len; i++) {\r\n    const [nameA, valueA] = iteration(a.entries(), i);\r\n    const [nameB, valueB] = iteration(b.entries(), i);\r\n    if (!equal(nameA, nameB) || !equal(valueA, valueB)) {\r\n      return false;\r\n    }\r\n  }\r\n  return true;\r\n}\r\n```\r\n\r\n可以发现`Set`和`Map`判断是否相似，首先对比成员数量，其次对比每一次当前位置的键名和键值。\r\n\r\n## 第四版\r\n\r\n写到这里我们已经实现了 80%的功能，剩下的一些判断还有\r\n\r\n- `new Date(111)`和`new Date(111)`相同\r\n- `new String(1)`和`new String(1)`之类的包装对象相同\r\n- `/a/`和`/a/`相同\r\n\r\n```js\r\n// 判断regexp\r\nif (a.constructor === RegExp) {\r\n  return a.source === b.source && a.flags === b.flags;\r\n}\r\nif (a.toString !== Object.prototype.toString) {\r\n  return a.toString() === b.toString();\r\n}\r\nif (a.valueOf !== Object.prototype.valueOf) {\r\n  return a.valueOf() === b.valueOf();\r\n}\r\n```\r\n\r\n判断包装类型和`Date`可以`valueOf`和`toString`方法实现，每个对象都会从`Object.prototype`继承`vlaueOf`和`toString`方法。\r\n\r\n通常情况下`valueOf`返回包装对象传递的参数，而有的对象会更改`valueOf`方法，例如`Date`返回`number`类型，所以上面判断`valueOf`一则是为了`Date`另外一方则是初始过滤传递的参数。\r\n\r\n至于为什么也判断`toString`则是为了考虑边界情况，例如：\r\n\r\n```js\r\nvar a = new Boolean(true);\r\nvar b = new Boolean(1);\r\na === b ?\r\n```\r\n\r\n如果没有`toString`这个就相同了\r\n\r\n## 最后\r\n\r\n完整的把代码贴一下，如果对你有帮助也可以`star`支持一下，有什么错误也欢迎指出。\r\n\r\n```js\r\nconst iteration = (value, j) => {\r\n  let i = 0;\r\n  for (const iterator of value) {\r\n    if (j === i++) {\r\n      return iterator;\r\n    }\r\n  }\r\n  return undefined;\r\n};\r\nfunction equal(a, b) {\r\n  // 判断NaN\r\n  if (a === b) {\r\n    return 1 / a === 1 / b;\r\n  }\r\n  // 判断对象\r\n  if (a && b && typeof a === 'object' && typeof b === 'object') {\r\n    // 判断对象\r\n    if (a && b && typeof a === 'object' && typeof b === 'object') {\r\n      if (a.constructor !== b.constructor) {\r\n        return false;\r\n      }\r\n      // 判断array\r\n      if (Array.isArray(a) && Array.isArray(b)) {\r\n        const len = a.length;\r\n        if (len !== b.length) {\r\n          return false;\r\n        }\r\n        for (let i = 0; i < len; i++) {\r\n          if (!equal(a[i], b[i])) {\r\n            return false;\r\n          }\r\n        }\r\n        return true;\r\n      }\r\n      // 判断set\r\n      if (a instanceof Set && b instanceof Set) {\r\n        const len = a.size;\r\n        if (len !== b.size) {\r\n          return false;\r\n        }\r\n        for (let i = 0; i < len; i++) {\r\n          if (!equal(iteration(a, i), iteration(b, i))) {\r\n            return false;\r\n          }\r\n        }\r\n        return true;\r\n      }\r\n      // 判断Map\r\n      if (a instanceof Map && b instanceof Map) {\r\n        const len = a.size;\r\n        if (len !== b.size) {\r\n          return false;\r\n        }\r\n        for (let i = 0; i < len; i++) {\r\n          const [nameA, valueA] = iteration(a.entries(), i);\r\n          const [nameB, valueB] = iteration(b.entries(), i);\r\n          if (!equal(nameA, nameB) || !equal(valueA, valueB)) {\r\n            return false;\r\n          }\r\n        }\r\n        return true;\r\n      }\r\n      // 判断regexp\r\n      if (a.constructor === RegExp) {\r\n        return a.source === b.source && a.flags === b.flags;\r\n      }\r\n      if (a.toString !== Object.prototype.toString) {\r\n        return a.toString() === b.toString();\r\n      }\r\n      if (a.valueOf !== Object.prototype.valueOf) {\r\n        return a.valueOf() === b.valueOf();\r\n      }\r\n      // 默认为对象，进行key和长度对比\r\n      const keys = Object.keys(a);\r\n      const len = keys.length;\r\n      if (Object.keys(b).length !== len) {\r\n        return false;\r\n      }\r\n      for (let i = 0; i < len; i++) {\r\n        const key = keys[i];\r\n        if (!Object.prototype.hasOwnProperty.call(b, key)) {\r\n          return false;\r\n        }\r\n        if (!equal(a[key], b[key])) {\r\n          return false;\r\n        }\r\n      }\r\n      return true;\r\n    }\r\n  }\r\n  // 判断NaN\r\n  return a !== a && b !== b;\r\n}\r\n```\r\n\r\n## 参考\r\n\r\n- [fast-deep-equal](https://github.com/epoberezkin/fast-deep-equal)\r\n",
          "reactions": {
            "url": "https://api.github.com/repos/bosens-China/blog/issues/77/reactions",
            "total_count": 0,
            "+1": 0,
            "-1": 0,
            "laugh": 0,
            "hooray": 0,
            "confused": 0,
            "heart": 0,
            "rocket": 0,
            "eyes": 0
          },
          "timeline_url": "https://api.github.com/repos/bosens-China/blog/issues/77/timeline",
          "performed_via_github_app": null,
          "state_reason": null
        },
        {
          "url": "https://api.github.com/repos/bosens-China/blog/issues/76",
          "repository_url": "https://api.github.com/repos/bosens-China/blog",
          "labels_url": "https://api.github.com/repos/bosens-China/blog/issues/76/labels{/name}",
          "comments_url": "https://api.github.com/repos/bosens-China/blog/issues/76/comments",
          "events_url": "https://api.github.com/repos/bosens-China/blog/issues/76/events",
          "html_url": "https://github.com/bosens-China/blog/issues/76",
          "id": 1029841361,
          "node_id": "I_kwDOCzPAy849YiHR",
          "number": 76,
          "title": "函数记忆",
          "user": {
            "login": "bosens-China",
            "id": 39508895,
            "node_id": "MDQ6VXNlcjM5NTA4ODk1",
            "avatar_url": "https://avatars.githubusercontent.com/u/39508895?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/bosens-China",
            "html_url": "https://github.com/bosens-China",
            "followers_url": "https://api.github.com/users/bosens-China/followers",
            "following_url": "https://api.github.com/users/bosens-China/following{/other_user}",
            "gists_url": "https://api.github.com/users/bosens-China/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/bosens-China/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/bosens-China/subscriptions",
            "organizations_url": "https://api.github.com/users/bosens-China/orgs",
            "repos_url": "https://api.github.com/users/bosens-China/repos",
            "events_url": "https://api.github.com/users/bosens-China/events{/privacy}",
            "received_events_url": "https://api.github.com/users/bosens-China/received_events",
            "type": "User",
            "site_admin": false
          },
          "labels": [
            {
              "id": 1602397157,
              "node_id": "MDU6TGFiZWwxNjAyMzk3MTU3",
              "url": "https://api.github.com/repos/bosens-China/blog/labels/%E6%B7%B1%E5%85%A5%E7%B3%BB%E5%88%97",
              "name": "深入系列",
              "color": "719192",
              "default": false,
              "description": "主要介绍实现的思路"
            }
          ],
          "state": "open",
          "locked": false,
          "assignee": null,
          "assignees": [],
          "milestone": null,
          "comments": 0,
          "created_at": "2021-10-19T04:16:45Z",
          "updated_at": "2021-12-21T09:58:43Z",
          "closed_at": null,
          "author_association": "OWNER",
          "active_lock_reason": null,
          "body": "> **记忆化**（英语：memoization）是一种提高[计算机程序](https://zh.wikipedia.org/wiki/计算机程序)执行速度的优化技术。通过储存大计算量[函数](https://zh.wikipedia.org/wiki/子程序)的返回值，当这个结果再次被需要时将其从[缓存](https://zh.wikipedia.org/wiki/缓存)提取，而不用再次计算来节省计算时间。\r\n>\r\n> 记忆化是一种典型的在计算时间与[电脑存储器](https://zh.wikipedia.org/wiki/電腦記憶體)空间之中获取平衡的方案。\r\n>\r\n> 来源：[维基百科](https://zh.wikipedia.org/wiki/%E8%AE%B0%E5%BF%86%E5%8C%96)\r\n\r\n从上面的定义可以看出缓存是一种非常有用的技巧，它可以把一些函数结果储存起来在下次调用的时候返回。\r\n这里不讨论什么样场景使用缓存而是抛砖引玉如何编写一个可复用的 Memoization 函数\r\n\r\n## MemoizationSync\r\n\r\nMemoizationSync 从字面就可以看出它是一个同步版本的 Memoization，下面的以 `add` 函数为例介绍如何编写一个通用的 memoization 来对结果进行缓存\r\n\r\n```js\r\nconst memo = {};\r\n\r\nconst add = (...args) => {\r\n  const key = args.join();\r\n  if (Object.prototype.hasOwnProperty.call(memo, key)) {\r\n    return memo[key];\r\n  }\r\n  const result = args.reduce((a, b) => a + b, 0);\r\n  memo[key] = result;\r\n  return result;\r\n};\r\n\r\nadd(1, 2, 3);\r\nadd(1, 2, 3);\r\n```\r\n\r\n如果要给 `add` 函数显示的添加一个缓存功能可能会按照上面的情况来编写，但是它存在问题。\r\n\r\n这个函数同时做了两件事情\r\n\r\n- 计算 args\r\n- 读取 memo 的缓存\r\n  但是这样显示违背了设计模式的单一原则，而且会给后续的维护带来麻烦，以及如果我们需要新的函数缓存是不是还要重新复制一份过去，显然不符合我们的要求，我们尝试将它进行一次抽离\r\n\r\n```js\r\nconst add = (...args) => {\r\n  return args.reduce((a, b) => a + b, 0);\r\n};\r\n\r\nconst memoizationSync = (fn, key) => {\r\n  const memo = {};\r\n  return function callback(...args) {\r\n    if (memo.hasOwnProperty(key)) {\r\n      return memo[key];\r\n    }\r\n    const result = fn.apply(this, args);\r\n    memo[key] = result;\r\n    return result;\r\n  };\r\n};\r\n\r\nconst argumentsArr = [1, 2, 3];\r\nconst memoizationAdd = memoizationSync(add, argumentsArr);\r\nmemoizationAdd(...argumentsArr);\r\nmemoizationAdd(...argumentsArr);\r\n```\r\n\r\n这样就得到了一个通用的 memoizationSync 函数，它接受一个 `key` ，通过 `key` 来进行区分缓存。\r\n\r\n不过为了它的灵活性和符合更多的场景的要求我们还是需要对它进行一次改造，来改造前我们看下这个函数做了啥\r\n\r\n- 根据 key 来读取缓存\r\n- 无缓存来执行函数设置缓存\r\n  显然这两步是不会改变的，但是我们可以对 `key` 下手提高 `key` 的唯一性，我们希望它可以是一个函数并且存在默认值，这样在复杂场景下可以由用户根据参数来指定缓存什么字段\r\n\r\n```js\r\nconst memoizationSync = (fn, getKey = (...args) => args.join('')) => {\r\n  const memo = {};\r\n  return function callback(...args) {\r\n    const key = typeof getKey === 'function' ? getKey.apply(this, args) : getKey;\r\n    if (memo.hasOwnProperty(key)) {\r\n      return memo[key];\r\n    }\r\n    const result = fn.apply(this, args);\r\n    memo[key] = result;\r\n    return result;\r\n  };\r\n};\r\n```\r\n\r\n## MemoizationAsync\r\n\r\n在 JavaScript 中异步场景粗略可以分为两部分\r\n\r\n- 回调函数\r\n- Promise（async 、Generator 都是基于 Promise）\r\n\r\n下面就来讨论这两部分我们如何实现缓存\r\n\r\n### Callback\r\n\r\n我现在有一个 getImgSize 的函数，它会根据 `img` 的 `src` 来返回图片的真实宽度和高度，如果成功就会调用 `callback` 来传递参数（node 回调风格），但是我希望如果 url 相同的时候就直接返回而不是继续调用一次 getImgSize\r\n\r\n```js\r\nconst getImgSize = (src, callback) => {\r\n  const img = new Image();\r\n  img.src = src;\r\n  img.addEventListener('load', () => {\r\n    callback(null, {\r\n      width: img.naturalWidth,\r\n      height: img.naturalHeight,\r\n    });\r\n  });\r\n\r\n  img.addEventListener('error', (e) => {\r\n    callback(new Error(e), null);\r\n  });\r\n};\r\n\r\nconst url = 'https://www.google.com/images/branding/googlelogo/1x/googlelogo_color_272x92dp.png';\r\n\r\ngetImgSize(url, (error, size) => {\r\n  if (error) {\r\n    return;\r\n  }\r\n  console.log(size);\r\n});\r\n```\r\n\r\n在编写 memoizationAsync 函数之前我们先想一下以什么样的方式来编写这个函数，按照惯例我们希望不要对用户的使用方式有太多影响，所以期待的调用方式如下\r\n\r\n```js\r\nconst getImgSizeMemoization = memoizationAsync(getImgSize);\r\ngetImgSizeMemoization(url, (error, size) => {\r\n  if (error) {\r\n    return;\r\n  }\r\n  console.log(size);\r\n});\r\n// 相同参数使用缓存\r\ngetImgSizeMemoization(url, (error, size) => {\r\n  if (error) {\r\n    return;\r\n  }\r\n  console.log(size);\r\n});\r\n```\r\n\r\n后面就是来编写这个函数\r\n\r\n```js\r\nconst memoizationAsync = (fn, getKey = (...args) => args.join()) => {\r\n  const memo = {};\r\n  const queue = {};\r\n  return function (...rest) {\r\n    const callback = Array.prototype.pop.call(rest);\r\n    const key = getKey.apply(this, rest);\r\n    const cb = (...args) => {\r\n      memo[key] = args;\r\n      queue[key].forEach((item) => {\r\n        item.apply(this, args);\r\n      });\r\n      delete queue[key];\r\n    };\r\n    if (memo.hasOwnProperty(key)) {\r\n      return memo[key];\r\n    }\r\n    if (!queue.hasOwnProperty(key)) {\r\n      queue[key] = [callback];\r\n    } else {\r\n      queue[key].push(callback);\r\n      // 后续加入等待第一个执行结束\r\n      return;\r\n    }\r\n    fn.apply(this, [...rest, cb]);\r\n  };\r\n};\r\n```\r\n\r\n说一下这个函数编写的思路，通过自定义创建 cb 回调函数来完成记录缓存和调用用户传递的回调，其他的读取和设置缓存与上面一致。\r\n\r\n而存在 `queue` 变量的原因是因为异步任务添加进来的时候可能正在请求，但是 `memo` 还没有被写入结果，所以通过队列来管理这个请求，等待第一个请求结束之后批量来执行队列的任务，最后删除。\r\n\r\n### Promise\r\n\r\n回忆一下[Promise 函数的特性](https://es6.ruanyifeng.com/#docs/promise#Promise-%E7%9A%84%E5%90%AB%E4%B9%89)\r\n\r\n- 对象的状态不受外界影响\r\n- 一旦状态改变，就不会再变，任何时候都可以得到这个结果\r\n\r\n重点是第二点，它不同于回调函数，只要结果出来了任何时候都可以调用，我们在 click 监听一个事件如果错过了这个监听想要回溯是不可能的，但是 promise 你重复无数次的`.then` 调用，基于这个特性我们来编写 MemoizationAsync\r\n\r\n```js\r\nconst getImgSize = (src) => {\r\n  return new Promise((resolve, reject) => {\r\n    const img = new Image();\r\n    img.src = src;\r\n    img.addEventListener('load', () => {\r\n      return resolve({\r\n        width: img.naturalWidth,\r\n        height: img.naturalHeight,\r\n      });\r\n    });\r\n\r\n    img.addEventListener('error', (e) => {\r\n      return reject(e);\r\n    });\r\n  });\r\n};\r\n\r\nconst url = 'https://www.google.com/images/branding/googlelogo/1x/googlelogo_color_272x92dp.png';\r\n\r\nconst memoizationAsync = (fn, getKey = (...args) => args.join()) => {\r\n  const memo = {};\r\n  return async function (...args) {\r\n    const key = getKey.apply(this, args);\r\n    if (memo.hasOwnProperty(key)) {\r\n      return memo[key];\r\n    }\r\n    const result = fn.apply(this, args);\r\n    memo[key] = result;\r\n    return result;\r\n  };\r\n};\r\n\r\nconst getImgSizeMemoization = memoizationAsync(getImgSize);\r\n\r\n(async () => {\r\n  const result = await Promise.all([getImgSizeMemoization(url), getImgSizeMemoization(url)]);\r\n  console.log(result);\r\n})();\r\n```\r\n\r\nmemoizationAsync 函数编写的十分精简跟同步版本基本没区别，不同点在于我们只是返回了 **Promise 的状态**，而得益于 Promise 的特性在任何时候这个函数都会返回正确的结果\r\n\r\n## 最后\r\n\r\n如果对你有帮助可以`关注`、 `star` 一下，有什么错误欢迎指出\r\n",
          "reactions": {
            "url": "https://api.github.com/repos/bosens-China/blog/issues/76/reactions",
            "total_count": 0,
            "+1": 0,
            "-1": 0,
            "laugh": 0,
            "hooray": 0,
            "confused": 0,
            "heart": 0,
            "rocket": 0,
            "eyes": 0
          },
          "timeline_url": "https://api.github.com/repos/bosens-China/blog/issues/76/timeline",
          "performed_via_github_app": null,
          "state_reason": null
        },
        {
          "url": "https://api.github.com/repos/bosens-China/blog/issues/22",
          "repository_url": "https://api.github.com/repos/bosens-China/blog",
          "labels_url": "https://api.github.com/repos/bosens-China/blog/issues/22/labels{/name}",
          "comments_url": "https://api.github.com/repos/bosens-China/blog/issues/22/comments",
          "events_url": "https://api.github.com/repos/bosens-China/blog/issues/22/events",
          "html_url": "https://github.com/bosens-China/blog/issues/22",
          "id": 485122259,
          "node_id": "MDU6SXNzdWU0ODUxMjIyNTk=",
          "number": 22,
          "title": "通用迭代器实现",
          "user": {
            "login": "bosens-China",
            "id": 39508895,
            "node_id": "MDQ6VXNlcjM5NTA4ODk1",
            "avatar_url": "https://avatars.githubusercontent.com/u/39508895?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/bosens-China",
            "html_url": "https://github.com/bosens-China",
            "followers_url": "https://api.github.com/users/bosens-China/followers",
            "following_url": "https://api.github.com/users/bosens-China/following{/other_user}",
            "gists_url": "https://api.github.com/users/bosens-China/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/bosens-China/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/bosens-China/subscriptions",
            "organizations_url": "https://api.github.com/users/bosens-China/orgs",
            "repos_url": "https://api.github.com/users/bosens-China/repos",
            "events_url": "https://api.github.com/users/bosens-China/events{/privacy}",
            "received_events_url": "https://api.github.com/users/bosens-China/received_events",
            "type": "User",
            "site_admin": false
          },
          "labels": [
            {
              "id": 1602397157,
              "node_id": "MDU6TGFiZWwxNjAyMzk3MTU3",
              "url": "https://api.github.com/repos/bosens-China/blog/labels/%E6%B7%B1%E5%85%A5%E7%B3%BB%E5%88%97",
              "name": "深入系列",
              "color": "719192",
              "default": false,
              "description": "主要介绍实现的思路"
            }
          ],
          "state": "open",
          "locked": false,
          "assignee": null,
          "assignees": [],
          "milestone": null,
          "comments": 0,
          "created_at": "2019-08-26T08:47:04Z",
          "updated_at": "2021-12-21T09:45:27Z",
          "closed_at": null,
          "author_association": "OWNER",
          "active_lock_reason": null,
          "body": "> 迭代器在很多语言都很常见，js 的 forEach 就是一个迭代器，下面就来介绍实现一个支持数组、对象、类数组的的 each 函数。\r\n\r\n## 前言\r\n\r\n写之前先整理一下思路\r\n\r\n1. 我们首先需要判断是不是类数组，如果是数组和类数组就使用 for 循环，如果是对象我们就用 for...in 循环。\r\n2. 回调函数的 this 处理，返回 false 终止循环\r\n\r\n## 判断类型\r\n\r\n判断基本类型我们可以使用 `typeof`，不过对于引用类型，比如数组和函数都会返回`object`，那么还有更好的判断方法么？\r\n那就是`Object.prototype.toString`\r\n\r\n```js\r\nObject.prototype.toString.call({}); // \"[object Object]\"\r\nObject.prototype.toString.call([]); // \"[object Array]\"\r\n```\r\n\r\n这里使用`Object.prototype.toString`的原因是一些引用类型的`toString`有自己的实现方式，比如数组的 `toString` 返回的就是以`\",\"`分隔的文本。\r\n数组的判断可以基于上面方法，下面就是封装成一个函数\r\n\r\n```js\r\nfunction isArray(arr) {\r\n  return Object.prototype.toString.call(arr) === \"[object Array]\";\r\n}\r\n```\r\n\r\n下面就来实现判断类数组的的思路，类数组就是指类似于\r\n\r\n```js\r\n{1: 123, 2：45, 6: 789, length: 7}\r\n// or\r\n// nodelist[]\r\n// arguments\r\n// ...\r\n```\r\n\r\n上面列举的几种对象，都存在`length`，而且都是一个对象，所以我们以这个为判断准则，下面就是实现\r\n\r\n```js\r\nfunction isClassArray(arr) {\r\n  var length = !!arr && length in arr && arr.length;\r\n  return (\r\n    isArray(arr) ||\r\n    length === 0 ||\r\n    (typeof arr === \"number\" && length - 1 in arr)\r\n  );\r\n}\r\n```\r\n\r\n判断还是比较简洁的，判断了三种情况\r\n\r\n1. 必须有 `length` 属性\r\n2. `length` 为 0 的情况\r\n3. `length- 1`必须存在\r\n\r\n第一种就不说了，第二种为什么要判断 length 为 `0` 的情况呢？\r\n假设有一个对象`{a: 1, b: 2, length: 0}`，认为它是类数组是不是不太合适，还有`arguments`是不是类数组对象根据函数的传递参数来变化，但是如果没有参数`length`为 0 就返回 false，是不是也不太合适，其实这里主要就是为了判断一些边界的对象\r\n\r\n```js\r\nfunction foo() {\r\n  arguments.length; // 0\r\n}\r\nfoo();\r\n```\r\n\r\n第三点，为什么要求 `length - 1` 存在？\r\n数组的 length 永远是成员数+1，要求`length - 1` 存在实际上这是为了数组和类数组的形式想对应，例如：\r\n\r\n```js\r\nvar a = [, , 2]; // length: 3\r\n// 对应类数组\r\nvar obj = {\r\n  2: 2,\r\n  length: 3\r\n};\r\n```\r\n\r\n上面数组存在`,`我们认为前面两位就是空，但是如果取消了`length - 1`必须存在，那么下面这种写法会出现下面情况\r\n\r\n```js\r\n// length: 2\r\nvar a = [1, ,];\r\nvar obj = {\r\n  0: 1，\r\n  length: 1\r\n};\r\n```\r\n\r\n## each\r\n\r\n上面把所需要用的讲解完毕了，下面就来实现一个最终版的 each\r\n\r\n```js\r\nfunction isArray(arr) {\r\n  return Object.prototype.toString.call(arr) === \"[object Array]\";\r\n}\r\nfunction isClassArray(arr) {\r\n  var length = !!arr && length in arr && arr.length;\r\n  return (\r\n    isArray(arr) ||\r\n    length === 0 ||\r\n    (typeof arr === \"number\" && length - 1 in arr)\r\n  );\r\n}\r\nfunction each(obj, callback) {\r\n  if (typeof obj !== \"object\") {\r\n    return obj;\r\n  }\r\n  // 数组和类数组\r\n  if (isClassArray(obj)) {\r\n    for (let i = 0; i < obj.length; i++) {\r\n      let v = callback.call(obj, i, obj[i]);\r\n      if (v === false) {\r\n        break;\r\n      }\r\n    }\r\n  } else {\r\n    for (let item in obj) {\r\n      let v = callback.call(obj, item, obj[item]);\r\n      if (v === false) {\r\n        break;\r\n      }\r\n    }\r\n  }\r\n}\r\n```\r\n\r\n## 参考\r\n\r\n[JavaScript 专题之类型判断(下) #30](https://github.com/mqyqingfeng/Blog/issues/30)\r\n",
          "reactions": {
            "url": "https://api.github.com/repos/bosens-China/blog/issues/22/reactions",
            "total_count": 0,
            "+1": 0,
            "-1": 0,
            "laugh": 0,
            "hooray": 0,
            "confused": 0,
            "heart": 0,
            "rocket": 0,
            "eyes": 0
          },
          "timeline_url": "https://api.github.com/repos/bosens-China/blog/issues/22/timeline",
          "performed_via_github_app": null,
          "state_reason": null
        },
        {
          "url": "https://api.github.com/repos/bosens-China/blog/issues/13",
          "repository_url": "https://api.github.com/repos/bosens-China/blog",
          "labels_url": "https://api.github.com/repos/bosens-China/blog/issues/13/labels{/name}",
          "comments_url": "https://api.github.com/repos/bosens-China/blog/issues/13/comments",
          "events_url": "https://api.github.com/repos/bosens-China/blog/issues/13/events",
          "html_url": "https://github.com/bosens-China/blog/issues/13",
          "id": 479666633,
          "node_id": "MDU6SXNzdWU0Nzk2NjY2MzM=",
          "number": 13,
          "title": "相等运算符比较",
          "user": {
            "login": "bosens-China",
            "id": 39508895,
            "node_id": "MDQ6VXNlcjM5NTA4ODk1",
            "avatar_url": "https://avatars.githubusercontent.com/u/39508895?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/bosens-China",
            "html_url": "https://github.com/bosens-China",
            "followers_url": "https://api.github.com/users/bosens-China/followers",
            "following_url": "https://api.github.com/users/bosens-China/following{/other_user}",
            "gists_url": "https://api.github.com/users/bosens-China/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/bosens-China/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/bosens-China/subscriptions",
            "organizations_url": "https://api.github.com/users/bosens-China/orgs",
            "repos_url": "https://api.github.com/users/bosens-China/repos",
            "events_url": "https://api.github.com/users/bosens-China/events{/privacy}",
            "received_events_url": "https://api.github.com/users/bosens-China/received_events",
            "type": "User",
            "site_admin": false
          },
          "labels": [
            {
              "id": 1602397157,
              "node_id": "MDU6TGFiZWwxNjAyMzk3MTU3",
              "url": "https://api.github.com/repos/bosens-China/blog/labels/%E6%B7%B1%E5%85%A5%E7%B3%BB%E5%88%97",
              "name": "深入系列",
              "color": "719192",
              "default": false,
              "description": "主要介绍实现的思路"
            }
          ],
          "state": "open",
          "locked": false,
          "assignee": null,
          "assignees": [],
          "milestone": null,
          "comments": 0,
          "created_at": "2019-08-12T14:08:20Z",
          "updated_at": "2021-12-21T09:40:08Z",
          "closed_at": null,
          "author_association": "OWNER",
          "active_lock_reason": null,
          "body": "> 看《你所不知道的JavaScript》一书，发现对相等运算符的描述推翻了许多人的固有影响，如果熟悉其机制，可以方便我们快速开发\r\n``` js\r\nfunction foo(s) {\r\n  s = s == null ?  true: s;\r\n  // ...\r\n};\r\n```\r\n上面这段代码我们估计经常使用，其实就是使用了隐式转换，下面就来聊聊相等运算符\r\n\r\n## 规则\r\n1. 数值与字符串比较，转化为数值比较\r\n``` js\r\n42 == \"42\";\r\n// 等于\r\n42 == Number(\"42\");\r\n```\r\n2. 布尔型与其他类型比较，转化为数值，之后比较\r\n``` js\r\n\"42\" == true;\r\n// 等于\r\n\"42\" == Number(true);\r\n\"42\" == 1;\r\nNumber(\"42\") == 1;\r\n```\r\n3. undefined 只与 null 相等，其他返回 false\r\n``` js\r\n// 全部false\r\nnull == false;\r\nnull == true;\r\nnull == \"\";\r\nnull == 0;\r\nundefined == true;\r\nundefined == false;\r\nundefined == \"\";\r\nundefined == 0;\r\n```\r\n4. 对象\r\n对象与基本类型比较，会将对象转化为基本类型之后再进行比较；\r\n转化规则很简单，默认调用 `valueOf`，如果返回不是基本类型继续调用 `toStirng`，如果返回还不是基本类型会报错。\r\n``` js\r\n[42] == 42;\r\n// 等于\r\n\"42\" == 42;\r\nNumber(\"42\") == 42;\r\n\r\n\"abc\" == new String(\"abc\");\r\n// 等于\r\n\"abc\" == \"abc\";\r\n```\r\n根据对象转化规则，我们自定义返回的值，比如：\r\n``` js\r\nvar a = [];\r\na.valueOf = function() {\r\n  return 42;\r\n};\r\na.toString = function() {\r\n  return \"123\";\r\n};\r\na == 42; //true\r\n```\r\n\r\n## 实战\r\n上面简单介绍了一下规则，再来看一下隐形的问题\r\n1. [] = ![]\r\n这里会返回 true 原因很简单，根据上述规则其实也就是\"\" == 0比较\r\n2. 0 == '\\n' \r\n这里会返回 true，因为空格和一些其他制表符会被忽略掉。 再来看一些常见的陷阱\r\n``` js\r\n\"0\" == false; // true\r\nfalse == 0; // true\r\nfalse == \"\"; // true\r\nfalse == []; // true\r\n\"\" == []; // true\r\n0 == []; // true\r\n\"\" == 0; // true\r\n```\r\n3. [null] == \"\"\r\n这里为true，可能你在想[null]返回的不就是字符串 null 么，不过很遗憾，**null 和 undefined，在数组中转化为字符串为\"\"**，这是 JavaScript 所规定的。\r\n``` js\r\n[null] == \"\";\r\n// 转化为\r\n\"\" == \"\";\r\n```\r\n\r\n## 最后\r\n``` js\r\n// a可能为true执行下去么\r\nif (a == 2 && a == 3) {\r\n  // 执行里面的代码\r\n}\r\n```",
          "reactions": {
            "url": "https://api.github.com/repos/bosens-China/blog/issues/13/reactions",
            "total_count": 0,
            "+1": 0,
            "-1": 0,
            "laugh": 0,
            "hooray": 0,
            "confused": 0,
            "heart": 0,
            "rocket": 0,
            "eyes": 0
          },
          "timeline_url": "https://api.github.com/repos/bosens-China/blog/issues/13/timeline",
          "performed_via_github_app": null,
          "state_reason": null
        },
        {
          "url": "https://api.github.com/repos/bosens-China/blog/issues/3",
          "repository_url": "https://api.github.com/repos/bosens-China/blog",
          "labels_url": "https://api.github.com/repos/bosens-China/blog/issues/3/labels{/name}",
          "comments_url": "https://api.github.com/repos/bosens-China/blog/issues/3/comments",
          "events_url": "https://api.github.com/repos/bosens-China/blog/issues/3/events",
          "html_url": "https://github.com/bosens-China/blog/issues/3",
          "id": 475021768,
          "node_id": "MDU6SXNzdWU0NzUwMjE3Njg=",
          "number": 3,
          "title": "函数防抖",
          "user": {
            "login": "bosens-China",
            "id": 39508895,
            "node_id": "MDQ6VXNlcjM5NTA4ODk1",
            "avatar_url": "https://avatars.githubusercontent.com/u/39508895?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/bosens-China",
            "html_url": "https://github.com/bosens-China",
            "followers_url": "https://api.github.com/users/bosens-China/followers",
            "following_url": "https://api.github.com/users/bosens-China/following{/other_user}",
            "gists_url": "https://api.github.com/users/bosens-China/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/bosens-China/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/bosens-China/subscriptions",
            "organizations_url": "https://api.github.com/users/bosens-China/orgs",
            "repos_url": "https://api.github.com/users/bosens-China/repos",
            "events_url": "https://api.github.com/users/bosens-China/events{/privacy}",
            "received_events_url": "https://api.github.com/users/bosens-China/received_events",
            "type": "User",
            "site_admin": false
          },
          "labels": [
            {
              "id": 1602397157,
              "node_id": "MDU6TGFiZWwxNjAyMzk3MTU3",
              "url": "https://api.github.com/repos/bosens-China/blog/labels/%E6%B7%B1%E5%85%A5%E7%B3%BB%E5%88%97",
              "name": "深入系列",
              "color": "719192",
              "default": false,
              "description": "主要介绍实现的思路"
            }
          ],
          "state": "open",
          "locked": false,
          "assignee": null,
          "assignees": [],
          "milestone": null,
          "comments": 0,
          "created_at": "2019-07-31T09:01:16Z",
          "updated_at": "2021-12-21T09:39:39Z",
          "closed_at": null,
          "author_association": "OWNER",
          "active_lock_reason": null,
          "body": "## 前言\r\n\r\n1. 为什么需要使用防抖函数\r\n   当一个事件触发太多的时候会出现性能问题，比如`mousemove`、`resize`、`scroll`等，看一个没有任何防抖的`mousemove`事件\r\n\r\n![1](https://user-images.githubusercontent.com/39508895/62198507-526ef780-b3b4-11e9-8019-21e510329930.gif)\r\n\r\n2. 什么是防抖?\r\n   简单就是你任意触发我只执行最后一次操作\r\n\r\n根据上面的定义可以很轻松编写出一个简单的防抖函数\r\n\r\n### 实现\r\n\r\n```js\r\n// 第一版\r\nfunction antiShake(call, time) {\r\n  var i = null;\r\n  return function() {\r\n    clearTimeout(i);\r\n    i = setTimeout(call, time);\r\n  };\r\n}\r\n```\r\n\r\n![2](https://user-images.githubusercontent.com/39508895/62198572-77fc0100-b3b4-11e9-8ad5-a46ac6a5a2e1.gif)\r\n\r\n### this 以及参数\r\n\r\n不过这样有一个问题，就是 this 指向不正确以及参数丢失，这里以`mousemove`为例，触发函数的时候会有一个`MouseEvent`对象，如果打印函数参数会发现为`undefined`，下面就来修复一下\r\n\r\n```js\r\n//  第二版\r\nfunction antiShake(call, time) {\r\n  var i = null;\r\n  return function() {\r\n    var that = this;\r\n    var rest = arguments;\r\n    clearTimeout(i);\r\n    i = setTimeout(function() {\r\n      call.apply(that, rest);\r\n    }, time);\r\n  };\r\n}\r\n```\r\n\r\n### 立即执行\r\n\r\n有时候我不想让他等待时间结束在执行，而是一开始就触发\r\n![4](https://user-images.githubusercontent.com/39508895/62198651-99f58380-b3b4-11e9-9fbc-78e805b13910.gif)\r\n\r\n```js\r\n// 第三版\r\nfunction antiShake(call, time, immediately) {\r\n  var i = null;\r\n  return function() {\r\n    var that = this;\r\n    var rest = arguments;\r\n    clearTimeout(i);\r\n    if (immediately) {\r\n      var reversal = !i;\r\n      i = setTimeout(function() {\r\n        i = null;\r\n      }, time);\r\n\r\n      if (reversal) {\r\n        call.apply(that, rest);\r\n      }\r\n    } else {\r\n      i = setTimeout(function() {\r\n        call.apply(that, rest);\r\n      }, time);\r\n    }\r\n  };\r\n}\r\n```\r\n\r\n### 返回值\r\n\r\n异步执行的函数我们没办法同步返回他的值，但是对于立即执行的函数，我们应当把值返回\r\n\r\n```js\r\n// 第四版\r\nfunction antiShake(call, time, immediately) {\r\n  var i = null;\r\n  return function() {\r\n    var that = this;\r\n    var rest = arguments;\r\n    clearTimeout(i);\r\n    if (immediately) {\r\n      var reversal = !i;\r\n      i = setTimeout(function() {\r\n        i = null;\r\n      }, time);\r\n\r\n      if (reversal) {\r\n        return call.apply(that, rest);\r\n      }\r\n    } else {\r\n      i = setTimeout(function() {\r\n        call.apply(that, rest);\r\n      }, time);\r\n    }\r\n  };\r\n}\r\n```\r\n\r\n### 取消\r\n\r\n到这里基本上防抖函数就基本写完了，上述我们用`mousemove`事件举例，但是我想当鼠标移开的时候我想取消这个事件，这也是正常的需求，下面就来实现取消功能\r\n\r\n```js\r\nfunction antiShake(call, time, immediately) {\r\n  var i = null;\r\n  function _private() {\r\n    var that = this;\r\n    var rest = arguments;\r\n    clearTimeout(i);\r\n    if (immediately) {\r\n      var reversal = !i;\r\n      i = setTimeout(function() {\r\n        i = null;\r\n      }, time);\r\n\r\n      if (reversal) {\r\n        return call.apply(that, rest);\r\n      }\r\n    } else {\r\n      i = setTimeout(function() {\r\n        call.apply(that, rest);\r\n      }, time);\r\n    }\r\n  }\r\n  _private.cancel = function() {\r\n    clearTimeout(i);\r\n    i = null;\r\n  };\r\n  return _private;\r\n}\r\n```\r\n\r\n![5](https://user-images.githubusercontent.com/39508895/62198673-a5e14580-b3b4-11e9-9ced-acc7814031dc.gif)\r\n",
          "reactions": {
            "url": "https://api.github.com/repos/bosens-China/blog/issues/3/reactions",
            "total_count": 0,
            "+1": 0,
            "-1": 0,
            "laugh": 0,
            "hooray": 0,
            "confused": 0,
            "heart": 0,
            "rocket": 0,
            "eyes": 0
          },
          "timeline_url": "https://api.github.com/repos/bosens-China/blog/issues/3/timeline",
          "performed_via_github_app": null,
          "state_reason": null
        },
        {
          "url": "https://api.github.com/repos/bosens-China/blog/issues/5",
          "repository_url": "https://api.github.com/repos/bosens-China/blog",
          "labels_url": "https://api.github.com/repos/bosens-China/blog/issues/5/labels{/name}",
          "comments_url": "https://api.github.com/repos/bosens-China/blog/issues/5/comments",
          "events_url": "https://api.github.com/repos/bosens-China/blog/issues/5/events",
          "html_url": "https://github.com/bosens-China/blog/issues/5",
          "id": 479484473,
          "node_id": "MDU6SXNzdWU0Nzk0ODQ0NzM=",
          "number": 5,
          "title": "函数节流",
          "user": {
            "login": "bosens-China",
            "id": 39508895,
            "node_id": "MDQ6VXNlcjM5NTA4ODk1",
            "avatar_url": "https://avatars.githubusercontent.com/u/39508895?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/bosens-China",
            "html_url": "https://github.com/bosens-China",
            "followers_url": "https://api.github.com/users/bosens-China/followers",
            "following_url": "https://api.github.com/users/bosens-China/following{/other_user}",
            "gists_url": "https://api.github.com/users/bosens-China/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/bosens-China/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/bosens-China/subscriptions",
            "organizations_url": "https://api.github.com/users/bosens-China/orgs",
            "repos_url": "https://api.github.com/users/bosens-China/repos",
            "events_url": "https://api.github.com/users/bosens-China/events{/privacy}",
            "received_events_url": "https://api.github.com/users/bosens-China/received_events",
            "type": "User",
            "site_admin": false
          },
          "labels": [
            {
              "id": 1602397157,
              "node_id": "MDU6TGFiZWwxNjAyMzk3MTU3",
              "url": "https://api.github.com/repos/bosens-China/blog/labels/%E6%B7%B1%E5%85%A5%E7%B3%BB%E5%88%97",
              "name": "深入系列",
              "color": "719192",
              "default": false,
              "description": "主要介绍实现的思路"
            }
          ],
          "state": "open",
          "locked": false,
          "assignee": null,
          "assignees": [],
          "milestone": null,
          "comments": 0,
          "created_at": "2019-08-12T06:23:18Z",
          "updated_at": "2021-12-21T09:39:31Z",
          "closed_at": null,
          "author_association": "OWNER",
          "active_lock_reason": null,
          "body": "本来打算从零写一个，不过意外看到一篇好文，下面就根据他的思路来实现一个节流，[JavaScript专题之跟着 underscore 学节流 ](https://github.com/mqyqingfeng/Blog/issues/26)\r\n\r\n## 前言\r\n节流有两种实现，第一种使用定时器，另外一种则是根据时间戳，判断两次执行的时间间隔，下面简单些一下这两种的实现。\r\n- 定时器\r\n``` js\r\nfunction throttle(fn, time) {\r\n  let timing = null;\r\n  return function(...rest) {\r\n    if(!timing) {\r\n      timing = setTimeout(() => {\r\n        timing = null;\r\n        fn.apply(this, rest);\r\n      }, time);\r\n    }\r\n  };\r\n};\r\n```\r\n- 时间戳\r\n``` js\r\nfunction throttle (fn, time) {\r\n  let times = 0;\r\n  return function (...rest) {\r\n    const s = time - (new Date().getTime() - times)\r\n    if (s <= 0) {\r\n      times = new Date().getTime();\r\n      fn.apply(this, rest);\r\n    }\r\n  };\r\n};\r\n```\r\n下面就是将两者结合起来\r\n\r\n## 节流\r\n``` js\r\n// 节流\r\n// initial初始立即执行，front最后执行一次\r\nfunction throttle (fn, time, { initial = true, front = false } = {}) {\r\n  // 上一次执行时间\r\n  let times = 0;\r\n  // 定时器\r\n  let timing = null;\r\n  function next (...args) {\r\n    // 判断条件，如果不是初始执行，改用定时器方法执行\r\n    if (!initial && !times) {\r\n      times = new Date().getTime();\r\n    }\r\n    const now = time - (new Date().getTime() - times);\r\n    // now > time是判断更改系统时间的边界问题，now正常情况下，肯定小于time\r\n    if (now <= 0 || now > time) {\r\n      if (!timing) {\r\n        clearTimeout(timing);\r\n        timing = null;\r\n      }\r\n      times = new Date().getTime();\r\n      fn.apply(this, args);\r\n      // 清理一下内存\r\n      if (!timing) {\r\n        args = null;\r\n      }\r\n    } else if (!timing && front) {\r\n      timing = setTimeout(() => {\r\n        timing = null;\r\n        times = initial ? 0 : new Date().getTime();\r\n        fn.apply(this, args);\r\n        if (!timing) {\r\n          args = null;\r\n        }\r\n      }, time);\r\n    }\r\n  }\r\n  // 取消\r\n  next.cancel = function () {\r\n    clearTimeout(timing);\r\n    timing = null;\r\n    // 为0即可，上面有初始判断条件\r\n    times = 0;\r\n  };\r\n  return next;\r\n};\r\n```\r\n## 注意\r\n上面有两个参数，但是不能同时设置为false",
          "reactions": {
            "url": "https://api.github.com/repos/bosens-China/blog/issues/5/reactions",
            "total_count": 0,
            "+1": 0,
            "-1": 0,
            "laugh": 0,
            "hooray": 0,
            "confused": 0,
            "heart": 0,
            "rocket": 0,
            "eyes": 0
          },
          "timeline_url": "https://api.github.com/repos/bosens-China/blog/issues/5/timeline",
          "performed_via_github_app": null,
          "state_reason": null
        },
        {
          "url": "https://api.github.com/repos/bosens-China/blog/issues/14",
          "repository_url": "https://api.github.com/repos/bosens-China/blog",
          "labels_url": "https://api.github.com/repos/bosens-China/blog/issues/14/labels{/name}",
          "comments_url": "https://api.github.com/repos/bosens-China/blog/issues/14/comments",
          "events_url": "https://api.github.com/repos/bosens-China/blog/issues/14/events",
          "html_url": "https://github.com/bosens-China/blog/issues/14",
          "id": 479671441,
          "node_id": "MDU6SXNzdWU0Nzk2NzE0NDE=",
          "number": 14,
          "title": "理解原型和原型链",
          "user": {
            "login": "bosens-China",
            "id": 39508895,
            "node_id": "MDQ6VXNlcjM5NTA4ODk1",
            "avatar_url": "https://avatars.githubusercontent.com/u/39508895?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/bosens-China",
            "html_url": "https://github.com/bosens-China",
            "followers_url": "https://api.github.com/users/bosens-China/followers",
            "following_url": "https://api.github.com/users/bosens-China/following{/other_user}",
            "gists_url": "https://api.github.com/users/bosens-China/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/bosens-China/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/bosens-China/subscriptions",
            "organizations_url": "https://api.github.com/users/bosens-China/orgs",
            "repos_url": "https://api.github.com/users/bosens-China/repos",
            "events_url": "https://api.github.com/users/bosens-China/events{/privacy}",
            "received_events_url": "https://api.github.com/users/bosens-China/received_events",
            "type": "User",
            "site_admin": false
          },
          "labels": [
            {
              "id": 1602397157,
              "node_id": "MDU6TGFiZWwxNjAyMzk3MTU3",
              "url": "https://api.github.com/repos/bosens-China/blog/labels/%E6%B7%B1%E5%85%A5%E7%B3%BB%E5%88%97",
              "name": "深入系列",
              "color": "719192",
              "default": false,
              "description": "主要介绍实现的思路"
            }
          ],
          "state": "open",
          "locked": false,
          "assignee": null,
          "assignees": [],
          "milestone": null,
          "comments": 0,
          "created_at": "2019-08-12T14:17:35Z",
          "updated_at": "2021-12-21T03:38:33Z",
          "closed_at": null,
          "author_association": "OWNER",
          "active_lock_reason": null,
          "body": "> 参考： [深入理解javascript原型和闭包（完结）](https://www.cnblogs.com/wangfupeng1988/p/3977924.html)\r\n\r\nJavaScript是弱类型，除了基本类型都可以理解为对象，这也是为什么说JavaScript中一切皆对象的原因。\r\n\r\n不过在对象中函数比较特殊，对象就是由函数创造出来的，这听起来是不是有点先有鸡后有蛋，先有蛋后有鸡的感觉，这也跟后面要说到的原型有关。\r\n\r\n先说`prototype`属性，这个属性是`函数`所独有的，函数也是对象也可以在自身定义属性和方法，那这个`prototype`属性有什么用呢？\r\n``` js\r\nvar a = {};\r\na.toString();\r\n```\r\n这里我并没有为a定义toString的方法，为什么可以调用呢？就跟prototype属性有关。\r\n\r\n上面只是简写，如果通过构造函数是这样的\r\n``` js\r\nvar a = new Object();\r\na.toString();\r\n```\r\n![https://pic1.zhimg.com/80/v2-038c5818398efc6b4e990b3c2fb3b54c_hd.jpg](https://pic1.zhimg.com/80/v2-038c5818398efc6b4e990b3c2fb3b54c_hd.jpg)\r\n这里可以看到toString的方法，这也是为什么没有定义却没有报错的原因。\r\n\r\n一个对象通过构造函数生成会执行下面四个步骤\r\n1. 创建一个新对象，作为要返回的实例\r\n2. 将新对象的原型（__proto__）指向构造函数的`prototype`属性\r\n3. 将内部的this指向新对象\r\n4. 执行内部代码，如果没有执行返回对象，则返回`this`（新对象）\r\n\r\n从上面可以看到，对象的原型会指向生成对象函数的`prototype`属性，对象本身如果没有属性或者方法，会向原型链查找，如果没有找到会一直找到`Object.prototype`属性上，如果还没有找到就会返回`undefined`。\r\n`Object.prototype`属性上还有原型链么？答案是有，是`Null`。\r\n\r\n上面简短的说了一下，下面通过例子的形式来结合\r\n\r\n## 示例\r\n``` js\r\nvar a = {};\r\n```\r\n这里我定义了一个对象a，根据上面说的每个对象都有一个原型，执行构造函数的`prototype`下面就是原型图。\r\n![https://pic4.zhimg.com/80/v2-c93843e5905a3990c0b1147d0dad7f03_hd.jpg](https://pic4.zhimg.com/80/v2-c93843e5905a3990c0b1147d0dad7f03_hd.jpg)\r\n上面就是一个简单的原型图，下面说一下`constructor`属性，这个属性有什么作用呢？\r\n`constructor`是`prototype`对象下的一个属性，他指向一个函数，与函数的相互依存，还是通过上面变量a来说明吧。\r\n![https://pic1.zhimg.com/80/v2-94e4180728a52844d1204a830249c10c_hd.jpg](https://pic1.zhimg.com/80/v2-94e4180728a52844d1204a830249c10c_hd.jpg)\r\n\r\n可以看到，通过`constructor`可以访问到构造函数，这个属性通常没有什么用，不过可以通用这个属性调用一些构造函数所独有的方法，比如`Date`函数的`now`方法\r\n``` js\r\nvar a = new Date();\r\na.__proto__.constructor.now();\r\n```\r\n这里为了方便演示使用了`_proto_`，不过在实际中不要这样写，因为这个属性只有浏览器才部署。\r\n![https://pic3.zhimg.com/80/v2-3ee04ff512a68800c014b66de0f6b3f2_hd.jpg](https://pic3.zhimg.com/80/v2-3ee04ff512a68800c014b66de0f6b3f2_hd.jpg)\r\n说了这么多，最后根据一张图，来总结一下。\r\n\r\n首先对象是由构造函数创建的（Object），你可能有疑问，函数也是对象，那么函数的`__proto__`指向什么？\r\n答案是`Function.prototype`，所有函数都是由`Fcuntion`创建的，举个例子\r\n``` js\r\nvar a = new Function('a', 'b', 'return a + b');\r\na(1, 2);\r\n```\r\n这里a的`__proto__`等于`Function.prototype`，之前说过prototype是一个对象，所以`Function.prototype`指向`Object.prototype`。\r\n最后说一点，`Function.__proto__`指向的是`Function`自身，他是唯一一个通过自身生成函数的例子，这里只需要了解一下。\r\n\r\n## 最后\r\n说了这么多，原型链好像还没有被提起，每个对象都有自己的原型，原型的对象也是对象，一方面对象可以作为另一个对象的原型，这样层层链接起来的原型就成为原型链。\r\n",
          "reactions": {
            "url": "https://api.github.com/repos/bosens-China/blog/issues/14/reactions",
            "total_count": 0,
            "+1": 0,
            "-1": 0,
            "laugh": 0,
            "hooray": 0,
            "confused": 0,
            "heart": 0,
            "rocket": 0,
            "eyes": 0
          },
          "timeline_url": "https://api.github.com/repos/bosens-China/blog/issues/14/timeline",
          "performed_via_github_app": null,
          "state_reason": null
        },
        {
          "url": "https://api.github.com/repos/bosens-China/blog/issues/30",
          "repository_url": "https://api.github.com/repos/bosens-China/blog",
          "labels_url": "https://api.github.com/repos/bosens-China/blog/issues/30/labels{/name}",
          "comments_url": "https://api.github.com/repos/bosens-China/blog/issues/30/comments",
          "events_url": "https://api.github.com/repos/bosens-China/blog/issues/30/events",
          "html_url": "https://github.com/bosens-China/blog/issues/30",
          "id": 503803775,
          "node_id": "MDU6SXNzdWU1MDM4MDM3NzU=",
          "number": 30,
          "title": "模拟实现call和apply",
          "user": {
            "login": "bosens-China",
            "id": 39508895,
            "node_id": "MDQ6VXNlcjM5NTA4ODk1",
            "avatar_url": "https://avatars.githubusercontent.com/u/39508895?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/bosens-China",
            "html_url": "https://github.com/bosens-China",
            "followers_url": "https://api.github.com/users/bosens-China/followers",
            "following_url": "https://api.github.com/users/bosens-China/following{/other_user}",
            "gists_url": "https://api.github.com/users/bosens-China/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/bosens-China/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/bosens-China/subscriptions",
            "organizations_url": "https://api.github.com/users/bosens-China/orgs",
            "repos_url": "https://api.github.com/users/bosens-China/repos",
            "events_url": "https://api.github.com/users/bosens-China/events{/privacy}",
            "received_events_url": "https://api.github.com/users/bosens-China/received_events",
            "type": "User",
            "site_admin": false
          },
          "labels": [
            {
              "id": 1602397157,
              "node_id": "MDU6TGFiZWwxNjAyMzk3MTU3",
              "url": "https://api.github.com/repos/bosens-China/blog/labels/%E6%B7%B1%E5%85%A5%E7%B3%BB%E5%88%97",
              "name": "深入系列",
              "color": "719192",
              "default": false,
              "description": "主要介绍实现的思路"
            }
          ],
          "state": "open",
          "locked": false,
          "assignee": null,
          "assignees": [],
          "milestone": null,
          "comments": 0,
          "created_at": "2019-10-08T03:31:31Z",
          "updated_at": "2021-12-21T03:07:06Z",
          "closed_at": null,
          "author_association": "OWNER",
          "active_lock_reason": null,
          "body": "> call() 方法使用一个指定的 this 值和单独给出的一个或多个参数来调用一个函数\r\n\r\n上面是 call 的定义，apply 与 call 类似只是第二个参数是一个数组而 call 接收的则是一个参数列表。\r\n\r\n看一个例子\r\n\r\n```js\r\nvar obj = {\r\n  name: \"obj\"\r\n};\r\nfunction foo() {\r\n  return this.name;\r\n}\r\nfoo.call(obj); //obj\r\n```\r\n\r\n上面通过 call 改变了 this 的指向，下面就是模拟实现\r\n\r\n## 实现\r\n\r\ncall 和 apply 是 es5 的方法，既然是模拟实现那肯定不能用 es5 方法了，我们先分析一下怎么来指定 this，this 跟动态作用域类似是在执行时确定，那我们在指定 this 的属性上添加一个方法并且执行，那么这个方法的 this 就是指定 this\r\n\r\n```js\r\nvar obj = {\r\n  name: \"obj\",\r\n  foo: function foo() {\r\n    return this.name;\r\n  }\r\n};\r\n\r\nobj.foo();\r\n```\r\n\r\n上面解决了 this，下面来看下怎么实现参数的传递，call 方法可以传递任意参数列表，我们可以通过`arguments`来获取，它是一个类数组。\r\n\r\n```js\r\nfunction getName() {\r\n  console.log(arguments); //Arguments(5) [1, 2, 3, 4, 5]\r\n}\r\nfunction foo() {\r\n  var args = [];\r\n  for (var i = 0; i < arguments.length; i++) {\r\n    args.push(\"arguments[\" + i + \"]\");\r\n  }\r\n  eval(\"getName(\" + args + \")\");\r\n}\r\nfoo(1, 2, 3, 4, 5);\r\n```\r\n\r\nOK，这两块已经搞定了，下面就是实现\r\n\r\n### call\r\n\r\n```js\r\nFunction.prototype.calls = function(con) {\r\n  con.fn = this;\r\n  // 获取参数\r\n  var args = [];\r\n  for (var i = 1; i < arguments.length; i++) {\r\n    args.push(\"arguments[\" + i + \"]\");\r\n  }\r\n  var result = eval(\"con.fn(\" + args + \")\");\r\n  delete con.fn;\r\n  return result;\r\n};\r\n```\r\n\r\n上面删除属性是为了避免污染，这里的`fn`可以是任意属性名只要保证不重复就行了，不过仔细观察上面函数还是有问题\r\n\r\n1. call 的 this 可以是 `null` 或者 `undefined`；\r\n2. 可以是字符串数字之类的，会转化为包装对象；\r\n\r\n```js\r\nFunction.prototype.calls = function(con) {\r\n  if (con == null) {\r\n    con = typeof window === \"object\" ? window : global;\r\n  }\r\n  con = Object(con);\r\n  con.fn = this;\r\n  // 获取参数\r\n  var args = [];\r\n  for (var i = 1; i < arguments.length; i++) {\r\n    args.push(\"arguments[\" + i + \"]\");\r\n  }\r\n  var result = eval(\"con.fn(\" + args + \")\");\r\n  delete con.fn;\r\n  return result;\r\n};\r\n```\r\n\r\n测试一下\r\n\r\n```js\r\nfunction foo() {\r\n  return this.length;\r\n}\r\nconsole.log(foo.calls(\"obj\")); // 3\r\n```\r\n\r\n撒花，这样就实现了 call\r\n\r\n### apply\r\n\r\n与 call 十分类似，这里就直接贴代码了\r\n\r\n```js\r\nFunction.prototype.applys = function(con, arr) {\r\n  if (con == null) {\r\n    con = typeof window === \"object\" ? window : global;\r\n  }\r\n  con = Object(con);\r\n  con.fn = this;\r\n  var result;\r\n  if (typeof arr === \"object\" && arr.length) {\r\n    var args = [];\r\n    for (var i = 0; i < arr.length; i++) {\r\n      args.push(\"arr[\" + i + \"]\");\r\n    }\r\n    result = eval(\"con.fn(\" + args + \")\");\r\n  } else {\r\n    result = eval(\"con.fn()\");\r\n  }\r\n  delete con.fn;\r\n  return result;\r\n};\r\n```\r\n\r\n## 参考\r\n\r\n1. https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/call\r\n2. https://github.com/mqyqingfeng/Blog/issues/11\r\n",
          "reactions": {
            "url": "https://api.github.com/repos/bosens-China/blog/issues/30/reactions",
            "total_count": 0,
            "+1": 0,
            "-1": 0,
            "laugh": 0,
            "hooray": 0,
            "confused": 0,
            "heart": 0,
            "rocket": 0,
            "eyes": 0
          },
          "timeline_url": "https://api.github.com/repos/bosens-China/blog/issues/30/timeline",
          "performed_via_github_app": null,
          "state_reason": null
        },
        {
          "url": "https://api.github.com/repos/bosens-China/blog/issues/31",
          "repository_url": "https://api.github.com/repos/bosens-China/blog",
          "labels_url": "https://api.github.com/repos/bosens-China/blog/issues/31/labels{/name}",
          "comments_url": "https://api.github.com/repos/bosens-China/blog/issues/31/comments",
          "events_url": "https://api.github.com/repos/bosens-China/blog/issues/31/events",
          "html_url": "https://github.com/bosens-China/blog/issues/31",
          "id": 503856924,
          "node_id": "MDU6SXNzdWU1MDM4NTY5MjQ=",
          "number": 31,
          "title": "模拟实现bind",
          "user": {
            "login": "bosens-China",
            "id": 39508895,
            "node_id": "MDQ6VXNlcjM5NTA4ODk1",
            "avatar_url": "https://avatars.githubusercontent.com/u/39508895?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/bosens-China",
            "html_url": "https://github.com/bosens-China",
            "followers_url": "https://api.github.com/users/bosens-China/followers",
            "following_url": "https://api.github.com/users/bosens-China/following{/other_user}",
            "gists_url": "https://api.github.com/users/bosens-China/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/bosens-China/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/bosens-China/subscriptions",
            "organizations_url": "https://api.github.com/users/bosens-China/orgs",
            "repos_url": "https://api.github.com/users/bosens-China/repos",
            "events_url": "https://api.github.com/users/bosens-China/events{/privacy}",
            "received_events_url": "https://api.github.com/users/bosens-China/received_events",
            "type": "User",
            "site_admin": false
          },
          "labels": [
            {
              "id": 1602397157,
              "node_id": "MDU6TGFiZWwxNjAyMzk3MTU3",
              "url": "https://api.github.com/repos/bosens-China/blog/labels/%E6%B7%B1%E5%85%A5%E7%B3%BB%E5%88%97",
              "name": "深入系列",
              "color": "719192",
              "default": false,
              "description": "主要介绍实现的思路"
            }
          ],
          "state": "open",
          "locked": false,
          "assignee": null,
          "assignees": [],
          "milestone": null,
          "comments": 0,
          "created_at": "2019-10-08T06:35:47Z",
          "updated_at": "2021-12-21T03:06:57Z",
          "closed_at": null,
          "author_association": "OWNER",
          "active_lock_reason": null,
          "body": "之前说了[模拟实现 call 和 apply](https://github.com/bosens-China/blog/issues/30)，下面就来实现 bind，首先先看一下定义 bind 定义\r\n\r\n> bind()方法创建一个新的函数，在 bind()被调用时，这个新函数的 this 被 bind 的第一个参数指定，其余的参数将作为新函数的参数供调用时使用。\r\n\r\n## 第一版\r\n\r\n根据定义我们尝试写一下\r\n\r\n```js\r\nFunction.prototype.binds = function(con) {\r\n  var fn = this;\r\n  var args = Array.prototype.slice.call(arguments, 1);\r\n  return function() {\r\n    return fn.apply(con, args);\r\n  };\r\n};\r\n```\r\n\r\n我们来测试一下上面的函数\r\n\r\n```js\r\nvar obj = {\r\n  value: \"zhangsan\"\r\n};\r\nfunction foo(name, age) {\r\n  console.log(this.value); //zhangsan\r\n  console.log(name); // name\r\n  console.log(age); // undefined\r\n}\r\nvar f = foo.binds(obj, \"name\");\r\nf(19);\r\n```\r\n\r\n`age` 输出的跟我们预期的不太一致，这是因为我们没有处理返回函数的参数，用 concat 把参数合并在一起就可以了。\r\n\r\n```js\r\nFunction.prototype.binds = function(con) {\r\n  var fn = this;\r\n  var args = Array.prototype.slice.call(arguments, 1);\r\n  return function() {\r\n    return fn.apply(con, args.concat(Array.prototype.slice.call(arguments)));\r\n  };\r\n};\r\n```\r\n\r\n## 第二版\r\n\r\n上面简单实现了函数的 bind，不过我们来看一下 bind 与构造函数相遇会怎么样\r\n\r\n```js\r\nvar obj = {\r\n  value: \"zhangsan\"\r\n};\r\nfunction Foo(name, age) {\r\n  console.log(this.value); //undefined\r\n  console.log(name);\r\n  console.log(age);\r\n}\r\nvar f = Foo.bind(obj, \"name\");\r\nnew f(19);\r\n```\r\n\r\n上面 `this.value` 的输出为 `undefined`，这是因为 **调用绑定函数时作为 this 参数传递给目标函数的值。 如果使用 new 运算符构造绑定函数，则忽略该值**。\r\n\r\n另外作为构造函数是可以获取到绑定 bind 函数的 `prototype` 的\r\n\r\n```js\r\nfunction Foo() {\r\n  console.log(this.gender); //male\r\n}\r\nFoo.prototype.gender = \"male\";\r\nvar f = Foo.bind(null, \"name\");\r\nnew f();\r\n```\r\n\r\n下面就是来实现上面两点：\r\n\r\n- 怎么来判断是否通过 new 来调用呢？可以通过`instanceof`\r\n\r\n```js\r\nfunction Foo() {\r\n  if (!(this instanceof Foo)) {\r\n    throw Error(\"请通过new调用\");\r\n  }\r\n}\r\nFoo();\r\n```\r\n\r\n- 继承的话我们可以通过寄生组合式继承，这类文章比较多，这里就简单举一个例子\r\n\r\n```js\r\nfunction create(con) {\r\n  var f = function() {};\r\n  f.prototype = con;\r\n  return new f();\r\n}\r\nfunction Par(name) {\r\n  this.name = name;\r\n}\r\nPar.prototype.getName = function() {\r\n  return this.name;\r\n};\r\nfunction Chi(name, age) {\r\n  Par.call(this, name);\r\n  this.age = age;\r\n}\r\nChi.prototype = create(Par.prototype);\r\nChi.prototype.constructor = Chi;\r\nChi.prototype.getDetails = function() {\r\n  var n = this.getName();\r\n  console.log(n, this.age);\r\n};\r\nvar d = new Chi(\"zhangsan\", 16);\r\nd.getDetails();\r\n```\r\n\r\nOK，上面两点解决后我们再来实现一版\r\n\r\n```js\r\nFunction.prototype.binds = function(con) {\r\n  var fn = this;\r\n  var args = Array.prototype.slice.call(arguments, 1);\r\n  var f = function() {};\r\n  if (this.prototype) {\r\n    f.prototype = this.prototype;\r\n  }\r\n  var result = function() {\r\n    return fn.apply(\r\n      this instanceof result ? this : con,\r\n      args.concat(Array.prototype.slice.call(arguments))\r\n    );\r\n  };\r\n  result.prototype = new f();\r\n  return result;\r\n};\r\n```\r\n\r\n## 优化\r\n\r\n观察上面的不难发现 bind 调用的必须是函数，而通过继承我们可能会调用到 bind 所以这里显示报错一下\r\n\r\n```js\r\nvar obj = Object.create(Function.prototype);\r\nconsole.log(obj.bind);\r\n```\r\n\r\n另外对于我们上面定义的`binds`肯定不太优雅，污染了命名空间，这里可以判断一下如果存在 `bind` 就用 `bind` 否则在定义\r\n\r\n## 最终\r\n\r\n```js\r\nif (!Function.prototype.bind) {\r\n  Function.prototype.bind = function(con) {\r\n    if (typeof this !== \"function\") {\r\n      throw new TypeError(\r\n        \"Function.prototype.bind - what is trying to be bound is not callable\"\r\n      );\r\n    }\r\n    var fn = this;\r\n    var args = Array.prototype.slice.call(arguments, 1);\r\n    var f = function() {};\r\n    if (this.prototype) {\r\n      f.prototype = this.prototype;\r\n    }\r\n    var result = function() {\r\n      return fn.apply(\r\n        this instanceof result ? this : con,\r\n        args.concat(Array.prototype.slice.call(arguments))\r\n      );\r\n    };\r\n    result.prototype = new f();\r\n    return result;\r\n  };\r\n}\r\n```\r\n",
          "reactions": {
            "url": "https://api.github.com/repos/bosens-China/blog/issues/31/reactions",
            "total_count": 0,
            "+1": 0,
            "-1": 0,
            "laugh": 0,
            "hooray": 0,
            "confused": 0,
            "heart": 0,
            "rocket": 0,
            "eyes": 0
          },
          "timeline_url": "https://api.github.com/repos/bosens-China/blog/issues/31/timeline",
          "performed_via_github_app": null,
          "state_reason": null
        },
        {
          "url": "https://api.github.com/repos/bosens-China/blog/issues/11",
          "repository_url": "https://api.github.com/repos/bosens-China/blog",
          "labels_url": "https://api.github.com/repos/bosens-China/blog/issues/11/labels{/name}",
          "comments_url": "https://api.github.com/repos/bosens-China/blog/issues/11/comments",
          "events_url": "https://api.github.com/repos/bosens-China/blog/issues/11/events",
          "html_url": "https://github.com/bosens-China/blog/issues/11",
          "id": 479656673,
          "node_id": "MDU6SXNzdWU0Nzk2NTY2NzM=",
          "number": 11,
          "title": "变量提升",
          "user": {
            "login": "bosens-China",
            "id": 39508895,
            "node_id": "MDQ6VXNlcjM5NTA4ODk1",
            "avatar_url": "https://avatars.githubusercontent.com/u/39508895?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/bosens-China",
            "html_url": "https://github.com/bosens-China",
            "followers_url": "https://api.github.com/users/bosens-China/followers",
            "following_url": "https://api.github.com/users/bosens-China/following{/other_user}",
            "gists_url": "https://api.github.com/users/bosens-China/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/bosens-China/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/bosens-China/subscriptions",
            "organizations_url": "https://api.github.com/users/bosens-China/orgs",
            "repos_url": "https://api.github.com/users/bosens-China/repos",
            "events_url": "https://api.github.com/users/bosens-China/events{/privacy}",
            "received_events_url": "https://api.github.com/users/bosens-China/received_events",
            "type": "User",
            "site_admin": false
          },
          "labels": [
            {
              "id": 1602397157,
              "node_id": "MDU6TGFiZWwxNjAyMzk3MTU3",
              "url": "https://api.github.com/repos/bosens-China/blog/labels/%E6%B7%B1%E5%85%A5%E7%B3%BB%E5%88%97",
              "name": "深入系列",
              "color": "719192",
              "default": false,
              "description": "主要介绍实现的思路"
            }
          ],
          "state": "open",
          "locked": false,
          "assignee": null,
          "assignees": [],
          "milestone": null,
          "comments": 0,
          "created_at": "2019-08-12T13:49:40Z",
          "updated_at": "2021-12-21T03:06:32Z",
          "closed_at": null,
          "author_association": "OWNER",
          "active_lock_reason": null,
          "body": "> 这里只是用伪代码的形式来说明，实际上变量声明只是执行上下文有关，推荐阅读[\r\nJavaScript深入之变量对象](https://github.com/mqyqingfeng/Blog/issues/5)\r\n\r\n## 太长不看篇\r\n函数参数 > 函数声明 > 变量声明\r\n\r\n## 变量声明\r\n首先想用一个伪生命周期来说这个事情，假设这段代码分为两个阶段，初始化阶段和赋值阶段； 看下面一段代码，用伪系统的话来阐述\r\n``` js\r\nconsole.log(a);\r\nvar a = 10;\r\n```\r\n如果按照上面的声明周期来说，首先变量 a 会在作用域注册一个变量(如果没有)默认赋值为 `undefined`\r\n\r\n初始化完成后，开始执行代码，第一行语句的时候因为变量 a 未经过赋值阶段，这一阶段的值是 `ndefined`，所以打印的结果自然也就是 `undefined`;\r\n\r\n在第二行的时候变量 a 会经过赋值阶段，这时变量 a 的值就是 10 了。\r\n\r\n## 函数声明\r\n函数声明与变量声明规则基本一致，优先级比变量声明要高\r\n\r\n是不是只说这一句话大家有些失望，如果只是单独来说函数声明未免太没意思，下面就结合变量声明来说说函数声明，毕竟代码只有变量声明就做不到有趣了。\r\n``` js\r\na();\r\nvar a = 10;\r\nfunction a() {\r\n  console.log(5);\r\n}\r\n```\r\n上面的执行结果是打印数字 5，为什么会出现这种情况呢？上面我们已经说了函数声明优先于变量声明，那么上面代码实际可以拆封成下面形式\r\n``` js\r\nfunction a() {\r\n  // ...\r\n}\r\na();\r\na = 10;\r\n```\r\n你可能还有疑惑，事实上如果变量提升的时候发现已经存在变量就会默默忽略掉，比如上面的代码变量 a 已经是一个函数了，那么变量声明的 a 会被忽略。\r\n\r\n最后说下函数参数，参数也是变量的一种形式，它的优先级最高，但是同样会受到函数声明的影响\r\n``` js\r\nfunction a(x) {\r\n  console.log(x);\r\n  function x() {}\r\n}\r\na(5);\r\n```\r\n这里输出结果是函数 x，原因是函数声明提升的时候会执行一个覆盖操作，就像我们写代码`x = 5`这样\r\n\r\n## 最后\r\n这里说的有很多地方不足，只是自己的见解，更推荐一篇文章[10 分钟理解执行上下文](https://zhuanlan.zhihu.com/p/25879753)\r\n\r\n最后根据上面的内容讲解一下他布置的一到题目\r\n``` js\r\nconsole.log(x);\r\nvar x = 10;\r\n\r\nconsole.log(x);\r\nx = 20;\r\n\r\nfunction x() {}\r\nconsole.log(x);\r\n\r\nif (true) {\r\n  var a = 1;\r\n} else {\r\n  var b = true;\r\n}\r\n\r\nconsole.log(a);\r\nconsole.log(b);\r\n```\r\n首先初始化阶段，`function x` 最先被提升，后面的变量提升因为已经存在函数 x 的原因会被忽略 第一个 console 输出的是函数` x`，\r\n\r\n之后执行到第二行代码的时候 `x` 被改变变成` 10`，第二个 `console` 输出为 `10`，之后继续被赋值为 `20`，第三个` console` 输出为 `20`，\r\n\r\n第四个和第五个 `console` 的输出分别为 `1` 和` undefined`，这是因为 es5 的环境下并不存在块级作用域，变量 `a` 和 `b` 会执行变量提升这一步骤， \r\n不同的是 `a` 被赋值为了 `1`，而 `b` 因为没有执行到 `var b = true` 所以值还是 `undefined`。",
          "reactions": {
            "url": "https://api.github.com/repos/bosens-China/blog/issues/11/reactions",
            "total_count": 0,
            "+1": 0,
            "-1": 0,
            "laugh": 0,
            "hooray": 0,
            "confused": 0,
            "heart": 0,
            "rocket": 0,
            "eyes": 0
          },
          "timeline_url": "https://api.github.com/repos/bosens-China/blog/issues/11/timeline",
          "performed_via_github_app": null,
          "state_reason": null
        },
        {
          "url": "https://api.github.com/repos/bosens-China/blog/issues/32",
          "repository_url": "https://api.github.com/repos/bosens-China/blog",
          "labels_url": "https://api.github.com/repos/bosens-China/blog/issues/32/labels{/name}",
          "comments_url": "https://api.github.com/repos/bosens-China/blog/issues/32/comments",
          "events_url": "https://api.github.com/repos/bosens-China/blog/issues/32/events",
          "html_url": "https://github.com/bosens-China/blog/issues/32",
          "id": 503866389,
          "node_id": "MDU6SXNzdWU1MDM4NjYzODk=",
          "number": 32,
          "title": "模拟实现new",
          "user": {
            "login": "bosens-China",
            "id": 39508895,
            "node_id": "MDQ6VXNlcjM5NTA4ODk1",
            "avatar_url": "https://avatars.githubusercontent.com/u/39508895?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/bosens-China",
            "html_url": "https://github.com/bosens-China",
            "followers_url": "https://api.github.com/users/bosens-China/followers",
            "following_url": "https://api.github.com/users/bosens-China/following{/other_user}",
            "gists_url": "https://api.github.com/users/bosens-China/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/bosens-China/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/bosens-China/subscriptions",
            "organizations_url": "https://api.github.com/users/bosens-China/orgs",
            "repos_url": "https://api.github.com/users/bosens-China/repos",
            "events_url": "https://api.github.com/users/bosens-China/events{/privacy}",
            "received_events_url": "https://api.github.com/users/bosens-China/received_events",
            "type": "User",
            "site_admin": false
          },
          "labels": [
            {
              "id": 1602397157,
              "node_id": "MDU6TGFiZWwxNjAyMzk3MTU3",
              "url": "https://api.github.com/repos/bosens-China/blog/labels/%E6%B7%B1%E5%85%A5%E7%B3%BB%E5%88%97",
              "name": "深入系列",
              "color": "719192",
              "default": false,
              "description": "主要介绍实现的思路"
            }
          ],
          "state": "open",
          "locked": false,
          "assignee": null,
          "assignees": [],
          "milestone": null,
          "comments": 0,
          "created_at": "2019-10-08T07:03:22Z",
          "updated_at": "2021-12-21T03:04:48Z",
          "closed_at": null,
          "author_association": "OWNER",
          "active_lock_reason": null,
          "body": "> new 运算符创建一个用户定义的对象类型的实例或具有构造函数的内置对象的实例。\r\n\r\n上面的定义有点抽象，我们来通过一个例子看 new 运算符扮演的角色\r\n\r\n```js\r\nfunction Foo(name, age) {\r\n  this.name = name;\r\n  this.age = age;\r\n}\r\nFoo.prototype.getName = function() {\r\n  return this.name;\r\n};\r\nFoo.prototype.foo = \"foo\";\r\nvar f = new Foo(\"zhangsan\", 18);\r\nf.getName(); // zhangsan\r\nf.foo; // foo\r\n```\r\n\r\n上面通过 new 创建了一个新的对象，并且这个对象通过原型链访问到了原型上的方法和属性，所以 new 运算符就是执行构造函数返回一个实例对象。\r\n\r\nnew 运算符在执行时执行了下面四步：\r\n\r\n1. 创建一个空的简单 JavaScript 对象（即{}）；\r\n2. 链接该对象（即设置该对象的构造函数）到另一个对象 ；\r\n3. 将步骤 1 新创建的对象作为 this 的上下文 ；\r\n4. 如果该函数没有返回对象，则返回 this。\r\n\r\n## 实现\r\n\r\n根据上面的执行步骤我们来尝试实现下，当然 new 操作符肯定是模拟不了了，下面通过函数的形式展示\r\n\r\n```js\r\nfunction newCall(fn) {\r\n  var args = Array.prototype.slice.call(arguments, 1);\r\n  var obj = {};\r\n  obj.__proto__ = fn.prototype;\r\n  var result = fn.apply(obj, args);\r\n  return result && typeof result === \"object\" ? result : obj;\r\n}\r\n```\r\n\r\nOk，到这里就实现了一个模拟 new 的操作，我们测试一下\r\n\r\n```js\r\nfunction Otaku(name, age) {\r\n  this.name = name;\r\n  this.age = age;\r\n\r\n  this.habit = \"Games\";\r\n}\r\n\r\nOtaku.prototype.strength = 60;\r\n\r\nOtaku.prototype.sayYourName = function() {\r\n  console.log(\"I am \" + this.name);\r\n};\r\n\r\nfunction newCall(fn) {\r\n  var args = Array.prototype.slice.call(arguments, 1);\r\n  var obj = {};\r\n  obj.__proto__ = fn.prototype;\r\n  var result = fn.apply(obj, args);\r\n  return result && typeof result === \"object\" ? result : obj;\r\n}\r\n\r\nvar person = newCall(Otaku, \"Kevin\", \"18\");\r\n\r\nconsole.log(person.name); // Kevin\r\nconsole.log(person.habit); // Games\r\nconsole.log(person.strength); // 60\r\n```\r\n\r\n撒花 ✿✿ ヽ(°▽°)ノ ✿，不过额外提醒一下`__proto__`是浏览器实现的非标准属性，一般情况下不推荐使用，不过既然是模拟 es5 推荐的`Object.setPrototypeOf`肯定没办法用了，只能将就着用了\r\n",
          "reactions": {
            "url": "https://api.github.com/repos/bosens-China/blog/issues/32/reactions",
            "total_count": 0,
            "+1": 0,
            "-1": 0,
            "laugh": 0,
            "hooray": 0,
            "confused": 0,
            "heart": 0,
            "rocket": 0,
            "eyes": 0
          },
          "timeline_url": "https://api.github.com/repos/bosens-China/blog/issues/32/timeline",
          "performed_via_github_app": null,
          "state_reason": null
        },
        {
          "url": "https://api.github.com/repos/bosens-China/blog/issues/59",
          "repository_url": "https://api.github.com/repos/bosens-China/blog",
          "labels_url": "https://api.github.com/repos/bosens-China/blog/issues/59/labels{/name}",
          "comments_url": "https://api.github.com/repos/bosens-China/blog/issues/59/comments",
          "events_url": "https://api.github.com/repos/bosens-China/blog/issues/59/events",
          "html_url": "https://github.com/bosens-China/blog/issues/59",
          "id": 647201487,
          "node_id": "MDU6SXNzdWU2NDcyMDE0ODc=",
          "number": 59,
          "title": "深浅拷贝和extend",
          "user": {
            "login": "bosens-China",
            "id": 39508895,
            "node_id": "MDQ6VXNlcjM5NTA4ODk1",
            "avatar_url": "https://avatars.githubusercontent.com/u/39508895?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/bosens-China",
            "html_url": "https://github.com/bosens-China",
            "followers_url": "https://api.github.com/users/bosens-China/followers",
            "following_url": "https://api.github.com/users/bosens-China/following{/other_user}",
            "gists_url": "https://api.github.com/users/bosens-China/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/bosens-China/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/bosens-China/subscriptions",
            "organizations_url": "https://api.github.com/users/bosens-China/orgs",
            "repos_url": "https://api.github.com/users/bosens-China/repos",
            "events_url": "https://api.github.com/users/bosens-China/events{/privacy}",
            "received_events_url": "https://api.github.com/users/bosens-China/received_events",
            "type": "User",
            "site_admin": false
          },
          "labels": [
            {
              "id": 1602397157,
              "node_id": "MDU6TGFiZWwxNjAyMzk3MTU3",
              "url": "https://api.github.com/repos/bosens-China/blog/labels/%E6%B7%B1%E5%85%A5%E7%B3%BB%E5%88%97",
              "name": "深入系列",
              "color": "719192",
              "default": false,
              "description": "主要介绍实现的思路"
            }
          ],
          "state": "open",
          "locked": false,
          "assignee": null,
          "assignees": [],
          "milestone": null,
          "comments": 0,
          "created_at": "2020-06-29T07:59:36Z",
          "updated_at": "2021-12-21T03:04:38Z",
          "closed_at": null,
          "author_association": "OWNER",
          "active_lock_reason": null,
          "body": "## 前言\r\n\r\n深浅拷贝和 extend 是项目中常用的工具类函数，今天就动手实现一下\r\n\r\n下面会重复这几个基础函数，为了简洁下面不会出现相关定义\r\n\r\n```js\r\nfunction isObject(obj) {\r\n  return obj && typeof obj === \"object\";\r\n}\r\nfunction type(obj) {\r\n  return Object.prototype.toString\r\n    .call(obj)\r\n    .replace(/\\[object.(.+?)\\]/, \"$1\")\r\n    .toLowerCase();\r\n}\r\nfunction array(par) {\r\n  return type(par) === \"array\";\r\n}\r\n```\r\n\r\n## 浅拷贝用法\r\n\r\n```js\r\nvar obj = { name: \"test\", args: [{ name: 1 }] };\r\nvar test = { ...obj };\r\n// 修改下原来属性\r\nobj.name = \"foo\";\r\n// test.name test\r\nobj.args.push(\"456\");\r\n// args: (2) [{…}, \"456\"]\r\n```\r\n\r\n从上面例子可以看到，当两个对象出现相同字段的时候，后者会覆盖前者，而不会进行深层次的覆盖。\r\n\r\n由此可以得到一个结论：浅拷贝可以简单理解为只拷贝对象的一层属性，如果拷贝的属性还是对象，那么修改它则会影响到拥有相同属性的对象。\r\n\r\n## 浅拷贝实现\r\n\r\n结合上面的结论，我们动手实现一个函数\r\n\r\n```js\r\nexport function copy(obj) {\r\n  if (!isObject(obj)) {\r\n    return;\r\n  }\r\n  const src = array(obj) ? [] : {};\r\n  for (const key in obj) {\r\n    const value = obj[key];\r\n    if (Object.prototype.hasOwnProperty.call(obj, key)) {\r\n      src[key] = value;\r\n    }\r\n  }\r\n  return src;\r\n}\r\n```\r\n\r\n测试用例\r\n\r\n```js\r\ntest(\"浅拷贝\", () => {\r\n  const value = { a: 123, b: 456, c: [1] };\r\n  const test = copy(value);\r\n  expect(test).toEqual({ a: 123, b: 456, c: [1] });\r\n  expect(value === test).toBeFalsy();\r\n  expect(value.c === test.c).toBeTruthy();\r\n  expect(value.a === test.a).toBeTruthy();\r\n});\r\n```\r\n\r\n## 深拷贝\r\n\r\n上面我们已经实现了浅拷贝，浅拷贝只是简单的拷贝了一层属性，如果是深拷贝呢？\r\n\r\n其实就是对属性为对象进行重复的调用，在实现这个之前先看一个比较简单的做法。\r\n\r\n#### json\r\n\r\n```js\r\nfunction deepAssign(par) {\r\n  return JSON.parse(JSON.stringify(par));\r\n}\r\n// 测试用例\r\nconst value = {a: {name: 456}};\r\nconst test = deepAssign({value);\r\ntest.a === value.a;\r\n//false\r\ndeepAssign({ a() {}, b: /abc/, c: Math.floor, d: null, e: new Set() });\r\n// {b: {}, d: null, e: {}}\r\n```\r\n\r\n需要特别注意用这个方法处理函数、正则之类的对象不会出现预期结果，不过在处理接口返回的数据不失为一种方法。\r\n\r\n#### 递归\r\n\r\n相比`JSON`的方式实现，可以让我们自由定制一些类型，例如上面的`正则`就可以通过`hack`方法创建，为了简化源码，这里只处理对象和数组，对于其他类型的处理可以参考一下第三方库\r\n\r\n```js\r\nfunction deepCopy(obj, has = new WeakMap()) {\r\n  if (!isObject(obj)) {\r\n    return;\r\n  }\r\n  // 避免循环引用\r\n  if (has.has(obj)) {\r\n    return has.get(obj);\r\n  }\r\n  const src = array(obj) ? [] : {};\r\n  has.set(obj, src);\r\n  for (const key in obj) {\r\n    const value = obj[key];\r\n    if (Object.prototype.hasOwnProperty.call(obj, key)) {\r\n      // 注意这一行\r\n      src[key] = isObject(value) ? copy(value, has) : value;\r\n    }\r\n  }\r\n  return src;\r\n}\r\n```\r\n\r\n测试用例\r\n\r\n```js\r\ntest(\"深拷贝\", () => {\r\n  const value = { a: 123, b: 456, c: [1] };\r\n  const test = deepCopy(value);\r\n  expect(test).toEqual({ a: 123, b: 456, c: [1] });\r\n  expect(value === test).toBeFalsy();\r\n  expect(value.c === test.c).toBeFalsy();\r\n  expect(value.a === test.a).toBeTruthy();\r\n});\r\n```\r\n\r\n注意上面用了一个`WeakMap`，这个是为了避免循环引入，你可以把上面的`WeakMap`相关代码去掉，然后在控制台输入下面这个例子，看看会出现什么结果。\r\n\r\n```js\r\nvar a = {};\r\na.a = a;\r\nvar test = deepCopy(a);\r\n```\r\n\r\n## extend\r\n\r\nextend 分为两部分:\r\n\r\n1. 浅合并，`Object.assign`就是浅拷贝；\r\n2. 深合并，没有相关的的 api，需要手动实现\r\n\r\n#### 浅合并使用方法\r\n\r\n在实现这个方法之前，我们约定一下格式\r\n\r\n```js\r\nassign( target [, object1 ] [, objectN ] )\r\n```\r\n\r\n第一个参数为目标对象必须是对象，之后的参数是目标对象，可以不为对象\r\n\r\n```js\r\nvar obj1 = {\r\n  a: 1,\r\n  b: { b1: 1, b2: 2 },\r\n};\r\n\r\nvar obj2 = {\r\n  b: { b1: 3, b3: 4 },\r\n  c: 3,\r\n};\r\n\r\nvar obj3 = {\r\n  d: 4,\r\n};\r\n\r\nconsole.log(assign(obj1, obj2, obj3));\r\n\r\n// {\r\n//    a: 1,\r\n//    b: { b1: 3, b3: 4 },\r\n//    c: 3,\r\n//    d: 4\r\n// }\r\n```\r\n\r\n#### 浅合并实现\r\n\r\n根据上面的约束，动手实现一下\r\n\r\n```js\r\nfunction assign() {\r\n  let target = arguments[0];\r\n  let i = 1,\r\n    leg = arguments.length;\r\n  if (!isObject(target)) {\r\n    target = {};\r\n  }\r\n  for (; i < leg; i++) {\r\n    const value = arguments[i];\r\n    if (value == null) {\r\n      continue;\r\n    }\r\n    for (const name in value) {\r\n      if (Object.prototype.hasOwnProperty.call(value, name)) {\r\n        const copy = value[name];\r\n        target[name] = copy;\r\n      }\r\n    }\r\n  }\r\n  return target;\r\n}\r\n```\r\n\r\n测试用例\r\n\r\n```js\r\ntest(\"浅拷贝\", () => {\r\n  const value1 = { name: \"test\", age: 17 };\r\n  const value2 = { name: \"app\", age: [1, 2, 3] };\r\n  const test = assign(value1, value2, null, undefined, \"abc\");\r\n  expect(assign(test)).toEqual({\r\n    name: \"app\",\r\n    age: [1, 2, 3],\r\n    0: \"a\",\r\n    1: \"b\",\r\n    2: \"c\",\r\n  });\r\n  expect(test.age === value2.age).toBeTruthy();\r\n  var obj1 = {\r\n    a: 1,\r\n    b: { b1: 1, b2: 2 },\r\n  };\r\n\r\n  var obj2 = {\r\n    b: { b1: 3, b3: 4 },\r\n    c: 3,\r\n  };\r\n\r\n  var obj3 = {\r\n    d: 4,\r\n  };\r\n  expect(assign(obj1, obj2, obj3)).toEqual({\r\n    a: 1,\r\n    b: { b1: 3, b3: 4 },\r\n    c: 3,\r\n    d: 4,\r\n  });\r\n});\r\n```\r\n\r\n#### 深合并\r\n\r\n```js\r\nfunction deepAssign(...args) {\r\n  let obj = {};\r\n  for (const value of args) {\r\n    if (array(value)) {\r\n      if (!array(obj)) {\r\n        obj = [];\r\n      }\r\n      // 对数组内容进行深拷贝\r\n      const arr = value.reduce((x, y) => {\r\n        x = x.concat(isObject(y) ? deepAssign([], y) : y);\r\n        return x;\r\n      }, []);\r\n      obj = [...obj, ...arr];\r\n    } else if (isObject(value)) {\r\n      for (let [name, val] of Object.entries(value)) {\r\n        if (isObject(val) && name in obj) {\r\n          val = deepAssign(obj[name], val);\r\n        }\r\n        obj = {\r\n          ...obj,\r\n          [name]: val,\r\n        };\r\n      }\r\n    }\r\n  }\r\n  return obj;\r\n}\r\n```\r\n\r\n`if (isObject(val) && name in obj)`注意这行的判断，只有当 target 属性上有值的时候才会进行递归调用。\r\n\r\n测试用例\r\n\r\n```js\r\ntest(\"深合并\", () => {\r\n  const value1 = [1, 2, { name: { age: [1, 2, 3, 4, 5] } }];\r\n  const value2 = [1, 2, { age: 18 }];\r\n  const test = deepAssign(value1, value2);\r\n  expect(test[2] === value1[2]).toBe(false);\r\n  expect(test).toEqual([\r\n    1,\r\n    2,\r\n    { name: { age: [1, 2, 3, 4, 5] } },\r\n    1,\r\n    2,\r\n    { age: 18 },\r\n  ]);\r\n  const obj1 = { name: [1, 2, 3] };\r\n  const obj2 = { age: 17, name: [4, 5, 6] };\r\n  const obj = deepAssign(obj1, obj2);\r\n  expect(obj).toEqual({ name: [1, 2, 3, 4, 5, 6], age: 17 });\r\n  const a = {};\r\n  a.a = a;\r\n  expect(deepAssign(a)).toEqual({ a: { a } });\r\n});\r\n```\r\n\r\n## 最后\r\n\r\n如果有错误或者不严谨的地方，请务必给予指正，十分感谢。如果喜欢或者有所启发，欢迎 `star`，对作者也是一种鼓励。\r\n",
          "reactions": {
            "url": "https://api.github.com/repos/bosens-China/blog/issues/59/reactions",
            "total_count": 0,
            "+1": 0,
            "-1": 0,
            "laugh": 0,
            "hooray": 0,
            "confused": 0,
            "heart": 0,
            "rocket": 0,
            "eyes": 0
          },
          "timeline_url": "https://api.github.com/repos/bosens-China/blog/issues/59/timeline",
          "performed_via_github_app": null,
          "state_reason": null
        }
      ]
    ],
    [
      "1371686610",
      [
        {
          "url": "https://api.github.com/repos/bosens-China/blog/issues/64",
          "repository_url": "https://api.github.com/repos/bosens-China/blog",
          "labels_url": "https://api.github.com/repos/bosens-China/blog/issues/64/labels{/name}",
          "comments_url": "https://api.github.com/repos/bosens-China/blog/issues/64/comments",
          "events_url": "https://api.github.com/repos/bosens-China/blog/issues/64/events",
          "html_url": "https://github.com/bosens-China/blog/issues/64",
          "id": 767600367,
          "node_id": "MDU6SXNzdWU3Njc2MDAzNjc=",
          "number": 64,
          "title": "ios屏幕适配",
          "user": {
            "login": "bosens-China",
            "id": 39508895,
            "node_id": "MDQ6VXNlcjM5NTA4ODk1",
            "avatar_url": "https://avatars.githubusercontent.com/u/39508895?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/bosens-China",
            "html_url": "https://github.com/bosens-China",
            "followers_url": "https://api.github.com/users/bosens-China/followers",
            "following_url": "https://api.github.com/users/bosens-China/following{/other_user}",
            "gists_url": "https://api.github.com/users/bosens-China/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/bosens-China/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/bosens-China/subscriptions",
            "organizations_url": "https://api.github.com/users/bosens-China/orgs",
            "repos_url": "https://api.github.com/users/bosens-China/repos",
            "events_url": "https://api.github.com/users/bosens-China/events{/privacy}",
            "received_events_url": "https://api.github.com/users/bosens-China/received_events",
            "type": "User",
            "site_admin": false
          },
          "labels": [
            {
              "id": 1371686610,
              "node_id": "MDU6TGFiZWwxMzcxNjg2NjEw",
              "url": "https://api.github.com/repos/bosens-China/blog/labels/css%20%E7%9B%B8%E5%85%B3",
              "name": "css 相关",
              "color": "42b883",
              "default": false,
              "description": "css 技巧和基础为主"
            }
          ],
          "state": "open",
          "locked": false,
          "assignee": null,
          "assignees": [],
          "milestone": null,
          "comments": 0,
          "created_at": "2020-12-15T13:34:49Z",
          "updated_at": "2021-12-21T09:51:42Z",
          "closed_at": null,
          "author_association": "OWNER",
          "active_lock_reason": null,
          "body": "这篇文章算是迟来的总结，最近做了一个 h5 项目内嵌到 app 页面内联，默认情况下 app 那边不会做任何处理，也就是顶部和底部需要额外处理一下\r\n![bg](https://user-images.githubusercontent.com/39508895/102221576-4211db00-3f1d-11eb-981c-885c51309964.png)\r\n\r\n\r\n## 做法\r\n\r\n默认情况下 ios 的顶部状态栏是`20px`，如果存在刘海则是`44px`，当然实际开发中也不需要使用 js 来进行判断，因为 ios11 之后新增了一个安全区域，用来定义可视窗口的范围，它一共有四个属性\r\n\r\n- safe-area-inset-left：安全区域距离左边边界距离\r\n- safe-area-inset-right：安全区域距离右边边界距离\r\n- safe-area-inset-top：安全区域距离顶部边界距离\r\n- safe-area-inset-bottom：安全区域距离底部边界距离\r\n\r\n使用方法也很简单：\r\n\r\n```css\r\npadding-bottom: env(safe-area-inset-bottom);\r\n```\r\n\r\n在`html`文件的`meta`中添加\r\n\r\n```html\r\n   <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0,user-scalable=no, viewport-fit=cover\">\r\n```\r\n\r\n> 只有设置了viewport-fit=cover，才能使用`env`，注意上面说的都是竖屏情况\r\n\r\n\r\n\r\n#### env 第二个参数\r\n\r\n上面写法的`env`和`constant`其实都支持第二个参数，作为不支持环境的后退，可以作为了解\r\n例如：\r\n``` css\r\n/* 不支持就回退到第二个参数 */\r\npadding-bottom: env(safe-area-inset-bottom, 20px);\r\n```\r\n\r\n#### @supports 额外判断\r\n\r\n为了防止部分安卓也使用`safe-area-inset-top`之类的属性，可以添加`-webkit-overflow-scrolling: touch`来进行双重判断\r\n\r\n> [-webkit-overflow-scrolling](https://caniuse.com/?search=-webkit-overflow-scrolling) 只有 iOS Safari 支持\r\n\r\n```css\r\n@supports (\r\n    (height: constant(safe-area-inset-top)) or\r\n      (height: env(safe-area-inset-top))\r\n  )\r\n  and (-webkit-overflow-scrolling: touch) {\r\n  /* 代码 */\r\n}\r\n```\r\n\r\n## fixed 写法\r\n\r\n- calc，直接把原来写的值加上安全区域范围\r\n\r\n```css\r\nbottom: calc(50px (假设值) + env(safe-area-inset-bottom));\r\n```\r\n\r\n- padding: 添加 padding 的内边距进行填充\r\n\r\n```css\r\npadding-bottom: env(safe-area-inset-bottom);\r\n```\r\n\r\n## 额外注意点\r\n\r\n是不是因为上面就说完了，其实还有还有一点兼容的地方需要额外关注\r\n\r\n> The env() function shipped in iOS 11 with the name constant(). Beginning with Safari Technology Preview 41 and the iOS 11.2 beta, constant() has been removed and replaced with env(). You can use the CSS fallback mechanism to support both versions, if necessary, but should prefer env() going forward.\r\n\r\n翻译过来就是`ios`11.2 之后不再支持`constant`而是使用`env`，所以生产过程中可以使用下面写法做兼容\r\n\r\n```css\r\npadding-bottom: constant(safe-area-inset-bottom);\r\n/* 兼容 iOS < 11.2 */\r\npadding-bottom: env(safe-area-inset-bottom);\r\n/* 兼容 iOS >= 11.2 */\r\n```\r\n\r\n## 最后\r\n\r\n如果对你有帮助可以点一下`star`\r\n\r\n参考文章\r\n\r\n- [网页适配 iPhoneX，就是这么简单](https://aotu.io/notes/2017/11/27/iphonex/index.html)\r\n\r\n- [IOS刘海屏H5 CSS适配](https://juejin.cn/post/6844903974491930637#heading-4)\r\n",
          "reactions": {
            "url": "https://api.github.com/repos/bosens-China/blog/issues/64/reactions",
            "total_count": 0,
            "+1": 0,
            "-1": 0,
            "laugh": 0,
            "hooray": 0,
            "confused": 0,
            "heart": 0,
            "rocket": 0,
            "eyes": 0
          },
          "timeline_url": "https://api.github.com/repos/bosens-China/blog/issues/64/timeline",
          "performed_via_github_app": null,
          "state_reason": null
        },
        {
          "url": "https://api.github.com/repos/bosens-China/blog/issues/34",
          "repository_url": "https://api.github.com/repos/bosens-China/blog",
          "labels_url": "https://api.github.com/repos/bosens-China/blog/issues/34/labels{/name}",
          "comments_url": "https://api.github.com/repos/bosens-China/blog/issues/34/comments",
          "events_url": "https://api.github.com/repos/bosens-China/blog/issues/34/events",
          "html_url": "https://github.com/bosens-China/blog/issues/34",
          "id": 512000452,
          "node_id": "MDU6SXNzdWU1MTIwMDA0NTI=",
          "number": 34,
          "title": "选择器那些事",
          "user": {
            "login": "bosens-China",
            "id": 39508895,
            "node_id": "MDQ6VXNlcjM5NTA4ODk1",
            "avatar_url": "https://avatars.githubusercontent.com/u/39508895?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/bosens-China",
            "html_url": "https://github.com/bosens-China",
            "followers_url": "https://api.github.com/users/bosens-China/followers",
            "following_url": "https://api.github.com/users/bosens-China/following{/other_user}",
            "gists_url": "https://api.github.com/users/bosens-China/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/bosens-China/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/bosens-China/subscriptions",
            "organizations_url": "https://api.github.com/users/bosens-China/orgs",
            "repos_url": "https://api.github.com/users/bosens-China/repos",
            "events_url": "https://api.github.com/users/bosens-China/events{/privacy}",
            "received_events_url": "https://api.github.com/users/bosens-China/received_events",
            "type": "User",
            "site_admin": false
          },
          "labels": [
            {
              "id": 1371686610,
              "node_id": "MDU6TGFiZWwxMzcxNjg2NjEw",
              "url": "https://api.github.com/repos/bosens-China/blog/labels/css%20%E7%9B%B8%E5%85%B3",
              "name": "css 相关",
              "color": "42b883",
              "default": false,
              "description": "css 技巧和基础为主"
            }
          ],
          "state": "open",
          "locked": false,
          "assignee": null,
          "assignees": [],
          "milestone": null,
          "comments": 0,
          "created_at": "2019-10-24T14:56:12Z",
          "updated_at": "2021-12-21T09:47:07Z",
          "closed_at": null,
          "author_association": "OWNER",
          "active_lock_reason": null,
          "body": "> 失踪人口冒个泡\r\n\r\n## 优先级\r\n\r\n入门学习的时候一定就听说过这些概念，在菜鸟教程之类的网站上也肯定学习过，比如类的优先级为 10、标签的优先级为 1，这些都是辅助我们记忆的，下面就来说一说容易出错的点。\r\n\r\n```css\r\n.top {\r\n  margin: 10px;\r\n}\r\n[class] {\r\n  margin: 20px;\r\n}\r\n```\r\n\r\n这里输出的`margin`为多少？\r\n\r\n答案是`20px`，对于类和属性选择器以及伪类优先级是一致的，当然这个例子只是帮你温习的，再来看一个\r\n\r\n```css\r\n/*第一条*/\r\nbody [class] {\r\n  color: #666;\r\n}\r\n/*第二条*/\r\nhtml:not([dir]) {\r\n  color: red;\r\n}\r\n```\r\n\r\n这里两条属性的优先级相等么？\r\n\r\n答案是相等的，对于`:not`这样的逻辑组合伪类影响优先级的是里面的元素，上面第一条是一个标签加上属性选择器优先级为 11，第二条 html 标签加上属性选择器优先级也是 11。\r\n\r\n## 渲染顺序\r\n\r\n上面举了一个例子最终颜色生效为`red`，这是因为后来居上的原则，不过注意这个后来居上说的是整体文档而言。\r\n\r\n```html\r\n<link rel=\"stylesheet\" href=\"a.css\" /> <link rel=\"stylesheet\" href=\"b.css\" />\r\n```\r\n\r\na.css\r\n\r\n```css\r\nbody .foo {\r\n  color: red;\r\n}\r\n```\r\n\r\nb.css\r\n\r\n```css\r\nhtml .foo {\r\n  color: #666;\r\n}\r\n```\r\n\r\n最终`color`的值为`#666`，同时还提醒一下 css 最终生效并不是看元素的距离的远近，而是根据优先级和位置，比如上面的 body 肯定比 html 离得近，但是因为后来居上所以并没有生效。\r\n\r\n## 选择器是否能跨级？\r\n\r\n在开头说了方便记忆我们会给类和标签之类的优先级添加上数字，但是如果你想用数量多就覆盖高一层级的是不可能的\r\n\r\n```css\r\n.a {\r\n  color: red;\r\n}\r\na,\r\na,\r\na,\r\na,\r\na,\r\na,\r\na,\r\na,\r\na,\r\na,\r\na,\r\na,\r\na,\r\na,\r\na,\r\na,\r\na,\r\na {\r\n  color: #666;\r\n}\r\n```\r\n\r\n输出结果还是红色。\r\n\r\n## 增加优先级\r\n\r\n传统添加优先级我们可能会通过给标签添加 id 或者继续嵌套来实现，不过这样做肯定不合适因为后面在想修改可能就需要使用`style`或者`important`了，下面就说下两个小技巧\r\n\r\n1. 使用属性选择器\r\n\r\n```css\r\n.a[class] {\r\n  color: red;\r\n}\r\n.a {\r\n  color: #666;\r\n}\r\n```\r\n\r\n2. 嵌套选择自己\r\n\r\n```css\r\n.a.a {\r\n  color: red;\r\n}\r\n.a {\r\n  color: #666;\r\n}\r\n```\r\n\r\n## 匹配顺序\r\n\r\n说一点新手噩梦，css 的匹配顺序是从右往左，所以嵌套太多层的 css 语句就不要在写了，一般而言 id 选择器和类选择器的解析最快，标签选择器的速度很慢，所以在项目中不要嵌入太多的标签选择器有利于项目的优化。\r\n\r\n## 是否区分大小写\r\n\r\n说这个首先要说一下 html 是否区分大小写，html 对于标签和属性是不区分大小写的，而对属性值则是区分的，css 与 html 保持一致\r\n\r\n```html\r\n<style>\r\n  p {\r\n    color: #666;\r\n  }\r\n  [CLASS] {\r\n    color: red;\r\n  }\r\n  .foo {\r\n    color: white;\r\n  }\r\n</style>\r\n<p class=\"FOO\">hello wrold</p>\r\n```\r\n\r\n这里 p 的 `color` 为 `red`，说明了标签和属性选择器不区分大小写，而对于 class 则是区分的。\r\n",
          "reactions": {
            "url": "https://api.github.com/repos/bosens-China/blog/issues/34/reactions",
            "total_count": 0,
            "+1": 0,
            "-1": 0,
            "laugh": 0,
            "hooray": 0,
            "confused": 0,
            "heart": 0,
            "rocket": 0,
            "eyes": 0
          },
          "timeline_url": "https://api.github.com/repos/bosens-China/blog/issues/34/timeline",
          "performed_via_github_app": null,
          "state_reason": null
        },
        {
          "url": "https://api.github.com/repos/bosens-China/blog/issues/18",
          "repository_url": "https://api.github.com/repos/bosens-China/blog",
          "labels_url": "https://api.github.com/repos/bosens-China/blog/issues/18/labels{/name}",
          "comments_url": "https://api.github.com/repos/bosens-China/blog/issues/18/comments",
          "events_url": "https://api.github.com/repos/bosens-China/blog/issues/18/events",
          "html_url": "https://github.com/bosens-China/blog/issues/18",
          "id": 479907836,
          "node_id": "MDU6SXNzdWU0Nzk5MDc4MzY=",
          "number": 18,
          "title": "无效的height100%？",
          "user": {
            "login": "bosens-China",
            "id": 39508895,
            "node_id": "MDQ6VXNlcjM5NTA4ODk1",
            "avatar_url": "https://avatars.githubusercontent.com/u/39508895?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/bosens-China",
            "html_url": "https://github.com/bosens-China",
            "followers_url": "https://api.github.com/users/bosens-China/followers",
            "following_url": "https://api.github.com/users/bosens-China/following{/other_user}",
            "gists_url": "https://api.github.com/users/bosens-China/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/bosens-China/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/bosens-China/subscriptions",
            "organizations_url": "https://api.github.com/users/bosens-China/orgs",
            "repos_url": "https://api.github.com/users/bosens-China/repos",
            "events_url": "https://api.github.com/users/bosens-China/events{/privacy}",
            "received_events_url": "https://api.github.com/users/bosens-China/received_events",
            "type": "User",
            "site_admin": false
          },
          "labels": [
            {
              "id": 1371686610,
              "node_id": "MDU6TGFiZWwxMzcxNjg2NjEw",
              "url": "https://api.github.com/repos/bosens-China/blog/labels/css%20%E7%9B%B8%E5%85%B3",
              "name": "css 相关",
              "color": "42b883",
              "default": false,
              "description": "css 技巧和基础为主"
            }
          ],
          "state": "open",
          "locked": false,
          "assignee": null,
          "assignees": [],
          "milestone": null,
          "comments": 0,
          "created_at": "2019-08-13T00:34:13Z",
          "updated_at": "2019-08-13T00:34:13Z",
          "closed_at": null,
          "author_association": "OWNER",
          "active_lock_reason": null,
          "body": "之所以写 height，是因为它出现的场所比较多\r\n``` css\r\nbody {\r\n  height: 100%;\r\n}\r\n```\r\n不知道你们有没有这样写过 css 属性，不过很遗憾这是无效的。\r\n\r\n父级没有给定明确的高度么？ 这样说有一定正确性，不过不够全面，在 height 的规范中规定了两种情况 100%可以解析出来\r\n\r\n1. 父级给定明确的高度\r\n这个没什么好说的，平时我们也是这样写的 比如上面 body 没有生效就是因为没有指定 html 的高度，所以要这样写\r\n``` css\r\nhtml,\r\nbody {\r\n  height: 100%;\r\n}\r\n```\r\n\r\n2. 使用绝对定位元素\r\n``` css\r\n.box {\r\n  position: relative;\r\n  .child {\r\n    position: absolute;\r\n    height: 100%;\r\n    widows: 100%;\r\n  }\r\n}\r\n```\r\n这样就获取到了高度，不过注意绝对定位获取的高度与父级给定高度有一定区别\r\n\r\n## 区别\r\ncss 是存在盒子模型的，平时高度和宽度都是作用在 `content-box` 上的，而上面说的第一种方式，高度获取到的就是父级 content 盒子的高度，怎么来证明呢？ `box-sizing` 可以改变作用高度和宽度的盒子，我们来用这个实验。\r\n``` html\r\n<div class=\"box\">\r\n  <div class=\"child\"></div>\r\n</div>\r\n.box {\r\n  width: 180px;\r\n  background: #ddd;\r\n  height: 150px;\r\n  padding: 30px;\r\n  box-sizing: border-box;\r\n  .child {\r\n    height: 100%;\r\n    background: #666;\r\n  }\r\n}\r\n```\r\n可以将上面代码复制到本地运行一下，可以看到子元素的高度并没有占用父元素的 100%。 改写一下，改成绝对定位来实现\r\n``` css\r\n.box {\r\n  width: 180px;\r\n  background: #ddd;\r\n  height: 150px;\r\n  padding: 30px;\r\n  box-sizing: border-box;\r\n  position: relative;\r\n  border: 20px solid;\r\n  .child {\r\n    height: 100%;\r\n    background: #666;\r\n    position: absolute;\r\n    width: 100%;\r\n  }\r\n}\r\n```\r\n对比一下可以看到绝对定位的高度是包含` padding` 区域的\r\n\r\n最后以一个示例结尾\r\n``` html\r\n<div class=\"box\">\r\n  <a href=\"javascript:\" class=\"nav\"></a>\r\n  <a href=\"javascript:\" class=\"nav nav1\"></a>\r\n  <img src=\"https://demo.cssworld.cn/images/common/l/1.jpg\" alt=\"\" />\r\n</div>\r\n.box {\r\n  display: inline-block;\r\n  position: relative;\r\n  .nav {\r\n    position: absolute;\r\n    height: 100%;\r\n    left: 0;\r\n    width: 50%;\r\n    opacity: 0.7;\r\n    background: #ddd;\r\n  }\r\n  .nav1 {\r\n    left: 50%;\r\n    background: #34538b;\r\n  }\r\n}\r\n```\r\n借助绝对定位实现了高度自适应的效果\r\n\r\n## 参考\r\n《css 世界》",
          "reactions": {
            "url": "https://api.github.com/repos/bosens-China/blog/issues/18/reactions",
            "total_count": 0,
            "+1": 0,
            "-1": 0,
            "laugh": 0,
            "hooray": 0,
            "confused": 0,
            "heart": 0,
            "rocket": 0,
            "eyes": 0
          },
          "timeline_url": "https://api.github.com/repos/bosens-China/blog/issues/18/timeline",
          "performed_via_github_app": null,
          "state_reason": null
        }
      ]
    ],
    [
      "1580833992",
      [
        {
          "url": "https://api.github.com/repos/bosens-China/blog/issues/42",
          "repository_url": "https://api.github.com/repos/bosens-China/blog",
          "labels_url": "https://api.github.com/repos/bosens-China/blog/issues/42/labels{/name}",
          "comments_url": "https://api.github.com/repos/bosens-China/blog/issues/42/comments",
          "events_url": "https://api.github.com/repos/bosens-China/blog/issues/42/events",
          "html_url": "https://github.com/bosens-China/blog/issues/42",
          "id": 542405907,
          "node_id": "MDU6SXNzdWU1NDI0MDU5MDc=",
          "number": 42,
          "title": "IntersectionObserver实现图片懒加载",
          "user": {
            "login": "bosens-China",
            "id": 39508895,
            "node_id": "MDQ6VXNlcjM5NTA4ODk1",
            "avatar_url": "https://avatars.githubusercontent.com/u/39508895?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/bosens-China",
            "html_url": "https://github.com/bosens-China",
            "followers_url": "https://api.github.com/users/bosens-China/followers",
            "following_url": "https://api.github.com/users/bosens-China/following{/other_user}",
            "gists_url": "https://api.github.com/users/bosens-China/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/bosens-China/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/bosens-China/subscriptions",
            "organizations_url": "https://api.github.com/users/bosens-China/orgs",
            "repos_url": "https://api.github.com/users/bosens-China/repos",
            "events_url": "https://api.github.com/users/bosens-China/events{/privacy}",
            "received_events_url": "https://api.github.com/users/bosens-China/received_events",
            "type": "User",
            "site_admin": false
          },
          "labels": [
            {
              "id": 1580833992,
              "node_id": "MDU6TGFiZWwxNTgwODMzOTky",
              "url": "https://api.github.com/repos/bosens-China/blog/labels/%E5%AE%9E%E9%AA%8C%E6%80%A7%20API",
              "name": "实验性 API",
              "color": "7aa9d6",
              "default": false,
              "description": "还未定稿的API"
            }
          ],
          "state": "open",
          "locked": false,
          "assignee": null,
          "assignees": [],
          "milestone": null,
          "comments": 0,
          "created_at": "2019-12-26T01:53:33Z",
          "updated_at": "2021-12-21T09:48:12Z",
          "closed_at": null,
          "author_association": "OWNER",
          "active_lock_reason": null,
          "body": "> 传统的图片懒加载实现思路是判断图片的 top 区域是否小于父级区域，且自身高度加上 top 大于 0，\r\n> 例如\r\n\r\n```js\r\n// 元素是否可视\r\nconst viewVisible = el => {\r\n  const { top, width, height, left } = el.getBoundingClientRect();\r\n  const w = window.innerWidth || document.documentElement.clientWidth;\r\n  const h = window.innerHeight || document.documentElement.clientHeight;\r\n  return top < h && top + height >= 0 && left < w && left + width >= 0;\r\n};\r\n```\r\n\r\n> 不过这样写的话有一个问题就是我们监听的事件会重复多次触发，所以我们还需要写一个节流或者防抖函数，不过使用`IntersectionObserver`我们可以轻松实现，首先看下兼容性\r\n\r\n>![IntersectionObserver兼容性](https://user-images.githubusercontent.com/39508895/146864557-35c7c4d6-600c-4379-a433-1d38225500f5.png)可以看到差强人意，不过好在可以[polyfill](https://github.com/w3c/IntersectionObserver/tree/master/polyfill)，下面就介绍使用\r\n\r\n## 使用方法\r\n\r\n`IntersectionObserver`使用方法很简单\r\n\r\n```js\r\nvar observer = new IntersectionObserver(callback[, options]);\r\n```\r\n\r\n`callback`接收两个参数，一个 IntersectionObserverEntry 对象列表(list)，以及触发 IntersectionObserverEntry 的实例\r\n\r\n| 方法         | 说明                                           |\r\n| ------------ | ---------------------------------------------- |\r\n| disconnect() | 使 IntersectionObserver 对象停止监听工作。     |\r\n| observe()    | 使 IntersectionObserver 开始监听一个目标元素。 |\r\n| unobserve()  | 使 IntersectionObserver 停止监听特定目标元素。 |\r\n\r\n**注意**\r\n`callback`的回调函数会触发两次，第一次是元素开始可见，第二次是元素不可见的时候。\r\n\r\n## 选项(options)\r\n\r\n注意可选属性\r\n\r\n| 属性       | 说明                                                                                                                                                                                           |\r\n| ---------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\r\n| root       | 监听元素的祖先元素 Element 对象                                                                                                                                                                |\r\n| rootMargin | 一个在计算交叉值时添加至根的边界盒(bounding_box)中的一组偏移量，类型为字符串，可以有效的缩小或扩大根的判定范围从而满足计算需要。语法大致和 CSS 中的 margin 属性等同，默认值是\"0px 0px 0px 0px\" |\r\n| threshold  | 规定了一个监听目标与边界盒交叉区域的比例值，可以是一个具体的数值或是一组 0.0 到 1.0 之间的数组。若指定值为 0.0，则意味着监听元素即使与根有 1 像素交叉，此元素也会被视为可见.                   |\r\n\r\n## 实例\r\n\r\n```js\r\nconst dom = new IntersectionObserver(a => {\r\n  console.log(a);\r\n});\r\nArray.from(document.querySelectorAll(\"img\")).forEach(f => {\r\n  dom.observe(f);\r\n});\r\n```\r\n\r\n返回的 a 是一个数组，里面存放着一些元素信息，下面所有属性都是只读\r\n\r\n| 属性               | 说明                                                                                                                                                                                                                                |\r\n| ------------------ | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\r\n| boundingClientRect | 返回包含目标元素的边界信息的 DOMRectReadOnly. 边界的计算方式与 Element.getBoundingClientRect() 相同.                                                                                                                                |\r\n| intersectionRatio  | 返回 intersectionRect 与 boundingClientRect 的比例值,**如果大于 0 则表示可见，完全可见为 1**.                                                                                                                                       |\r\n| intersectionRect   | 返回一个 DOMRectReadOnly 用来描述根和目标元素的相交区域.                                                                                                                                                                            |\r\n| isIntersecting     | 返回一个布尔值, 如果目标元素与交叉区域观察者对象(intersection observer) 的根相交，则返回 true .如果返回 true, 则 IntersectionObserverEntry 描述了变换到交叉时的状态; 如果返回 false, 那么可以由此判断,变换是从交叉状态到非交叉状态. |\r\n| rootBounds         | 返回一个 DOMRectReadOnly 用来描述交叉区域观察者(intersection observer)中的根.                                                                                                                                                       |\r\n| target             | 与根出现相交区域改变的元素 (Element).                                                                                                                                                                                               |\r\n| time               | 返回一个记录从 IntersectionObserver 的时间原点(time origin)到交叉被触发的时间的时间戳(DOMHighResTimeStamp).                                                                                                                         |\r\n\r\n## 实现\r\n\r\n上面已经实现判断元素是否可见，下面我们只需要根据上面思路完善一下即可开发一个图片懒加载的类，首先先说明一下图片懒加载一般情况下为了防止图片`src`为空样式不统一和加载图片突然拉伸空间，会给默认的图片设置一个占位图片，或者给定一个样式\r\n\r\n```css\r\nimg {\r\n  width: 400px;\r\n  height: 400px;\r\n  display: inline-block;\r\n}\r\n```\r\n\r\n```html\r\n<img />\r\n```\r\n\r\n上面给了一个简单的演示，注意 `src` 属性不要写，因为即使为空也还会加载。 顺便说下火狐浏览器如果 img 标签没有其他属性的话会理解成内联元素，就是 span 标签一样的内联元素，所以如果不放置占位图片的话推荐重置 img 为 `inline-block` 然后设置固定宽高。\r\n\r\n之后就是给图片动态添加 src 属性，比较推荐的是`data-`的自定义属性，许多库用的也是这个方法，替换完成之后将图片元素从`IntersectionObserver`移除。\r\n\r\n## 最后\r\n\r\n`IntersectionObserver`使用的是异步的方式，可以不用担心性能问题\r\n\r\n- 参考\r\n  [IntersectionObserver MDN](https://developer.mozilla.org/zh-CN/docs/Web/API/IntersectionObserver/IntersectionObserver)\r\n",
          "reactions": {
            "url": "https://api.github.com/repos/bosens-China/blog/issues/42/reactions",
            "total_count": 0,
            "+1": 0,
            "-1": 0,
            "laugh": 0,
            "hooray": 0,
            "confused": 0,
            "heart": 0,
            "rocket": 0,
            "eyes": 0
          },
          "timeline_url": "https://api.github.com/repos/bosens-China/blog/issues/42/timeline",
          "performed_via_github_app": null,
          "state_reason": null
        },
        {
          "url": "https://api.github.com/repos/bosens-China/blog/issues/28",
          "repository_url": "https://api.github.com/repos/bosens-China/blog",
          "labels_url": "https://api.github.com/repos/bosens-China/blog/issues/28/labels{/name}",
          "comments_url": "https://api.github.com/repos/bosens-China/blog/issues/28/comments",
          "events_url": "https://api.github.com/repos/bosens-China/blog/issues/28/events",
          "html_url": "https://github.com/bosens-China/blog/issues/28",
          "id": 499359943,
          "node_id": "MDU6SXNzdWU0OTkzNTk5NDM=",
          "number": 28,
          "title": "MatchMedia API",
          "user": {
            "login": "bosens-China",
            "id": 39508895,
            "node_id": "MDQ6VXNlcjM5NTA4ODk1",
            "avatar_url": "https://avatars.githubusercontent.com/u/39508895?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/bosens-China",
            "html_url": "https://github.com/bosens-China",
            "followers_url": "https://api.github.com/users/bosens-China/followers",
            "following_url": "https://api.github.com/users/bosens-China/following{/other_user}",
            "gists_url": "https://api.github.com/users/bosens-China/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/bosens-China/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/bosens-China/subscriptions",
            "organizations_url": "https://api.github.com/users/bosens-China/orgs",
            "repos_url": "https://api.github.com/users/bosens-China/repos",
            "events_url": "https://api.github.com/users/bosens-China/events{/privacy}",
            "received_events_url": "https://api.github.com/users/bosens-China/received_events",
            "type": "User",
            "site_admin": false
          },
          "labels": [
            {
              "id": 1580833992,
              "node_id": "MDU6TGFiZWwxNTgwODMzOTky",
              "url": "https://api.github.com/repos/bosens-China/blog/labels/%E5%AE%9E%E9%AA%8C%E6%80%A7%20API",
              "name": "实验性 API",
              "color": "7aa9d6",
              "default": false,
              "description": "还未定稿的API"
            }
          ],
          "state": "open",
          "locked": false,
          "assignee": null,
          "assignees": [],
          "milestone": null,
          "comments": 0,
          "created_at": "2019-09-27T10:12:54Z",
          "updated_at": "2019-09-27T10:14:33Z",
          "closed_at": null,
          "author_association": "OWNER",
          "active_lock_reason": null,
          "body": "\r\n![456](https://user-images.githubusercontent.com/39508895/65761913-63d54580-e152-11e9-89e1-76f82d5df39f.jpg)\r\n\r\n\r\n> 注意`matchMedia`为实验性语法文档可能被重新修订，后面有可能会改变语法，在生产中请配合[matchMedia polyfill](https://github.com/paulirish/matchMedia.js)使用\r\n\r\n通过媒体查询，您可以根据各种设备特征和参数的值或者是否存在来调整您的网站或应用；\r\n\r\n上面是 MDN 对媒体查询的定义，简单情况通过 css 媒体查询 调整页面已经足够了，不过现在页面交互和功能越来越多，比如一个页面要响应式布局，同时在不同屏幕下页面结构不同，是不是感觉有些力不从心了，下面介绍一下`matchMedia`。\r\n\r\n## 使用方法\r\n\r\n```js\r\nvar mqList = window.matchMedia(mediaQueryString);\r\n```\r\n\r\nmatchMedia 可以实现编程方法式媒体查询，参数`mediaQueryString`为媒体语句，返回类型为`MediaQueryList`，下面是一个例子\r\n\r\n```js\r\nif (window.matchMedia(\"(min-width: 400px)\").matches) {\r\n  // 窗口大于等于400 情况\r\n} else {\r\n  // 窗口小于400\r\n}\r\n```\r\n\r\n## MediaQueryList \r\n\r\n- 属性\r\n\r\n  - matches:boolean： 如果当前 document 匹配该媒体查询列表则其值为 true；反之其值为 false。只读；\r\n  - media:DOMString 序列化的媒体查询列表；\r\n\r\n- 方法\r\n  - addListener(call: Function):void\r\n  - removeListener(call: Function):void\r\n\r\n### addListener\r\n\r\n```js\r\nMediaQueryList.addListener(func);\r\n```\r\n\r\nfunc 接收一个参数，初版参数的类型为[MediaQueryListListener ](https://developer.mozilla.org/en-US/docs/Web/API/MediaQueryListListener)新修订的参数类型为[MediaQueryListEvent,](https://developer.mozilla.org/en-US/docs/Web/API/MediaQueryListEvent)\r\n\r\n```js\r\nvar mql = window.matchMedia(\"(max-width: 600px)\");\r\n\r\nfunction screenTest(e) {\r\n  if (e.matches) {\r\n    // 屏幕小于等于600\r\n  } else {\r\n    // 屏幕大于600\r\n  }\r\n}\r\nmql.addListener(screenTest);\r\n```\r\n\r\n### removeListener\r\n\r\n```js\r\nMediaQueryList.removeListener(func);\r\n```\r\n\r\nfunc 表示要删除的回调函数的函数或函数引用\r\n\r\n```js\r\nvar mql = window.matchMedia(\"(max-width: 600px)\");\r\n\r\nfunction screenTest(e) {\r\n  if (e.matches) {\r\n    // 屏幕小于等于600\r\n  } else {\r\n    // 屏幕大于600\r\n  }\r\n}\r\n\r\nmql.addListener(screenTest);\r\n\r\n// 取消监听\r\nmql.removeListener(screenTest);\r\n```\r\n\r\n## 参考\r\n\r\nhttps://developer.mozilla.org/en-US/docs/Web/API/MediaQueryList/media\r\n",
          "reactions": {
            "url": "https://api.github.com/repos/bosens-China/blog/issues/28/reactions",
            "total_count": 0,
            "+1": 0,
            "-1": 0,
            "laugh": 0,
            "hooray": 0,
            "confused": 0,
            "heart": 0,
            "rocket": 0,
            "eyes": 0
          },
          "timeline_url": "https://api.github.com/repos/bosens-China/blog/issues/28/timeline",
          "performed_via_github_app": null,
          "state_reason": null
        },
        {
          "url": "https://api.github.com/repos/bosens-China/blog/issues/26",
          "repository_url": "https://api.github.com/repos/bosens-China/blog",
          "labels_url": "https://api.github.com/repos/bosens-China/blog/issues/26/labels{/name}",
          "comments_url": "https://api.github.com/repos/bosens-China/blog/issues/26/comments",
          "events_url": "https://api.github.com/repos/bosens-China/blog/issues/26/events",
          "html_url": "https://github.com/bosens-China/blog/issues/26",
          "id": 498112062,
          "node_id": "MDU6SXNzdWU0OTgxMTIwNjI=",
          "number": 26,
          "title": "ResizeObserver API",
          "user": {
            "login": "bosens-China",
            "id": 39508895,
            "node_id": "MDQ6VXNlcjM5NTA4ODk1",
            "avatar_url": "https://avatars.githubusercontent.com/u/39508895?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/bosens-China",
            "html_url": "https://github.com/bosens-China",
            "followers_url": "https://api.github.com/users/bosens-China/followers",
            "following_url": "https://api.github.com/users/bosens-China/following{/other_user}",
            "gists_url": "https://api.github.com/users/bosens-China/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/bosens-China/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/bosens-China/subscriptions",
            "organizations_url": "https://api.github.com/users/bosens-China/orgs",
            "repos_url": "https://api.github.com/users/bosens-China/repos",
            "events_url": "https://api.github.com/users/bosens-China/events{/privacy}",
            "received_events_url": "https://api.github.com/users/bosens-China/received_events",
            "type": "User",
            "site_admin": false
          },
          "labels": [
            {
              "id": 1580833992,
              "node_id": "MDU6TGFiZWwxNTgwODMzOTky",
              "url": "https://api.github.com/repos/bosens-China/blog/labels/%E5%AE%9E%E9%AA%8C%E6%80%A7%20API",
              "name": "实验性 API",
              "color": "7aa9d6",
              "default": false,
              "description": "还未定稿的API"
            }
          ],
          "state": "open",
          "locked": false,
          "assignee": null,
          "assignees": [],
          "milestone": null,
          "comments": 0,
          "created_at": "2019-09-25T07:51:27Z",
          "updated_at": "2019-09-27T02:03:01Z",
          "closed_at": null,
          "author_association": "OWNER",
          "active_lock_reason": null,
          "body": "\r\n![123](https://user-images.githubusercontent.com/39508895/65580529-6d24ad80-dfac-11e9-868f-328d7427391e.jpg)\r\n\r\n无意之间看到这个 API，发现这个 API 十分实用特来分享一下。\r\n\r\nResizeObserver 可以监听到 Element 的元素的变化，例如大小变化，在之前我们可能要监听 window 对象，因为 resize 定义在 window 上，不过注意这个 API 还是处于实验性阶段，在项目中要配合 [polyfill](https://github.com/que-etc/resize-observer-polyfill) 来使用\r\n\r\n## constructor\r\n\r\n```js\r\nvar ResizeObserver = new ResizeObserver(callback);\r\n```\r\n\r\n使用方法很简单，ResizeObserver 接收一个回调函数作为参数，当尺寸发生变化的时候 `callback` 函数接收一个 `ResizeObserverEntry` 数组，下面看一个例子\r\n\r\n```html\r\n<div class=\"box\"></div>\r\n<script>\r\n  const box = document.querySelector(\".box\");\r\n  const resizeObserver = new ResizeObserver(entries => {\r\n    for (let entry of entries) {\r\n      const dimensions = entry.contentRect;\r\n      console.log(`${dimensions.width} x ${dimensions.height}`);\r\n    }\r\n  });\r\n  resizeObserver.observe(box);\r\n  setTimeout(() => {\r\n    box.style.width = \"99px\";\r\n  }, 1000);\r\n</script>\r\n```\r\n\r\n上面定义了一个 box 的元素，并在一秒后更改宽度 `ResizeObserver` 可以监听到这一更改。\r\n\r\n> 特别提醒一下，添加初始元素的时候默认就会执行执行一次回调，也就是说不用手动执行一次获取初始信息了。\r\n\r\n## ResizeObserverEntry\r\n\r\n你可能好奇 ResizeObserverEntry 会返回什么格式的数据？\r\n它由两部分组成\r\n\r\n- target\r\n  target 很好理解就是我们添加的元素\r\n\r\n- contentRect\r\n  contentRect 其实就是一个盒子信息，它的类型是 [DOMRectReadOnly](https://developer.mozilla.org/zh-CN/docs/Web/API/DOMRectReadOnly),有以下几个属性\r\n  - bottom\r\n    返回的底部坐标值（通常与 y + 高度相同）\r\n  - height\r\n    高度\r\n  - width\r\n    宽度\r\n  - left\r\n    返回的左坐标值（通常与 x 相同）\r\n  - right\r\n    返回的右坐标值（通常与 x + width 相同）\r\n  - top\r\n    返回的顶部坐标值（通常与 y 相同）\r\n  - x\r\n    原点的 x 坐标\r\n  - y\r\n    原点的 y 坐标\r\n\r\n## 方法\r\n\r\n### observe\r\n\r\n```js\r\nresizeObserver.observe(target);\r\n```\r\n\r\n上面的示例中也有用到这个方法，用于添加监听的元素，注意 target 的类型必须是 Element 或 SVGElement 引用。\r\n\r\n### disconnect\r\n\r\n```js\r\nresizeObserver.disconnect();\r\n```\r\n\r\n停止和取消目标对象上所有对 Element 或 SVGElement 的监听。\r\n\r\n### unobserve\r\n\r\n```js\r\nresizeObserver.unobserve(target);\r\n```\r\n\r\n接收一个参数，停止对指定目标的监听，target 的类型为 Element 或 SVGElement 引用\r\n",
          "reactions": {
            "url": "https://api.github.com/repos/bosens-China/blog/issues/26/reactions",
            "total_count": 0,
            "+1": 0,
            "-1": 0,
            "laugh": 0,
            "hooray": 0,
            "confused": 0,
            "heart": 0,
            "rocket": 0,
            "eyes": 0
          },
          "timeline_url": "https://api.github.com/repos/bosens-China/blog/issues/26/timeline",
          "performed_via_github_app": null,
          "state_reason": null
        }
      ]
    ],
    [
      "1740561541",
      [
        {
          "url": "https://api.github.com/repos/bosens-China/blog/issues/43",
          "repository_url": "https://api.github.com/repos/bosens-China/blog",
          "labels_url": "https://api.github.com/repos/bosens-China/blog/issues/43/labels{/name}",
          "comments_url": "https://api.github.com/repos/bosens-China/blog/issues/43/comments",
          "events_url": "https://api.github.com/repos/bosens-China/blog/issues/43/events",
          "html_url": "https://github.com/bosens-China/blog/issues/43",
          "id": 544505720,
          "node_id": "MDU6SXNzdWU1NDQ1MDU3MjA=",
          "number": 43,
          "title": "从form表单来看策略模式",
          "user": {
            "login": "bosens-China",
            "id": 39508895,
            "node_id": "MDQ6VXNlcjM5NTA4ODk1",
            "avatar_url": "https://avatars.githubusercontent.com/u/39508895?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/bosens-China",
            "html_url": "https://github.com/bosens-China",
            "followers_url": "https://api.github.com/users/bosens-China/followers",
            "following_url": "https://api.github.com/users/bosens-China/following{/other_user}",
            "gists_url": "https://api.github.com/users/bosens-China/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/bosens-China/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/bosens-China/subscriptions",
            "organizations_url": "https://api.github.com/users/bosens-China/orgs",
            "repos_url": "https://api.github.com/users/bosens-China/repos",
            "events_url": "https://api.github.com/users/bosens-China/events{/privacy}",
            "received_events_url": "https://api.github.com/users/bosens-China/received_events",
            "type": "User",
            "site_admin": false
          },
          "labels": [
            {
              "id": 1740561541,
              "node_id": "MDU6TGFiZWwxNzQwNTYxNTQx",
              "url": "https://api.github.com/repos/bosens-China/blog/labels/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F",
              "name": "设计模式",
              "color": "d1a540",
              "default": false,
              "description": "设计模式在JavaScript的实现"
            }
          ],
          "state": "open",
          "locked": false,
          "assignee": null,
          "assignees": [],
          "milestone": null,
          "comments": 0,
          "created_at": "2020-01-02T09:36:08Z",
          "updated_at": "2021-12-21T09:47:57Z",
          "closed_at": null,
          "author_association": "OWNER",
          "active_lock_reason": null,
          "body": "### 前言\r\n\r\n之前写程序的时候为了快速开发写了许多`if`、`else if`的语句，当时开发倒是挺爽的，事后维护的时候想骂人，为了不坑自己和其他小伙伴，下面从零开始用一个基础表单 + 策略模式清除`if`分支语句\r\n\r\n```html\r\n<form class=\"cs-form\">\r\n  <label>\r\n    <span>账号：</span>\r\n    <input name=\"account\" type=\"text\" />\r\n  </label>\r\n  <label>\r\n    <span>密码：</span>\r\n    <input name=\"password\" type=\"password\" />\r\n  </label>\r\n  <label>\r\n    <span>手机号：</span>\r\n    <input name=\"mobile\" type=\"number\" />\r\n  </label>\r\n  <button class=\"submit\" type=\"submit\">登录</button>\r\n</form>\r\n```\r\n\r\n上面是一个很常见的表单元素，里面有账号和密码以及手机号，我们需要在提交之前对他进行一些校验，这里默认的规则是账号和密码不能为空，手机号的长度必须是 11 的纯数字。\r\n\r\n### 第一版\r\n\r\n```ts\r\ninterface Iform {\r\n  [k: string]: any;\r\n  account: HTMLInputElement;\r\n  password: HTMLInputElement;\r\n  mobile: HTMLInputElement;\r\n}\r\nconst form = document.querySelector(\".cs-form\") as HTMLFormElement;\r\n\r\nform.addEventListener(\"submit\", function(e) {\r\n  e.preventDefault();\r\n  const { account, password, mobile } = (form as unknown) as Iform;\r\n  if (!account.value) {\r\n    // 提示\r\n    alert(\"请输入账号\");\r\n    return false;\r\n  }\r\n  if (!password.value) {\r\n    // 提示\r\n    alert(\"请输入密码\");\r\n    return false;\r\n  }\r\n  if (!/\\d{11}/.test(mobile.value)) {\r\n    // 提示\r\n    alert(\"请输入正确的手机号\");\r\n    return false;\r\n  }\r\n  return false;\r\n});\r\n```\r\n\r\n根据上面的要求，我们实现了第一版代码，从代码的实现看毫无疑问是正确的，为了对比下面再用策略模式实现以下上述的功能\r\n\r\n### 第二版\r\n\r\n```ts\r\ninterface Iform {\r\n  [k: string]: any;\r\n  account: HTMLInputElement;\r\n  password: HTMLInputElement;\r\n  mobile: HTMLInputElement;\r\n}\r\n\r\ninterface Ilist {\r\n  value: string;\r\n  type: name;\r\n  msg: string;\r\n}\r\n\r\ntype name = keyof typeof rule;\r\nconst rule = {\r\n  account(value: string, msg: string) {\r\n    if (!value) {\r\n      return msg;\r\n    }\r\n  },\r\n  password(value: string, msg: string) {\r\n    if (!value) {\r\n      return msg;\r\n    }\r\n  },\r\n  mobile(value: string, msg: string) {\r\n    if (!/\\d{11}/.test(value)) {\r\n      return msg;\r\n    }\r\n  }\r\n};\r\nclass Verification {\r\n  private list: Ilist[] = [];\r\n  public message: string;\r\n  add<T extends { value: string }>(dom: T, type: name, msg: string) {\r\n    this.list.push({\r\n      value: dom.value,\r\n      type: type,\r\n      msg: msg\r\n    });\r\n  }\r\n  start(): boolean {\r\n    for (let i = 0; i < this.list.length; i++) {\r\n      const { value, type, msg } = this.list[i];\r\n      const fn = rule[type](value, msg);\r\n      if (fn) {\r\n        this.message = msg;\r\n        return false;\r\n      }\r\n    }\r\n    this.message = \"\";\r\n    return true;\r\n  }\r\n}\r\n\r\nconst form = document.querySelector(\".cs-form\") as HTMLFormElement;\r\n\r\nform.addEventListener(\"submit\", function(e) {\r\n  e.preventDefault();\r\n  const { account, password, mobile } = (form as unknown) as Iform;\r\n\r\n  const ruleSet = new Verification();\r\n  ruleSet.add(account, \"account\", \"请输入账号\");\r\n  ruleSet.add(password, \"password\", \"请输入密码\");\r\n  ruleSet.add(mobile, \"mobile\", \"请输入正确的手机号\");\r\n\r\n  if (!ruleSet.start()) {\r\n    // 提示\r\n    alert(ruleSet.message);\r\n    return false;\r\n  }\r\n  return false;\r\n});\r\n```\r\n\r\n从代码量看比第一版多出了很多语句，这里做法是把代码的规则放置在 rule 对象中，因为 javascript 本身就是这么灵活不需要在使用传统语言的 class 来实现了，剩下的就是新建一个校验类，新增校验规则最后校验，当然现在验证规则还是比较少，看不出策略模式的优点。\r\n\r\n下面再来新增一个要求，密码长度不能小于 6 位，在第一版中我们要紧接在密码不能为空的校验之后写，再来看下策略模式新增这个验证会新增哪些代码。\r\n\r\n```ts\r\ninterface Iform {\r\n  [k: string]: any;\r\n  account: HTMLInputElement;\r\n  password: HTMLInputElement;\r\n  mobile: HTMLInputElement;\r\n}\r\n\r\ninterface Ilist {\r\n  value: string;\r\n  type: name;\r\n  msg: string;\r\n}\r\n\r\ntype name = keyof typeof rule;\r\nconst rule = {\r\n  account(value: string, msg: string) {\r\n    if (!value) {\r\n      return msg;\r\n    }\r\n  },\r\n  password(value: string, msg: string) {\r\n    if (!value) {\r\n      return msg;\r\n    }\r\n  },\r\n  // 密码长度小于6的时候提示\r\n  passwordMinLength(value: string, msg: string) {\r\n    if (value.length < 6) {\r\n      return msg;\r\n    }\r\n  },\r\n  mobile(value: string, msg: string) {\r\n    if (!/\\d{11}/.test(value)) {\r\n      return msg;\r\n    }\r\n  }\r\n};\r\nclass Verification {\r\n  private list: Ilist[] = [];\r\n  public message: string;\r\n  add<T extends { value: string }>(dom: T, type: name, msg: string) {\r\n    this.list.push({\r\n      value: dom.value,\r\n      type: type,\r\n      msg: msg\r\n    });\r\n  }\r\n  start(): boolean {\r\n    for (let i = 0; i < this.list.length; i++) {\r\n      const { value, type, msg } = this.list[i];\r\n      const fn = rule[type](value, msg);\r\n      if (fn) {\r\n        this.message = msg;\r\n        return false;\r\n      }\r\n    }\r\n    this.message = \"\";\r\n    return true;\r\n  }\r\n}\r\n\r\nconst form = document.querySelector(\".cs-form\") as HTMLFormElement;\r\n\r\nform.addEventListener(\"submit\", function(e) {\r\n  e.preventDefault();\r\n  const { account, password, mobile } = (form as unknown) as Iform;\r\n\r\n  const ruleSet = new Verification();\r\n  ruleSet.add(account, \"account\", \"请输入账号\");\r\n  ruleSet.add(password, \"password\", \"请输入密码\");\r\n  ruleSet.add(password, \"passwordMinLength\", \"密码长度不符合要求\");\r\n  ruleSet.add(mobile, \"mobile\", \"请输入正确的手机号\");\r\n\r\n  if (!ruleSet.start()) {\r\n    // 提示\r\n    alert(ruleSet.message);\r\n    return false;\r\n  }\r\n  return false;\r\n});\r\n```\r\n\r\n把密码不能小于六位的规则添加到`rule`中，之后 add 的时候添加它，这里基本的校验其实就完成了，不过从上面看，我们的校验肯定不是一个 input 就对应一条，实际上会存在多种校验，比如最小长度最大长度，不能包含敏感词等，添加多条规则也是很合理的要求，下面就是最终版的实现。\r\n\r\n### 最终版\r\n\r\n```ts\r\ninterface Iform {\r\n  [k: string]: any;\r\n  account: HTMLInputElement;\r\n  password: HTMLInputElement;\r\n  mobile: HTMLInputElement;\r\n}\r\n\r\ninterface Ilist {\r\n  value: string;\r\n  type: name;\r\n  msg: string;\r\n}\r\ninterface Iadd {\r\n  type: name;\r\n  msg: string;\r\n}\r\n\r\ntype name = keyof typeof rule;\r\nconst rule = {\r\n  require(value: string, msg: string) {\r\n    if (!value) {\r\n      return msg;\r\n    }\r\n  },\r\n  minLength(value: string, msg: string) {\r\n    if (value.length < 6) {\r\n      return msg;\r\n    }\r\n  },\r\n  mobile(value: string, msg: string) {\r\n    if (!/\\d{11}/.test(value)) {\r\n      return msg;\r\n    }\r\n  }\r\n};\r\nclass Verification {\r\n  private list: Ilist[] = [];\r\n  public message: string;\r\n  // 用函数重载的形式实现\r\n  add<T extends { value: string }>(dom: T, type: name, msg: string): void;\r\n  add<T extends { value: string }>(dom: T, ruleArr: Array<Iadd>): void;\r\n  add<T extends { value: string }>(\r\n    dom: T,\r\n    ruleArr: Array<Iadd> | name,\r\n    msg?: string\r\n  ): void {\r\n    if (Array.isArray(ruleArr)) {\r\n      this.list.push(\r\n        ...ruleArr.map(f => {\r\n          return {\r\n            value: dom.value,\r\n            type: f.type,\r\n            msg: f.msg\r\n          };\r\n        })\r\n      );\r\n    } else {\r\n      this.list.push({\r\n        value: dom.value,\r\n        type: ruleArr,\r\n        msg: msg\r\n      });\r\n    }\r\n  }\r\n  start(): boolean {\r\n    for (let i = 0; i < this.list.length; i++) {\r\n      const { value, type, msg } = this.list[i];\r\n      const fn = rule[type](value, msg);\r\n      if (fn) {\r\n        this.message = msg;\r\n        return false;\r\n      }\r\n    }\r\n    this.message = \"\";\r\n    return true;\r\n  }\r\n}\r\n\r\nconst form = document.querySelector(\".cs-form\") as HTMLFormElement;\r\n\r\nform.addEventListener(\"submit\", function(e) {\r\n  e.preventDefault();\r\n  const { account, password, mobile } = (form as unknown) as Iform;\r\n\r\n  const ruleSet = new Verification();\r\n  ruleSet.add(account, \"require\", \"请输入账号\");\r\n  ruleSet.add(password, [\r\n    {\r\n      type: \"require\",\r\n      msg: \"请输入密码\"\r\n    },\r\n    {\r\n      type: \"minLength\",\r\n      msg: \"密码长度不符合要求\"\r\n    }\r\n  ]);\r\n  ruleSet.add(mobile, [\r\n    {\r\n      type: \"require\",\r\n      msg: \"请输入手机号\"\r\n    },\r\n    {\r\n      type: \"mobile\",\r\n      msg: \"请输入正确的手机号\"\r\n    }\r\n  ]);\r\n\r\n  if (!ruleSet.start()) {\r\n    // 提示\r\n    alert(ruleSet.message);\r\n    return false;\r\n  }\r\n  return false;\r\n});\r\n```\r\n\r\n撒花，这里就已经写完了，整体来看代码量还是蛮多的，主要是用 ts 写需要定义各种接口和类型，最终版本的时候我将上述的手机和账号的验证抽离成 require 函数，后续如果有用到只需要在 `rule` 规则中新增即可。\r\n\r\n当然因为只是讲解策略模式的使用所以这里并没有对这个校验更完整的定义，如果有进一步需要可以将 min 和 max 属性以及 regexp 属性新增上，进一步提高校验的规则\r\n",
          "reactions": {
            "url": "https://api.github.com/repos/bosens-China/blog/issues/43/reactions",
            "total_count": 0,
            "+1": 0,
            "-1": 0,
            "laugh": 0,
            "hooray": 0,
            "confused": 0,
            "heart": 0,
            "rocket": 0,
            "eyes": 0
          },
          "timeline_url": "https://api.github.com/repos/bosens-China/blog/issues/43/timeline",
          "performed_via_github_app": null,
          "state_reason": null
        },
        {
          "url": "https://api.github.com/repos/bosens-China/blog/issues/19",
          "repository_url": "https://api.github.com/repos/bosens-China/blog",
          "labels_url": "https://api.github.com/repos/bosens-China/blog/issues/19/labels{/name}",
          "comments_url": "https://api.github.com/repos/bosens-China/blog/issues/19/comments",
          "events_url": "https://api.github.com/repos/bosens-China/blog/issues/19/events",
          "html_url": "https://github.com/bosens-China/blog/issues/19",
          "id": 479944938,
          "node_id": "MDU6SXNzdWU0Nzk5NDQ5Mzg=",
          "number": 19,
          "title": "单例模式",
          "user": {
            "login": "bosens-China",
            "id": 39508895,
            "node_id": "MDQ6VXNlcjM5NTA4ODk1",
            "avatar_url": "https://avatars.githubusercontent.com/u/39508895?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/bosens-China",
            "html_url": "https://github.com/bosens-China",
            "followers_url": "https://api.github.com/users/bosens-China/followers",
            "following_url": "https://api.github.com/users/bosens-China/following{/other_user}",
            "gists_url": "https://api.github.com/users/bosens-China/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/bosens-China/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/bosens-China/subscriptions",
            "organizations_url": "https://api.github.com/users/bosens-China/orgs",
            "repos_url": "https://api.github.com/users/bosens-China/repos",
            "events_url": "https://api.github.com/users/bosens-China/events{/privacy}",
            "received_events_url": "https://api.github.com/users/bosens-China/received_events",
            "type": "User",
            "site_admin": false
          },
          "labels": [
            {
              "id": 1740561541,
              "node_id": "MDU6TGFiZWwxNzQwNTYxNTQx",
              "url": "https://api.github.com/repos/bosens-China/blog/labels/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F",
              "name": "设计模式",
              "color": "d1a540",
              "default": false,
              "description": "设计模式在JavaScript的实现"
            }
          ],
          "state": "open",
          "locked": false,
          "assignee": null,
          "assignees": [],
          "milestone": null,
          "comments": 0,
          "created_at": "2019-08-13T03:44:23Z",
          "updated_at": "2021-12-21T09:43:21Z",
          "closed_at": null,
          "author_association": "OWNER",
          "active_lock_reason": null,
          "body": "单例模式是很常见的一种设计模式，保证一个类仅有一个实例，并提供一个访问它的全局访问点。\r\n\r\n## 单例实现\r\n\r\n根据上面定义很容易想到用闭包来实现\r\n\r\n```js\r\nvar dom = (function() {\r\n  var d;\r\n  function createdDiv(html) {\r\n    if (d) {\r\n      return d;\r\n    }\r\n    this.html = html;\r\n    this.init();\r\n    return (d = this);\r\n  }\r\n  createdDiv.prototype.init = function() {\r\n    var dom = document.createElement(\"div\");\r\n    dom.innerHTML = this.html;\r\n    document.body.append(dom);\r\n  };\r\n  return createdDiv;\r\n})();\r\nvar d1 = new dom(\"hello wrold\");\r\nvar d2 = new dom(\"你好世界\");\r\nconsole.log(d1 === d2); // true\r\n```\r\n\r\n上面通过变量`d`来判断，没有就生成一个`div`，有的话就返回`d`，不过上面代码生成和保证单一组合在一起实际上违反了面向对象的单一职责，下面就用代理的方式来清除这种耦合。\r\n\r\n## 代理\r\n\r\n还是通过上面代码为例，我们通过观察发现`createdDiv`函数负责`div`的创建和生成，如何保证类的单一，我们可以使用另外一个函数来检测和返回。\r\n\r\n```js\r\nvar dom = (function() {\r\n  var d;\r\n  function createdDiv(html) {\r\n    this.html = html;\r\n    this.init();\r\n  }\r\n  createdDiv.prototype.init = function() {\r\n    var dom = document.createElement(\"div\");\r\n    dom.innerHTML = this.html;\r\n    document.body.append(dom);\r\n  };\r\n  return function(h) {\r\n    if (!d) {\r\n      d = new createdDiv(h);\r\n    }\r\n    return d;\r\n  };\r\n})();\r\nvar d1 = new dom(\"hello wrold\");\r\nvar d2 = new dom(\"你好世界\");\r\nconsole.log(d1 === d2); // true\r\n```\r\n\r\n## 惰性\r\n\r\n以兼容 dom 事件为例，ie 有自己的 dom 事件添加方法，如果我们要写一个兼容的函数可能会这样写\r\n\r\n```js\r\nfunction addEvent(type, el, fn) {\r\n  if (window.addEventListener) {\r\n    el.addEventListener(type, fn, false);\r\n  } else if (window.attachEvent) {\r\n    el.attachEvent(\"on\" + type, fn);\r\n  }\r\n}\r\n```\r\n\r\n不过这里每次运行函数都会判断一次，实际上没有必要，我们可以通过闭包的形式只判断一次\r\n\r\n```js\r\nfunction addEvent(type, el, fn) {\r\n  if (window.addEventListener) {\r\n    return function() {\r\n      el.addEventListener(type, fn, false);\r\n    };\r\n  } else if (window.attachEvent) {\r\n    return function() {\r\n      el.attachEvent(\"on\" + type, fn);\r\n    };\r\n  }\r\n}\r\n```\r\n\r\n惰性的应用很广泛，许多优化也牵扯其中，比如 webpack 对`import()`可以做到代码分割，减少首屏加载时间。\r\n\r\n## 信任函数\r\n\r\n还是通过惰性的例子为例，我们用了一个闭包来实现，不过也可以通过改写这个函数来实现\r\n\r\n```js\r\nfunction addEvent(type, el, fn) {\r\n  if (window.addEventListener) {\r\n    addEvent = function(type, el, fn) {\r\n      el.addEventListener(type, fn, false);\r\n    };\r\n  } else if (window.attachEvent) {\r\n    addEvent = function(type, el, fn) {\r\n      el.attachEvent(\"on\" + type, fn);\r\n    };\r\n  }\r\n}\r\n```\r\n\r\n## es6 之后的单例\r\n\r\n在 javascript 中单例实际上有些特殊，因为并没有类，而且单例的作用只是为了保证类的单一性，那我们可以直接定义一个全局变量就可以做到了\r\n\r\n```js\r\nvar a = {};\r\n```\r\n\r\n这里`a`在全局只会存在一次，不过缺点也很明显，就是会被覆盖和修改以及污染了全局变量，而从 es6 开始引用了模块的机制，它有些特殊，它是运行前加载，而且会将模块的值动态同步，怎么理解这句话呢？\r\n\r\n```js\r\nlet d = 5;\r\nsetTimeout(() => {\r\n  d = 10;\r\n}, 1000);\r\nexport { d };\r\n// 引用\r\n\r\nimport { d } from \"./demo.js\";\r\nconsole.log(d);\r\nsetTimeout(() => {\r\n  console.log(d);\r\n}, 1000);\r\n```\r\n\r\n上面会输出 5 和 10,所以根据模块这一特性可以很轻松实现单例模式\r\n\r\n```js\r\nlet event;\r\nif (!event) {\r\n  if (window.addEventListener) {\r\n    event = function(type, el, fn) {\r\n      el.addEventListener(type, fn, false);\r\n    };\r\n  } else if (window.attachEvent) {\r\n    event = function(type, el, fn) {\r\n      el.attachEvent(\"on\" + type, fn);\r\n    };\r\n  }\r\n}\r\nexport default event;\r\n```\r\n\r\n## 最后\r\n\r\n上面简单介绍了单例的传统实现，以及在 javascript 中的实现，最后额外提一下，es6 新增的`symbol`也可以跟单例想结合使用，它确保了这个属性名是唯一的，我们可以通过`symbol.for`来判断有没有这个`symbol`\r\n",
          "reactions": {
            "url": "https://api.github.com/repos/bosens-China/blog/issues/19/reactions",
            "total_count": 0,
            "+1": 0,
            "-1": 0,
            "laugh": 0,
            "hooray": 0,
            "confused": 0,
            "heart": 0,
            "rocket": 0,
            "eyes": 0
          },
          "timeline_url": "https://api.github.com/repos/bosens-China/blog/issues/19/timeline",
          "performed_via_github_app": null,
          "state_reason": null
        },
        {
          "url": "https://api.github.com/repos/bosens-China/blog/issues/20",
          "repository_url": "https://api.github.com/repos/bosens-China/blog",
          "labels_url": "https://api.github.com/repos/bosens-China/blog/issues/20/labels{/name}",
          "comments_url": "https://api.github.com/repos/bosens-China/blog/issues/20/comments",
          "events_url": "https://api.github.com/repos/bosens-China/blog/issues/20/events",
          "html_url": "https://github.com/bosens-China/blog/issues/20",
          "id": 480491465,
          "node_id": "MDU6SXNzdWU0ODA0OTE0NjU=",
          "number": 20,
          "title": "发布订阅模式",
          "user": {
            "login": "bosens-China",
            "id": 39508895,
            "node_id": "MDQ6VXNlcjM5NTA4ODk1",
            "avatar_url": "https://avatars.githubusercontent.com/u/39508895?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/bosens-China",
            "html_url": "https://github.com/bosens-China",
            "followers_url": "https://api.github.com/users/bosens-China/followers",
            "following_url": "https://api.github.com/users/bosens-China/following{/other_user}",
            "gists_url": "https://api.github.com/users/bosens-China/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/bosens-China/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/bosens-China/subscriptions",
            "organizations_url": "https://api.github.com/users/bosens-China/orgs",
            "repos_url": "https://api.github.com/users/bosens-China/repos",
            "events_url": "https://api.github.com/users/bosens-China/events{/privacy}",
            "received_events_url": "https://api.github.com/users/bosens-China/received_events",
            "type": "User",
            "site_admin": false
          },
          "labels": [
            {
              "id": 1740561541,
              "node_id": "MDU6TGFiZWwxNzQwNTYxNTQx",
              "url": "https://api.github.com/repos/bosens-China/blog/labels/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F",
              "name": "设计模式",
              "color": "d1a540",
              "default": false,
              "description": "设计模式在JavaScript的实现"
            }
          ],
          "state": "open",
          "locked": false,
          "assignee": null,
          "assignees": [],
          "milestone": null,
          "comments": 0,
          "created_at": "2019-08-14T05:44:57Z",
          "updated_at": "2021-12-21T09:42:53Z",
          "closed_at": null,
          "author_association": "OWNER",
          "active_lock_reason": null,
          "body": "发布订阅模式也成为观察者模式，以下面三部分组成\r\n\r\n1. 发布者\r\n2. 订阅者\r\n3. 消息队列\r\n\r\n上面介绍了组成可能你还有疑惑，下面就举一个例子，小明打算去售楼处去买一套房子，销售小姐告诉他这套住宅暂时没有房源，小明于是留了手机号码给他，某一天有房源的时候通知他。\r\n上面例子中，发布者就是售楼中心，订阅者就是小明，消息队列就是小明留的手机号码，观察者模式可以让对象松耦合在一起。\r\n\r\n## 实现\r\n\r\n> 下面使用 ES6 的语法来写，如果没有基础，推荐看一遍 es6 入门再来\r\n\r\n上面介绍了定义，就根据上面的定义编写一个可以取消以及支持传递参数的观察者实例\r\n\r\n```js\r\nconst Event = new (class Watch {\r\n  constructor() {\r\n    // 消息队列\r\n    this.list = {};\r\n  }\r\n  // 订阅\r\n  subscribe(key, fn) {\r\n    if (!this.list[key]) {\r\n      // 避免重复\r\n      this.list[key] = new Set();\r\n    }\r\n    this.list[key].add(fn);\r\n  }\r\n  // 触发\r\n  trigger(key, ...args) {\r\n    const v = this.list[key];\r\n    if (!v) {\r\n      return;\r\n    }\r\n    v.forEach((f) => f.apply(this, args), this);\r\n  }\r\n  // 删除，key是必须的\r\n  remove(key, fn) {\r\n    const v = this.list[key];\r\n    if (!v) {\r\n      return false;\r\n    }\r\n    if (v.has(fn)) {\r\n      return v.delete(fn);\r\n    }\r\n    // clear没有返回值，这里返回一个true\r\n    return v.clear() || true;\r\n  }\r\n})();\r\nEvent.subscribe('abc', function (a) {\r\n  console.log(a); // x\r\n});\r\nEvent.trigger('abc', 'x');\r\n```\r\n\r\n上面就实现了简单的观察者模式，不过可以观察上面代码可以发现观察者运行的机制是*先订阅后发布*，有没有办法类似于 QQ 消息一样，可以接收到离线消息，当然这个离线消息只能接收一次。\r\n\r\n## 支持先发布后订阅\r\n\r\n实现的思路很简单，就是通过一个离线消息队列，发布的时候判断这个离线消息队列存在么，如果存在，将消息存放在离线消息队列，当订阅的时候如果发现有离线消息队列就执行一次，之后清空\r\n\r\n```js\r\nconst Event = new (class Watch {\r\n  constructor() {\r\n    // 消息队列\r\n    this.list = {};\r\n    this.offLine = new Set();\r\n  }\r\n  // 订阅\r\n  subscribe(key, fn) {\r\n    if (!this.list[key]) {\r\n      // 避免重复\r\n      this.list[key] = new Set();\r\n    }\r\n    this.list[key].add(fn);\r\n    if (this.offLine) {\r\n      this.offLine.forEach((f) => f(), this);\r\n    }\r\n    this.offLine = null;\r\n  }\r\n  // 触发\r\n  trigger(key, ...args) {\r\n    // 关键代码\r\n    const fn = () => {\r\n      const v = this.list[key];\r\n      if (!v) {\r\n        return;\r\n      }\r\n      v.forEach((f) => f.apply(this, args), this);\r\n    };\r\n    if (this.offLine) {\r\n      this.offLine.add(fn);\r\n    }\r\n    fn();\r\n  }\r\n  // 删除，key是必须的\r\n  remove(key, fn) {\r\n    const v = this.list[key];\r\n    if (!v) {\r\n      return false;\r\n    }\r\n    if (v.has(fn)) {\r\n      return v.delete(fn);\r\n    }\r\n    // clear没有返回值，这里返回一个true\r\n    return v.clear() || true;\r\n  }\r\n})();\r\nEvent.trigger('abc', 'x');\r\nEvent.subscribe('abc', function (a) {\r\n  console.log(a); // x\r\n});\r\n```\r\n\r\n撒花，一个支持取消和先发布后订阅的观察者模式已经实现了，不过还是有待优化的地方，比如命名，我们能不能通过`Event.created('zhangsan').trigger`的形式来调用呢？\r\n\r\n## 命名\r\n\r\n动手写之前，我们先缕清一下头绪\r\n\r\n- 命名是否必须，能不能不通过`created`先调用，比如直接就是`Event.trigger`发布之后再订阅\r\n\r\nok，下面就是针对上面问题实现\r\n\r\n```js\r\n// 定义一个基础类，这个类是实现的核心层\r\nclass Basics {\r\n  _obj = {};\r\n  _default = 'default';\r\n  _created(name = this._default) {\r\n    // 定义消息队列和离线消息队列\r\n    const list = {};\r\n    let offLine = new Set();\r\n    const then = this;\r\n    const obj = {\r\n      // 触发，如果第一次触发就添加到离线队列中\r\n      trigger(key, ...rest) {\r\n        const fn = () => {\r\n          const arr = [list, key, ...rest];\r\n          return then._trigger.apply(then, arr);\r\n        };\r\n        if (offLine) {\r\n          offLine.add(fn);\r\n        }\r\n        return fn();\r\n      },\r\n      // 添加订阅者同时执行离线队列\r\n      subscribe(key, fn) {\r\n        then._subscribe(...[list, key, fn]);\r\n        if (offLine) {\r\n          offLine.forEach((f) => f());\r\n        }\r\n        offLine = null;\r\n      },\r\n      // 删除，key是必须的\r\n      remove(key, fn) {\r\n        const v = this.list[key];\r\n        if (!v) {\r\n          return false;\r\n        }\r\n        if (v.has(fn)) {\r\n          return v.delete(fn);\r\n        }\r\n        // clear没有返回值，这里返回一个true\r\n        return v.clear() || true;\r\n      },\r\n    };\r\n    // 判断命名来决定返回\r\n    return name ? (this._obj[name] ? this._obj[name] : (this._obj[name] = obj)) : obj;\r\n  }\r\n  // 触发\r\n  _trigger(l, k, ...args) {\r\n    const v = l[k];\r\n    if (!v || !v.size) {\r\n      return;\r\n    }\r\n    return Array.from(v, (f) => f.apply(this, args), this);\r\n  }\r\n  _subscribe(list, key, fn) {\r\n    if (!list[key]) {\r\n      list[key] = new Set();\r\n    }\r\n    list[key].add(fn);\r\n  }\r\n}\r\n// 这个是实现类\r\nclass Watch extends Basics {\r\n  constructor() {\r\n    // 必须，es6规定\r\n    super();\r\n    this.created = super._created;\r\n  }\r\n  trigger(key, ...rest) {\r\n    const v = this.created();\r\n    v.trigger(key, ...rest);\r\n  }\r\n  subscribe(key, fn) {\r\n    const v = this.created();\r\n    v.subscribe(key, fn);\r\n  }\r\n  remove(key, fn) {\r\n    const v = this.created();\r\n    v.remove(key, fn);\r\n  }\r\n}\r\nconst Event = new Watch();\r\nEvent.trigger('abc');\r\nEvent.subscribe('abc', function () {\r\n  console.log(123);\r\n});\r\nEvent.created('zhangsan').subscribe('abc', function (c) {\r\n  console.log(c);\r\n});\r\nEvent.created('zhangsan').trigger('abc', 456);\r\n```\r\n\r\n在实际中我们使用观察者模式的例子也有很多，比如一个网站，分为导航和侧边，当用户信息更新的时候展示部分需要更换就可以用到，还有我们用的框架，比如`vue、React`等\r\n",
          "reactions": {
            "url": "https://api.github.com/repos/bosens-China/blog/issues/20/reactions",
            "total_count": 0,
            "+1": 0,
            "-1": 0,
            "laugh": 0,
            "hooray": 0,
            "confused": 0,
            "heart": 0,
            "rocket": 0,
            "eyes": 0
          },
          "timeline_url": "https://api.github.com/repos/bosens-China/blog/issues/20/timeline",
          "performed_via_github_app": null,
          "state_reason": null
        },
        {
          "url": "https://api.github.com/repos/bosens-China/blog/issues/21",
          "repository_url": "https://api.github.com/repos/bosens-China/blog",
          "labels_url": "https://api.github.com/repos/bosens-China/blog/issues/21/labels{/name}",
          "comments_url": "https://api.github.com/repos/bosens-China/blog/issues/21/comments",
          "events_url": "https://api.github.com/repos/bosens-China/blog/issues/21/events",
          "html_url": "https://github.com/bosens-China/blog/issues/21",
          "id": 482752452,
          "node_id": "MDU6SXNzdWU0ODI3NTI0NTI=",
          "number": 21,
          "title": "代理模式",
          "user": {
            "login": "bosens-China",
            "id": 39508895,
            "node_id": "MDQ6VXNlcjM5NTA4ODk1",
            "avatar_url": "https://avatars.githubusercontent.com/u/39508895?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/bosens-China",
            "html_url": "https://github.com/bosens-China",
            "followers_url": "https://api.github.com/users/bosens-China/followers",
            "following_url": "https://api.github.com/users/bosens-China/following{/other_user}",
            "gists_url": "https://api.github.com/users/bosens-China/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/bosens-China/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/bosens-China/subscriptions",
            "organizations_url": "https://api.github.com/users/bosens-China/orgs",
            "repos_url": "https://api.github.com/users/bosens-China/repos",
            "events_url": "https://api.github.com/users/bosens-China/events{/privacy}",
            "received_events_url": "https://api.github.com/users/bosens-China/received_events",
            "type": "User",
            "site_admin": false
          },
          "labels": [
            {
              "id": 1740561541,
              "node_id": "MDU6TGFiZWwxNzQwNTYxNTQx",
              "url": "https://api.github.com/repos/bosens-China/blog/labels/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F",
              "name": "设计模式",
              "color": "d1a540",
              "default": false,
              "description": "设计模式在JavaScript的实现"
            }
          ],
          "state": "open",
          "locked": false,
          "assignee": null,
          "assignees": [],
          "milestone": null,
          "comments": 0,
          "created_at": "2019-08-20T09:37:17Z",
          "updated_at": "2021-12-21T09:41:37Z",
          "closed_at": null,
          "author_association": "OWNER",
          "active_lock_reason": null,
          "body": "## 前言\r\n\r\n代理模式是为一个对象提供一个代用品或占位符，以便控制对它的访问。\r\n例如：\r\n![1](https://user-images.githubusercontent.com/39508895/63336089-23272700-c371-11e9-8bf0-f31c74e016b6.jpg)\r\n\r\n下面就介绍最常用的几种场景\r\n\r\n## 保护代理\r\n\r\n例如作为孩子我们总希望他健康成长，在成长路上遇到的烦恼会被家长解决，这样来看其实就是保护代理，下面用一段伪代码来实现。\r\n\r\n```js\r\nfunction Children() {\r\n  this.knowledge = [];\r\n}\r\nChildren.prototype.Study = function(content) {\r\n  // ...学习，增加知识\r\n  this.knowledge.push(content);\r\n};\r\nvar Parent = (function() {\r\n  var small = new Children();\r\n  return {\r\n    knowledge: function(content) {\r\n      if (content === \"bad\") {\r\n        // 坏的，过滤掉\r\n      } else {\r\n        small.Study(content);\r\n      }\r\n    }\r\n  };\r\n})();\r\n```\r\n\r\n上面用伪代码的形式来实现了一个保护例子，不过你可能会困惑，这样不是多此一举么，我们完全可以在`Children`内部实现，不过这样做\r\n\r\n1. 增加了程序耦合度，如果想要过滤更多，或者某一天不过滤了，还要更改代码\r\n2. 违背了单一原则，对于代码的阅读和维护，造成了更多的成本\r\n\r\n## 缓存代理\r\n\r\n缓存代理是很实用的一个例子，例如一个`阶乘函数`，计算 n 的阶乘，最多需要保存 n 个调用记录，我们可能这样写\r\n\r\n```js\r\nfunction factorial(n) {\r\n  if (n === 1) return 1;\r\n  return n * factorial(n - 1);\r\n}\r\nfactorial(5); // 120\r\n```\r\n\r\n不过如果重复计算 5 或者 10，很明显造成了多次浪费，这个时候就可以使用代理，把结果缓存下来，如果存在就直接返回。\r\n\r\n```js\r\nfunction next(n, total) {\r\n  if (n === 1) return 1;\r\n  return n * factorial(n - 1);\r\n}\r\nvar factorial = (function() {\r\n  var obj = {};\r\n  return function(v) {\r\n    if (obj[v]) {\r\n      return obj[v];\r\n    }\r\n    obj[v] = next(v);\r\n    return obj[v];\r\n  };\r\n})();\r\nfactorial(5); // 120\r\nfactorial(5); // 120\r\n```\r\n\r\n上面就将结果缓存了下来，除此之外还可以引用在异步请求中可以节省加载的时间。\r\n\r\n## 应用场景\r\n\r\n上面简单介绍了两种模式，实际上还有很多，比如虚拟代理、远程代理、防火墙代理等，不过这里不做介绍了，下面看看使用场景。\r\n\r\n### jquery\r\n\r\n`jquery`基于链式调用，比如`$('.a').html('').text('')`，不过你会不会很好奇，`$()`调用的时候它是怎么记录这个值的呢，每次调用`$()`存储的 dom 都不相同，实际上它就是借用了代理模式，这里直接贴代码了\r\n\r\n```js\r\nfunction Jquery(dom) {\r\n  this.dom = dom;\r\n}\r\n// 代理者\r\nfunction $(dom) {\r\n  return new Jquery(dom);\r\n}\r\n$.prototype = Jquery.prototype = {\r\n  // 只做演示，不涉及具体代码\r\n  html() {\r\n    return this;\r\n  },\r\n  text() {\r\n    return this;\r\n  }\r\n};\r\n$(\".a\")\r\n  .html(\"\")\r\n  .text(\"\");\r\n```\r\n\r\n### vue\r\n\r\n我们在使用 vue 的时候给定了配置项`data`，它是一个对象，里面的属性会被 vue 响应式处理，我们可以通过`this.`的方式来简单访问，也是用了代理模式，下面就用一段伪 vue 代码来说明\r\n\r\n```js\r\nclass Mvvm {\r\n  constructor(option = {}) {\r\n    this.$option = option;\r\n    this._data = option.data || {};\r\n    // 代理数据\r\n    for (const name in this._data) {\r\n      Object.defineProperty(this, name, {\r\n        configurable: true,\r\n        enumerable: true,\r\n        get() {\r\n          return this._data[name];\r\n        },\r\n        set(v) {\r\n          return (this._data[name] = v);\r\n        }\r\n      });\r\n    }\r\n  }\r\n}\r\nexport default Mvvm;\r\n```\r\n\r\n可以复制上面代码，自己简单试下。\r\n",
          "reactions": {
            "url": "https://api.github.com/repos/bosens-China/blog/issues/21/reactions",
            "total_count": 0,
            "+1": 0,
            "-1": 0,
            "laugh": 0,
            "hooray": 0,
            "confused": 0,
            "heart": 0,
            "rocket": 0,
            "eyes": 0
          },
          "timeline_url": "https://api.github.com/repos/bosens-China/blog/issues/21/timeline",
          "performed_via_github_app": null,
          "state_reason": null
        }
      ]
    ]
  ],
  "user": {
    "login": "bosens-China",
    "id": 39508895,
    "node_id": "MDQ6VXNlcjM5NTA4ODk1",
    "avatar_url": "https://avatars.githubusercontent.com/u/39508895?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/bosens-China",
    "html_url": "https://github.com/bosens-China",
    "followers_url": "https://api.github.com/users/bosens-China/followers",
    "following_url": "https://api.github.com/users/bosens-China/following{/other_user}",
    "gists_url": "https://api.github.com/users/bosens-China/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/bosens-China/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/bosens-China/subscriptions",
    "organizations_url": "https://api.github.com/users/bosens-China/orgs",
    "repos_url": "https://api.github.com/users/bosens-China/repos",
    "events_url": "https://api.github.com/users/bosens-China/events{/privacy}",
    "received_events_url": "https://api.github.com/users/bosens-China/received_events",
    "type": "User",
    "site_admin": false,
    "name": "yliu",
    "company": null,
    "blog": "http://yangliu.pub/",
    "location": "china",
    "email": null,
    "hireable": true,
    "bio": "时来天地皆同力，运去英雄不自由",
    "twitter_username": null,
    "public_repos": 20,
    "public_gists": 0,
    "followers": 10,
    "following": 3,
    "created_at": "2018-05-22T03:17:00Z",
    "updated_at": "2024-02-20T08:17:35Z",
    "private_gists": 2,
    "total_private_repos": 0,
    "owned_private_repos": 0,
    "disk_usage": 13465,
    "collaborators": 0,
    "two_factor_authentication": true,
    "plan": {
      "name": "free",
      "space": 976562499,
      "collaborators": 0,
      "private_repos": 10000
    },
    "GITHUB_REPOSITORY": "bosens-China/blog"
  }
}
